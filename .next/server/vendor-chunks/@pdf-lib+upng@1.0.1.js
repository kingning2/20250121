"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@pdf-lib+upng@1.0.1";
exports.ids = ["vendor-chunks/@pdf-lib+upng@1.0.1"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/@pdf-lib+upng@1.0.1/node_modules/@pdf-lib/upng/UPNG.js":
/*!***********************************************************************************!*\
  !*** ./node_modules/.pnpm/@pdf-lib+upng@1.0.1/node_modules/@pdf-lib/upng/UPNG.js ***!
  \***********************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__)\n/* harmony export */ });\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! pako */ \"(ssr)/./node_modules/.pnpm/pako@1.0.11/node_modules/pako/index.js\");\n/* harmony import */ var pako__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(pako__WEBPACK_IMPORTED_MODULE_0__);\n\n\nvar UPNG = {};\n\n\t\n\nUPNG.toRGBA8 = function(out)\n{\n\tvar w = out.width, h = out.height;\n\tif(out.tabs.acTL==null) return [UPNG.toRGBA8.decodeImage(out.data, w, h, out).buffer];\n\t\n\tvar frms = [];\n\tif(out.frames[0].data==null) out.frames[0].data = out.data;\n\t\n\tvar len = w*h*4, img = new Uint8Array(len), empty = new Uint8Array(len), prev=new Uint8Array(len);\n\tfor(var i=0; i<out.frames.length; i++)\n\t{\n\t\tvar frm = out.frames[i];\n\t\tvar fx=frm.rect.x, fy=frm.rect.y, fw = frm.rect.width, fh = frm.rect.height;\n\t\tvar fdata = UPNG.toRGBA8.decodeImage(frm.data, fw,fh, out);\n\t\t\n\t\tif(i!=0) for(var j=0; j<len; j++) prev[j]=img[j];\n\t\t\n\t\tif     (frm.blend==0) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 0);\n\t\telse if(frm.blend==1) UPNG._copyTile(fdata, fw, fh, img, w, h, fx, fy, 1);\n\t\t\n\t\tfrms.push(img.buffer.slice(0));\n\t\t\n\t\tif     (frm.dispose==0) {}\n\t\telse if(frm.dispose==1) UPNG._copyTile(empty, fw, fh, img, w, h, fx, fy, 0);\n\t\telse if(frm.dispose==2) for(var j=0; j<len; j++) img[j]=prev[j];\n\t}\n\treturn frms;\n}\nUPNG.toRGBA8.decodeImage = function(data, w, h, out)\n{\n\tvar area = w*h, bpp = UPNG.decode._getBPP(out);\n\tvar bpl = Math.ceil(w*bpp/8);\t// bytes per line\n\n\tvar bf = new Uint8Array(area*4), bf32 = new Uint32Array(bf.buffer);\n\tvar ctype = out.ctype, depth = out.depth;\n\tvar rs = UPNG._bin.readUshort;\n\t\n\t//console.log(ctype, depth);\n\tvar time = Date.now();\n\n\tif     (ctype==6) { // RGB + alpha\n\t\tvar qarea = area<<2;\n\t\tif(depth== 8) for(var i=0; i<qarea;i+=4) {  bf[i] = data[i];  bf[i+1] = data[i+1];  bf[i+2] = data[i+2];  bf[i+3] = data[i+3]; }\n\t\tif(depth==16) for(var i=0; i<qarea;i++ ) {  bf[i] = data[i<<1];  }\n\t}\n\telse if(ctype==2) {\t// RGB\n\t\tvar ts=out.tabs[\"tRNS\"];\n\t\tif(ts==null) {\n\t\t\tif(depth== 8) for(var i=0; i<area; i++) {  var ti=i*3;  bf32[i] = (255<<24)|(data[ti+2]<<16)|(data[ti+1]<<8)|data[ti];  }\n\t\t\tif(depth==16) for(var i=0; i<area; i++) {  var ti=i*6;  bf32[i] = (255<<24)|(data[ti+4]<<16)|(data[ti+2]<<8)|data[ti];  }\n\t\t}\n\t\telse {  var tr=ts[0], tg=ts[1], tb=ts[2];\n\t\t\tif(depth== 8) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*3;  bf32[i] = (255<<24)|(data[ti+2]<<16)|(data[ti+1]<<8)|data[ti];\n\t\t\t\tif(data[ti]   ==tr && data[ti+1]   ==tg && data[ti+2]   ==tb) bf[qi+3] = 0;  }\n\t\t\tif(depth==16) for(var i=0; i<area; i++) {  var qi=i<<2, ti=i*6;  bf32[i] = (255<<24)|(data[ti+4]<<16)|(data[ti+2]<<8)|data[ti];\n\t\t\t\tif(rs(data,ti)==tr && rs(data,ti+2)==tg && rs(data,ti+4)==tb) bf[qi+3] = 0;  }\n\t\t}\n\t}\n\telse if(ctype==3) {\t// palette\n\t\tvar p=out.tabs[\"PLTE\"], ap=out.tabs[\"tRNS\"], tl=ap?ap.length:0;\n\t\t//console.log(p, ap);\n\t\tif(depth==1) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>3)]>>(7-((i&7)<<0)))& 1), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==2) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>2)]>>(6-((i&3)<<1)))& 3), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==4) for(var y=0; y<h; y++) {  var s0 = y*bpl, t0 = y*w;\n\t\t\tfor(var i=0; i<w; i++) { var qi=(t0+i)<<2, j=((data[s0+(i>>1)]>>(4-((i&1)<<2)))&15), cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t\t}\n\t\tif(depth==8) for(var i=0; i<area; i++ ) {  var qi=i<<2, j=data[i]                      , cj=3*j;  bf[qi]=p[cj];  bf[qi+1]=p[cj+1];  bf[qi+2]=p[cj+2];  bf[qi+3]=(j<tl)?ap[j]:255;  }\n\t}\n\telse if(ctype==4) {\t// gray + alpha\n\t\tif(depth== 8)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<1, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+1];  }\n\t\tif(depth==16)  for(var i=0; i<area; i++) {  var qi=i<<2, di=i<<2, gr=data[di];  bf[qi]=gr;  bf[qi+1]=gr;  bf[qi+2]=gr;  bf[qi+3]=data[di+2];  }\n\t}\n\telse if(ctype==0) {\t// gray\n\t\tvar tr = out.tabs[\"tRNS\"] ? out.tabs[\"tRNS\"] : -1;\n\t\tfor(var y=0; y<h; y++) {\n\t\t\tvar off = y*bpl, to = y*w;\n\t\t\tif     (depth== 1) for(var x=0; x<w; x++) {  var gr=255*((data[off+(x>>>3)]>>>(7 -((x&7)   )))& 1), al=(gr==tr*255)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\t\telse if(depth== 2) for(var x=0; x<w; x++) {  var gr= 85*((data[off+(x>>>2)]>>>(6 -((x&3)<<1)))& 3), al=(gr==tr* 85)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\t\telse if(depth== 4) for(var x=0; x<w; x++) {  var gr= 17*((data[off+(x>>>1)]>>>(4 -((x&1)<<2)))&15), al=(gr==tr* 17)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\t\telse if(depth== 8) for(var x=0; x<w; x++) {  var gr=data[off+     x], al=(gr                 ==tr)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\t\telse if(depth==16) for(var x=0; x<w; x++) {  var gr=data[off+(x<<1)], al=(rs(data,off+(x<<i))==tr)?0:255;  bf32[to+x]=(al<<24)|(gr<<16)|(gr<<8)|gr;  }\n\t\t}\n\t}\n\t//console.log(Date.now()-time);\n\treturn bf;\n}\n\n\n\nUPNG.decode = function(buff)\n{\n\tvar data = new Uint8Array(buff), offset = 8, bin = UPNG._bin, rUs = bin.readUshort, rUi = bin.readUint;\n\tvar out = {tabs:{}, frames:[]};\n\tvar dd = new Uint8Array(data.length), doff = 0;\t // put all IDAT data into it\n\tvar fd, foff = 0;\t// frames\n\t\n\tvar mgck = [0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\tfor(var i=0; i<8; i++) if(data[i]!=mgck[i]) throw \"The input is not a PNG file!\";\n\n\twhile(offset<data.length)\n\t{\n\t\tvar len  = bin.readUint(data, offset);  offset += 4;\n\t\tvar type = bin.readASCII(data, offset, 4);  offset += 4;\n\t\t//console.log(type,len);\n\t\t\n\t\tif     (type==\"IHDR\")  {  UPNG.decode._IHDR(data, offset, out);  }\n\t\telse if(type==\"IDAT\") {\n\t\t\tfor(var i=0; i<len; i++) dd[doff+i] = data[offset+i];\n\t\t\tdoff += len;\n\t\t}\n\t\telse if(type==\"acTL\")  {\n\t\t\tout.tabs[type] = {  num_frames:rUi(data, offset), num_plays:rUi(data, offset+4)  };\n\t\t\tfd = new Uint8Array(data.length);\n\t\t}\n\t\telse if(type==\"fcTL\")  {\n\t\t\tif(foff!=0) {  var fr = out.frames[out.frames.length-1];\n\t\t\t\tfr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;\n\t\t\t}\n\t\t\tvar rct = {x:rUi(data, offset+12),y:rUi(data, offset+16),width:rUi(data, offset+4),height:rUi(data, offset+8)};\n\t\t\tvar del = rUs(data, offset+22);  del = rUs(data, offset+20) / (del==0?100:del);\n\t\t\tvar frm = {rect:rct, delay:Math.round(del*1000), dispose:data[offset+24], blend:data[offset+25]};\n\t\t\t//console.log(frm);\n\t\t\tout.frames.push(frm);\n\t\t}\n\t\telse if(type==\"fdAT\") {\n\t\t\tfor(var i=0; i<len-4; i++) fd[foff+i] = data[offset+i+4];\n\t\t\tfoff += len-4;\n\t\t}\n\t\telse if(type==\"pHYs\") {\n\t\t\tout.tabs[type] = [bin.readUint(data, offset), bin.readUint(data, offset+4), data[offset+8]];\n\t\t}\n\t\telse if(type==\"cHRM\") {\n\t\t\tout.tabs[type] = [];\n\t\t\tfor(var i=0; i<8; i++) out.tabs[type].push(bin.readUint(data, offset+i*4));\n\t\t}\n\t\telse if(type==\"tEXt\") {\n\t\t\tif(out.tabs[type]==null) out.tabs[type] = {};\n\t\t\tvar nz = bin.nextZero(data, offset);\n\t\t\tvar keyw = bin.readASCII(data, offset, nz-offset);\n\t\t\tvar text = bin.readASCII(data, nz+1, offset+len-nz-1);\n\t\t\tout.tabs[type][keyw] = text;\n\t\t}\n\t\telse if(type==\"iTXt\") {\n\t\t\tif(out.tabs[type]==null) out.tabs[type] = {};\n\t\t\tvar nz = 0, off = offset;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar keyw = bin.readASCII(data, off, nz-off);  off = nz + 1;\n\t\t\tvar cflag = data[off], cmeth = data[off+1];  off+=2;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar ltag = bin.readASCII(data, off, nz-off);  off = nz + 1;\n\t\t\tnz = bin.nextZero(data, off);\n\t\t\tvar tkeyw = bin.readUTF8(data, off, nz-off);  off = nz + 1;\n\t\t\tvar text  = bin.readUTF8(data, off, len-(off-offset));\n\t\t\tout.tabs[type][keyw] = text;\n\t\t}\n\t\telse if(type==\"PLTE\") {\n\t\t\tout.tabs[type] = bin.readBytes(data, offset, len);\n\t\t}\n\t\telse if(type==\"hIST\") {\n\t\t\tvar pl = out.tabs[\"PLTE\"].length/3;\n\t\t\tout.tabs[type] = [];  for(var i=0; i<pl; i++) out.tabs[type].push(rUs(data, offset+i*2));\n\t\t}\n\t\telse if(type==\"tRNS\") {\n\t\t\tif     (out.ctype==3) out.tabs[type] = bin.readBytes(data, offset, len);\n\t\t\telse if(out.ctype==0) out.tabs[type] = rUs(data, offset);\n\t\t\telse if(out.ctype==2) out.tabs[type] = [ rUs(data,offset),rUs(data,offset+2),rUs(data,offset+4) ];\n\t\t\t//else console.log(\"tRNS for unsupported color type\",out.ctype, len);\n\t\t}\n\t\telse if(type==\"gAMA\") out.tabs[type] = bin.readUint(data, offset)/100000;\n\t\telse if(type==\"sRGB\") out.tabs[type] = data[offset];\n\t\telse if(type==\"bKGD\")\n\t\t{\n\t\t\tif     (out.ctype==0 || out.ctype==4) out.tabs[type] = [rUs(data, offset)];\n\t\t\telse if(out.ctype==2 || out.ctype==6) out.tabs[type] = [rUs(data, offset), rUs(data, offset+2), rUs(data, offset+4)];\n\t\t\telse if(out.ctype==3) out.tabs[type] = data[offset];\n\t\t}\n\t\telse if(type==\"IEND\") {\n\t\t\tbreak;\n\t\t}\n\t\t//else {  log(\"unknown chunk type\", type, len);  }\n\t\toffset += len;\n\t\tvar crc = bin.readUint(data, offset);  offset += 4;\n\t}\n\tif(foff!=0) {  var fr = out.frames[out.frames.length-1];\n\t\tfr.data = UPNG.decode._decompress(out, fd.slice(0,foff), fr.rect.width, fr.rect.height);  foff=0;\n\t}\t\n\tout.data = UPNG.decode._decompress(out, dd, out.width, out.height);\n\t\n\tdelete out.compress;  delete out.interlace;  delete out.filter;\n\treturn out;\n}\n\nUPNG.decode._decompress = function(out, dd, w, h) {\n\tvar time = Date.now();\n\tvar bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), buff = new Uint8Array((bpl+1+out.interlace)*h);\n\tdd = UPNG.decode._inflate(dd,buff);\n\t//console.log(dd.length, buff.length);\n\t//console.log(Date.now()-time);\n\n\tvar time=Date.now();\n\tif     (out.interlace==0) dd = UPNG.decode._filterZero(dd, out, 0, w, h);\n\telse if(out.interlace==1) dd = UPNG.decode._readInterlace(dd, out);\n\t//console.log(Date.now()-time);\n\treturn dd;\n}\n\nUPNG.decode._inflate = function(data, buff) {  var out=UPNG[\"inflateRaw\"](new Uint8Array(data.buffer, 2,data.length-6),buff);  return out;  }\nUPNG.inflateRaw=function(){var H={};H.H={};H.H.N=function(N,W){var R=Uint8Array,i=0,m=0,J=0,h=0,Q=0,X=0,u=0,w=0,d=0,v,C;\nif(N[0]==3&&N[1]==0)return W?W:new R(0);var V=H.H,n=V.b,A=V.e,l=V.R,M=V.n,I=V.A,e=V.Z,b=V.m,Z=W==null;\nif(Z)W=new R(N.length>>>2<<3);while(i==0){i=n(N,d,1);m=n(N,d+1,2);d+=3;if(m==0){if((d&7)!=0)d+=8-(d&7);\nvar D=(d>>>3)+4,q=N[D-4]|N[D-3]<<8;if(Z)W=H.H.W(W,w+q);W.set(new R(N.buffer,N.byteOffset+D,q),w);d=D+q<<3;\nw+=q;continue}if(Z)W=H.H.W(W,w+(1<<17));if(m==1){v=b.J;C=b.h;X=(1<<9)-1;u=(1<<5)-1}if(m==2){J=A(N,d,5)+257;\nh=A(N,d+5,5)+1;Q=A(N,d+10,4)+4;d+=14;var E=d,j=1;for(var c=0;c<38;c+=2){b.Q[c]=0;b.Q[c+1]=0}for(var c=0;\nc<Q;c++){var K=A(N,d+c*3,3);b.Q[(b.X[c]<<1)+1]=K;if(K>j)j=K}d+=3*Q;M(b.Q,j);I(b.Q,j,b.u);v=b.w;C=b.d;\nd=l(b.u,(1<<j)-1,J+h,N,d,b.v);var r=V.V(b.v,0,J,b.C);X=(1<<r)-1;var S=V.V(b.v,J,h,b.D);u=(1<<S)-1;M(b.C,r);\nI(b.C,r,v);M(b.D,S);I(b.D,S,C)}while(!0){var T=v[e(N,d)&X];d+=T&15;var p=T>>>4;if(p>>>8==0){W[w++]=p}else if(p==256){break}else{var z=w+p-254;\nif(p>264){var _=b.q[p-257];z=w+(_>>>3)+A(N,d,_&7);d+=_&7}var $=C[e(N,d)&u];d+=$&15;var s=$>>>4,Y=b.c[s],a=(Y>>>4)+n(N,d,Y&15);\nd+=Y&15;while(w<z){W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a];W[w]=W[w++-a]}w=z}}}return W.length==w?W:W.slice(0,w)};\nH.H.W=function(N,W){var R=N.length;if(W<=R)return N;var V=new Uint8Array(R<<1);V.set(N,0);return V};\nH.H.R=function(N,W,R,V,n,A){var l=H.H.e,M=H.H.Z,I=0;while(I<R){var e=N[M(V,n)&W];n+=e&15;var b=e>>>4;\nif(b<=15){A[I]=b;I++}else{var Z=0,m=0;if(b==16){m=3+l(V,n,2);n+=2;Z=A[I-1]}else if(b==17){m=3+l(V,n,3);\nn+=3}else if(b==18){m=11+l(V,n,7);n+=7}var J=I+m;while(I<J){A[I]=Z;I++}}}return n};H.H.V=function(N,W,R,V){var n=0,A=0,l=V.length>>>1;\nwhile(A<R){var M=N[A+W];V[A<<1]=0;V[(A<<1)+1]=M;if(M>n)n=M;A++}while(A<l){V[A<<1]=0;V[(A<<1)+1]=0;A++}return n};\nH.H.n=function(N,W){var R=H.H.m,V=N.length,n,A,l,M,I,e=R.j;for(var M=0;M<=W;M++)e[M]=0;for(M=1;M<V;M+=2)e[N[M]]++;\nvar b=R.K;n=0;e[0]=0;for(A=1;A<=W;A++){n=n+e[A-1]<<1;b[A]=n}for(l=0;l<V;l+=2){I=N[l+1];if(I!=0){N[l]=b[I];\nb[I]++}}};H.H.A=function(N,W,R){var V=N.length,n=H.H.m,A=n.r;for(var l=0;l<V;l+=2)if(N[l+1]!=0){var M=l>>1,I=N[l+1],e=M<<4|I,b=W-I,Z=N[l]<<b,m=Z+(1<<b);\nwhile(Z!=m){var J=A[Z]>>>15-W;R[J]=e;Z++}}};H.H.l=function(N,W){var R=H.H.m.r,V=15-W;for(var n=0;n<N.length;\nn+=2){var A=N[n]<<W-N[n+1];N[n]=R[A]>>>V}};H.H.M=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8};\nH.H.I=function(N,W,R){R=R<<(W&7);var V=W>>>3;N[V]|=R;N[V+1]|=R>>>8;N[V+2]|=R>>>16};H.H.e=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8)>>>(W&7)&(1<<R)-1};\nH.H.b=function(N,W,R){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)&(1<<R)-1};H.H.Z=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16)>>>(W&7)};\nH.H.i=function(N,W){return(N[W>>>3]|N[(W>>>3)+1]<<8|N[(W>>>3)+2]<<16|N[(W>>>3)+3]<<24)>>>(W&7)};H.H.m=function(){var N=Uint16Array,W=Uint32Array;\nreturn{K:new N(16),j:new N(16),X:[16,17,18,0,8,7,9,6,10,5,11,4,12,3,13,2,14,1,15],S:[3,4,5,6,7,8,9,10,11,13,15,17,19,23,27,31,35,43,51,59,67,83,99,115,131,163,195,227,258,999,999,999],T:[0,0,0,0,0,0,0,0,1,1,1,1,2,2,2,2,3,3,3,3,4,4,4,4,5,5,5,5,0,0,0,0],q:new N(32),p:[1,2,3,4,5,7,9,13,17,25,33,49,65,97,129,193,257,385,513,769,1025,1537,2049,3073,4097,6145,8193,12289,16385,24577,65535,65535],z:[0,0,0,0,1,1,2,2,3,3,4,4,5,5,6,6,7,7,8,8,9,9,10,10,11,11,12,12,13,13,0,0],c:new W(32),J:new N(512),_:[],h:new N(32),$:[],w:new N(32768),C:[],v:[],d:new N(32768),D:[],u:new N(512),Q:[],r:new N(1<<15),s:new W(286),Y:new W(30),a:new W(19),t:new W(15e3),k:new N(1<<16),g:new N(1<<15)}}();\n(function(){var N=H.H.m,W=1<<15;for(var R=0;R<W;R++){var V=R;V=(V&2863311530)>>>1|(V&1431655765)<<1;\nV=(V&3435973836)>>>2|(V&858993459)<<2;V=(V&4042322160)>>>4|(V&252645135)<<4;V=(V&4278255360)>>>8|(V&16711935)<<8;\nN.r[R]=(V>>>16|V<<16)>>>17}function n(A,l,M){while(l--!=0)A.push(0,M)}for(var R=0;R<32;R++){N.q[R]=N.S[R]<<3|N.T[R];\nN.c[R]=N.p[R]<<4|N.z[R]}n(N._,144,8);n(N._,255-143,9);n(N._,279-255,7);n(N._,287-279,8);H.H.n(N._,9);\nH.H.A(N._,9,N.J);H.H.l(N._,9);n(N.$,32,5);H.H.n(N.$,5);H.H.A(N.$,5,N.h);H.H.l(N.$,5);n(N.Q,19,0);n(N.C,286,0);\nn(N.D,30,0);n(N.v,320,0)}());return H.H.N}()\n\n\nUPNG.decode._readInterlace = function(data, out)\n{\n\tvar w = out.width, h = out.height;\n\tvar bpp = UPNG.decode._getBPP(out), cbpp = bpp>>3, bpl = Math.ceil(w*bpp/8);\n\tvar img = new Uint8Array( h * bpl );\n\tvar di = 0;\n\n\tvar starting_row  = [ 0, 0, 4, 0, 2, 0, 1 ];\n\tvar starting_col  = [ 0, 4, 0, 2, 0, 1, 0 ];\n\tvar row_increment = [ 8, 8, 8, 4, 4, 2, 2 ];\n\tvar col_increment = [ 8, 8, 4, 4, 2, 2, 1 ];\n\n\tvar pass=0;\n\twhile(pass<7)\n\t{\n\t\tvar ri = row_increment[pass], ci = col_increment[pass];\n\t\tvar sw = 0, sh = 0;\n\t\tvar cr = starting_row[pass];  while(cr<h) {  cr+=ri;  sh++;  }\n\t\tvar cc = starting_col[pass];  while(cc<w) {  cc+=ci;  sw++;  }\n\t\tvar bpll = Math.ceil(sw*bpp/8);\n\t\tUPNG.decode._filterZero(data, out, di, sw, sh);\n\n\t\tvar y=0, row = starting_row[pass];\n\t\twhile(row<h)\n\t\t{\n\t\t\tvar col = starting_col[pass];\n\t\t\tvar cdi = (di+y*bpll)<<3;\n\n\t\t\twhile(col<w)\n\t\t\t{\n\t\t\t\tif(bpp==1) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(7-(cdi&7)))&1;\n\t\t\t\t\timg[row*bpl + (col>>3)] |= (val << (7-((col&7)<<0)));\n\t\t\t\t}\n\t\t\t\tif(bpp==2) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(6-(cdi&7)))&3;\n\t\t\t\t\timg[row*bpl + (col>>2)] |= (val << (6-((col&3)<<1)));\n\t\t\t\t}\n\t\t\t\tif(bpp==4) {\n\t\t\t\t\tvar val = data[cdi>>3];  val = (val>>(4-(cdi&7)))&15;\n\t\t\t\t\timg[row*bpl + (col>>1)] |= (val << (4-((col&1)<<2)));\n\t\t\t\t}\n\t\t\t\tif(bpp>=8) {\n\t\t\t\t\tvar ii = row*bpl+col*cbpp;\n\t\t\t\t\tfor(var j=0; j<cbpp; j++) img[ii+j] = data[(cdi>>3)+j];\n\t\t\t\t}\n\t\t\t\tcdi+=bpp;  col+=ci;\n\t\t\t}\n\t\t\ty++;  row += ri;\n\t\t}\n\t\tif(sw*sh!=0) di += sh * (1 + bpll);\n\t\tpass = pass + 1;\n\t}\n\treturn img;\n}\n\nUPNG.decode._getBPP = function(out) {\n\tvar noc = [1,null,3,1,2,null,4][out.ctype];\n\treturn noc * out.depth;\n}\n\nUPNG.decode._filterZero = function(data, out, off, w, h)\n{\n\tvar bpp = UPNG.decode._getBPP(out), bpl = Math.ceil(w*bpp/8), paeth = UPNG.decode._paeth;\n\tbpp = Math.ceil(bpp/8);\n\t\n\tvar i=0, di=1, type=data[off], x=0;\n\t\n\tif(type>1) data[off]=[0,0,1][type-2];  \n\tif(type==3) for(x=bpp; x<bpl; x++) data[x+1] = (data[x+1] + (data[x+1-bpp]>>>1) )&255;\n\n\tfor(var y=0; y<h; y++)  {\n\t\ti = off+y*bpl; di = i+y+1;\n\t\ttype = data[di-1]; x=0;\n\n\t\tif     (type==0)   for(; x<bpl; x++) data[i+x] = data[di+x];\n\t\telse if(type==1) { for(; x<bpp; x++) data[i+x] = data[di+x];\n\t\t\t\t\t\t   for(; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpp]);  }\n\t\telse if(type==2) { for(; x<bpl; x++) data[i+x] = (data[di+x] + data[i+x-bpl]);  }\n\t\telse if(type==3) { for(; x<bpp; x++) data[i+x] = (data[di+x] + ( data[i+x-bpl]>>>1));\n\t\t\t               for(; x<bpl; x++) data[i+x] = (data[di+x] + ((data[i+x-bpl]+data[i+x-bpp])>>>1) );  }\n\t\telse             { for(; x<bpp; x++) data[i+x] = (data[di+x] + paeth(0, data[i+x-bpl], 0));\n\t\t\t\t\t\t   for(; x<bpl; x++) data[i+x] = (data[di+x] + paeth(data[i+x-bpp], data[i+x-bpl], data[i+x-bpp-bpl]) );  }\n\t}\n\treturn data;\n}\n\nUPNG.decode._paeth = function(a,b,c)\n{\n\tvar p = a+b-c, pa = (p-a), pb = (p-b), pc = (p-c);\n\tif (pa*pa <= pb*pb && pa*pa <= pc*pc)  return a;\n\telse if (pb*pb <= pc*pc)  return b;\n\treturn c;\n}\n\nUPNG.decode._IHDR = function(data, offset, out)\n{\n\tvar bin = UPNG._bin;\n\tout.width  = bin.readUint(data, offset);  offset += 4;\n\tout.height = bin.readUint(data, offset);  offset += 4;\n\tout.depth     = data[offset];  offset++;\n\tout.ctype     = data[offset];  offset++;\n\tout.compress  = data[offset];  offset++;\n\tout.filter    = data[offset];  offset++;\n\tout.interlace = data[offset];  offset++;\n}\n\nUPNG._bin = {\n\tnextZero   : function(data,p)  {  while(data[p]!=0) p++;  return p;  },\n\treadUshort : function(buff,p)  {  return (buff[p]<< 8) | buff[p+1];  },\n\twriteUshort: function(buff,p,n){  buff[p] = (n>>8)&255;  buff[p+1] = n&255;  },\n\treadUint   : function(buff,p)  {  return (buff[p]*(256*256*256)) + ((buff[p+1]<<16) | (buff[p+2]<< 8) | buff[p+3]);  },\n\twriteUint  : function(buff,p,n){  buff[p]=(n>>24)&255;  buff[p+1]=(n>>16)&255;  buff[p+2]=(n>>8)&255;  buff[p+3]=n&255;  },\n\treadASCII  : function(buff,p,l){  var s = \"\";  for(var i=0; i<l; i++) s += String.fromCharCode(buff[p+i]);  return s;    },\n\twriteASCII : function(data,p,s){  for(var i=0; i<s.length; i++) data[p+i] = s.charCodeAt(i);  },\n\treadBytes  : function(buff,p,l){  var arr = [];   for(var i=0; i<l; i++) arr.push(buff[p+i]);   return arr;  },\n\tpad : function(n) { return n.length < 2 ? \"0\" + n : n; },\n\treadUTF8 : function(buff, p, l) {\n\t\tvar s = \"\", ns;\n\t\tfor(var i=0; i<l; i++) s += \"%\" + UPNG._bin.pad(buff[p+i].toString(16));\n\t\ttry {  ns = decodeURIComponent(s); }\n\t\tcatch(e) {  return UPNG._bin.readASCII(buff, p, l);  }\n\t\treturn  ns;\n\t}\n}\nUPNG._copyTile = function(sb, sw, sh, tb, tw, th, xoff, yoff, mode)\n{\n\tvar w = Math.min(sw,tw), h = Math.min(sh,th);\n\tvar si=0, ti=0;\n\tfor(var y=0; y<h; y++)\n\t\tfor(var x=0; x<w; x++)\n\t\t{\n\t\t\tif(xoff>=0 && yoff>=0) {  si = (y*sw+x)<<2;  ti = (( yoff+y)*tw+xoff+x)<<2;  }\n\t\t\telse                   {  si = ((-yoff+y)*sw-xoff+x)<<2;  ti = (y*tw+x)<<2;  }\n\t\t\t\n\t\t\tif     (mode==0) {  tb[ti] = sb[si];  tb[ti+1] = sb[si+1];  tb[ti+2] = sb[si+2];  tb[ti+3] = sb[si+3];  }\n\t\t\telse if(mode==1) {\n\t\t\t\tvar fa = sb[si+3]*(1/255), fr=sb[si]*fa, fg=sb[si+1]*fa, fb=sb[si+2]*fa; \n\t\t\t\tvar ba = tb[ti+3]*(1/255), br=tb[ti]*ba, bg=tb[ti+1]*ba, bb=tb[ti+2]*ba; \n\t\t\t\t\n\t\t\t\tvar ifa=1-fa, oa = fa+ba*ifa, ioa = (oa==0?0:1/oa);\n\t\t\t\ttb[ti+3] = 255*oa;  \n\t\t\t\ttb[ti+0] = (fr+br*ifa)*ioa;  \n\t\t\t\ttb[ti+1] = (fg+bg*ifa)*ioa;   \n\t\t\t\ttb[ti+2] = (fb+bb*ifa)*ioa;  \n\t\t\t}\n\t\t\telse if(mode==2){\t// copy only differences, otherwise zero\n\t\t\t\tvar fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2]; \n\t\t\t\tvar ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2]; \n\t\t\t\tif(fa==ba && fr==br && fg==bg && fb==bb) {  tb[ti]=0;  tb[ti+1]=0;  tb[ti+2]=0;  tb[ti+3]=0;  }\n\t\t\t\telse {  tb[ti]=fr;  tb[ti+1]=fg;  tb[ti+2]=fb;  tb[ti+3]=fa;  }\n\t\t\t}\n\t\t\telse if(mode==3){\t// check if can be blended\n\t\t\t\tvar fa = sb[si+3], fr=sb[si], fg=sb[si+1], fb=sb[si+2]; \n\t\t\t\tvar ba = tb[ti+3], br=tb[ti], bg=tb[ti+1], bb=tb[ti+2]; \n\t\t\t\tif(fa==ba && fr==br && fg==bg && fb==bb) continue;\n\t\t\t\t//if(fa!=255 && ba!=0) return false;\n\t\t\t\tif(fa<220 && ba>20) return false;\n\t\t\t}\n\t\t}\n\treturn true;\n}\n\n\n\n\nUPNG.encode = function(bufs, w, h, ps, dels, tabs, forbidPlte)\n{\n\tif(ps==null) ps=0;\n\tif(forbidPlte==null) forbidPlte = false;\n\n\tvar nimg = UPNG.encode.compress(bufs, w, h, ps, [false, false, false, 0, forbidPlte]);\n\tUPNG.encode.compressPNG(nimg, -1);\n\t\n\treturn UPNG.encode._main(nimg, w, h, dels, tabs);\n}\n\nUPNG.encodeLL = function(bufs, w, h, cc, ac, depth, dels, tabs) {\n\tvar nimg = {  ctype: 0 + (cc==1 ? 0 : 2) + (ac==0 ? 0 : 4),      depth: depth,  frames: []  };\n\t\n\tvar time = Date.now();\n\tvar bipp = (cc+ac)*depth, bipl = bipp * w;\n\tfor(var i=0; i<bufs.length; i++)\n\t\tnimg.frames.push({  rect:{x:0,y:0,width:w,height:h},  img:new Uint8Array(bufs[i]), blend:0, dispose:1, bpp:Math.ceil(bipp/8), bpl:Math.ceil(bipl/8)  });\n\t\n\tUPNG.encode.compressPNG(nimg, 0, true);\n\t\n\tvar out = UPNG.encode._main(nimg, w, h, dels, tabs);\n\treturn out;\n}\n\nUPNG.encode._main = function(nimg, w, h, dels, tabs) {\n\tif(tabs==null) tabs={};\n\tvar crc = UPNG.crc.crc, wUi = UPNG._bin.writeUint, wUs = UPNG._bin.writeUshort, wAs = UPNG._bin.writeASCII;\n\tvar offset = 8, anim = nimg.frames.length>1, pltAlpha = false;\n\t\n\tvar leng = 8 + (16+5+4) /*+ (9+4)*/ + (anim ? 20 : 0);\n\tif(tabs[\"sRGB\"]!=null) leng += 8+1+4;\n\tif(tabs[\"pHYs\"]!=null) leng += 8+9+4;\n\tif(nimg.ctype==3) {\n\t\tvar dl = nimg.plte.length;\n\t\tfor(var i=0; i<dl; i++) if((nimg.plte[i]>>>24)!=255) pltAlpha = true;\n\t\tleng += (8 + dl*3 + 4) + (pltAlpha ? (8 + dl*1 + 4) : 0);\n\t}\n\tfor(var j=0; j<nimg.frames.length; j++)\n\t{\n\t\tvar fr = nimg.frames[j];\n\t\tif(anim) leng += 38;\n\t\tleng += fr.cimg.length + 12;\n\t\tif(j!=0) leng+=4;\n\t}\n\tleng += 12; \n\t\n\tvar data = new Uint8Array(leng);\n\tvar wr=[0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a];\n\tfor(var i=0; i<8; i++) data[i]=wr[i];\n\t\n\twUi(data,offset, 13);     offset+=4;\n\twAs(data,offset,\"IHDR\");  offset+=4;\n\twUi(data,offset,w);  offset+=4;\n\twUi(data,offset,h);  offset+=4;\n\tdata[offset] = nimg.depth;  offset++;  // depth\n\tdata[offset] = nimg.ctype;  offset++;  // ctype\n\tdata[offset] = 0;  offset++;  // compress\n\tdata[offset] = 0;  offset++;  // filter\n\tdata[offset] = 0;  offset++;  // interlace\n\twUi(data,offset,crc(data,offset-17,17));  offset+=4; // crc\n\n\t// 13 bytes to say, that it is sRGB\n\tif(tabs[\"sRGB\"]!=null) {\n\t\twUi(data,offset, 1);      offset+=4;\n\t\twAs(data,offset,\"sRGB\");  offset+=4;\n\t\tdata[offset] = tabs[\"sRGB\"];  offset++;\n\t\twUi(data,offset,crc(data,offset-5,5));  offset+=4; // crc\n\t}\n\tif(tabs[\"pHYs\"]!=null) {\n\t\twUi(data,offset, 9);      offset+=4;\n\t\twAs(data,offset,\"pHYs\");  offset+=4;\n\t\twUi(data,offset, tabs[\"pHYs\"][0]);      offset+=4;\n\t\twUi(data,offset, tabs[\"pHYs\"][1]);      offset+=4;\n\t\tdata[offset]=tabs[\"pHYs\"][2];\t\t\toffset++;\n\t\twUi(data,offset,crc(data,offset-13,13));  offset+=4; // crc\n\t}\n\n\tif(anim) {\n\t\twUi(data,offset, 8);      offset+=4;\n\t\twAs(data,offset,\"acTL\");  offset+=4;\n\t\twUi(data,offset, nimg.frames.length);     offset+=4;\n\t\twUi(data,offset, tabs[\"loop\"]!=null?tabs[\"loop\"]:0);      offset+=4;\n\t\twUi(data,offset,crc(data,offset-12,12));  offset+=4; // crc\n\t}\n\n\tif(nimg.ctype==3) {\n\t\tvar dl = nimg.plte.length;\n\t\twUi(data,offset, dl*3);  offset+=4;\n\t\twAs(data,offset,\"PLTE\");  offset+=4;\n\t\tfor(var i=0; i<dl; i++){\n\t\t\tvar ti=i*3, c=nimg.plte[i], r=(c)&255, g=(c>>>8)&255, b=(c>>>16)&255;\n\t\t\tdata[offset+ti+0]=r;  data[offset+ti+1]=g;  data[offset+ti+2]=b;\n\t\t}\n\t\toffset+=dl*3;\n\t\twUi(data,offset,crc(data,offset-dl*3-4,dl*3+4));  offset+=4; // crc\n\n\t\tif(pltAlpha) {\n\t\t\twUi(data,offset, dl);  offset+=4;\n\t\t\twAs(data,offset,\"tRNS\");  offset+=4;\n\t\t\tfor(var i=0; i<dl; i++)  data[offset+i]=(nimg.plte[i]>>>24)&255;\n\t\t\toffset+=dl;\n\t\t\twUi(data,offset,crc(data,offset-dl-4,dl+4));  offset+=4; // crc\n\t\t}\n\t}\n\t\n\tvar fi = 0;\n\tfor(var j=0; j<nimg.frames.length; j++)\n\t{\n\t\tvar fr = nimg.frames[j];\n\t\tif(anim) {\n\t\t\twUi(data, offset, 26);     offset+=4;\n\t\t\twAs(data, offset,\"fcTL\");  offset+=4;\n\t\t\twUi(data, offset, fi++);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.width );   offset+=4;\n\t\t\twUi(data, offset, fr.rect.height);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.x);   offset+=4;\n\t\t\twUi(data, offset, fr.rect.y);   offset+=4;\n\t\t\twUs(data, offset, dels[j]);   offset+=2;\n\t\t\twUs(data, offset,  1000);   offset+=2;\n\t\t\tdata[offset] = fr.dispose;  offset++;\t// dispose\n\t\t\tdata[offset] = fr.blend  ;  offset++;\t// blend\n\t\t\twUi(data,offset,crc(data,offset-30,30));  offset+=4; // crc\n\t\t}\n\t\t\t\t\n\t\tvar imgd = fr.cimg, dl = imgd.length;\n\t\twUi(data,offset, dl+(j==0?0:4));     offset+=4;\n\t\tvar ioff = offset;\n\t\twAs(data,offset,(j==0)?\"IDAT\":\"fdAT\");  offset+=4;\n\t\tif(j!=0) {  wUi(data, offset, fi++);  offset+=4;  }\n\t\tdata.set(imgd,offset);\n\t\toffset += dl;\n\t\twUi(data,offset,crc(data,ioff,offset-ioff));  offset+=4; // crc\n\t}\n\n\twUi(data,offset, 0);     offset+=4;\n\twAs(data,offset,\"IEND\");  offset+=4;\n\twUi(data,offset,crc(data,offset-4,4));  offset+=4; // crc\n\n\treturn data.buffer;\n}\n\nUPNG.encode.compressPNG = function(out, filter, levelZero) {\n\tfor(var i=0; i<out.frames.length; i++) {\n\t\tvar frm = out.frames[i], nw=frm.rect.width, nh=frm.rect.height;\n\t\tvar fdata = new Uint8Array(nh*frm.bpl+nh);\n\t\tfrm.cimg = UPNG.encode._filterZero(frm.img,nh,frm.bpp,frm.bpl,fdata, filter, levelZero);\n\t}\n}\n\n\n\nUPNG.encode.compress = function(bufs, w, h, ps, prms) // prms:  onlyBlend, minBits, forbidPlte\n{\n\t//var time = Date.now();\n\tvar onlyBlend = prms[0], evenCrd = prms[1], forbidPrev = prms[2], minBits = prms[3], forbidPlte = prms[4];\n\t\n\tvar ctype = 6, depth = 8, alphaAnd=255\n\t\n\tfor(var j=0; j<bufs.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame\n\t\tvar img = new Uint8Array(bufs[j]), ilen = img.length;\n\t\tfor(var i=0; i<ilen; i+=4) alphaAnd &= img[i+3];\n\t}\n\tvar gotAlpha = (alphaAnd!=255);\n\t\n\t//console.log(\"alpha check\", Date.now()-time);  time = Date.now();\n\t\n\t//var brute = gotAlpha && forGIF;\t\t// brute : frames can only be copied, not \"blended\"\n\tvar frms = UPNG.encode.framize(bufs, w, h, onlyBlend, evenCrd, forbidPrev);\n\t//console.log(\"framize\", Date.now()-time);  time = Date.now();\n\t\n\tvar cmap={}, plte=[], inds=[];  \n\t\n\tif(ps!=0) {\n\t\tvar nbufs = [];  for(var i=0; i<frms.length; i++) nbufs.push(frms[i].img.buffer);\n\t\t\n\t\tvar abuf = UPNG.encode.concatRGBA(nbufs), qres = UPNG.quantize(abuf, ps);  \n\t\tvar cof = 0, bb = new Uint8Array(qres.abuf);\n\t\tfor(var i=0; i<frms.length; i++) {  var ti=frms[i].img, bln=ti.length;  inds.push(new Uint8Array(qres.inds.buffer, cof>>2, bln>>2));\n\t\t\tfor(var j=0; j<bln; j+=4) {  ti[j]=bb[cof+j];  ti[j+1]=bb[cof+j+1];  ti[j+2]=bb[cof+j+2];  ti[j+3]=bb[cof+j+3];  }    cof+=bln;  }\n\t\t\n\t\tfor(var i=0; i<qres.plte.length; i++) plte.push(qres.plte[i].est.rgba);\n\t\t//console.log(\"quantize\", Date.now()-time);  time = Date.now();\n\t}\n\telse {\n\t\t// what if ps==0, but there are <=256 colors?  we still need to detect, if the palette could be used\n\t\tfor(var j=0; j<frms.length; j++)  {  // when not quantized, other frames can contain colors, that are not in an initial frame\n\t\t\tvar frm = frms[j], img32 = new Uint32Array(frm.img.buffer), nw=frm.rect.width, ilen = img32.length;\n\t\t\tvar ind = new Uint8Array(ilen);  inds.push(ind);\n\t\t\tfor(var i=0; i<ilen; i++) {\n\t\t\t\tvar c = img32[i];\n\t\t\t\tif     (i!=0 && c==img32[i- 1]) ind[i]=ind[i-1];\n\t\t\t\telse if(i>nw && c==img32[i-nw]) ind[i]=ind[i-nw];\n\t\t\t\telse {\n\t\t\t\t\tvar cmc = cmap[c];\n\t\t\t\t\tif(cmc==null) {  cmap[c]=cmc=plte.length;  plte.push(c);  if(plte.length>=300) break;  }\n\t\t\t\t\tind[i]=cmc;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t//console.log(\"make palette\", Date.now()-time);  time = Date.now();\n\t}\n\t\n\tvar cc=plte.length; //console.log(\"colors:\",cc);\n\tif(cc<=256 && forbidPlte==false) {\n\t\tif(cc<= 2) depth=1;  else if(cc<= 4) depth=2;  else if(cc<=16) depth=4;  else depth=8;\n\t\tdepth =  Math.max(depth, minBits);\n\t}\n\t\n\tfor(var j=0; j<frms.length; j++)\n\t{\n\t\tvar frm = frms[j], nx=frm.rect.x, ny=frm.rect.y, nw=frm.rect.width, nh=frm.rect.height;\n\t\tvar cimg = frm.img, cimg32 = new Uint32Array(cimg.buffer);\n\t\tvar bpl = 4*nw, bpp=4;\n\t\tif(cc<=256 && forbidPlte==false) {\n\t\t\tbpl = Math.ceil(depth*nw/8);\n\t\t\tvar nimg = new Uint8Array(bpl*nh);\n\t\t\tvar inj = inds[j];\n\t\t\tfor(var y=0; y<nh; y++) {  var i=y*bpl, ii=y*nw;\n\t\t\t\tif     (depth==8) for(var x=0; x<nw; x++) nimg[i+(x)   ]   =  (inj[ii+x]             );\n\t\t\t\telse if(depth==4) for(var x=0; x<nw; x++) nimg[i+(x>>1)]  |=  (inj[ii+x]<<(4-(x&1)*4));\n\t\t\t\telse if(depth==2) for(var x=0; x<nw; x++) nimg[i+(x>>2)]  |=  (inj[ii+x]<<(6-(x&3)*2));\n\t\t\t\telse if(depth==1) for(var x=0; x<nw; x++) nimg[i+(x>>3)]  |=  (inj[ii+x]<<(7-(x&7)*1));\n\t\t\t}\n\t\t\tcimg=nimg;  ctype=3;  bpp=1;\n\t\t}\n\t\telse if(gotAlpha==false && frms.length==1) {\t// some next \"reduced\" frames may contain alpha for blending\n\t\t\tvar nimg = new Uint8Array(nw*nh*3), area=nw*nh;\n\t\t\tfor(var i=0; i<area; i++) { var ti=i*3, qi=i*4;  nimg[ti]=cimg[qi];  nimg[ti+1]=cimg[qi+1];  nimg[ti+2]=cimg[qi+2];  }\n\t\t\tcimg=nimg;  ctype=2;  bpp=3;  bpl=3*nw;\n\t\t}\n\t\tfrm.img=cimg;  frm.bpl=bpl;  frm.bpp=bpp;\n\t}\n\t//console.log(\"colors => palette indices\", Date.now()-time);  time = Date.now();\n\t\n\treturn {ctype:ctype, depth:depth, plte:plte, frames:frms  };\n}\nUPNG.encode.framize = function(bufs,w,h,alwaysBlend,evenCrd,forbidPrev) {\n\t/*  DISPOSE\n\t    - 0 : no change\n\t\t- 1 : clear to transparent\n\t\t- 2 : retstore to content before rendering (previous frame disposed)\n\t\tBLEND\n\t\t- 0 : replace\n\t\t- 1 : blend\n\t*/\n\tvar frms = [];\n\tfor(var j=0; j<bufs.length; j++) {\n\t\tvar cimg = new Uint8Array(bufs[j]), cimg32 = new Uint32Array(cimg.buffer);\n\t\tvar nimg;\n\t\t\n\t\tvar nx=0, ny=0, nw=w, nh=h, blend=alwaysBlend?1:0;\n\t\tif(j!=0) {\n\t\t\tvar tlim = (forbidPrev || alwaysBlend || j==1 || frms[j-2].dispose!=0)?1:2, tstp = 0, tarea = 1e9;\n\t\t\tfor(var it=0; it<tlim; it++)\n\t\t\t{\n\t\t\t\tvar pimg = new Uint8Array(bufs[j-1-it]), p32 = new Uint32Array(bufs[j-1-it]);\n\t\t\t\tvar mix=w,miy=h,max=-1,may=-1;\n\t\t\t\tfor(var y=0; y<h; y++) for(var x=0; x<w; x++) {\n\t\t\t\t\tvar i = y*w+x;\n\t\t\t\t\tif(cimg32[i]!=p32[i]) {\n\t\t\t\t\t\tif(x<mix) mix=x;  if(x>max) max=x;\n\t\t\t\t\t\tif(y<miy) miy=y;  if(y>may) may=y;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tif(max==-1) mix=miy=max=may=0;\n\t\t\t\tif(evenCrd) {  if((mix&1)==1)mix--;  if((miy&1)==1)miy--;  }\n\t\t\t\tvar sarea = (max-mix+1)*(may-miy+1);\n\t\t\t\tif(sarea<tarea) {\n\t\t\t\t\ttarea = sarea;  tstp = it;\n\t\t\t\t\tnx = mix; ny = miy; nw = max-mix+1; nh = may-miy+1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\t// alwaysBlend: pokud zjistím, že blendit nelze, nastavím předchozímu snímku dispose=1. Zajistím, aby obsahoval můj obdélník.\n\t\t\tvar pimg = new Uint8Array(bufs[j-1-tstp]);\n\t\t\tif(tstp==1) frms[j-1].dispose = 2;\n\t\t\t\n\t\t\tnimg = new Uint8Array(nw*nh*4);\n\t\t\tUPNG._copyTile(pimg,w,h, nimg,nw,nh, -nx,-ny, 0);\n\t\t\t\n\t\t\tblend =  UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 3) ? 1 : 0;\n\t\t\tif(blend==1) UPNG.encode._prepareDiff(cimg,w,h,nimg,{x:nx,y:ny,width:nw,height:nh});\n\t\t\telse         UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, 0);\n\t\t\t//UPNG._copyTile(cimg,w,h, nimg,nw,nh, -nx,-ny, blend==1?2:0);\n\t\t}\n\t\telse nimg = cimg.slice(0);\t// img may be rewritten further ... don't rewrite input\n\t\t\n\t\tfrms.push({rect:{x:nx,y:ny,width:nw,height:nh}, img:nimg, blend:blend, dispose:0});\n\t}\n\t\n\t\n\tif(alwaysBlend) for(var j=0; j<frms.length; j++) {\n\t\tvar frm = frms[j];  if(frm.blend==1) continue;\n\t\tvar r0 = frm.rect, r1 = frms[j-1].rect\n\t\tvar miX = Math.min(r0.x, r1.x), miY = Math.min(r0.y, r1.y);\n\t\tvar maX = Math.max(r0.x+r0.width, r1.x+r1.width), maY = Math.max(r0.y+r0.height, r1.y+r1.height);\n\t\tvar r = {x:miX, y:miY, width:maX-miX, height:maY-miY};\n\t\t\n\t\tfrms[j-1].dispose = 1;\n\t\tif(j-1!=0) \n\t\tUPNG.encode._updateFrame(bufs, w,h,frms, j-1,r, evenCrd);\n\t\tUPNG.encode._updateFrame(bufs, w,h,frms, j  ,r, evenCrd);\n\t}\n\tvar area = 0;\n\tif(bufs.length!=1) for(var i=0; i<frms.length; i++) {\n\t\tvar frm = frms[i];\n\t\tarea += frm.rect.width*frm.rect.height;\n\t\t//if(i==0 || frm.blend!=1) continue;\n\t\t//var ob = new Uint8Array(\n\t\t//console.log(frm.blend, frm.dispose, frm.rect);\n\t}\n\t//if(area!=0) console.log(area);\n\treturn frms;\n}\nUPNG.encode._updateFrame = function(bufs, w,h, frms, i, r, evenCrd) {\n\tvar U8 = Uint8Array, U32 = Uint32Array;\n\tvar pimg = new U8(bufs[i-1]), pimg32 = new U32(bufs[i-1]), nimg = i+1<bufs.length ? new U8(bufs[i+1]):null;\n\tvar cimg = new U8(bufs[i]), cimg32 = new U32(cimg.buffer);\n\t\n\tvar mix=w,miy=h,max=-1,may=-1;\n\tfor(var y=0; y<r.height; y++) for(var x=0; x<r.width; x++) {\n\t\tvar cx = r.x+x, cy = r.y+y;\n\t\tvar j = cy*w+cx, cc = cimg32[j];\n\t\t// no need to draw transparency, or to dispose it. Or, if writing the same color and the next one does not need transparency.\n\t\tif(cc==0 || (frms[i-1].dispose==0 && pimg32[j]==cc && (nimg==null || nimg[j*4+3]!=0))/**/) {}\n\t\telse {\n\t\t\tif(cx<mix) mix=cx;  if(cx>max) max=cx;\n\t\t\tif(cy<miy) miy=cy;  if(cy>may) may=cy;\n\t\t}\n\t}\n\tif(max==-1) mix=miy=max=may=0;\n\tif(evenCrd) {  if((mix&1)==1)mix--;  if((miy&1)==1)miy--;  }\n\tr = {x:mix, y:miy, width:max-mix+1, height:may-miy+1};\n\t\n\tvar fr = frms[i];  fr.rect = r;  fr.blend = 1;  fr.img = new Uint8Array(r.width*r.height*4);\n\tif(frms[i-1].dispose==0) {\n\t\tUPNG._copyTile(pimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 0);\n\t\tUPNG.encode._prepareDiff(cimg,w,h,fr.img,r);\n\t\t//UPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 2);\n\t}\n\telse\n\t\tUPNG._copyTile(cimg,w,h, fr.img,r.width,r.height, -r.x,-r.y, 0);\n}\nUPNG.encode._prepareDiff = function(cimg, w,h, nimg, rec) {\n\tUPNG._copyTile(cimg,w,h, nimg,rec.width,rec.height, -rec.x,-rec.y, 2);\n\t/*\n\tvar n32 = new Uint32Array(nimg.buffer);\n\tvar og = new Uint8Array(rec.width*rec.height*4), o32 = new Uint32Array(og.buffer);\n\tUPNG._copyTile(cimg,w,h, og,rec.width,rec.height, -rec.x,-rec.y, 0);\n\tfor(var i=4; i<nimg.length; i+=4) {\n\t\tif(nimg[i-1]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)-1]) {\n\t\t\tn32[i>>>2]=o32[i>>>2];\n\t\t\t//var j = i, c=p32[(i>>>2)-1];\n\t\t\t//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n\t\t}\n\t}\n\tfor(var i=nimg.length-8; i>0; i-=4) {\n\t\tif(nimg[i+7]!=0 && nimg[i+3]==0 && o32[i>>>2]==o32[(i>>>2)+1]) {\n\t\t\tn32[i>>>2]=o32[i>>>2];\n\t\t\t//var j = i, c=p32[(i>>>2)-1];\n\t\t\t//while(p32[j>>>2]==c) {  n32[j>>>2]=c;  j+=4;  }\n\t\t}\n\t}*/\n}\n\nUPNG.encode._filterZero = function(img,h,bpp,bpl,data, filter, levelZero)\n{\n\tvar fls = [], ftry=[0,1,2,3,4];\n\tif     (filter!=-1)             ftry=[filter];\n\telse if(h*bpl>500000 || bpp==1) ftry=[0];\n\tvar opts;  if(levelZero) opts={level:0};\n\t\n\tvar CMPR = (levelZero && UZIP!=null) ? UZIP : (pako__WEBPACK_IMPORTED_MODULE_0___default());\n\t\n\tfor(var i=0; i<ftry.length; i++) {\n\t\tfor(var y=0; y<h; y++) UPNG.encode._filterLine(data, img, y, bpl, bpp, ftry[i]);\n\t\t//var nimg = new Uint8Array(data.length);\n\t\t//var sz = UZIP.F.deflate(data, nimg);  fls.push(nimg.slice(0,sz));\n\t\t//var dfl = pako[\"deflate\"](data), dl=dfl.length-4;\n\t\t//var crc = (dfl[dl+3]<<24)|(dfl[dl+2]<<16)|(dfl[dl+1]<<8)|(dfl[dl+0]<<0);\n\t\t//console.log(crc, UZIP.adler(data,2,data.length-6));\n\t\tfls.push(CMPR[\"deflate\"](data,opts));\n\t}\n\tvar ti, tsize=1e9;\n\tfor(var i=0; i<fls.length; i++) if(fls[i].length<tsize) {  ti=i;  tsize=fls[i].length;  }\n\treturn fls[ti];\n}\nUPNG.encode._filterLine = function(data, img, y, bpl, bpp, type)\n{\n\tvar i = y*bpl, di = i+y, paeth = UPNG.decode._paeth\n\tdata[di]=type;  di++;\n\n\tif(type==0) {\n\t\tif(bpl<500) for(var x=0; x<bpl; x++) data[di+x] = img[i+x];\n\t\telse data.set(new Uint8Array(img.buffer,i,bpl),di);\n\t}\n\telse if(type==1) {\n\t\tfor(var x=  0; x<bpp; x++) data[di+x] =  img[i+x];\n\t\tfor(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]-img[i+x-bpp]+256)&255;\n\t}\n\telse if(y==0) {\n\t\tfor(var x=  0; x<bpp; x++) data[di+x] = img[i+x];\n\n\t\tif(type==2) for(var x=bpp; x<bpl; x++) data[di+x] = img[i+x];\n\t\tif(type==3) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - (img[i+x-bpp]>>1) +256)&255;\n\t\tif(type==4) for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x] - paeth(img[i+x-bpp], 0, 0) +256)&255;\n\t}\n\telse {\n\t\tif(type==2) { for(var x=  0; x<bpl; x++) data[di+x] = (img[i+x]+256 - img[i+x-bpl])&255;  }\n\t\tif(type==3) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - (img[i+x-bpl]>>1))&255;\n\t\t\t\t\t  for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - ((img[i+x-bpl]+img[i+x-bpp])>>1))&255;  }\n\t\tif(type==4) { for(var x=  0; x<bpp; x++) data[di+x] = (img[i+x]+256 - paeth(0, img[i+x-bpl], 0))&255;\n\t\t\t\t\t  for(var x=bpp; x<bpl; x++) data[di+x] = (img[i+x]+256 - paeth(img[i+x-bpp], img[i+x-bpl], img[i+x-bpp-bpl]))&255;  }\n\t}\n}\n\nUPNG.crc = {\n\ttable : ( function() {\n\t   var tab = new Uint32Array(256);\n\t   for (var n=0; n<256; n++) {\n\t\t\tvar c = n;\n\t\t\tfor (var k=0; k<8; k++) {\n\t\t\t\tif (c & 1)  c = 0xedb88320 ^ (c >>> 1);\n\t\t\t\telse        c = c >>> 1;\n\t\t\t}\n\t\t\ttab[n] = c;  }\n\t\treturn tab;  })(),\n\tupdate : function(c, buf, off, len) {\n\t\tfor (var i=0; i<len; i++)  c = UPNG.crc.table[(c ^ buf[off+i]) & 0xff] ^ (c >>> 8);\n\t\treturn c;\n\t},\n\tcrc : function(b,o,l)  {  return UPNG.crc.update(0xffffffff,b,o,l) ^ 0xffffffff;  }\n}\n\n\nUPNG.quantize = function(abuf, ps)\n{\t\n\tvar oimg = new Uint8Array(abuf), nimg = oimg.slice(0), nimg32 = new Uint32Array(nimg.buffer);\n\t\n\tvar KD = UPNG.quantize.getKDtree(nimg, ps);\n\tvar root = KD[0], leafs = KD[1];\n\t\n\tvar planeDst = UPNG.quantize.planeDst;\n\tvar sb = oimg, tb = nimg32, len=sb.length;\n\t\t\n\tvar inds = new Uint8Array(oimg.length>>2);\n\tfor(var i=0; i<len; i+=4) {\n\t\tvar r=sb[i]*(1/255), g=sb[i+1]*(1/255), b=sb[i+2]*(1/255), a=sb[i+3]*(1/255);\n\t\t\n\t\t//  exact, but too slow :(\n\t\tvar nd = UPNG.quantize.getNearest(root, r, g, b, a);\n\t\t//var nd = root;\n\t\t//while(nd.left) nd = (planeDst(nd.est,r,g,b,a)<=0) ? nd.left : nd.right;\n\t\t\n\t\tinds[i>>2] = nd.ind;\n\t\ttb[i>>2] = nd.est.rgba;\n\t}\n\treturn {  abuf:nimg.buffer, inds:inds, plte:leafs  };\n}\n\nUPNG.quantize.getKDtree = function(nimg, ps, err) {\n\tif(err==null) err = 0.0001;\n\tvar nimg32 = new Uint32Array(nimg.buffer);\n\t\n\tvar root = {i0:0, i1:nimg.length, bst:null, est:null, tdst:0, left:null, right:null };  // basic statistic, extra statistic\n\troot.bst = UPNG.quantize.stats(  nimg,root.i0, root.i1  );  root.est = UPNG.quantize.estats( root.bst );\n\tvar leafs = [root];\n\t\n\twhile(leafs.length<ps)\n\t{\n\t\tvar maxL = 0, mi=0;\n\t\tfor(var i=0; i<leafs.length; i++) if(leafs[i].est.L > maxL) {  maxL=leafs[i].est.L;  mi=i;  }\n\t\tif(maxL<err) break;\n\t\tvar node = leafs[mi];\n\t\t\n\t\tvar s0 = UPNG.quantize.splitPixels(nimg,nimg32, node.i0, node.i1, node.est.e, node.est.eMq255);\n\t\tvar s0wrong = (node.i0>=s0 || node.i1<=s0);\n\t\t//console.log(maxL, leafs.length, mi);\n\t\tif(s0wrong) {  node.est.L=0;  continue;  }\n\t\t\n\t\t\n\t\tvar ln = {i0:node.i0, i1:s0, bst:null, est:null, tdst:0, left:null, right:null };  ln.bst = UPNG.quantize.stats( nimg, ln.i0, ln.i1 );  \n\t\tln.est = UPNG.quantize.estats( ln.bst );\n\t\tvar rn = {i0:s0, i1:node.i1, bst:null, est:null, tdst:0, left:null, right:null };  rn.bst = {R:[], m:[], N:node.bst.N-ln.bst.N};\n\t\tfor(var i=0; i<16; i++) rn.bst.R[i] = node.bst.R[i]-ln.bst.R[i];\n\t\tfor(var i=0; i< 4; i++) rn.bst.m[i] = node.bst.m[i]-ln.bst.m[i];\n\t\trn.est = UPNG.quantize.estats( rn.bst );\n\t\t\n\t\tnode.left = ln;  node.right = rn;\n\t\tleafs[mi]=ln;  leafs.push(rn);\n\t}\n\tleafs.sort(function(a,b) {  return b.bst.N-a.bst.N;  });\n\tfor(var i=0; i<leafs.length; i++) leafs[i].ind=i;\n\treturn [root, leafs];\n}\n\nUPNG.quantize.getNearest = function(nd, r,g,b,a)\n{\n\tif(nd.left==null) {  nd.tdst = UPNG.quantize.dist(nd.est.q,r,g,b,a);  return nd;  }\n\tvar planeDst = UPNG.quantize.planeDst(nd.est,r,g,b,a);\n\t\n\tvar node0 = nd.left, node1 = nd.right;\n\tif(planeDst>0) {  node0=nd.right;  node1=nd.left;  }\n\t\n\tvar ln = UPNG.quantize.getNearest(node0, r,g,b,a);\n\tif(ln.tdst<=planeDst*planeDst) return ln;\n\tvar rn = UPNG.quantize.getNearest(node1, r,g,b,a);\n\treturn rn.tdst<ln.tdst ? rn : ln;\n}\nUPNG.quantize.planeDst = function(est, r,g,b,a) {  var e = est.e;  return e[0]*r + e[1]*g + e[2]*b + e[3]*a - est.eMq;  }\nUPNG.quantize.dist     = function(q,   r,g,b,a) {  var d0=r-q[0], d1=g-q[1], d2=b-q[2], d3=a-q[3];  return d0*d0+d1*d1+d2*d2+d3*d3;  }\n\nUPNG.quantize.splitPixels = function(nimg, nimg32, i0, i1, e, eMq)\n{\n\tvar vecDot = UPNG.quantize.vecDot;\n\ti1-=4;\n\tvar shfs = 0;\n\twhile(i0<i1)\n\t{\n\t\twhile(vecDot(nimg, i0, e)<=eMq) i0+=4;\n\t\twhile(vecDot(nimg, i1, e)> eMq) i1-=4;\n\t\tif(i0>=i1) break;\n\t\t\n\t\tvar t = nimg32[i0>>2];  nimg32[i0>>2] = nimg32[i1>>2];  nimg32[i1>>2]=t;\n\t\t\n\t\ti0+=4;  i1-=4;\n\t}\n\twhile(vecDot(nimg, i0, e)>eMq) i0-=4;\n\treturn i0+4;\n}\nUPNG.quantize.vecDot = function(nimg, i, e)\n{\n\treturn nimg[i]*e[0] + nimg[i+1]*e[1] + nimg[i+2]*e[2] + nimg[i+3]*e[3];\n}\nUPNG.quantize.stats = function(nimg, i0, i1){\n\tvar R = [0,0,0,0,  0,0,0,0,  0,0,0,0,  0,0,0,0];\n\tvar m = [0,0,0,0];\n\tvar N = (i1-i0)>>2;\n\tfor(var i=i0; i<i1; i+=4)\n\t{\n\t\tvar r = nimg[i]*(1/255), g = nimg[i+1]*(1/255), b = nimg[i+2]*(1/255), a = nimg[i+3]*(1/255);\n\t\t//var r = nimg[i], g = nimg[i+1], b = nimg[i+2], a = nimg[i+3];\n\t\tm[0]+=r;  m[1]+=g;  m[2]+=b;  m[3]+=a;\n\t\t\n\t\tR[ 0] += r*r;  R[ 1] += r*g;  R[ 2] += r*b;  R[ 3] += r*a;  \n\t\t               R[ 5] += g*g;  R[ 6] += g*b;  R[ 7] += g*a; \n\t\t                              R[10] += b*b;  R[11] += b*a;  \n\t\t                                             R[15] += a*a;  \n\t}\n\tR[4]=R[1];  R[8]=R[2];  R[9]=R[6];  R[12]=R[3];  R[13]=R[7];  R[14]=R[11];\n\t\n\treturn {R:R, m:m, N:N};\n}\nUPNG.quantize.estats = function(stats){\n\tvar R = stats.R, m = stats.m, N = stats.N;\n\t\n\t// when all samples are equal, but N is large (millions), the Rj can be non-zero ( 0.0003.... - precission error)\n\tvar m0 = m[0], m1 = m[1], m2 = m[2], m3 = m[3], iN = (N==0 ? 0 : 1/N);\n\tvar Rj = [\n\t\tR[ 0] - m0*m0*iN,  R[ 1] - m0*m1*iN,  R[ 2] - m0*m2*iN,  R[ 3] - m0*m3*iN,  \n\t\tR[ 4] - m1*m0*iN,  R[ 5] - m1*m1*iN,  R[ 6] - m1*m2*iN,  R[ 7] - m1*m3*iN,\n\t\tR[ 8] - m2*m0*iN,  R[ 9] - m2*m1*iN,  R[10] - m2*m2*iN,  R[11] - m2*m3*iN,  \n\t\tR[12] - m3*m0*iN,  R[13] - m3*m1*iN,  R[14] - m3*m2*iN,  R[15] - m3*m3*iN \n\t];\n\t\n\tvar A = Rj, M = UPNG.M4;\n\tvar b = [0.5,0.5,0.5,0.5], mi = 0, tmi = 0;\n\t\n\tif(N!=0)\n\tfor(var i=0; i<10; i++) {\n\t\tb = M.multVec(A, b);  tmi = Math.sqrt(M.dot(b,b));  b = M.sml(1/tmi,  b);\n\t\tif(Math.abs(tmi-mi)<1e-9) break;  mi = tmi;\n\t}\t\n\t//b = [0,0,1,0];  mi=N;\n\tvar q = [m0*iN, m1*iN, m2*iN, m3*iN];\n\tvar eMq255 = M.dot(M.sml(255,q),b);\n\t\n\treturn {  Cov:Rj, q:q, e:b, L:mi,  eMq255:eMq255, eMq : M.dot(b,q),\n\t\t\t\trgba: (((Math.round(255*q[3])<<24) | (Math.round(255*q[2])<<16) |  (Math.round(255*q[1])<<8) | (Math.round(255*q[0])<<0))>>>0)  };\n}\nUPNG.M4 = {\n\tmultVec : function(m,v) {\n\t\t\treturn [\n\t\t\t\tm[ 0]*v[0] + m[ 1]*v[1] + m[ 2]*v[2] + m[ 3]*v[3],\n\t\t\t\tm[ 4]*v[0] + m[ 5]*v[1] + m[ 6]*v[2] + m[ 7]*v[3],\n\t\t\t\tm[ 8]*v[0] + m[ 9]*v[1] + m[10]*v[2] + m[11]*v[3],\n\t\t\t\tm[12]*v[0] + m[13]*v[1] + m[14]*v[2] + m[15]*v[3]\n\t\t\t];\n\t},\n\tdot : function(x,y) {  return  x[0]*y[0]+x[1]*y[1]+x[2]*y[2]+x[3]*y[3];  },\n\tsml : function(a,y) {  return [a*y[0],a*y[1],a*y[2],a*y[3]];  }\n}\n\nUPNG.encode.concatRGBA = function(bufs) {\n\tvar tlen = 0;\n\tfor(var i=0; i<bufs.length; i++) tlen += bufs[i].byteLength;\n\tvar nimg = new Uint8Array(tlen), noff=0;\n\tfor(var i=0; i<bufs.length; i++) {\n\t\tvar img = new Uint8Array(bufs[i]), il = img.length;\n\t\tfor(var j=0; j<il; j+=4) {  \n\t\t\tvar r=img[j], g=img[j+1], b=img[j+2], a = img[j+3];\n\t\t\tif(a==0) r=g=b=0;\n\t\t\tnimg[noff+j]=r;  nimg[noff+j+1]=g;  nimg[noff+j+2]=b;  nimg[noff+j+3]=a;  }\n\t\tnoff += il;\n\t}\n\treturn nimg.buffer;\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (UPNG);\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vQHBkZi1saWIrdXBuZ0AxLjAuMS9ub2RlX21vZHVsZXMvQHBkZi1saWIvdXBuZy9VUE5HLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUF3Qjs7QUFFeEI7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxxQkFBcUI7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixPQUFPO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0I7O0FBRS9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxxQkFBcUI7QUFDckI7QUFDQSw2QkFBNkIsUUFBUSxTQUFTLGtCQUFrQixzQkFBc0Isc0JBQXNCO0FBQzVHLDZCQUE2QixRQUFRLFNBQVM7QUFDOUM7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDhCQUE4QixRQUFRLFFBQVEsYUFBYTtBQUMzRCw4QkFBOEIsUUFBUSxRQUFRLGFBQWE7QUFDM0Q7QUFDQSxVQUFVO0FBQ1YsOEJBQThCLFFBQVEsUUFBUSxzQkFBc0I7QUFDcEU7QUFDQSw4QkFBOEIsUUFBUSxRQUFRLHNCQUFzQjtBQUNwRTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBLDRCQUE0QixLQUFLLFFBQVE7QUFDekMsZ0JBQWdCLEtBQUssT0FBTyxxRUFBcUUsZUFBZSxtQkFBbUIsbUJBQW1CO0FBQ3RKO0FBQ0EsNEJBQTRCLEtBQUssUUFBUTtBQUN6QyxnQkFBZ0IsS0FBSyxPQUFPLHFFQUFxRSxlQUFlLG1CQUFtQixtQkFBbUI7QUFDdEo7QUFDQSw0QkFBNEIsS0FBSyxRQUFRO0FBQ3pDLGdCQUFnQixLQUFLLE9BQU8scUVBQXFFLGVBQWUsbUJBQW1CLG1CQUFtQjtBQUN0SjtB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LGVBQWU7QUFDN0I7QUFDQSxlQUFlLE1BQU07QUFDckI7QUFDQTtBQUNBLG9CQUFvQixtQkFBbUIsbUJBQW1CO0FBQzFEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlFQUFlLElBQUksRUFBQyIsInNvdXJjZXMiOlsiRDpcXGR1Y2tUYWJsZVxcZGVtb1xccGRmLXJvdGF0ZS10b29sXFxub2RlX21vZHVsZXNcXC5wbnBtXFxAcGRmLWxpYit1cG5nQDEuMC4xXFxub2RlX21vZHVsZXNcXEBwZGYtbGliXFx1cG5nXFxVUE5HLmpzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBwYWtvIGZyb20gJ3Bha28nO1xuXG52YXIgVVBORyA9IHt9O1xuXG5cdFxuXG5VUE5HLnRvUkdCQTggPSBmdW5jdGlvbihvdXQpXG57XG5cdHZhciB3ID0gb3V0LndpZHRoLCBoID0gb3V0LmhlaWdodDtcblx0aWYob3V0LnRhYnMuYWNUTD09bnVsbCkgcmV0dXJuIFtVUE5HLnRvUkdCQTguZGVjb2RlSW1hZ2Uob3V0LmRhdGEsIHcsIGgsIG91dCkuYnVmZmVyXTtcblx0XG5cdHZhciBmcm1zID0gW107XG5cdGlmKG91dC5mcmFtZXNbMF0uZGF0YT09bnVsbCkgb3V0LmZyYW1lc1swXS5kYXRhID0gb3V0LmRhdGE7XG5cdFxuXHR2YXIgbGVuID0gdypoKjQsIGltZyA9IG5ldyBVaW50OEFycmF5KGxlbiksIGVtcHR5ID0gbmV3IFVpbnQ4QXJyYXkobGVuKSwgcHJldj1uZXcgVWludDhBcnJheShsZW4pO1xuXHRmb3IodmFyIGk9MDsgaTxvdXQuZnJhbWVzLmxlbmd0aDsgaSsrKVxuXHR7XG5cdFx0dmFyIGZybSA9IG91dC5mcmFtZXNbaV07XG5cdFx0dmFyIGZ4PWZybS5yZWN0LngsIGZ5PWZybS5yZWN0LnksIGZ3ID0gZnJtLnJlY3Qud2lkdGgsIGZoID0gZnJtLnJlY3QuaGVpZ2h0O1xuXHRcdHZhciBmZGF0YSA9IFVQTkcudG9SR0JBOC5kZWNvZGVJbWFnZShmcm0uZGF0YSwgZncsZmgsIG91dCk7XG5cdFx0XG5cdFx0aWYoaSE9MCkgZm9yKHZhciBqPTA7IGo8bGVuOyBqKyspIHByZXZbal09aW1nW2pdO1xuXHRcdFxuXHRcdGlmICAgICAoZnJtLmJsZW5kPT0wKSBVUE5HLl9jb3B5VGlsZShmZGF0YSwgZncsIGZoLCBpbWcsIHcsIGgsIGZ4LCBmeSwgMCk7XG5cdFx0ZWxzZSBpZihmcm0uYmxlbmQ9PTEpIFVQTkcuX2NvcHlUaWxlKGZkYXRhLCBmdywgZmgsIGltZywgdywgaCwgZngsIGZ5LCAxKTtcblx0XHRcblx0XHRmcm1zLnB1c2goaW1nLmJ1ZmZlci5zbGljZSgwKSk7XG5cdFx0XG5cdFx0aWYgICAgIChmcm0uZGlzcG9zZT09MCkge31cblx0XHRlbHNlIGlmKGZybS5kaXNwb3NlPT0xKSBVUE5HLl9jb3B5VGlsZShlbXB0eSwgZncsIGZoLCBpbWcsIHcsIGgsIGZ4LCBmeSwgMCk7XG5cdFx0ZWxzZSBpZihmcm0uZGlzcG9zZT09MikgZm9yKHZhciBqPTA7IGo8bGVuOyBqKyspIGltZ1tqXT1wcmV2W2pdO1xuXHR9XG5cdHJldHVybiBmcm1zO1xufVxuVVBORy50b1JHQkE4LmRlY29kZUltYWdlID0gZnVuY3Rpb24oZGF0YSwgdywgaCwgb3V0KVxue1xuXHR2YXIgYXJlYSA9IHcqaCwgYnBwID0gVVBORy5kZWNvZGUuX2dldEJQUChvdXQpO1xuXHR2YXIgYnBsID0gTWF0aC5jZWlsKHcqYnBwLzgpO1x0Ly8gYnl0ZXMgcGVyIGxpbmVcblxuXHR2YXIgYmYgPSBuZXcgVWludDhBcnJheShhcmVhKjQpLCBiZjMyID0gbmV3IFVpbnQzMkFycmF5KGJmLmJ1ZmZlcik7XG5cdHZhciBjdHlwZSA9IG91dC5jdHlwZSwgZGVwdGggPSBvdXQuZGVwdGg7XG5cdHZhciBycyA9IFVQTkcuX2Jpbi5yZWFkVXNob3J0O1xuXHRcblx0Ly9jb25zb2xlLmxvZyhjdHlwZSwgZGVwdGgpO1xuXHR2YXIgdGltZSA9IERhdGUubm93KCk7XG5cblx0aWYgICAgIChjdHlwZT09NikgeyAvLyBSR0IgKyBhbHBoYVxuXHRcdHZhciBxYXJlYSA9IGFyZWE8PDI7XG5cdFx0aWYoZGVwdGg9PSA4KSBmb3IodmFyIGk9MDsgaTxxYXJlYTtpKz00KSB7ICBiZltpXSA9IGRhdGFbaV07ICBiZltpKzFdID0gZGF0YVtpKzFdOyAgYmZbaSsyXSA9IGRhdGFbaSsyXTsgIGJmW2krM10gPSBkYXRhW2krM107IH1cblx0XHRpZihkZXB0aD09MTYpIGZvcih2YXIgaT0wOyBpPHFhcmVhO2krKyApIHsgIGJmW2ldID0gZGF0YVtpPDwxXTsgIH1cblx0fVxuXHRlbHNlIGlmKGN0eXBlPT0yKSB7XHQvLyBSR0Jcblx0XHR2YXIgdHM9b3V0LnRhYnNbXCJ0Uk5TXCJdO1xuXHRcdGlmKHRzPT1udWxsKSB7XG5cdFx0XHRpZihkZXB0aD09IDgpIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHRpPWkqMzsgIGJmMzJbaV0gPSAoMjU1PDwyNCl8KGRhdGFbdGkrMl08PDE2KXwoZGF0YVt0aSsxXTw8OCl8ZGF0YVt0aV07ICB9XG5cdFx0XHRpZihkZXB0aD09MTYpIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHRpPWkqNjsgIGJmMzJbaV0gPSAoMjU1PDwyNCl8KGRhdGFbdGkrNF08PDE2KXwoZGF0YVt0aSsyXTw8OCl8ZGF0YVt0aV07ICB9XG5cdFx0fVxuXHRcdGVsc2UgeyAgdmFyIHRyPXRzWzBdLCB0Zz10c1sxXSwgdGI9dHNbMl07XG5cdFx0XHRpZihkZXB0aD09IDgpIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHFpPWk8PDIsIHRpPWkqMzsgIGJmMzJbaV0gPSAoMjU1PDwyNCl8KGRhdGFbdGkrMl08PDE2KXwoZGF0YVt0aSsxXTw8OCl8ZGF0YVt0aV07XG5cdFx0XHRcdGlmKGRhdGFbdGldICAgPT10ciAmJiBkYXRhW3RpKzFdICAgPT10ZyAmJiBkYXRhW3RpKzJdICAgPT10YikgYmZbcWkrM10gPSAwOyAgfVxuXHRcdFx0aWYoZGVwdGg9PTE2KSBmb3IodmFyIGk9MDsgaTxhcmVhOyBpKyspIHsgIHZhciBxaT1pPDwyLCB0aT1pKjY7ICBiZjMyW2ldID0gKDI1NTw8MjQpfChkYXRhW3RpKzRdPDwxNil8KGRhdGFbdGkrMl08PDgpfGRhdGFbdGldO1xuXHRcdFx0XHRpZihycyhkYXRhLHRpKT09dHIgJiYgcnMoZGF0YSx0aSsyKT09dGcgJiYgcnMoZGF0YSx0aSs0KT09dGIpIGJmW3FpKzNdID0gMDsgIH1cblx0XHR9XG5cdH1cblx0ZWxzZSBpZihjdHlwZT09Mykge1x0Ly8gcGFsZXR0ZVxuXHRcdHZhciBwPW91dC50YWJzW1wiUExURVwiXSwgYXA9b3V0LnRhYnNbXCJ0Uk5TXCJdLCB0bD1hcD9hcC5sZW5ndGg6MDtcblx0XHQvL2NvbnNvbGUubG9nKHAsIGFwKTtcblx0XHRpZihkZXB0aD09MSkgZm9yKHZhciB5PTA7IHk8aDsgeSsrKSB7ICB2YXIgczAgPSB5KmJwbCwgdDAgPSB5Knc7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTx3OyBpKyspIHsgdmFyIHFpPSh0MCtpKTw8Miwgaj0oKGRhdGFbczArKGk+PjMpXT4+KDctKChpJjcpPDwwKSkpJiAxKSwgY2o9MypqOyAgYmZbcWldPXBbY2pdOyAgYmZbcWkrMV09cFtjaisxXTsgIGJmW3FpKzJdPXBbY2orMl07ICBiZltxaSszXT0oajx0bCk/YXBbal06MjU1OyAgfVxuXHRcdH1cblx0XHRpZihkZXB0aD09MikgZm9yKHZhciB5PTA7IHk8aDsgeSsrKSB7ICB2YXIgczAgPSB5KmJwbCwgdDAgPSB5Knc7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTx3OyBpKyspIHsgdmFyIHFpPSh0MCtpKTw8Miwgaj0oKGRhdGFbczArKGk+PjIpXT4+KDYtKChpJjMpPDwxKSkpJiAzKSwgY2o9MypqOyAgYmZbcWldPXBbY2pdOyAgYmZbcWkrMV09cFtjaisxXTsgIGJmW3FpKzJdPXBbY2orMl07ICBiZltxaSszXT0oajx0bCk/YXBbal06MjU1OyAgfVxuXHRcdH1cblx0XHRpZihkZXB0aD09NCkgZm9yKHZhciB5PTA7IHk8aDsgeSsrKSB7ICB2YXIgczAgPSB5KmJwbCwgdDAgPSB5Knc7XG5cdFx0XHRmb3IodmFyIGk9MDsgaTx3OyBpKyspIHsgdmFyIHFpPSh0MCtpKTw8Miwgaj0oKGRhdGFbczArKGk+PjEpXT4+KDQtKChpJjEpPDwyKSkpJjE1KSwgY2o9MypqOyAgYmZbcWldPXBbY2pdOyAgYmZbcWkrMV09cFtjaisxXTsgIGJmW3FpKzJdPXBbY2orMl07ICBiZltxaSszXT0oajx0bCk/YXBbal06MjU1OyAgfVxuXHRcdH1cblx0XHRpZihkZXB0aD09OCkgZm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrICkgeyAgdmFyIHFpPWk8PDIsIGo9ZGF0YVtpXSAgICAgICAgICAgICAgICAgICAgICAsIGNqPTMqajsgIGJmW3FpXT1wW2NqXTsgIGJmW3FpKzFdPXBbY2orMV07ICBiZltxaSsyXT1wW2NqKzJdOyAgYmZbcWkrM109KGo8dGwpP2FwW2pdOjI1NTsgIH1cblx0fVxuXHRlbHNlIGlmKGN0eXBlPT00KSB7XHQvLyBncmF5ICsgYWxwaGFcblx0XHRpZihkZXB0aD09IDgpICBmb3IodmFyIGk9MDsgaTxhcmVhOyBpKyspIHsgIHZhciBxaT1pPDwyLCBkaT1pPDwxLCBncj1kYXRhW2RpXTsgIGJmW3FpXT1ncjsgIGJmW3FpKzFdPWdyOyAgYmZbcWkrMl09Z3I7ICBiZltxaSszXT1kYXRhW2RpKzFdOyAgfVxuXHRcdGlmKGRlcHRoPT0xNikgIGZvcih2YXIgaT0wOyBpPGFyZWE7IGkrKykgeyAgdmFyIHFpPWk8PDIsIGRpPWk8PDIsIGdyPWRhdGFbZGldOyAgYmZbcWldPWdyOyAgYmZbcWkrMV09Z3I7ICBiZltxaSsyXT1ncjsgIGJmW3FpKzNdPWRhdGFbZGkrMl07ICB9XG5cdH1cblx0ZWxzZSBpZihjdHlwZT09MCkge1x0Ly8gZ3JheVxuXHRcdHZhciB0ciA9IG91dC50YWJzW1widFJOU1wiXSA/IG91dC50YWJzW1widFJOU1wiXSA6IC0xO1xuXHRcdGZvcih2YXIgeT0wOyB5PGg7IHkrKykge1xuXHRcdFx0dmFyIG9mZiA9IHkqYnBsLCB0byA9IHkqdztcblx0XHRcdGlmICAgICAoZGVwdGg9PSAxKSBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHsgIHZhciBncj0yNTUqKChkYXRhW29mZisoeD4+PjMpXT4+Pig3IC0oKHgmNykgICApKSkmIDEpLCBhbD0oZ3I9PXRyKjI1NSk/MDoyNTU7ICBiZjMyW3RvK3hdPShhbDw8MjQpfChncjw8MTYpfChncjw8OCl8Z3I7ICB9XG5cdFx0XHRlbHNlIGlmKGRlcHRoPT0gMikgZm9yKHZhciB4PTA7IHg8dzsgeCsrKSB7ICB2YXIgZ3I9IDg1KigoZGF0YVtvZmYrKHg+Pj4yKV0+Pj4oNiAtKCh4JjMpPDwxKSkpJiAzKSwgYWw9KGdyPT10ciogODUpPzA6MjU1OyAgYmYzMlt0byt4XT0oYWw8PDI0KXwoZ3I8PDE2KXwoZ3I8PDgpfGdyOyAgfVxuXHRcdFx0ZWxzZSBpZihkZXB0aD09IDQpIGZvcih2YXIgeD0wOyB4PHc7IHgrKykgeyAgdmFyIGdyPSAxNyooKGRhdGFbb2ZmKyh4Pj4+MSldPj4+KDQgLSgoeCYxKTw8MikpKSYxNSksIGFsPShncj09dHIqIDE3KT8wOjI1NTsgIGJmMzJbdG8reF09KGFsPDwyNCl8KGdyPDwxNil8KGdyPDw4KXxncjsgIH1cblx0XHRcdGVsc2UgaWYoZGVwdGg9PSA4KSBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHsgIHZhciBncj1kYXRhW29mZisgICAgIHhdLCBhbD0oZ3IgICAgICAgICAgICAgICAgID09dHIpPzA6MjU1OyAgYmYzMlt0byt4XT0oYWw8PDI0KXwoZ3I8PDE2KXwoZ3I8PDgpfGdyOyAgfVxuXHRcdFx0ZWxzZSBpZihkZXB0aD09MTYpIGZvcih2YXIgeD0wOyB4PHc7IHgrKykgeyAgdmFyIGdyPWRhdGFbb2ZmKyh4PDwxKV0sIGFsPShycyhkYXRhLG9mZisoeDw8aSkpPT10cik/MDoyNTU7ICBiZjMyW3RvK3hdPShhbDw8MjQpfChncjw8MTYpfChncjw8OCl8Z3I7ICB9XG5cdFx0fVxuXHR9XG5cdC8vY29uc29sZS5sb2coRGF0ZS5ub3coKS10aW1lKTtcblx0cmV0dXJuIGJmO1xufVxuXG5cblxuVVBORy5kZWNvZGUgPSBmdW5jdGlvbihidWZmKVxue1xuXHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGJ1ZmYpLCBvZmZzZXQgPSA4LCBiaW4gPSBVUE5HLl9iaW4sIHJVcyA9IGJpbi5yZWFkVXNob3J0LCByVWkgPSBiaW4ucmVhZFVpbnQ7XG5cdHZhciBvdXQgPSB7dGFiczp7fSwgZnJhbWVzOltdfTtcblx0dmFyIGRkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpLCBkb2ZmID0gMDtcdCAvLyBwdXQgYWxsIElEQVQgZGF0YSBpbnRvIGl0XG5cdHZhciBmZCwgZm9mZiA9IDA7XHQvLyBmcmFtZXNcblx0XG5cdHZhciBtZ2NrID0gWzB4ODksIDB4NTAsIDB4NGUsIDB4NDcsIDB4MGQsIDB4MGEsIDB4MWEsIDB4MGFdO1xuXHRmb3IodmFyIGk9MDsgaTw4OyBpKyspIGlmKGRhdGFbaV0hPW1nY2tbaV0pIHRocm93IFwiVGhlIGlucHV0IGlzIG5vdCBhIFBORyBmaWxlIVwiO1xuXG5cdHdoaWxlKG9mZnNldDxkYXRhLmxlbmd0aClcblx0e1xuXHRcdHZhciBsZW4gID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0XHR2YXIgdHlwZSA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2Zmc2V0LCA0KTsgIG9mZnNldCArPSA0O1xuXHRcdC8vY29uc29sZS5sb2codHlwZSxsZW4pO1xuXHRcdFxuXHRcdGlmICAgICAodHlwZT09XCJJSERSXCIpICB7ICBVUE5HLmRlY29kZS5fSUhEUihkYXRhLCBvZmZzZXQsIG91dCk7ICB9XG5cdFx0ZWxzZSBpZih0eXBlPT1cIklEQVRcIikge1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bGVuOyBpKyspIGRkW2RvZmYraV0gPSBkYXRhW29mZnNldCtpXTtcblx0XHRcdGRvZmYgKz0gbGVuO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiYWNUTFwiKSAge1xuXHRcdFx0b3V0LnRhYnNbdHlwZV0gPSB7ICBudW1fZnJhbWVzOnJVaShkYXRhLCBvZmZzZXQpLCBudW1fcGxheXM6clVpKGRhdGEsIG9mZnNldCs0KSAgfTtcblx0XHRcdGZkID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiZmNUTFwiKSAge1xuXHRcdFx0aWYoZm9mZiE9MCkgeyAgdmFyIGZyID0gb3V0LmZyYW1lc1tvdXQuZnJhbWVzLmxlbmd0aC0xXTtcblx0XHRcdFx0ZnIuZGF0YSA9IFVQTkcuZGVjb2RlLl9kZWNvbXByZXNzKG91dCwgZmQuc2xpY2UoMCxmb2ZmKSwgZnIucmVjdC53aWR0aCwgZnIucmVjdC5oZWlnaHQpOyAgZm9mZj0wO1xuXHRcdFx0fVxuXHRcdFx0dmFyIHJjdCA9IHt4OnJVaShkYXRhLCBvZmZzZXQrMTIpLHk6clVpKGRhdGEsIG9mZnNldCsxNiksd2lkdGg6clVpKGRhdGEsIG9mZnNldCs0KSxoZWlnaHQ6clVpKGRhdGEsIG9mZnNldCs4KX07XG5cdFx0XHR2YXIgZGVsID0gclVzKGRhdGEsIG9mZnNldCsyMik7ICBkZWwgPSByVXMoZGF0YSwgb2Zmc2V0KzIwKSAvIChkZWw9PTA/MTAwOmRlbCk7XG5cdFx0XHR2YXIgZnJtID0ge3JlY3Q6cmN0LCBkZWxheTpNYXRoLnJvdW5kKGRlbCoxMDAwKSwgZGlzcG9zZTpkYXRhW29mZnNldCsyNF0sIGJsZW5kOmRhdGFbb2Zmc2V0KzI1XX07XG5cdFx0XHQvL2NvbnNvbGUubG9nKGZybSk7XG5cdFx0XHRvdXQuZnJhbWVzLnB1c2goZnJtKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cImZkQVRcIikge1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8bGVuLTQ7IGkrKykgZmRbZm9mZitpXSA9IGRhdGFbb2Zmc2V0K2krNF07XG5cdFx0XHRmb2ZmICs9IGxlbi00O1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwicEhZc1wiKSB7XG5cdFx0XHRvdXQudGFic1t0eXBlXSA9IFtiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KSwgYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCs0KSwgZGF0YVtvZmZzZXQrOF1dO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiY0hSTVwiKSB7XG5cdFx0XHRvdXQudGFic1t0eXBlXSA9IFtdO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8ODsgaSsrKSBvdXQudGFic1t0eXBlXS5wdXNoKGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQraSo0KSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJ0RVh0XCIpIHtcblx0XHRcdGlmKG91dC50YWJzW3R5cGVdPT1udWxsKSBvdXQudGFic1t0eXBlXSA9IHt9O1xuXHRcdFx0dmFyIG56ID0gYmluLm5leHRaZXJvKGRhdGEsIG9mZnNldCk7XG5cdFx0XHR2YXIga2V5dyA9IGJpbi5yZWFkQVNDSUkoZGF0YSwgb2Zmc2V0LCBuei1vZmZzZXQpO1xuXHRcdFx0dmFyIHRleHQgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG56KzEsIG9mZnNldCtsZW4tbnotMSk7XG5cdFx0XHRvdXQudGFic1t0eXBlXVtrZXl3XSA9IHRleHQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJpVFh0XCIpIHtcblx0XHRcdGlmKG91dC50YWJzW3R5cGVdPT1udWxsKSBvdXQudGFic1t0eXBlXSA9IHt9O1xuXHRcdFx0dmFyIG56ID0gMCwgb2ZmID0gb2Zmc2V0O1xuXHRcdFx0bnogPSBiaW4ubmV4dFplcm8oZGF0YSwgb2ZmKTtcblx0XHRcdHZhciBrZXl3ID0gYmluLnJlYWRBU0NJSShkYXRhLCBvZmYsIG56LW9mZik7ICBvZmYgPSBueiArIDE7XG5cdFx0XHR2YXIgY2ZsYWcgPSBkYXRhW29mZl0sIGNtZXRoID0gZGF0YVtvZmYrMV07ICBvZmYrPTI7XG5cdFx0XHRueiA9IGJpbi5uZXh0WmVybyhkYXRhLCBvZmYpO1xuXHRcdFx0dmFyIGx0YWcgPSBiaW4ucmVhZEFTQ0lJKGRhdGEsIG9mZiwgbnotb2ZmKTsgIG9mZiA9IG56ICsgMTtcblx0XHRcdG56ID0gYmluLm5leHRaZXJvKGRhdGEsIG9mZik7XG5cdFx0XHR2YXIgdGtleXcgPSBiaW4ucmVhZFVURjgoZGF0YSwgb2ZmLCBuei1vZmYpOyAgb2ZmID0gbnogKyAxO1xuXHRcdFx0dmFyIHRleHQgID0gYmluLnJlYWRVVEY4KGRhdGEsIG9mZiwgbGVuLShvZmYtb2Zmc2V0KSk7XG5cdFx0XHRvdXQudGFic1t0eXBlXVtrZXl3XSA9IHRleHQ7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJQTFRFXCIpIHtcblx0XHRcdG91dC50YWJzW3R5cGVdID0gYmluLnJlYWRCeXRlcyhkYXRhLCBvZmZzZXQsIGxlbik7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJoSVNUXCIpIHtcblx0XHRcdHZhciBwbCA9IG91dC50YWJzW1wiUExURVwiXS5sZW5ndGgvMztcblx0XHRcdG91dC50YWJzW3R5cGVdID0gW107ICBmb3IodmFyIGk9MDsgaTxwbDsgaSsrKSBvdXQudGFic1t0eXBlXS5wdXNoKHJVcyhkYXRhLCBvZmZzZXQraSoyKSk7XG5cdFx0fVxuXHRcdGVsc2UgaWYodHlwZT09XCJ0Uk5TXCIpIHtcblx0XHRcdGlmICAgICAob3V0LmN0eXBlPT0zKSBvdXQudGFic1t0eXBlXSA9IGJpbi5yZWFkQnl0ZXMoZGF0YSwgb2Zmc2V0LCBsZW4pO1xuXHRcdFx0ZWxzZSBpZihvdXQuY3R5cGU9PTApIG91dC50YWJzW3R5cGVdID0gclVzKGRhdGEsIG9mZnNldCk7XG5cdFx0XHRlbHNlIGlmKG91dC5jdHlwZT09Mikgb3V0LnRhYnNbdHlwZV0gPSBbIHJVcyhkYXRhLG9mZnNldCksclVzKGRhdGEsb2Zmc2V0KzIpLHJVcyhkYXRhLG9mZnNldCs0KSBdO1xuXHRcdFx0Ly9lbHNlIGNvbnNvbGUubG9nKFwidFJOUyBmb3IgdW5zdXBwb3J0ZWQgY29sb3IgdHlwZVwiLG91dC5jdHlwZSwgbGVuKTtcblx0XHR9XG5cdFx0ZWxzZSBpZih0eXBlPT1cImdBTUFcIikgb3V0LnRhYnNbdHlwZV0gPSBiaW4ucmVhZFVpbnQoZGF0YSwgb2Zmc2V0KS8xMDAwMDA7XG5cdFx0ZWxzZSBpZih0eXBlPT1cInNSR0JcIikgb3V0LnRhYnNbdHlwZV0gPSBkYXRhW29mZnNldF07XG5cdFx0ZWxzZSBpZih0eXBlPT1cImJLR0RcIilcblx0XHR7XG5cdFx0XHRpZiAgICAgKG91dC5jdHlwZT09MCB8fCBvdXQuY3R5cGU9PTQpIG91dC50YWJzW3R5cGVdID0gW3JVcyhkYXRhLCBvZmZzZXQpXTtcblx0XHRcdGVsc2UgaWYob3V0LmN0eXBlPT0yIHx8IG91dC5jdHlwZT09Nikgb3V0LnRhYnNbdHlwZV0gPSBbclVzKGRhdGEsIG9mZnNldCksIHJVcyhkYXRhLCBvZmZzZXQrMiksIHJVcyhkYXRhLCBvZmZzZXQrNCldO1xuXHRcdFx0ZWxzZSBpZihvdXQuY3R5cGU9PTMpIG91dC50YWJzW3R5cGVdID0gZGF0YVtvZmZzZXRdO1xuXHRcdH1cblx0XHRlbHNlIGlmKHR5cGU9PVwiSUVORFwiKSB7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Ly9lbHNlIHsgIGxvZyhcInVua25vd24gY2h1bmsgdHlwZVwiLCB0eXBlLCBsZW4pOyAgfVxuXHRcdG9mZnNldCArPSBsZW47XG5cdFx0dmFyIGNyYyA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG5cdH1cblx0aWYoZm9mZiE9MCkgeyAgdmFyIGZyID0gb3V0LmZyYW1lc1tvdXQuZnJhbWVzLmxlbmd0aC0xXTtcblx0XHRmci5kYXRhID0gVVBORy5kZWNvZGUuX2RlY29tcHJlc3Mob3V0LCBmZC5zbGljZSgwLGZvZmYpLCBmci5yZWN0LndpZHRoLCBmci5yZWN0LmhlaWdodCk7ICBmb2ZmPTA7XG5cdH1cdFxuXHRvdXQuZGF0YSA9IFVQTkcuZGVjb2RlLl9kZWNvbXByZXNzKG91dCwgZGQsIG91dC53aWR0aCwgb3V0LmhlaWdodCk7XG5cdFxuXHRkZWxldGUgb3V0LmNvbXByZXNzOyAgZGVsZXRlIG91dC5pbnRlcmxhY2U7ICBkZWxldGUgb3V0LmZpbHRlcjtcblx0cmV0dXJuIG91dDtcbn1cblxuVVBORy5kZWNvZGUuX2RlY29tcHJlc3MgPSBmdW5jdGlvbihvdXQsIGRkLCB3LCBoKSB7XG5cdHZhciB0aW1lID0gRGF0ZS5ub3coKTtcblx0dmFyIGJwcCA9IFVQTkcuZGVjb2RlLl9nZXRCUFAob3V0KSwgYnBsID0gTWF0aC5jZWlsKHcqYnBwLzgpLCBidWZmID0gbmV3IFVpbnQ4QXJyYXkoKGJwbCsxK291dC5pbnRlcmxhY2UpKmgpO1xuXHRkZCA9IFVQTkcuZGVjb2RlLl9pbmZsYXRlKGRkLGJ1ZmYpO1xuXHQvL2NvbnNvbGUubG9nKGRkLmxlbmd0aCwgYnVmZi5sZW5ndGgpO1xuXHQvL2NvbnNvbGUubG9nKERhdGUubm93KCktdGltZSk7XG5cblx0dmFyIHRpbWU9RGF0ZS5ub3coKTtcblx0aWYgICAgIChvdXQuaW50ZXJsYWNlPT0wKSBkZCA9IFVQTkcuZGVjb2RlLl9maWx0ZXJaZXJvKGRkLCBvdXQsIDAsIHcsIGgpO1xuXHRlbHNlIGlmKG91dC5pbnRlcmxhY2U9PTEpIGRkID0gVVBORy5kZWNvZGUuX3JlYWRJbnRlcmxhY2UoZGQsIG91dCk7XG5cdC8vY29uc29sZS5sb2coRGF0ZS5ub3coKS10aW1lKTtcblx0cmV0dXJuIGRkO1xufVxuXG5VUE5HLmRlY29kZS5faW5mbGF0ZSA9IGZ1bmN0aW9uKGRhdGEsIGJ1ZmYpIHsgIHZhciBvdXQ9VVBOR1tcImluZmxhdGVSYXdcIl0obmV3IFVpbnQ4QXJyYXkoZGF0YS5idWZmZXIsIDIsZGF0YS5sZW5ndGgtNiksYnVmZik7ICByZXR1cm4gb3V0OyAgfVxuVVBORy5pbmZsYXRlUmF3PWZ1bmN0aW9uKCl7dmFyIEg9e307SC5IPXt9O0guSC5OPWZ1bmN0aW9uKE4sVyl7dmFyIFI9VWludDhBcnJheSxpPTAsbT0wLEo9MCxoPTAsUT0wLFg9MCx1PTAsdz0wLGQ9MCx2LEM7XG5pZihOWzBdPT0zJiZOWzFdPT0wKXJldHVybiBXP1c6bmV3IFIoMCk7dmFyIFY9SC5ILG49Vi5iLEE9Vi5lLGw9Vi5SLE09Vi5uLEk9Vi5BLGU9Vi5aLGI9Vi5tLFo9Vz09bnVsbDtcbmlmKFopVz1uZXcgUihOLmxlbmd0aD4+PjI8PDMpO3doaWxlKGk9PTApe2k9bihOLGQsMSk7bT1uKE4sZCsxLDIpO2QrPTM7aWYobT09MCl7aWYoKGQmNykhPTApZCs9OC0oZCY3KTtcbnZhciBEPShkPj4+MykrNCxxPU5bRC00XXxOW0QtM108PDg7aWYoWilXPUguSC5XKFcsdytxKTtXLnNldChuZXcgUihOLmJ1ZmZlcixOLmJ5dGVPZmZzZXQrRCxxKSx3KTtkPUQrcTw8MztcbncrPXE7Y29udGludWV9aWYoWilXPUguSC5XKFcsdysoMTw8MTcpKTtpZihtPT0xKXt2PWIuSjtDPWIuaDtYPSgxPDw5KS0xO3U9KDE8PDUpLTF9aWYobT09Mil7Sj1BKE4sZCw1KSsyNTc7XG5oPUEoTixkKzUsNSkrMTtRPUEoTixkKzEwLDQpKzQ7ZCs9MTQ7dmFyIEU9ZCxqPTE7Zm9yKHZhciBjPTA7YzwzODtjKz0yKXtiLlFbY109MDtiLlFbYysxXT0wfWZvcih2YXIgYz0wO1xuYzxRO2MrKyl7dmFyIEs9QShOLGQrYyozLDMpO2IuUVsoYi5YW2NdPDwxKSsxXT1LO2lmKEs+ailqPUt9ZCs9MypRO00oYi5RLGopO0koYi5RLGosYi51KTt2PWIudztDPWIuZDtcbmQ9bChiLnUsKDE8PGopLTEsSitoLE4sZCxiLnYpO3ZhciByPVYuVihiLnYsMCxKLGIuQyk7WD0oMTw8ciktMTt2YXIgUz1WLlYoYi52LEosaCxiLkQpO3U9KDE8PFMpLTE7TShiLkMscik7XG5JKGIuQyxyLHYpO00oYi5ELFMpO0koYi5ELFMsQyl9d2hpbGUoITApe3ZhciBUPXZbZShOLGQpJlhdO2QrPVQmMTU7dmFyIHA9VD4+PjQ7aWYocD4+Pjg9PTApe1dbdysrXT1wfWVsc2UgaWYocD09MjU2KXticmVha31lbHNle3ZhciB6PXcrcC0yNTQ7XG5pZihwPjI2NCl7dmFyIF89Yi5xW3AtMjU3XTt6PXcrKF8+Pj4zKStBKE4sZCxfJjcpO2QrPV8mN312YXIgJD1DW2UoTixkKSZ1XTtkKz0kJjE1O3ZhciBzPSQ+Pj40LFk9Yi5jW3NdLGE9KFk+Pj40KStuKE4sZCxZJjE1KTtcbmQrPVkmMTU7d2hpbGUodzx6KXtXW3ddPVdbdysrLWFdO1dbd109V1t3KystYV07V1t3XT1XW3crKy1hXTtXW3ddPVdbdysrLWFdfXc9en19fXJldHVybiBXLmxlbmd0aD09dz9XOlcuc2xpY2UoMCx3KX07XG5ILkguVz1mdW5jdGlvbihOLFcpe3ZhciBSPU4ubGVuZ3RoO2lmKFc8PVIpcmV0dXJuIE47dmFyIFY9bmV3IFVpbnQ4QXJyYXkoUjw8MSk7Vi5zZXQoTiwwKTtyZXR1cm4gVn07XG5ILkguUj1mdW5jdGlvbihOLFcsUixWLG4sQSl7dmFyIGw9SC5ILmUsTT1ILkguWixJPTA7d2hpbGUoSTxSKXt2YXIgZT1OW00oVixuKSZXXTtuKz1lJjE1O3ZhciBiPWU+Pj40O1xuaWYoYjw9MTUpe0FbSV09YjtJKyt9ZWxzZXt2YXIgWj0wLG09MDtpZihiPT0xNil7bT0zK2woVixuLDIpO24rPTI7Wj1BW0ktMV19ZWxzZSBpZihiPT0xNyl7bT0zK2woVixuLDMpO1xubis9M31lbHNlIGlmKGI9PTE4KXttPTExK2woVixuLDcpO24rPTd9dmFyIEo9SSttO3doaWxlKEk8Sil7QVtJXT1aO0krK319fXJldHVybiBufTtILkguVj1mdW5jdGlvbihOLFcsUixWKXt2YXIgbj0wLEE9MCxsPVYubGVuZ3RoPj4+MTtcbndoaWxlKEE8Uil7dmFyIE09TltBK1ddO1ZbQTw8MV09MDtWWyhBPDwxKSsxXT1NO2lmKE0+biluPU07QSsrfXdoaWxlKEE8bCl7VltBPDwxXT0wO1ZbKEE8PDEpKzFdPTA7QSsrfXJldHVybiBufTtcbkguSC5uPWZ1bmN0aW9uKE4sVyl7dmFyIFI9SC5ILm0sVj1OLmxlbmd0aCxuLEEsbCxNLEksZT1SLmo7Zm9yKHZhciBNPTA7TTw9VztNKyspZVtNXT0wO2ZvcihNPTE7TTxWO00rPTIpZVtOW01dXSsrO1xudmFyIGI9Ui5LO249MDtlWzBdPTA7Zm9yKEE9MTtBPD1XO0ErKyl7bj1uK2VbQS0xXTw8MTtiW0FdPW59Zm9yKGw9MDtsPFY7bCs9Mil7ST1OW2wrMV07aWYoSSE9MCl7TltsXT1iW0ldO1xuYltJXSsrfX19O0guSC5BPWZ1bmN0aW9uKE4sVyxSKXt2YXIgVj1OLmxlbmd0aCxuPUguSC5tLEE9bi5yO2Zvcih2YXIgbD0wO2w8VjtsKz0yKWlmKE5bbCsxXSE9MCl7dmFyIE09bD4+MSxJPU5bbCsxXSxlPU08PDR8SSxiPVctSSxaPU5bbF08PGIsbT1aKygxPDxiKTtcbndoaWxlKFohPW0pe3ZhciBKPUFbWl0+Pj4xNS1XO1JbSl09ZTtaKyt9fX07SC5ILmw9ZnVuY3Rpb24oTixXKXt2YXIgUj1ILkgubS5yLFY9MTUtVztmb3IodmFyIG49MDtuPE4ubGVuZ3RoO1xubis9Mil7dmFyIEE9TltuXTw8Vy1OW24rMV07TltuXT1SW0FdPj4+Vn19O0guSC5NPWZ1bmN0aW9uKE4sVyxSKXtSPVI8PChXJjcpO3ZhciBWPVc+Pj4zO05bVl18PVI7TltWKzFdfD1SPj4+OH07XG5ILkguST1mdW5jdGlvbihOLFcsUil7Uj1SPDwoVyY3KTt2YXIgVj1XPj4+MztOW1ZdfD1SO05bVisxXXw9Uj4+Pjg7TltWKzJdfD1SPj4+MTZ9O0guSC5lPWZ1bmN0aW9uKE4sVyxSKXtyZXR1cm4oTltXPj4+M118TlsoVz4+PjMpKzFdPDw4KT4+PihXJjcpJigxPDxSKS0xfTtcbkguSC5iPWZ1bmN0aW9uKE4sVyxSKXtyZXR1cm4oTltXPj4+M118TlsoVz4+PjMpKzFdPDw4fE5bKFc+Pj4zKSsyXTw8MTYpPj4+KFcmNykmKDE8PFIpLTF9O0guSC5aPWZ1bmN0aW9uKE4sVyl7cmV0dXJuKE5bVz4+PjNdfE5bKFc+Pj4zKSsxXTw8OHxOWyhXPj4+MykrMl08PDE2KT4+PihXJjcpfTtcbkguSC5pPWZ1bmN0aW9uKE4sVyl7cmV0dXJuKE5bVz4+PjNdfE5bKFc+Pj4zKSsxXTw8OHxOWyhXPj4+MykrMl08PDE2fE5bKFc+Pj4zKSszXTw8MjQpPj4+KFcmNyl9O0guSC5tPWZ1bmN0aW9uKCl7dmFyIE49VWludDE2QXJyYXksVz1VaW50MzJBcnJheTtcbnJldHVybntLOm5ldyBOKDE2KSxqOm5ldyBOKDE2KSxYOlsxNiwxNywxOCwwLDgsNyw5LDYsMTAsNSwxMSw0LDEyLDMsMTMsMiwxNCwxLDE1XSxTOlszLDQsNSw2LDcsOCw5LDEwLDExLDEzLDE1LDE3LDE5LDIzLDI3LDMxLDM1LDQzLDUxLDU5LDY3LDgzLDk5LDExNSwxMzEsMTYzLDE5NSwyMjcsMjU4LDk5OSw5OTksOTk5XSxUOlswLDAsMCwwLDAsMCwwLDAsMSwxLDEsMSwyLDIsMiwyLDMsMywzLDMsNCw0LDQsNCw1LDUsNSw1LDAsMCwwLDBdLHE6bmV3IE4oMzIpLHA6WzEsMiwzLDQsNSw3LDksMTMsMTcsMjUsMzMsNDksNjUsOTcsMTI5LDE5MywyNTcsMzg1LDUxMyw3NjksMTAyNSwxNTM3LDIwNDksMzA3Myw0MDk3LDYxNDUsODE5MywxMjI4OSwxNjM4NSwyNDU3Nyw2NTUzNSw2NTUzNV0sejpbMCwwLDAsMCwxLDEsMiwyLDMsMyw0LDQsNSw1LDYsNiw3LDcsOCw4LDksOSwxMCwxMCwxMSwxMSwxMiwxMiwxMywxMywwLDBdLGM6bmV3IFcoMzIpLEo6bmV3IE4oNTEyKSxfOltdLGg6bmV3IE4oMzIpLCQ6W10sdzpuZXcgTigzMjc2OCksQzpbXSx2OltdLGQ6bmV3IE4oMzI3NjgpLEQ6W10sdTpuZXcgTig1MTIpLFE6W10scjpuZXcgTigxPDwxNSksczpuZXcgVygyODYpLFk6bmV3IFcoMzApLGE6bmV3IFcoMTkpLHQ6bmV3IFcoMTVlMyksazpuZXcgTigxPDwxNiksZzpuZXcgTigxPDwxNSl9fSgpO1xuKGZ1bmN0aW9uKCl7dmFyIE49SC5ILm0sVz0xPDwxNTtmb3IodmFyIFI9MDtSPFc7UisrKXt2YXIgVj1SO1Y9KFYmMjg2MzMxMTUzMCk+Pj4xfChWJjE0MzE2NTU3NjUpPDwxO1xuVj0oViYzNDM1OTczODM2KT4+PjJ8KFYmODU4OTkzNDU5KTw8MjtWPShWJjQwNDIzMjIxNjApPj4+NHwoViYyNTI2NDUxMzUpPDw0O1Y9KFYmNDI3ODI1NTM2MCk+Pj44fChWJjE2NzExOTM1KTw8ODtcbk4ucltSXT0oVj4+PjE2fFY8PDE2KT4+PjE3fWZ1bmN0aW9uIG4oQSxsLE0pe3doaWxlKGwtLSE9MClBLnB1c2goMCxNKX1mb3IodmFyIFI9MDtSPDMyO1IrKyl7Ti5xW1JdPU4uU1tSXTw8M3xOLlRbUl07XG5OLmNbUl09Ti5wW1JdPDw0fE4ueltSXX1uKE4uXywxNDQsOCk7bihOLl8sMjU1LTE0Myw5KTtuKE4uXywyNzktMjU1LDcpO24oTi5fLDI4Ny0yNzksOCk7SC5ILm4oTi5fLDkpO1xuSC5ILkEoTi5fLDksTi5KKTtILkgubChOLl8sOSk7bihOLiQsMzIsNSk7SC5ILm4oTi4kLDUpO0guSC5BKE4uJCw1LE4uaCk7SC5ILmwoTi4kLDUpO24oTi5RLDE5LDApO24oTi5DLDI4NiwwKTtcbm4oTi5ELDMwLDApO24oTi52LDMyMCwwKX0oKSk7cmV0dXJuIEguSC5OfSgpXG5cblxuVVBORy5kZWNvZGUuX3JlYWRJbnRlcmxhY2UgPSBmdW5jdGlvbihkYXRhLCBvdXQpXG57XG5cdHZhciB3ID0gb3V0LndpZHRoLCBoID0gb3V0LmhlaWdodDtcblx0dmFyIGJwcCA9IFVQTkcuZGVjb2RlLl9nZXRCUFAob3V0KSwgY2JwcCA9IGJwcD4+MywgYnBsID0gTWF0aC5jZWlsKHcqYnBwLzgpO1xuXHR2YXIgaW1nID0gbmV3IFVpbnQ4QXJyYXkoIGggKiBicGwgKTtcblx0dmFyIGRpID0gMDtcblxuXHR2YXIgc3RhcnRpbmdfcm93ICA9IFsgMCwgMCwgNCwgMCwgMiwgMCwgMSBdO1xuXHR2YXIgc3RhcnRpbmdfY29sICA9IFsgMCwgNCwgMCwgMiwgMCwgMSwgMCBdO1xuXHR2YXIgcm93X2luY3JlbWVudCA9IFsgOCwgOCwgOCwgNCwgNCwgMiwgMiBdO1xuXHR2YXIgY29sX2luY3JlbWVudCA9IFsgOCwgOCwgNCwgNCwgMiwgMiwgMSBdO1xuXG5cdHZhciBwYXNzPTA7XG5cdHdoaWxlKHBhc3M8Nylcblx0e1xuXHRcdHZhciByaSA9IHJvd19pbmNyZW1lbnRbcGFzc10sIGNpID0gY29sX2luY3JlbWVudFtwYXNzXTtcblx0XHR2YXIgc3cgPSAwLCBzaCA9IDA7XG5cdFx0dmFyIGNyID0gc3RhcnRpbmdfcm93W3Bhc3NdOyAgd2hpbGUoY3I8aCkgeyAgY3IrPXJpOyAgc2grKzsgIH1cblx0XHR2YXIgY2MgPSBzdGFydGluZ19jb2xbcGFzc107ICB3aGlsZShjYzx3KSB7ICBjYys9Y2k7ICBzdysrOyAgfVxuXHRcdHZhciBicGxsID0gTWF0aC5jZWlsKHN3KmJwcC84KTtcblx0XHRVUE5HLmRlY29kZS5fZmlsdGVyWmVybyhkYXRhLCBvdXQsIGRpLCBzdywgc2gpO1xuXG5cdFx0dmFyIHk9MCwgcm93ID0gc3RhcnRpbmdfcm93W3Bhc3NdO1xuXHRcdHdoaWxlKHJvdzxoKVxuXHRcdHtcblx0XHRcdHZhciBjb2wgPSBzdGFydGluZ19jb2xbcGFzc107XG5cdFx0XHR2YXIgY2RpID0gKGRpK3kqYnBsbCk8PDM7XG5cblx0XHRcdHdoaWxlKGNvbDx3KVxuXHRcdFx0e1xuXHRcdFx0XHRpZihicHA9PTEpIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZGF0YVtjZGk+PjNdOyAgdmFsID0gKHZhbD4+KDctKGNkaSY3KSkpJjE7XG5cdFx0XHRcdFx0aW1nW3JvdypicGwgKyAoY29sPj4zKV0gfD0gKHZhbCA8PCAoNy0oKGNvbCY3KTw8MCkpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihicHA9PTIpIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZGF0YVtjZGk+PjNdOyAgdmFsID0gKHZhbD4+KDYtKGNkaSY3KSkpJjM7XG5cdFx0XHRcdFx0aW1nW3JvdypicGwgKyAoY29sPj4yKV0gfD0gKHZhbCA8PCAoNi0oKGNvbCYzKTw8MSkpKTtcblx0XHRcdFx0fVxuXHRcdFx0XHRpZihicHA9PTQpIHtcblx0XHRcdFx0XHR2YXIgdmFsID0gZGF0YVtjZGk+PjNdOyAgdmFsID0gKHZhbD4+KDQtKGNkaSY3KSkpJjE1O1xuXHRcdFx0XHRcdGltZ1tyb3cqYnBsICsgKGNvbD4+MSldIHw9ICh2YWwgPDwgKDQtKChjb2wmMSk8PDIpKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0aWYoYnBwPj04KSB7XG5cdFx0XHRcdFx0dmFyIGlpID0gcm93KmJwbCtjb2wqY2JwcDtcblx0XHRcdFx0XHRmb3IodmFyIGo9MDsgajxjYnBwOyBqKyspIGltZ1tpaStqXSA9IGRhdGFbKGNkaT4+Mykral07XG5cdFx0XHRcdH1cblx0XHRcdFx0Y2RpKz1icHA7ICBjb2wrPWNpO1xuXHRcdFx0fVxuXHRcdFx0eSsrOyAgcm93ICs9IHJpO1xuXHRcdH1cblx0XHRpZihzdypzaCE9MCkgZGkgKz0gc2ggKiAoMSArIGJwbGwpO1xuXHRcdHBhc3MgPSBwYXNzICsgMTtcblx0fVxuXHRyZXR1cm4gaW1nO1xufVxuXG5VUE5HLmRlY29kZS5fZ2V0QlBQID0gZnVuY3Rpb24ob3V0KSB7XG5cdHZhciBub2MgPSBbMSxudWxsLDMsMSwyLG51bGwsNF1bb3V0LmN0eXBlXTtcblx0cmV0dXJuIG5vYyAqIG91dC5kZXB0aDtcbn1cblxuVVBORy5kZWNvZGUuX2ZpbHRlclplcm8gPSBmdW5jdGlvbihkYXRhLCBvdXQsIG9mZiwgdywgaClcbntcblx0dmFyIGJwcCA9IFVQTkcuZGVjb2RlLl9nZXRCUFAob3V0KSwgYnBsID0gTWF0aC5jZWlsKHcqYnBwLzgpLCBwYWV0aCA9IFVQTkcuZGVjb2RlLl9wYWV0aDtcblx0YnBwID0gTWF0aC5jZWlsKGJwcC84KTtcblx0XG5cdHZhciBpPTAsIGRpPTEsIHR5cGU9ZGF0YVtvZmZdLCB4PTA7XG5cdFxuXHRpZih0eXBlPjEpIGRhdGFbb2ZmXT1bMCwwLDFdW3R5cGUtMl07ICBcblx0aWYodHlwZT09MykgZm9yKHg9YnBwOyB4PGJwbDsgeCsrKSBkYXRhW3grMV0gPSAoZGF0YVt4KzFdICsgKGRhdGFbeCsxLWJwcF0+Pj4xKSApJjI1NTtcblxuXHRmb3IodmFyIHk9MDsgeTxoOyB5KyspICB7XG5cdFx0aSA9IG9mZit5KmJwbDsgZGkgPSBpK3krMTtcblx0XHR0eXBlID0gZGF0YVtkaS0xXTsgeD0wO1xuXG5cdFx0aWYgICAgICh0eXBlPT0wKSAgIGZvcig7IHg8YnBsOyB4KyspIGRhdGFbaSt4XSA9IGRhdGFbZGkreF07XG5cdFx0ZWxzZSBpZih0eXBlPT0xKSB7IGZvcig7IHg8YnBwOyB4KyspIGRhdGFbaSt4XSA9IGRhdGFbZGkreF07XG5cdFx0XHRcdFx0XHQgICBmb3IoOyB4PGJwbDsgeCsrKSBkYXRhW2kreF0gPSAoZGF0YVtkaSt4XSArIGRhdGFbaSt4LWJwcF0pOyAgfVxuXHRcdGVsc2UgaWYodHlwZT09MikgeyBmb3IoOyB4PGJwbDsgeCsrKSBkYXRhW2kreF0gPSAoZGF0YVtkaSt4XSArIGRhdGFbaSt4LWJwbF0pOyAgfVxuXHRcdGVsc2UgaWYodHlwZT09MykgeyBmb3IoOyB4PGJwcDsgeCsrKSBkYXRhW2kreF0gPSAoZGF0YVtkaSt4XSArICggZGF0YVtpK3gtYnBsXT4+PjEpKTtcblx0XHRcdCAgICAgICAgICAgICAgIGZvcig7IHg8YnBsOyB4KyspIGRhdGFbaSt4XSA9IChkYXRhW2RpK3hdICsgKChkYXRhW2kreC1icGxdK2RhdGFbaSt4LWJwcF0pPj4+MSkgKTsgIH1cblx0XHRlbHNlICAgICAgICAgICAgIHsgZm9yKDsgeDxicHA7IHgrKykgZGF0YVtpK3hdID0gKGRhdGFbZGkreF0gKyBwYWV0aCgwLCBkYXRhW2kreC1icGxdLCAwKSk7XG5cdFx0XHRcdFx0XHQgICBmb3IoOyB4PGJwbDsgeCsrKSBkYXRhW2kreF0gPSAoZGF0YVtkaSt4XSArIHBhZXRoKGRhdGFbaSt4LWJwcF0sIGRhdGFbaSt4LWJwbF0sIGRhdGFbaSt4LWJwcC1icGxdKSApOyAgfVxuXHR9XG5cdHJldHVybiBkYXRhO1xufVxuXG5VUE5HLmRlY29kZS5fcGFldGggPSBmdW5jdGlvbihhLGIsYylcbntcblx0dmFyIHAgPSBhK2ItYywgcGEgPSAocC1hKSwgcGIgPSAocC1iKSwgcGMgPSAocC1jKTtcblx0aWYgKHBhKnBhIDw9IHBiKnBiICYmIHBhKnBhIDw9IHBjKnBjKSAgcmV0dXJuIGE7XG5cdGVsc2UgaWYgKHBiKnBiIDw9IHBjKnBjKSAgcmV0dXJuIGI7XG5cdHJldHVybiBjO1xufVxuXG5VUE5HLmRlY29kZS5fSUhEUiA9IGZ1bmN0aW9uKGRhdGEsIG9mZnNldCwgb3V0KVxue1xuXHR2YXIgYmluID0gVVBORy5fYmluO1xuXHRvdXQud2lkdGggID0gYmluLnJlYWRVaW50KGRhdGEsIG9mZnNldCk7ICBvZmZzZXQgKz0gNDtcblx0b3V0LmhlaWdodCA9IGJpbi5yZWFkVWludChkYXRhLCBvZmZzZXQpOyAgb2Zmc2V0ICs9IDQ7XG5cdG91dC5kZXB0aCAgICAgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcblx0b3V0LmN0eXBlICAgICA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xuXHRvdXQuY29tcHJlc3MgID0gZGF0YVtvZmZzZXRdOyAgb2Zmc2V0Kys7XG5cdG91dC5maWx0ZXIgICAgPSBkYXRhW29mZnNldF07ICBvZmZzZXQrKztcblx0b3V0LmludGVybGFjZSA9IGRhdGFbb2Zmc2V0XTsgIG9mZnNldCsrO1xufVxuXG5VUE5HLl9iaW4gPSB7XG5cdG5leHRaZXJvICAgOiBmdW5jdGlvbihkYXRhLHApICB7ICB3aGlsZShkYXRhW3BdIT0wKSBwKys7ICByZXR1cm4gcDsgIH0sXG5cdHJlYWRVc2hvcnQgOiBmdW5jdGlvbihidWZmLHApICB7ICByZXR1cm4gKGJ1ZmZbcF08PCA4KSB8IGJ1ZmZbcCsxXTsgIH0sXG5cdHdyaXRlVXNob3J0OiBmdW5jdGlvbihidWZmLHAsbil7ICBidWZmW3BdID0gKG4+PjgpJjI1NTsgIGJ1ZmZbcCsxXSA9IG4mMjU1OyAgfSxcblx0cmVhZFVpbnQgICA6IGZ1bmN0aW9uKGJ1ZmYscCkgIHsgIHJldHVybiAoYnVmZltwXSooMjU2KjI1NioyNTYpKSArICgoYnVmZltwKzFdPDwxNikgfCAoYnVmZltwKzJdPDwgOCkgfCBidWZmW3ArM10pOyAgfSxcblx0d3JpdGVVaW50ICA6IGZ1bmN0aW9uKGJ1ZmYscCxuKXsgIGJ1ZmZbcF09KG4+PjI0KSYyNTU7ICBidWZmW3ArMV09KG4+PjE2KSYyNTU7ICBidWZmW3ArMl09KG4+PjgpJjI1NTsgIGJ1ZmZbcCszXT1uJjI1NTsgIH0sXG5cdHJlYWRBU0NJSSAgOiBmdW5jdGlvbihidWZmLHAsbCl7ICB2YXIgcyA9IFwiXCI7ICBmb3IodmFyIGk9MDsgaTxsOyBpKyspIHMgKz0gU3RyaW5nLmZyb21DaGFyQ29kZShidWZmW3AraV0pOyAgcmV0dXJuIHM7ICAgIH0sXG5cdHdyaXRlQVNDSUkgOiBmdW5jdGlvbihkYXRhLHAscyl7ICBmb3IodmFyIGk9MDsgaTxzLmxlbmd0aDsgaSsrKSBkYXRhW3AraV0gPSBzLmNoYXJDb2RlQXQoaSk7ICB9LFxuXHRyZWFkQnl0ZXMgIDogZnVuY3Rpb24oYnVmZixwLGwpeyAgdmFyIGFyciA9IFtdOyAgIGZvcih2YXIgaT0wOyBpPGw7IGkrKykgYXJyLnB1c2goYnVmZltwK2ldKTsgICByZXR1cm4gYXJyOyAgfSxcblx0cGFkIDogZnVuY3Rpb24obikgeyByZXR1cm4gbi5sZW5ndGggPCAyID8gXCIwXCIgKyBuIDogbjsgfSxcblx0cmVhZFVURjggOiBmdW5jdGlvbihidWZmLCBwLCBsKSB7XG5cdFx0dmFyIHMgPSBcIlwiLCBucztcblx0XHRmb3IodmFyIGk9MDsgaTxsOyBpKyspIHMgKz0gXCIlXCIgKyBVUE5HLl9iaW4ucGFkKGJ1ZmZbcCtpXS50b1N0cmluZygxNikpO1xuXHRcdHRyeSB7ICBucyA9IGRlY29kZVVSSUNvbXBvbmVudChzKTsgfVxuXHRcdGNhdGNoKGUpIHsgIHJldHVybiBVUE5HLl9iaW4ucmVhZEFTQ0lJKGJ1ZmYsIHAsIGwpOyAgfVxuXHRcdHJldHVybiAgbnM7XG5cdH1cbn1cblVQTkcuX2NvcHlUaWxlID0gZnVuY3Rpb24oc2IsIHN3LCBzaCwgdGIsIHR3LCB0aCwgeG9mZiwgeW9mZiwgbW9kZSlcbntcblx0dmFyIHcgPSBNYXRoLm1pbihzdyx0dyksIGggPSBNYXRoLm1pbihzaCx0aCk7XG5cdHZhciBzaT0wLCB0aT0wO1xuXHRmb3IodmFyIHk9MDsgeTxoOyB5KyspXG5cdFx0Zm9yKHZhciB4PTA7IHg8dzsgeCsrKVxuXHRcdHtcblx0XHRcdGlmKHhvZmY+PTAgJiYgeW9mZj49MCkgeyAgc2kgPSAoeSpzdyt4KTw8MjsgIHRpID0gKCggeW9mZit5KSp0dyt4b2ZmK3gpPDwyOyAgfVxuXHRcdFx0ZWxzZSAgICAgICAgICAgICAgICAgICB7ICBzaSA9ICgoLXlvZmYreSkqc3cteG9mZit4KTw8MjsgIHRpID0gKHkqdHcreCk8PDI7ICB9XG5cdFx0XHRcblx0XHRcdGlmICAgICAobW9kZT09MCkgeyAgdGJbdGldID0gc2Jbc2ldOyAgdGJbdGkrMV0gPSBzYltzaSsxXTsgIHRiW3RpKzJdID0gc2Jbc2krMl07ICB0Ylt0aSszXSA9IHNiW3NpKzNdOyAgfVxuXHRcdFx0ZWxzZSBpZihtb2RlPT0xKSB7XG5cdFx0XHRcdHZhciBmYSA9IHNiW3NpKzNdKigxLzI1NSksIGZyPXNiW3NpXSpmYSwgZmc9c2Jbc2krMV0qZmEsIGZiPXNiW3NpKzJdKmZhOyBcblx0XHRcdFx0dmFyIGJhID0gdGJbdGkrM10qKDEvMjU1KSwgYnI9dGJbdGldKmJhLCBiZz10Ylt0aSsxXSpiYSwgYmI9dGJbdGkrMl0qYmE7IFxuXHRcdFx0XHRcblx0XHRcdFx0dmFyIGlmYT0xLWZhLCBvYSA9IGZhK2JhKmlmYSwgaW9hID0gKG9hPT0wPzA6MS9vYSk7XG5cdFx0XHRcdHRiW3RpKzNdID0gMjU1Km9hOyAgXG5cdFx0XHRcdHRiW3RpKzBdID0gKGZyK2JyKmlmYSkqaW9hOyAgXG5cdFx0XHRcdHRiW3RpKzFdID0gKGZnK2JnKmlmYSkqaW9hOyAgIFxuXHRcdFx0XHR0Ylt0aSsyXSA9IChmYitiYippZmEpKmlvYTsgIFxuXHRcdFx0fVxuXHRcdFx0ZWxzZSBpZihtb2RlPT0yKXtcdC8vIGNvcHkgb25seSBkaWZmZXJlbmNlcywgb3RoZXJ3aXNlIHplcm9cblx0XHRcdFx0dmFyIGZhID0gc2Jbc2krM10sIGZyPXNiW3NpXSwgZmc9c2Jbc2krMV0sIGZiPXNiW3NpKzJdOyBcblx0XHRcdFx0dmFyIGJhID0gdGJbdGkrM10sIGJyPXRiW3RpXSwgYmc9dGJbdGkrMV0sIGJiPXRiW3RpKzJdOyBcblx0XHRcdFx0aWYoZmE9PWJhICYmIGZyPT1iciAmJiBmZz09YmcgJiYgZmI9PWJiKSB7ICB0Ylt0aV09MDsgIHRiW3RpKzFdPTA7ICB0Ylt0aSsyXT0wOyAgdGJbdGkrM109MDsgIH1cblx0XHRcdFx0ZWxzZSB7ICB0Ylt0aV09ZnI7ICB0Ylt0aSsxXT1mZzsgIHRiW3RpKzJdPWZiOyAgdGJbdGkrM109ZmE7ICB9XG5cdFx0XHR9XG5cdFx0XHRlbHNlIGlmKG1vZGU9PTMpe1x0Ly8gY2hlY2sgaWYgY2FuIGJlIGJsZW5kZWRcblx0XHRcdFx0dmFyIGZhID0gc2Jbc2krM10sIGZyPXNiW3NpXSwgZmc9c2Jbc2krMV0sIGZiPXNiW3NpKzJdOyBcblx0XHRcdFx0dmFyIGJhID0gdGJbdGkrM10sIGJyPXRiW3RpXSwgYmc9dGJbdGkrMV0sIGJiPXRiW3RpKzJdOyBcblx0XHRcdFx0aWYoZmE9PWJhICYmIGZyPT1iciAmJiBmZz09YmcgJiYgZmI9PWJiKSBjb250aW51ZTtcblx0XHRcdFx0Ly9pZihmYSE9MjU1ICYmIGJhIT0wKSByZXR1cm4gZmFsc2U7XG5cdFx0XHRcdGlmKGZhPDIyMCAmJiBiYT4yMCkgcmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblx0cmV0dXJuIHRydWU7XG59XG5cblxuXG5cblVQTkcuZW5jb2RlID0gZnVuY3Rpb24oYnVmcywgdywgaCwgcHMsIGRlbHMsIHRhYnMsIGZvcmJpZFBsdGUpXG57XG5cdGlmKHBzPT1udWxsKSBwcz0wO1xuXHRpZihmb3JiaWRQbHRlPT1udWxsKSBmb3JiaWRQbHRlID0gZmFsc2U7XG5cblx0dmFyIG5pbWcgPSBVUE5HLmVuY29kZS5jb21wcmVzcyhidWZzLCB3LCBoLCBwcywgW2ZhbHNlLCBmYWxzZSwgZmFsc2UsIDAsIGZvcmJpZFBsdGVdKTtcblx0VVBORy5lbmNvZGUuY29tcHJlc3NQTkcobmltZywgLTEpO1xuXHRcblx0cmV0dXJuIFVQTkcuZW5jb2RlLl9tYWluKG5pbWcsIHcsIGgsIGRlbHMsIHRhYnMpO1xufVxuXG5VUE5HLmVuY29kZUxMID0gZnVuY3Rpb24oYnVmcywgdywgaCwgY2MsIGFjLCBkZXB0aCwgZGVscywgdGFicykge1xuXHR2YXIgbmltZyA9IHsgIGN0eXBlOiAwICsgKGNjPT0xID8gMCA6IDIpICsgKGFjPT0wID8gMCA6IDQpLCAgICAgIGRlcHRoOiBkZXB0aCwgIGZyYW1lczogW10gIH07XG5cdFxuXHR2YXIgdGltZSA9IERhdGUubm93KCk7XG5cdHZhciBiaXBwID0gKGNjK2FjKSpkZXB0aCwgYmlwbCA9IGJpcHAgKiB3O1xuXHRmb3IodmFyIGk9MDsgaTxidWZzLmxlbmd0aDsgaSsrKVxuXHRcdG5pbWcuZnJhbWVzLnB1c2goeyAgcmVjdDp7eDowLHk6MCx3aWR0aDp3LGhlaWdodDpofSwgIGltZzpuZXcgVWludDhBcnJheShidWZzW2ldKSwgYmxlbmQ6MCwgZGlzcG9zZToxLCBicHA6TWF0aC5jZWlsKGJpcHAvOCksIGJwbDpNYXRoLmNlaWwoYmlwbC84KSAgfSk7XG5cdFxuXHRVUE5HLmVuY29kZS5jb21wcmVzc1BORyhuaW1nLCAwLCB0cnVlKTtcblx0XG5cdHZhciBvdXQgPSBVUE5HLmVuY29kZS5fbWFpbihuaW1nLCB3LCBoLCBkZWxzLCB0YWJzKTtcblx0cmV0dXJuIG91dDtcbn1cblxuVVBORy5lbmNvZGUuX21haW4gPSBmdW5jdGlvbihuaW1nLCB3LCBoLCBkZWxzLCB0YWJzKSB7XG5cdGlmKHRhYnM9PW51bGwpIHRhYnM9e307XG5cdHZhciBjcmMgPSBVUE5HLmNyYy5jcmMsIHdVaSA9IFVQTkcuX2Jpbi53cml0ZVVpbnQsIHdVcyA9IFVQTkcuX2Jpbi53cml0ZVVzaG9ydCwgd0FzID0gVVBORy5fYmluLndyaXRlQVNDSUk7XG5cdHZhciBvZmZzZXQgPSA4LCBhbmltID0gbmltZy5mcmFtZXMubGVuZ3RoPjEsIHBsdEFscGhhID0gZmFsc2U7XG5cdFxuXHR2YXIgbGVuZyA9IDggKyAoMTYrNSs0KSAvKisgKDkrNCkqLyArIChhbmltID8gMjAgOiAwKTtcblx0aWYodGFic1tcInNSR0JcIl0hPW51bGwpIGxlbmcgKz0gOCsxKzQ7XG5cdGlmKHRhYnNbXCJwSFlzXCJdIT1udWxsKSBsZW5nICs9IDgrOSs0O1xuXHRpZihuaW1nLmN0eXBlPT0zKSB7XG5cdFx0dmFyIGRsID0gbmltZy5wbHRlLmxlbmd0aDtcblx0XHRmb3IodmFyIGk9MDsgaTxkbDsgaSsrKSBpZigobmltZy5wbHRlW2ldPj4+MjQpIT0yNTUpIHBsdEFscGhhID0gdHJ1ZTtcblx0XHRsZW5nICs9ICg4ICsgZGwqMyArIDQpICsgKHBsdEFscGhhID8gKDggKyBkbCoxICsgNCkgOiAwKTtcblx0fVxuXHRmb3IodmFyIGo9MDsgajxuaW1nLmZyYW1lcy5sZW5ndGg7IGorKylcblx0e1xuXHRcdHZhciBmciA9IG5pbWcuZnJhbWVzW2pdO1xuXHRcdGlmKGFuaW0pIGxlbmcgKz0gMzg7XG5cdFx0bGVuZyArPSBmci5jaW1nLmxlbmd0aCArIDEyO1xuXHRcdGlmKGohPTApIGxlbmcrPTQ7XG5cdH1cblx0bGVuZyArPSAxMjsgXG5cdFxuXHR2YXIgZGF0YSA9IG5ldyBVaW50OEFycmF5KGxlbmcpO1xuXHR2YXIgd3I9WzB4ODksIDB4NTAsIDB4NGUsIDB4NDcsIDB4MGQsIDB4MGEsIDB4MWEsIDB4MGFdO1xuXHRmb3IodmFyIGk9MDsgaTw4OyBpKyspIGRhdGFbaV09d3JbaV07XG5cdFxuXHR3VWkoZGF0YSxvZmZzZXQsIDEzKTsgICAgIG9mZnNldCs9NDtcblx0d0FzKGRhdGEsb2Zmc2V0LFwiSUhEUlwiKTsgIG9mZnNldCs9NDtcblx0d1VpKGRhdGEsb2Zmc2V0LHcpOyAgb2Zmc2V0Kz00O1xuXHR3VWkoZGF0YSxvZmZzZXQsaCk7ICBvZmZzZXQrPTQ7XG5cdGRhdGFbb2Zmc2V0XSA9IG5pbWcuZGVwdGg7ICBvZmZzZXQrKzsgIC8vIGRlcHRoXG5cdGRhdGFbb2Zmc2V0XSA9IG5pbWcuY3R5cGU7ICBvZmZzZXQrKzsgIC8vIGN0eXBlXG5cdGRhdGFbb2Zmc2V0XSA9IDA7ICBvZmZzZXQrKzsgIC8vIGNvbXByZXNzXG5cdGRhdGFbb2Zmc2V0XSA9IDA7ICBvZmZzZXQrKzsgIC8vIGZpbHRlclxuXHRkYXRhW29mZnNldF0gPSAwOyAgb2Zmc2V0Kys7ICAvLyBpbnRlcmxhY2Vcblx0d1VpKGRhdGEsb2Zmc2V0LGNyYyhkYXRhLG9mZnNldC0xNywxNykpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblxuXHQvLyAxMyBieXRlcyB0byBzYXksIHRoYXQgaXQgaXMgc1JHQlxuXHRpZih0YWJzW1wic1JHQlwiXSE9bnVsbCkge1xuXHRcdHdVaShkYXRhLG9mZnNldCwgMSk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdHdBcyhkYXRhLG9mZnNldCxcInNSR0JcIik7ICBvZmZzZXQrPTQ7XG5cdFx0ZGF0YVtvZmZzZXRdID0gdGFic1tcInNSR0JcIl07ICBvZmZzZXQrKztcblx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTUsNSkpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblx0fVxuXHRpZih0YWJzW1wicEhZc1wiXSE9bnVsbCkge1xuXHRcdHdVaShkYXRhLG9mZnNldCwgOSk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdHdBcyhkYXRhLG9mZnNldCxcInBIWXNcIik7ICBvZmZzZXQrPTQ7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCB0YWJzW1wicEhZc1wiXVswXSk7ICAgICAgb2Zmc2V0Kz00O1xuXHRcdHdVaShkYXRhLG9mZnNldCwgdGFic1tcInBIWXNcIl1bMV0pOyAgICAgIG9mZnNldCs9NDtcblx0XHRkYXRhW29mZnNldF09dGFic1tcInBIWXNcIl1bMl07XHRcdFx0b2Zmc2V0Kys7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LGNyYyhkYXRhLG9mZnNldC0xMywxMykpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblx0fVxuXG5cdGlmKGFuaW0pIHtcblx0XHR3VWkoZGF0YSxvZmZzZXQsIDgpOyAgICAgIG9mZnNldCs9NDtcblx0XHR3QXMoZGF0YSxvZmZzZXQsXCJhY1RMXCIpOyAgb2Zmc2V0Kz00O1xuXHRcdHdVaShkYXRhLG9mZnNldCwgbmltZy5mcmFtZXMubGVuZ3RoKTsgICAgIG9mZnNldCs9NDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsIHRhYnNbXCJsb29wXCJdIT1udWxsP3RhYnNbXCJsb29wXCJdOjApOyAgICAgIG9mZnNldCs9NDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTEyLDEyKSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXHR9XG5cblx0aWYobmltZy5jdHlwZT09Mykge1xuXHRcdHZhciBkbCA9IG5pbWcucGx0ZS5sZW5ndGg7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LCBkbCozKTsgIG9mZnNldCs9NDtcblx0XHR3QXMoZGF0YSxvZmZzZXQsXCJQTFRFXCIpOyAgb2Zmc2V0Kz00O1xuXHRcdGZvcih2YXIgaT0wOyBpPGRsOyBpKyspe1xuXHRcdFx0dmFyIHRpPWkqMywgYz1uaW1nLnBsdGVbaV0sIHI9KGMpJjI1NSwgZz0oYz4+PjgpJjI1NSwgYj0oYz4+PjE2KSYyNTU7XG5cdFx0XHRkYXRhW29mZnNldCt0aSswXT1yOyAgZGF0YVtvZmZzZXQrdGkrMV09ZzsgIGRhdGFbb2Zmc2V0K3RpKzJdPWI7XG5cdFx0fVxuXHRcdG9mZnNldCs9ZGwqMztcblx0XHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LWRsKjMtNCxkbCozKzQpKTsgIG9mZnNldCs9NDsgLy8gY3JjXG5cblx0XHRpZihwbHRBbHBoYSkge1xuXHRcdFx0d1VpKGRhdGEsb2Zmc2V0LCBkbCk7ICBvZmZzZXQrPTQ7XG5cdFx0XHR3QXMoZGF0YSxvZmZzZXQsXCJ0Uk5TXCIpOyAgb2Zmc2V0Kz00O1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8ZGw7IGkrKykgIGRhdGFbb2Zmc2V0K2ldPShuaW1nLnBsdGVbaV0+Pj4yNCkmMjU1O1xuXHRcdFx0b2Zmc2V0Kz1kbDtcblx0XHRcdHdVaShkYXRhLG9mZnNldCxjcmMoZGF0YSxvZmZzZXQtZGwtNCxkbCs0KSk7ICBvZmZzZXQrPTQ7IC8vIGNyY1xuXHRcdH1cblx0fVxuXHRcblx0dmFyIGZpID0gMDtcblx0Zm9yKHZhciBqPTA7IGo8bmltZy5mcmFtZXMubGVuZ3RoOyBqKyspXG5cdHtcblx0XHR2YXIgZnIgPSBuaW1nLmZyYW1lc1tqXTtcblx0XHRpZihhbmltKSB7XG5cdFx0XHR3VWkoZGF0YSwgb2Zmc2V0LCAyNik7ICAgICBvZmZzZXQrPTQ7XG5cdFx0XHR3QXMoZGF0YSwgb2Zmc2V0LFwiZmNUTFwiKTsgIG9mZnNldCs9NDtcblx0XHRcdHdVaShkYXRhLCBvZmZzZXQsIGZpKyspOyAgIG9mZnNldCs9NDtcblx0XHRcdHdVaShkYXRhLCBvZmZzZXQsIGZyLnJlY3Qud2lkdGggKTsgICBvZmZzZXQrPTQ7XG5cdFx0XHR3VWkoZGF0YSwgb2Zmc2V0LCBmci5yZWN0LmhlaWdodCk7ICAgb2Zmc2V0Kz00O1xuXHRcdFx0d1VpKGRhdGEsIG9mZnNldCwgZnIucmVjdC54KTsgICBvZmZzZXQrPTQ7XG5cdFx0XHR3VWkoZGF0YSwgb2Zmc2V0LCBmci5yZWN0LnkpOyAgIG9mZnNldCs9NDtcblx0XHRcdHdVcyhkYXRhLCBvZmZzZXQsIGRlbHNbal0pOyAgIG9mZnNldCs9Mjtcblx0XHRcdHdVcyhkYXRhLCBvZmZzZXQsICAxMDAwKTsgICBvZmZzZXQrPTI7XG5cdFx0XHRkYXRhW29mZnNldF0gPSBmci5kaXNwb3NlOyAgb2Zmc2V0Kys7XHQvLyBkaXNwb3NlXG5cdFx0XHRkYXRhW29mZnNldF0gPSBmci5ibGVuZCAgOyAgb2Zmc2V0Kys7XHQvLyBibGVuZFxuXHRcdFx0d1VpKGRhdGEsb2Zmc2V0LGNyYyhkYXRhLG9mZnNldC0zMCwzMCkpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblx0XHR9XG5cdFx0XHRcdFxuXHRcdHZhciBpbWdkID0gZnIuY2ltZywgZGwgPSBpbWdkLmxlbmd0aDtcblx0XHR3VWkoZGF0YSxvZmZzZXQsIGRsKyhqPT0wPzA6NCkpOyAgICAgb2Zmc2V0Kz00O1xuXHRcdHZhciBpb2ZmID0gb2Zmc2V0O1xuXHRcdHdBcyhkYXRhLG9mZnNldCwoaj09MCk/XCJJREFUXCI6XCJmZEFUXCIpOyAgb2Zmc2V0Kz00O1xuXHRcdGlmKGohPTApIHsgIHdVaShkYXRhLCBvZmZzZXQsIGZpKyspOyAgb2Zmc2V0Kz00OyAgfVxuXHRcdGRhdGEuc2V0KGltZ2Qsb2Zmc2V0KTtcblx0XHRvZmZzZXQgKz0gZGw7XG5cdFx0d1VpKGRhdGEsb2Zmc2V0LGNyYyhkYXRhLGlvZmYsb2Zmc2V0LWlvZmYpKTsgIG9mZnNldCs9NDsgLy8gY3JjXG5cdH1cblxuXHR3VWkoZGF0YSxvZmZzZXQsIDApOyAgICAgb2Zmc2V0Kz00O1xuXHR3QXMoZGF0YSxvZmZzZXQsXCJJRU5EXCIpOyAgb2Zmc2V0Kz00O1xuXHR3VWkoZGF0YSxvZmZzZXQsY3JjKGRhdGEsb2Zmc2V0LTQsNCkpOyAgb2Zmc2V0Kz00OyAvLyBjcmNcblxuXHRyZXR1cm4gZGF0YS5idWZmZXI7XG59XG5cblVQTkcuZW5jb2RlLmNvbXByZXNzUE5HID0gZnVuY3Rpb24ob3V0LCBmaWx0ZXIsIGxldmVsWmVybykge1xuXHRmb3IodmFyIGk9MDsgaTxvdXQuZnJhbWVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGZybSA9IG91dC5mcmFtZXNbaV0sIG53PWZybS5yZWN0LndpZHRoLCBuaD1mcm0ucmVjdC5oZWlnaHQ7XG5cdFx0dmFyIGZkYXRhID0gbmV3IFVpbnQ4QXJyYXkobmgqZnJtLmJwbCtuaCk7XG5cdFx0ZnJtLmNpbWcgPSBVUE5HLmVuY29kZS5fZmlsdGVyWmVybyhmcm0uaW1nLG5oLGZybS5icHAsZnJtLmJwbCxmZGF0YSwgZmlsdGVyLCBsZXZlbFplcm8pO1xuXHR9XG59XG5cblxuXG5VUE5HLmVuY29kZS5jb21wcmVzcyA9IGZ1bmN0aW9uKGJ1ZnMsIHcsIGgsIHBzLCBwcm1zKSAvLyBwcm1zOiAgb25seUJsZW5kLCBtaW5CaXRzLCBmb3JiaWRQbHRlXG57XG5cdC8vdmFyIHRpbWUgPSBEYXRlLm5vdygpO1xuXHR2YXIgb25seUJsZW5kID0gcHJtc1swXSwgZXZlbkNyZCA9IHBybXNbMV0sIGZvcmJpZFByZXYgPSBwcm1zWzJdLCBtaW5CaXRzID0gcHJtc1szXSwgZm9yYmlkUGx0ZSA9IHBybXNbNF07XG5cdFxuXHR2YXIgY3R5cGUgPSA2LCBkZXB0aCA9IDgsIGFscGhhQW5kPTI1NVxuXHRcblx0Zm9yKHZhciBqPTA7IGo8YnVmcy5sZW5ndGg7IGorKykgIHsgIC8vIHdoZW4gbm90IHF1YW50aXplZCwgb3RoZXIgZnJhbWVzIGNhbiBjb250YWluIGNvbG9ycywgdGhhdCBhcmUgbm90IGluIGFuIGluaXRpYWwgZnJhbWVcblx0XHR2YXIgaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tqXSksIGlsZW4gPSBpbWcubGVuZ3RoO1xuXHRcdGZvcih2YXIgaT0wOyBpPGlsZW47IGkrPTQpIGFscGhhQW5kICY9IGltZ1tpKzNdO1xuXHR9XG5cdHZhciBnb3RBbHBoYSA9IChhbHBoYUFuZCE9MjU1KTtcblx0XG5cdC8vY29uc29sZS5sb2coXCJhbHBoYSBjaGVja1wiLCBEYXRlLm5vdygpLXRpbWUpOyAgdGltZSA9IERhdGUubm93KCk7XG5cdFxuXHQvL3ZhciBicnV0ZSA9IGdvdEFscGhhICYmIGZvckdJRjtcdFx0Ly8gYnJ1dGUgOiBmcmFtZXMgY2FuIG9ubHkgYmUgY29waWVkLCBub3QgXCJibGVuZGVkXCJcblx0dmFyIGZybXMgPSBVUE5HLmVuY29kZS5mcmFtaXplKGJ1ZnMsIHcsIGgsIG9ubHlCbGVuZCwgZXZlbkNyZCwgZm9yYmlkUHJldik7XG5cdC8vY29uc29sZS5sb2coXCJmcmFtaXplXCIsIERhdGUubm93KCktdGltZSk7ICB0aW1lID0gRGF0ZS5ub3coKTtcblx0XG5cdHZhciBjbWFwPXt9LCBwbHRlPVtdLCBpbmRzPVtdOyAgXG5cdFxuXHRpZihwcyE9MCkge1xuXHRcdHZhciBuYnVmcyA9IFtdOyAgZm9yKHZhciBpPTA7IGk8ZnJtcy5sZW5ndGg7IGkrKykgbmJ1ZnMucHVzaChmcm1zW2ldLmltZy5idWZmZXIpO1xuXHRcdFxuXHRcdHZhciBhYnVmID0gVVBORy5lbmNvZGUuY29uY2F0UkdCQShuYnVmcyksIHFyZXMgPSBVUE5HLnF1YW50aXplKGFidWYsIHBzKTsgIFxuXHRcdHZhciBjb2YgPSAwLCBiYiA9IG5ldyBVaW50OEFycmF5KHFyZXMuYWJ1Zik7XG5cdFx0Zm9yKHZhciBpPTA7IGk8ZnJtcy5sZW5ndGg7IGkrKykgeyAgdmFyIHRpPWZybXNbaV0uaW1nLCBibG49dGkubGVuZ3RoOyAgaW5kcy5wdXNoKG5ldyBVaW50OEFycmF5KHFyZXMuaW5kcy5idWZmZXIsIGNvZj4+MiwgYmxuPj4yKSk7XG5cdFx0XHRmb3IodmFyIGo9MDsgajxibG47IGorPTQpIHsgIHRpW2pdPWJiW2NvZitqXTsgIHRpW2orMV09YmJbY29mK2orMV07ICB0aVtqKzJdPWJiW2NvZitqKzJdOyAgdGlbaiszXT1iYltjb2YraiszXTsgIH0gICAgY29mKz1ibG47ICB9XG5cdFx0XG5cdFx0Zm9yKHZhciBpPTA7IGk8cXJlcy5wbHRlLmxlbmd0aDsgaSsrKSBwbHRlLnB1c2gocXJlcy5wbHRlW2ldLmVzdC5yZ2JhKTtcblx0XHQvL2NvbnNvbGUubG9nKFwicXVhbnRpemVcIiwgRGF0ZS5ub3coKS10aW1lKTsgIHRpbWUgPSBEYXRlLm5vdygpO1xuXHR9XG5cdGVsc2Uge1xuXHRcdC8vIHdoYXQgaWYgcHM9PTAsIGJ1dCB0aGVyZSBhcmUgPD0yNTYgY29sb3JzPyAgd2Ugc3RpbGwgbmVlZCB0byBkZXRlY3QsIGlmIHRoZSBwYWxldHRlIGNvdWxkIGJlIHVzZWRcblx0XHRmb3IodmFyIGo9MDsgajxmcm1zLmxlbmd0aDsgaisrKSAgeyAgLy8gd2hlbiBub3QgcXVhbnRpemVkLCBvdGhlciBmcmFtZXMgY2FuIGNvbnRhaW4gY29sb3JzLCB0aGF0IGFyZSBub3QgaW4gYW4gaW5pdGlhbCBmcmFtZVxuXHRcdFx0dmFyIGZybSA9IGZybXNbal0sIGltZzMyID0gbmV3IFVpbnQzMkFycmF5KGZybS5pbWcuYnVmZmVyKSwgbnc9ZnJtLnJlY3Qud2lkdGgsIGlsZW4gPSBpbWczMi5sZW5ndGg7XG5cdFx0XHR2YXIgaW5kID0gbmV3IFVpbnQ4QXJyYXkoaWxlbik7ICBpbmRzLnB1c2goaW5kKTtcblx0XHRcdGZvcih2YXIgaT0wOyBpPGlsZW47IGkrKykge1xuXHRcdFx0XHR2YXIgYyA9IGltZzMyW2ldO1xuXHRcdFx0XHRpZiAgICAgKGkhPTAgJiYgYz09aW1nMzJbaS0gMV0pIGluZFtpXT1pbmRbaS0xXTtcblx0XHRcdFx0ZWxzZSBpZihpPm53ICYmIGM9PWltZzMyW2ktbnddKSBpbmRbaV09aW5kW2ktbnddO1xuXHRcdFx0XHRlbHNlIHtcblx0XHRcdFx0XHR2YXIgY21jID0gY21hcFtjXTtcblx0XHRcdFx0XHRpZihjbWM9PW51bGwpIHsgIGNtYXBbY109Y21jPXBsdGUubGVuZ3RoOyAgcGx0ZS5wdXNoKGMpOyAgaWYocGx0ZS5sZW5ndGg+PTMwMCkgYnJlYWs7ICB9XG5cdFx0XHRcdFx0aW5kW2ldPWNtYztcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH1cblx0XHQvL2NvbnNvbGUubG9nKFwibWFrZSBwYWxldHRlXCIsIERhdGUubm93KCktdGltZSk7ICB0aW1lID0gRGF0ZS5ub3coKTtcblx0fVxuXHRcblx0dmFyIGNjPXBsdGUubGVuZ3RoOyAvL2NvbnNvbGUubG9nKFwiY29sb3JzOlwiLGNjKTtcblx0aWYoY2M8PTI1NiAmJiBmb3JiaWRQbHRlPT1mYWxzZSkge1xuXHRcdGlmKGNjPD0gMikgZGVwdGg9MTsgIGVsc2UgaWYoY2M8PSA0KSBkZXB0aD0yOyAgZWxzZSBpZihjYzw9MTYpIGRlcHRoPTQ7ICBlbHNlIGRlcHRoPTg7XG5cdFx0ZGVwdGggPSAgTWF0aC5tYXgoZGVwdGgsIG1pbkJpdHMpO1xuXHR9XG5cdFxuXHRmb3IodmFyIGo9MDsgajxmcm1zLmxlbmd0aDsgaisrKVxuXHR7XG5cdFx0dmFyIGZybSA9IGZybXNbal0sIG54PWZybS5yZWN0LngsIG55PWZybS5yZWN0LnksIG53PWZybS5yZWN0LndpZHRoLCBuaD1mcm0ucmVjdC5oZWlnaHQ7XG5cdFx0dmFyIGNpbWcgPSBmcm0uaW1nLCBjaW1nMzIgPSBuZXcgVWludDMyQXJyYXkoY2ltZy5idWZmZXIpO1xuXHRcdHZhciBicGwgPSA0Km53LCBicHA9NDtcblx0XHRpZihjYzw9MjU2ICYmIGZvcmJpZFBsdGU9PWZhbHNlKSB7XG5cdFx0XHRicGwgPSBNYXRoLmNlaWwoZGVwdGgqbncvOCk7XG5cdFx0XHR2YXIgbmltZyA9IG5ldyBVaW50OEFycmF5KGJwbCpuaCk7XG5cdFx0XHR2YXIgaW5qID0gaW5kc1tqXTtcblx0XHRcdGZvcih2YXIgeT0wOyB5PG5oOyB5KyspIHsgIHZhciBpPXkqYnBsLCBpaT15Km53O1xuXHRcdFx0XHRpZiAgICAgKGRlcHRoPT04KSBmb3IodmFyIHg9MDsgeDxudzsgeCsrKSBuaW1nW2krKHgpICAgXSAgID0gIChpbmpbaWkreF0gICAgICAgICAgICAgKTtcblx0XHRcdFx0ZWxzZSBpZihkZXB0aD09NCkgZm9yKHZhciB4PTA7IHg8bnc7IHgrKykgbmltZ1tpKyh4Pj4xKV0gIHw9ICAoaW5qW2lpK3hdPDwoNC0oeCYxKSo0KSk7XG5cdFx0XHRcdGVsc2UgaWYoZGVwdGg9PTIpIGZvcih2YXIgeD0wOyB4PG53OyB4KyspIG5pbWdbaSsoeD4+MildICB8PSAgKGlualtpaSt4XTw8KDYtKHgmMykqMikpO1xuXHRcdFx0XHRlbHNlIGlmKGRlcHRoPT0xKSBmb3IodmFyIHg9MDsgeDxudzsgeCsrKSBuaW1nW2krKHg+PjMpXSAgfD0gIChpbmpbaWkreF08PCg3LSh4JjcpKjEpKTtcblx0XHRcdH1cblx0XHRcdGNpbWc9bmltZzsgIGN0eXBlPTM7ICBicHA9MTtcblx0XHR9XG5cdFx0ZWxzZSBpZihnb3RBbHBoYT09ZmFsc2UgJiYgZnJtcy5sZW5ndGg9PTEpIHtcdC8vIHNvbWUgbmV4dCBcInJlZHVjZWRcIiBmcmFtZXMgbWF5IGNvbnRhaW4gYWxwaGEgZm9yIGJsZW5kaW5nXG5cdFx0XHR2YXIgbmltZyA9IG5ldyBVaW50OEFycmF5KG53Km5oKjMpLCBhcmVhPW53Km5oO1xuXHRcdFx0Zm9yKHZhciBpPTA7IGk8YXJlYTsgaSsrKSB7IHZhciB0aT1pKjMsIHFpPWkqNDsgIG5pbWdbdGldPWNpbWdbcWldOyAgbmltZ1t0aSsxXT1jaW1nW3FpKzFdOyAgbmltZ1t0aSsyXT1jaW1nW3FpKzJdOyAgfVxuXHRcdFx0Y2ltZz1uaW1nOyAgY3R5cGU9MjsgIGJwcD0zOyAgYnBsPTMqbnc7XG5cdFx0fVxuXHRcdGZybS5pbWc9Y2ltZzsgIGZybS5icGw9YnBsOyAgZnJtLmJwcD1icHA7XG5cdH1cblx0Ly9jb25zb2xlLmxvZyhcImNvbG9ycyA9PiBwYWxldHRlIGluZGljZXNcIiwgRGF0ZS5ub3coKS10aW1lKTsgIHRpbWUgPSBEYXRlLm5vdygpO1xuXHRcblx0cmV0dXJuIHtjdHlwZTpjdHlwZSwgZGVwdGg6ZGVwdGgsIHBsdGU6cGx0ZSwgZnJhbWVzOmZybXMgIH07XG59XG5VUE5HLmVuY29kZS5mcmFtaXplID0gZnVuY3Rpb24oYnVmcyx3LGgsYWx3YXlzQmxlbmQsZXZlbkNyZCxmb3JiaWRQcmV2KSB7XG5cdC8qICBESVNQT1NFXG5cdCAgICAtIDAgOiBubyBjaGFuZ2Vcblx0XHQtIDEgOiBjbGVhciB0byB0cmFuc3BhcmVudFxuXHRcdC0gMiA6IHJldHN0b3JlIHRvIGNvbnRlbnQgYmVmb3JlIHJlbmRlcmluZyAocHJldmlvdXMgZnJhbWUgZGlzcG9zZWQpXG5cdFx0QkxFTkRcblx0XHQtIDAgOiByZXBsYWNlXG5cdFx0LSAxIDogYmxlbmRcblx0Ki9cblx0dmFyIGZybXMgPSBbXTtcblx0Zm9yKHZhciBqPTA7IGo8YnVmcy5sZW5ndGg7IGorKykge1xuXHRcdHZhciBjaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tqXSksIGNpbWczMiA9IG5ldyBVaW50MzJBcnJheShjaW1nLmJ1ZmZlcik7XG5cdFx0dmFyIG5pbWc7XG5cdFx0XG5cdFx0dmFyIG54PTAsIG55PTAsIG53PXcsIG5oPWgsIGJsZW5kPWFsd2F5c0JsZW5kPzE6MDtcblx0XHRpZihqIT0wKSB7XG5cdFx0XHR2YXIgdGxpbSA9IChmb3JiaWRQcmV2IHx8IGFsd2F5c0JsZW5kIHx8IGo9PTEgfHwgZnJtc1tqLTJdLmRpc3Bvc2UhPTApPzE6MiwgdHN0cCA9IDAsIHRhcmVhID0gMWU5O1xuXHRcdFx0Zm9yKHZhciBpdD0wOyBpdDx0bGltOyBpdCsrKVxuXHRcdFx0e1xuXHRcdFx0XHR2YXIgcGltZyA9IG5ldyBVaW50OEFycmF5KGJ1ZnNbai0xLWl0XSksIHAzMiA9IG5ldyBVaW50MzJBcnJheShidWZzW2otMS1pdF0pO1xuXHRcdFx0XHR2YXIgbWl4PXcsbWl5PWgsbWF4PS0xLG1heT0tMTtcblx0XHRcdFx0Zm9yKHZhciB5PTA7IHk8aDsgeSsrKSBmb3IodmFyIHg9MDsgeDx3OyB4KyspIHtcblx0XHRcdFx0XHR2YXIgaSA9IHkqdyt4O1xuXHRcdFx0XHRcdGlmKGNpbWczMltpXSE9cDMyW2ldKSB7XG5cdFx0XHRcdFx0XHRpZih4PG1peCkgbWl4PXg7ICBpZih4Pm1heCkgbWF4PXg7XG5cdFx0XHRcdFx0XHRpZih5PG1peSkgbWl5PXk7ICBpZih5Pm1heSkgbWF5PXk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHR9XG5cdFx0XHRcdGlmKG1heD09LTEpIG1peD1taXk9bWF4PW1heT0wO1xuXHRcdFx0XHRpZihldmVuQ3JkKSB7ICBpZigobWl4JjEpPT0xKW1peC0tOyAgaWYoKG1peSYxKT09MSltaXktLTsgIH1cblx0XHRcdFx0dmFyIHNhcmVhID0gKG1heC1taXgrMSkqKG1heS1taXkrMSk7XG5cdFx0XHRcdGlmKHNhcmVhPHRhcmVhKSB7XG5cdFx0XHRcdFx0dGFyZWEgPSBzYXJlYTsgIHRzdHAgPSBpdDtcblx0XHRcdFx0XHRueCA9IG1peDsgbnkgPSBtaXk7IG53ID0gbWF4LW1peCsxOyBuaCA9IG1heS1taXkrMTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdFx0XG5cdFx0XHQvLyBhbHdheXNCbGVuZDogcG9rdWQgemppc3TDrW0sIMW+ZSBibGVuZGl0IG5lbHplLCBuYXN0YXbDrW0gcMWZZWRjaG96w61tdSBzbsOtbWt1IGRpc3Bvc2U9MS4gWmFqaXN0w61tLCBhYnkgb2JzYWhvdmFsIG3Fr2ogb2Jkw6lsbsOtay5cblx0XHRcdHZhciBwaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tqLTEtdHN0cF0pO1xuXHRcdFx0aWYodHN0cD09MSkgZnJtc1tqLTFdLmRpc3Bvc2UgPSAyO1xuXHRcdFx0XG5cdFx0XHRuaW1nID0gbmV3IFVpbnQ4QXJyYXkobncqbmgqNCk7XG5cdFx0XHRVUE5HLl9jb3B5VGlsZShwaW1nLHcsaCwgbmltZyxudyxuaCwgLW54LC1ueSwgMCk7XG5cdFx0XHRcblx0XHRcdGJsZW5kID0gIFVQTkcuX2NvcHlUaWxlKGNpbWcsdyxoLCBuaW1nLG53LG5oLCAtbngsLW55LCAzKSA/IDEgOiAwO1xuXHRcdFx0aWYoYmxlbmQ9PTEpIFVQTkcuZW5jb2RlLl9wcmVwYXJlRGlmZihjaW1nLHcsaCxuaW1nLHt4Om54LHk6bnksd2lkdGg6bncsaGVpZ2h0Om5ofSk7XG5cdFx0XHRlbHNlICAgICAgICAgVVBORy5fY29weVRpbGUoY2ltZyx3LGgsIG5pbWcsbncsbmgsIC1ueCwtbnksIDApO1xuXHRcdFx0Ly9VUE5HLl9jb3B5VGlsZShjaW1nLHcsaCwgbmltZyxudyxuaCwgLW54LC1ueSwgYmxlbmQ9PTE/MjowKTtcblx0XHR9XG5cdFx0ZWxzZSBuaW1nID0gY2ltZy5zbGljZSgwKTtcdC8vIGltZyBtYXkgYmUgcmV3cml0dGVuIGZ1cnRoZXIgLi4uIGRvbid0IHJld3JpdGUgaW5wdXRcblx0XHRcblx0XHRmcm1zLnB1c2goe3JlY3Q6e3g6bngseTpueSx3aWR0aDpudyxoZWlnaHQ6bmh9LCBpbWc6bmltZywgYmxlbmQ6YmxlbmQsIGRpc3Bvc2U6MH0pO1xuXHR9XG5cdFxuXHRcblx0aWYoYWx3YXlzQmxlbmQpIGZvcih2YXIgaj0wOyBqPGZybXMubGVuZ3RoOyBqKyspIHtcblx0XHR2YXIgZnJtID0gZnJtc1tqXTsgIGlmKGZybS5ibGVuZD09MSkgY29udGludWU7XG5cdFx0dmFyIHIwID0gZnJtLnJlY3QsIHIxID0gZnJtc1tqLTFdLnJlY3Rcblx0XHR2YXIgbWlYID0gTWF0aC5taW4ocjAueCwgcjEueCksIG1pWSA9IE1hdGgubWluKHIwLnksIHIxLnkpO1xuXHRcdHZhciBtYVggPSBNYXRoLm1heChyMC54K3IwLndpZHRoLCByMS54K3IxLndpZHRoKSwgbWFZID0gTWF0aC5tYXgocjAueStyMC5oZWlnaHQsIHIxLnkrcjEuaGVpZ2h0KTtcblx0XHR2YXIgciA9IHt4Om1pWCwgeTptaVksIHdpZHRoOm1hWC1taVgsIGhlaWdodDptYVktbWlZfTtcblx0XHRcblx0XHRmcm1zW2otMV0uZGlzcG9zZSA9IDE7XG5cdFx0aWYoai0xIT0wKSBcblx0XHRVUE5HLmVuY29kZS5fdXBkYXRlRnJhbWUoYnVmcywgdyxoLGZybXMsIGotMSxyLCBldmVuQ3JkKTtcblx0XHRVUE5HLmVuY29kZS5fdXBkYXRlRnJhbWUoYnVmcywgdyxoLGZybXMsIGogICxyLCBldmVuQ3JkKTtcblx0fVxuXHR2YXIgYXJlYSA9IDA7XG5cdGlmKGJ1ZnMubGVuZ3RoIT0xKSBmb3IodmFyIGk9MDsgaTxmcm1zLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGZybSA9IGZybXNbaV07XG5cdFx0YXJlYSArPSBmcm0ucmVjdC53aWR0aCpmcm0ucmVjdC5oZWlnaHQ7XG5cdFx0Ly9pZihpPT0wIHx8IGZybS5ibGVuZCE9MSkgY29udGludWU7XG5cdFx0Ly92YXIgb2IgPSBuZXcgVWludDhBcnJheShcblx0XHQvL2NvbnNvbGUubG9nKGZybS5ibGVuZCwgZnJtLmRpc3Bvc2UsIGZybS5yZWN0KTtcblx0fVxuXHQvL2lmKGFyZWEhPTApIGNvbnNvbGUubG9nKGFyZWEpO1xuXHRyZXR1cm4gZnJtcztcbn1cblVQTkcuZW5jb2RlLl91cGRhdGVGcmFtZSA9IGZ1bmN0aW9uKGJ1ZnMsIHcsaCwgZnJtcywgaSwgciwgZXZlbkNyZCkge1xuXHR2YXIgVTggPSBVaW50OEFycmF5LCBVMzIgPSBVaW50MzJBcnJheTtcblx0dmFyIHBpbWcgPSBuZXcgVTgoYnVmc1tpLTFdKSwgcGltZzMyID0gbmV3IFUzMihidWZzW2ktMV0pLCBuaW1nID0gaSsxPGJ1ZnMubGVuZ3RoID8gbmV3IFU4KGJ1ZnNbaSsxXSk6bnVsbDtcblx0dmFyIGNpbWcgPSBuZXcgVTgoYnVmc1tpXSksIGNpbWczMiA9IG5ldyBVMzIoY2ltZy5idWZmZXIpO1xuXHRcblx0dmFyIG1peD13LG1peT1oLG1heD0tMSxtYXk9LTE7XG5cdGZvcih2YXIgeT0wOyB5PHIuaGVpZ2h0OyB5KyspIGZvcih2YXIgeD0wOyB4PHIud2lkdGg7IHgrKykge1xuXHRcdHZhciBjeCA9IHIueCt4LCBjeSA9IHIueSt5O1xuXHRcdHZhciBqID0gY3kqdytjeCwgY2MgPSBjaW1nMzJbal07XG5cdFx0Ly8gbm8gbmVlZCB0byBkcmF3IHRyYW5zcGFyZW5jeSwgb3IgdG8gZGlzcG9zZSBpdC4gT3IsIGlmIHdyaXRpbmcgdGhlIHNhbWUgY29sb3IgYW5kIHRoZSBuZXh0IG9uZSBkb2VzIG5vdCBuZWVkIHRyYW5zcGFyZW5jeS5cblx0XHRpZihjYz09MCB8fCAoZnJtc1tpLTFdLmRpc3Bvc2U9PTAgJiYgcGltZzMyW2pdPT1jYyAmJiAobmltZz09bnVsbCB8fCBuaW1nW2oqNCszXSE9MCkpLyoqLykge31cblx0XHRlbHNlIHtcblx0XHRcdGlmKGN4PG1peCkgbWl4PWN4OyAgaWYoY3g+bWF4KSBtYXg9Y3g7XG5cdFx0XHRpZihjeTxtaXkpIG1peT1jeTsgIGlmKGN5Pm1heSkgbWF5PWN5O1xuXHRcdH1cblx0fVxuXHRpZihtYXg9PS0xKSBtaXg9bWl5PW1heD1tYXk9MDtcblx0aWYoZXZlbkNyZCkgeyAgaWYoKG1peCYxKT09MSltaXgtLTsgIGlmKChtaXkmMSk9PTEpbWl5LS07ICB9XG5cdHIgPSB7eDptaXgsIHk6bWl5LCB3aWR0aDptYXgtbWl4KzEsIGhlaWdodDptYXktbWl5KzF9O1xuXHRcblx0dmFyIGZyID0gZnJtc1tpXTsgIGZyLnJlY3QgPSByOyAgZnIuYmxlbmQgPSAxOyAgZnIuaW1nID0gbmV3IFVpbnQ4QXJyYXkoci53aWR0aCpyLmhlaWdodCo0KTtcblx0aWYoZnJtc1tpLTFdLmRpc3Bvc2U9PTApIHtcblx0XHRVUE5HLl9jb3B5VGlsZShwaW1nLHcsaCwgZnIuaW1nLHIud2lkdGgsci5oZWlnaHQsIC1yLngsLXIueSwgMCk7XG5cdFx0VVBORy5lbmNvZGUuX3ByZXBhcmVEaWZmKGNpbWcsdyxoLGZyLmltZyxyKTtcblx0XHQvL1VQTkcuX2NvcHlUaWxlKGNpbWcsdyxoLCBmci5pbWcsci53aWR0aCxyLmhlaWdodCwgLXIueCwtci55LCAyKTtcblx0fVxuXHRlbHNlXG5cdFx0VVBORy5fY29weVRpbGUoY2ltZyx3LGgsIGZyLmltZyxyLndpZHRoLHIuaGVpZ2h0LCAtci54LC1yLnksIDApO1xufVxuVVBORy5lbmNvZGUuX3ByZXBhcmVEaWZmID0gZnVuY3Rpb24oY2ltZywgdyxoLCBuaW1nLCByZWMpIHtcblx0VVBORy5fY29weVRpbGUoY2ltZyx3LGgsIG5pbWcscmVjLndpZHRoLHJlYy5oZWlnaHQsIC1yZWMueCwtcmVjLnksIDIpO1xuXHQvKlxuXHR2YXIgbjMyID0gbmV3IFVpbnQzMkFycmF5KG5pbWcuYnVmZmVyKTtcblx0dmFyIG9nID0gbmV3IFVpbnQ4QXJyYXkocmVjLndpZHRoKnJlYy5oZWlnaHQqNCksIG8zMiA9IG5ldyBVaW50MzJBcnJheShvZy5idWZmZXIpO1xuXHRVUE5HLl9jb3B5VGlsZShjaW1nLHcsaCwgb2cscmVjLndpZHRoLHJlYy5oZWlnaHQsIC1yZWMueCwtcmVjLnksIDApO1xuXHRmb3IodmFyIGk9NDsgaTxuaW1nLmxlbmd0aDsgaSs9NCkge1xuXHRcdGlmKG5pbWdbaS0xXSE9MCAmJiBuaW1nW2krM109PTAgJiYgbzMyW2k+Pj4yXT09bzMyWyhpPj4+MiktMV0pIHtcblx0XHRcdG4zMltpPj4+Ml09bzMyW2k+Pj4yXTtcblx0XHRcdC8vdmFyIGogPSBpLCBjPXAzMlsoaT4+PjIpLTFdO1xuXHRcdFx0Ly93aGlsZShwMzJbaj4+PjJdPT1jKSB7ICBuMzJbaj4+PjJdPWM7ICBqKz00OyAgfVxuXHRcdH1cblx0fVxuXHRmb3IodmFyIGk9bmltZy5sZW5ndGgtODsgaT4wOyBpLT00KSB7XG5cdFx0aWYobmltZ1tpKzddIT0wICYmIG5pbWdbaSszXT09MCAmJiBvMzJbaT4+PjJdPT1vMzJbKGk+Pj4yKSsxXSkge1xuXHRcdFx0bjMyW2k+Pj4yXT1vMzJbaT4+PjJdO1xuXHRcdFx0Ly92YXIgaiA9IGksIGM9cDMyWyhpPj4+MiktMV07XG5cdFx0XHQvL3doaWxlKHAzMltqPj4+Ml09PWMpIHsgIG4zMltqPj4+Ml09YzsgIGorPTQ7ICB9XG5cdFx0fVxuXHR9Ki9cbn1cblxuVVBORy5lbmNvZGUuX2ZpbHRlclplcm8gPSBmdW5jdGlvbihpbWcsaCxicHAsYnBsLGRhdGEsIGZpbHRlciwgbGV2ZWxaZXJvKVxue1xuXHR2YXIgZmxzID0gW10sIGZ0cnk9WzAsMSwyLDMsNF07XG5cdGlmICAgICAoZmlsdGVyIT0tMSkgICAgICAgICAgICAgZnRyeT1bZmlsdGVyXTtcblx0ZWxzZSBpZihoKmJwbD41MDAwMDAgfHwgYnBwPT0xKSBmdHJ5PVswXTtcblx0dmFyIG9wdHM7ICBpZihsZXZlbFplcm8pIG9wdHM9e2xldmVsOjB9O1xuXHRcblx0dmFyIENNUFIgPSAobGV2ZWxaZXJvICYmIFVaSVAhPW51bGwpID8gVVpJUCA6IHBha287XG5cdFxuXHRmb3IodmFyIGk9MDsgaTxmdHJ5Lmxlbmd0aDsgaSsrKSB7XG5cdFx0Zm9yKHZhciB5PTA7IHk8aDsgeSsrKSBVUE5HLmVuY29kZS5fZmlsdGVyTGluZShkYXRhLCBpbWcsIHksIGJwbCwgYnBwLCBmdHJ5W2ldKTtcblx0XHQvL3ZhciBuaW1nID0gbmV3IFVpbnQ4QXJyYXkoZGF0YS5sZW5ndGgpO1xuXHRcdC8vdmFyIHN6ID0gVVpJUC5GLmRlZmxhdGUoZGF0YSwgbmltZyk7ICBmbHMucHVzaChuaW1nLnNsaWNlKDAsc3opKTtcblx0XHQvL3ZhciBkZmwgPSBwYWtvW1wiZGVmbGF0ZVwiXShkYXRhKSwgZGw9ZGZsLmxlbmd0aC00O1xuXHRcdC8vdmFyIGNyYyA9IChkZmxbZGwrM108PDI0KXwoZGZsW2RsKzJdPDwxNil8KGRmbFtkbCsxXTw8OCl8KGRmbFtkbCswXTw8MCk7XG5cdFx0Ly9jb25zb2xlLmxvZyhjcmMsIFVaSVAuYWRsZXIoZGF0YSwyLGRhdGEubGVuZ3RoLTYpKTtcblx0XHRmbHMucHVzaChDTVBSW1wiZGVmbGF0ZVwiXShkYXRhLG9wdHMpKTtcblx0fVxuXHR2YXIgdGksIHRzaXplPTFlOTtcblx0Zm9yKHZhciBpPTA7IGk8ZmxzLmxlbmd0aDsgaSsrKSBpZihmbHNbaV0ubGVuZ3RoPHRzaXplKSB7ICB0aT1pOyAgdHNpemU9ZmxzW2ldLmxlbmd0aDsgIH1cblx0cmV0dXJuIGZsc1t0aV07XG59XG5VUE5HLmVuY29kZS5fZmlsdGVyTGluZSA9IGZ1bmN0aW9uKGRhdGEsIGltZywgeSwgYnBsLCBicHAsIHR5cGUpXG57XG5cdHZhciBpID0geSpicGwsIGRpID0gaSt5LCBwYWV0aCA9IFVQTkcuZGVjb2RlLl9wYWV0aFxuXHRkYXRhW2RpXT10eXBlOyAgZGkrKztcblxuXHRpZih0eXBlPT0wKSB7XG5cdFx0aWYoYnBsPDUwMCkgZm9yKHZhciB4PTA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSBpbWdbaSt4XTtcblx0XHRlbHNlIGRhdGEuc2V0KG5ldyBVaW50OEFycmF5KGltZy5idWZmZXIsaSxicGwpLGRpKTtcblx0fVxuXHRlbHNlIGlmKHR5cGU9PTEpIHtcblx0XHRmb3IodmFyIHg9ICAwOyB4PGJwcDsgeCsrKSBkYXRhW2RpK3hdID0gIGltZ1tpK3hdO1xuXHRcdGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0taW1nW2kreC1icHBdKzI1NikmMjU1O1xuXHR9XG5cdGVsc2UgaWYoeT09MCkge1xuXHRcdGZvcih2YXIgeD0gIDA7IHg8YnBwOyB4KyspIGRhdGFbZGkreF0gPSBpbWdbaSt4XTtcblxuXHRcdGlmKHR5cGU9PTIpIGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSBpbWdbaSt4XTtcblx0XHRpZih0eXBlPT0zKSBmb3IodmFyIHg9YnBwOyB4PGJwbDsgeCsrKSBkYXRhW2RpK3hdID0gKGltZ1tpK3hdIC0gKGltZ1tpK3gtYnBwXT4+MSkgKzI1NikmMjU1O1xuXHRcdGlmKHR5cGU9PTQpIGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0gLSBwYWV0aChpbWdbaSt4LWJwcF0sIDAsIDApICsyNTYpJjI1NTtcblx0fVxuXHRlbHNlIHtcblx0XHRpZih0eXBlPT0yKSB7IGZvcih2YXIgeD0gIDA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0rMjU2IC0gaW1nW2kreC1icGxdKSYyNTU7ICB9XG5cdFx0aWYodHlwZT09MykgeyBmb3IodmFyIHg9ICAwOyB4PGJwcDsgeCsrKSBkYXRhW2RpK3hdID0gKGltZ1tpK3hdKzI1NiAtIChpbWdbaSt4LWJwbF0+PjEpKSYyNTU7XG5cdFx0XHRcdFx0ICBmb3IodmFyIHg9YnBwOyB4PGJwbDsgeCsrKSBkYXRhW2RpK3hdID0gKGltZ1tpK3hdKzI1NiAtICgoaW1nW2kreC1icGxdK2ltZ1tpK3gtYnBwXSk+PjEpKSYyNTU7ICB9XG5cdFx0aWYodHlwZT09NCkgeyBmb3IodmFyIHg9ICAwOyB4PGJwcDsgeCsrKSBkYXRhW2RpK3hdID0gKGltZ1tpK3hdKzI1NiAtIHBhZXRoKDAsIGltZ1tpK3gtYnBsXSwgMCkpJjI1NTtcblx0XHRcdFx0XHQgIGZvcih2YXIgeD1icHA7IHg8YnBsOyB4KyspIGRhdGFbZGkreF0gPSAoaW1nW2kreF0rMjU2IC0gcGFldGgoaW1nW2kreC1icHBdLCBpbWdbaSt4LWJwbF0sIGltZ1tpK3gtYnBwLWJwbF0pKSYyNTU7ICB9XG5cdH1cbn1cblxuVVBORy5jcmMgPSB7XG5cdHRhYmxlIDogKCBmdW5jdGlvbigpIHtcblx0ICAgdmFyIHRhYiA9IG5ldyBVaW50MzJBcnJheSgyNTYpO1xuXHQgICBmb3IgKHZhciBuPTA7IG48MjU2OyBuKyspIHtcblx0XHRcdHZhciBjID0gbjtcblx0XHRcdGZvciAodmFyIGs9MDsgazw4OyBrKyspIHtcblx0XHRcdFx0aWYgKGMgJiAxKSAgYyA9IDB4ZWRiODgzMjAgXiAoYyA+Pj4gMSk7XG5cdFx0XHRcdGVsc2UgICAgICAgIGMgPSBjID4+PiAxO1xuXHRcdFx0fVxuXHRcdFx0dGFiW25dID0gYzsgIH1cblx0XHRyZXR1cm4gdGFiOyAgfSkoKSxcblx0dXBkYXRlIDogZnVuY3Rpb24oYywgYnVmLCBvZmYsIGxlbikge1xuXHRcdGZvciAodmFyIGk9MDsgaTxsZW47IGkrKykgIGMgPSBVUE5HLmNyYy50YWJsZVsoYyBeIGJ1ZltvZmYraV0pICYgMHhmZl0gXiAoYyA+Pj4gOCk7XG5cdFx0cmV0dXJuIGM7XG5cdH0sXG5cdGNyYyA6IGZ1bmN0aW9uKGIsbyxsKSAgeyAgcmV0dXJuIFVQTkcuY3JjLnVwZGF0ZSgweGZmZmZmZmZmLGIsbyxsKSBeIDB4ZmZmZmZmZmY7ICB9XG59XG5cblxuVVBORy5xdWFudGl6ZSA9IGZ1bmN0aW9uKGFidWYsIHBzKVxue1x0XG5cdHZhciBvaW1nID0gbmV3IFVpbnQ4QXJyYXkoYWJ1ZiksIG5pbWcgPSBvaW1nLnNsaWNlKDApLCBuaW1nMzIgPSBuZXcgVWludDMyQXJyYXkobmltZy5idWZmZXIpO1xuXHRcblx0dmFyIEtEID0gVVBORy5xdWFudGl6ZS5nZXRLRHRyZWUobmltZywgcHMpO1xuXHR2YXIgcm9vdCA9IEtEWzBdLCBsZWFmcyA9IEtEWzFdO1xuXHRcblx0dmFyIHBsYW5lRHN0ID0gVVBORy5xdWFudGl6ZS5wbGFuZURzdDtcblx0dmFyIHNiID0gb2ltZywgdGIgPSBuaW1nMzIsIGxlbj1zYi5sZW5ndGg7XG5cdFx0XG5cdHZhciBpbmRzID0gbmV3IFVpbnQ4QXJyYXkob2ltZy5sZW5ndGg+PjIpO1xuXHRmb3IodmFyIGk9MDsgaTxsZW47IGkrPTQpIHtcblx0XHR2YXIgcj1zYltpXSooMS8yNTUpLCBnPXNiW2krMV0qKDEvMjU1KSwgYj1zYltpKzJdKigxLzI1NSksIGE9c2JbaSszXSooMS8yNTUpO1xuXHRcdFxuXHRcdC8vICBleGFjdCwgYnV0IHRvbyBzbG93IDooXG5cdFx0dmFyIG5kID0gVVBORy5xdWFudGl6ZS5nZXROZWFyZXN0KHJvb3QsIHIsIGcsIGIsIGEpO1xuXHRcdC8vdmFyIG5kID0gcm9vdDtcblx0XHQvL3doaWxlKG5kLmxlZnQpIG5kID0gKHBsYW5lRHN0KG5kLmVzdCxyLGcsYixhKTw9MCkgPyBuZC5sZWZ0IDogbmQucmlnaHQ7XG5cdFx0XG5cdFx0aW5kc1tpPj4yXSA9IG5kLmluZDtcblx0XHR0YltpPj4yXSA9IG5kLmVzdC5yZ2JhO1xuXHR9XG5cdHJldHVybiB7ICBhYnVmOm5pbWcuYnVmZmVyLCBpbmRzOmluZHMsIHBsdGU6bGVhZnMgIH07XG59XG5cblVQTkcucXVhbnRpemUuZ2V0S0R0cmVlID0gZnVuY3Rpb24obmltZywgcHMsIGVycikge1xuXHRpZihlcnI9PW51bGwpIGVyciA9IDAuMDAwMTtcblx0dmFyIG5pbWczMiA9IG5ldyBVaW50MzJBcnJheShuaW1nLmJ1ZmZlcik7XG5cdFxuXHR2YXIgcm9vdCA9IHtpMDowLCBpMTpuaW1nLmxlbmd0aCwgYnN0Om51bGwsIGVzdDpudWxsLCB0ZHN0OjAsIGxlZnQ6bnVsbCwgcmlnaHQ6bnVsbCB9OyAgLy8gYmFzaWMgc3RhdGlzdGljLCBleHRyYSBzdGF0aXN0aWNcblx0cm9vdC5ic3QgPSBVUE5HLnF1YW50aXplLnN0YXRzKCAgbmltZyxyb290LmkwLCByb290LmkxICApOyAgcm9vdC5lc3QgPSBVUE5HLnF1YW50aXplLmVzdGF0cyggcm9vdC5ic3QgKTtcblx0dmFyIGxlYWZzID0gW3Jvb3RdO1xuXHRcblx0d2hpbGUobGVhZnMubGVuZ3RoPHBzKVxuXHR7XG5cdFx0dmFyIG1heEwgPSAwLCBtaT0wO1xuXHRcdGZvcih2YXIgaT0wOyBpPGxlYWZzLmxlbmd0aDsgaSsrKSBpZihsZWFmc1tpXS5lc3QuTCA+IG1heEwpIHsgIG1heEw9bGVhZnNbaV0uZXN0Lkw7ICBtaT1pOyAgfVxuXHRcdGlmKG1heEw8ZXJyKSBicmVhaztcblx0XHR2YXIgbm9kZSA9IGxlYWZzW21pXTtcblx0XHRcblx0XHR2YXIgczAgPSBVUE5HLnF1YW50aXplLnNwbGl0UGl4ZWxzKG5pbWcsbmltZzMyLCBub2RlLmkwLCBub2RlLmkxLCBub2RlLmVzdC5lLCBub2RlLmVzdC5lTXEyNTUpO1xuXHRcdHZhciBzMHdyb25nID0gKG5vZGUuaTA+PXMwIHx8IG5vZGUuaTE8PXMwKTtcblx0XHQvL2NvbnNvbGUubG9nKG1heEwsIGxlYWZzLmxlbmd0aCwgbWkpO1xuXHRcdGlmKHMwd3JvbmcpIHsgIG5vZGUuZXN0Lkw9MDsgIGNvbnRpbnVlOyAgfVxuXHRcdFxuXHRcdFxuXHRcdHZhciBsbiA9IHtpMDpub2RlLmkwLCBpMTpzMCwgYnN0Om51bGwsIGVzdDpudWxsLCB0ZHN0OjAsIGxlZnQ6bnVsbCwgcmlnaHQ6bnVsbCB9OyAgbG4uYnN0ID0gVVBORy5xdWFudGl6ZS5zdGF0cyggbmltZywgbG4uaTAsIGxuLmkxICk7ICBcblx0XHRsbi5lc3QgPSBVUE5HLnF1YW50aXplLmVzdGF0cyggbG4uYnN0ICk7XG5cdFx0dmFyIHJuID0ge2kwOnMwLCBpMTpub2RlLmkxLCBic3Q6bnVsbCwgZXN0Om51bGwsIHRkc3Q6MCwgbGVmdDpudWxsLCByaWdodDpudWxsIH07ICBybi5ic3QgPSB7UjpbXSwgbTpbXSwgTjpub2RlLmJzdC5OLWxuLmJzdC5OfTtcblx0XHRmb3IodmFyIGk9MDsgaTwxNjsgaSsrKSBybi5ic3QuUltpXSA9IG5vZGUuYnN0LlJbaV0tbG4uYnN0LlJbaV07XG5cdFx0Zm9yKHZhciBpPTA7IGk8IDQ7IGkrKykgcm4uYnN0Lm1baV0gPSBub2RlLmJzdC5tW2ldLWxuLmJzdC5tW2ldO1xuXHRcdHJuLmVzdCA9IFVQTkcucXVhbnRpemUuZXN0YXRzKCBybi5ic3QgKTtcblx0XHRcblx0XHRub2RlLmxlZnQgPSBsbjsgIG5vZGUucmlnaHQgPSBybjtcblx0XHRsZWFmc1ttaV09bG47ICBsZWFmcy5wdXNoKHJuKTtcblx0fVxuXHRsZWFmcy5zb3J0KGZ1bmN0aW9uKGEsYikgeyAgcmV0dXJuIGIuYnN0Lk4tYS5ic3QuTjsgIH0pO1xuXHRmb3IodmFyIGk9MDsgaTxsZWFmcy5sZW5ndGg7IGkrKykgbGVhZnNbaV0uaW5kPWk7XG5cdHJldHVybiBbcm9vdCwgbGVhZnNdO1xufVxuXG5VUE5HLnF1YW50aXplLmdldE5lYXJlc3QgPSBmdW5jdGlvbihuZCwgcixnLGIsYSlcbntcblx0aWYobmQubGVmdD09bnVsbCkgeyAgbmQudGRzdCA9IFVQTkcucXVhbnRpemUuZGlzdChuZC5lc3QucSxyLGcsYixhKTsgIHJldHVybiBuZDsgIH1cblx0dmFyIHBsYW5lRHN0ID0gVVBORy5xdWFudGl6ZS5wbGFuZURzdChuZC5lc3QscixnLGIsYSk7XG5cdFxuXHR2YXIgbm9kZTAgPSBuZC5sZWZ0LCBub2RlMSA9IG5kLnJpZ2h0O1xuXHRpZihwbGFuZURzdD4wKSB7ICBub2RlMD1uZC5yaWdodDsgIG5vZGUxPW5kLmxlZnQ7ICB9XG5cdFxuXHR2YXIgbG4gPSBVUE5HLnF1YW50aXplLmdldE5lYXJlc3Qobm9kZTAsIHIsZyxiLGEpO1xuXHRpZihsbi50ZHN0PD1wbGFuZURzdCpwbGFuZURzdCkgcmV0dXJuIGxuO1xuXHR2YXIgcm4gPSBVUE5HLnF1YW50aXplLmdldE5lYXJlc3Qobm9kZTEsIHIsZyxiLGEpO1xuXHRyZXR1cm4gcm4udGRzdDxsbi50ZHN0ID8gcm4gOiBsbjtcbn1cblVQTkcucXVhbnRpemUucGxhbmVEc3QgPSBmdW5jdGlvbihlc3QsIHIsZyxiLGEpIHsgIHZhciBlID0gZXN0LmU7ICByZXR1cm4gZVswXSpyICsgZVsxXSpnICsgZVsyXSpiICsgZVszXSphIC0gZXN0LmVNcTsgIH1cblVQTkcucXVhbnRpemUuZGlzdCAgICAgPSBmdW5jdGlvbihxLCAgIHIsZyxiLGEpIHsgIHZhciBkMD1yLXFbMF0sIGQxPWctcVsxXSwgZDI9Yi1xWzJdLCBkMz1hLXFbM107ICByZXR1cm4gZDAqZDArZDEqZDErZDIqZDIrZDMqZDM7ICB9XG5cblVQTkcucXVhbnRpemUuc3BsaXRQaXhlbHMgPSBmdW5jdGlvbihuaW1nLCBuaW1nMzIsIGkwLCBpMSwgZSwgZU1xKVxue1xuXHR2YXIgdmVjRG90ID0gVVBORy5xdWFudGl6ZS52ZWNEb3Q7XG5cdGkxLT00O1xuXHR2YXIgc2hmcyA9IDA7XG5cdHdoaWxlKGkwPGkxKVxuXHR7XG5cdFx0d2hpbGUodmVjRG90KG5pbWcsIGkwLCBlKTw9ZU1xKSBpMCs9NDtcblx0XHR3aGlsZSh2ZWNEb3QobmltZywgaTEsIGUpPiBlTXEpIGkxLT00O1xuXHRcdGlmKGkwPj1pMSkgYnJlYWs7XG5cdFx0XG5cdFx0dmFyIHQgPSBuaW1nMzJbaTA+PjJdOyAgbmltZzMyW2kwPj4yXSA9IG5pbWczMltpMT4+Ml07ICBuaW1nMzJbaTE+PjJdPXQ7XG5cdFx0XG5cdFx0aTArPTQ7ICBpMS09NDtcblx0fVxuXHR3aGlsZSh2ZWNEb3QobmltZywgaTAsIGUpPmVNcSkgaTAtPTQ7XG5cdHJldHVybiBpMCs0O1xufVxuVVBORy5xdWFudGl6ZS52ZWNEb3QgPSBmdW5jdGlvbihuaW1nLCBpLCBlKVxue1xuXHRyZXR1cm4gbmltZ1tpXSplWzBdICsgbmltZ1tpKzFdKmVbMV0gKyBuaW1nW2krMl0qZVsyXSArIG5pbWdbaSszXSplWzNdO1xufVxuVVBORy5xdWFudGl6ZS5zdGF0cyA9IGZ1bmN0aW9uKG5pbWcsIGkwLCBpMSl7XG5cdHZhciBSID0gWzAsMCwwLDAsICAwLDAsMCwwLCAgMCwwLDAsMCwgIDAsMCwwLDBdO1xuXHR2YXIgbSA9IFswLDAsMCwwXTtcblx0dmFyIE4gPSAoaTEtaTApPj4yO1xuXHRmb3IodmFyIGk9aTA7IGk8aTE7IGkrPTQpXG5cdHtcblx0XHR2YXIgciA9IG5pbWdbaV0qKDEvMjU1KSwgZyA9IG5pbWdbaSsxXSooMS8yNTUpLCBiID0gbmltZ1tpKzJdKigxLzI1NSksIGEgPSBuaW1nW2krM10qKDEvMjU1KTtcblx0XHQvL3ZhciByID0gbmltZ1tpXSwgZyA9IG5pbWdbaSsxXSwgYiA9IG5pbWdbaSsyXSwgYSA9IG5pbWdbaSszXTtcblx0XHRtWzBdKz1yOyAgbVsxXSs9ZzsgIG1bMl0rPWI7ICBtWzNdKz1hO1xuXHRcdFxuXHRcdFJbIDBdICs9IHIqcjsgIFJbIDFdICs9IHIqZzsgIFJbIDJdICs9IHIqYjsgIFJbIDNdICs9IHIqYTsgIFxuXHRcdCAgICAgICAgICAgICAgIFJbIDVdICs9IGcqZzsgIFJbIDZdICs9IGcqYjsgIFJbIDddICs9IGcqYTsgXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUlsxMF0gKz0gYipiOyAgUlsxMV0gKz0gYiphOyAgXG5cdFx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgUlsxNV0gKz0gYSphOyAgXG5cdH1cblx0Uls0XT1SWzFdOyAgUls4XT1SWzJdOyAgUls5XT1SWzZdOyAgUlsxMl09UlszXTsgIFJbMTNdPVJbN107ICBSWzE0XT1SWzExXTtcblx0XG5cdHJldHVybiB7UjpSLCBtOm0sIE46Tn07XG59XG5VUE5HLnF1YW50aXplLmVzdGF0cyA9IGZ1bmN0aW9uKHN0YXRzKXtcblx0dmFyIFIgPSBzdGF0cy5SLCBtID0gc3RhdHMubSwgTiA9IHN0YXRzLk47XG5cdFxuXHQvLyB3aGVuIGFsbCBzYW1wbGVzIGFyZSBlcXVhbCwgYnV0IE4gaXMgbGFyZ2UgKG1pbGxpb25zKSwgdGhlIFJqIGNhbiBiZSBub24temVybyAoIDAuMDAwMy4uLi4gLSBwcmVjaXNzaW9uIGVycm9yKVxuXHR2YXIgbTAgPSBtWzBdLCBtMSA9IG1bMV0sIG0yID0gbVsyXSwgbTMgPSBtWzNdLCBpTiA9IChOPT0wID8gMCA6IDEvTik7XG5cdHZhciBSaiA9IFtcblx0XHRSWyAwXSAtIG0wKm0wKmlOLCAgUlsgMV0gLSBtMCptMSppTiwgIFJbIDJdIC0gbTAqbTIqaU4sICBSWyAzXSAtIG0wKm0zKmlOLCAgXG5cdFx0UlsgNF0gLSBtMSptMCppTiwgIFJbIDVdIC0gbTEqbTEqaU4sICBSWyA2XSAtIG0xKm0yKmlOLCAgUlsgN10gLSBtMSptMyppTixcblx0XHRSWyA4XSAtIG0yKm0wKmlOLCAgUlsgOV0gLSBtMiptMSppTiwgIFJbMTBdIC0gbTIqbTIqaU4sICBSWzExXSAtIG0yKm0zKmlOLCAgXG5cdFx0UlsxMl0gLSBtMyptMCppTiwgIFJbMTNdIC0gbTMqbTEqaU4sICBSWzE0XSAtIG0zKm0yKmlOLCAgUlsxNV0gLSBtMyptMyppTiBcblx0XTtcblx0XG5cdHZhciBBID0gUmosIE0gPSBVUE5HLk00O1xuXHR2YXIgYiA9IFswLjUsMC41LDAuNSwwLjVdLCBtaSA9IDAsIHRtaSA9IDA7XG5cdFxuXHRpZihOIT0wKVxuXHRmb3IodmFyIGk9MDsgaTwxMDsgaSsrKSB7XG5cdFx0YiA9IE0ubXVsdFZlYyhBLCBiKTsgIHRtaSA9IE1hdGguc3FydChNLmRvdChiLGIpKTsgIGIgPSBNLnNtbCgxL3RtaSwgIGIpO1xuXHRcdGlmKE1hdGguYWJzKHRtaS1taSk8MWUtOSkgYnJlYWs7ICBtaSA9IHRtaTtcblx0fVx0XG5cdC8vYiA9IFswLDAsMSwwXTsgIG1pPU47XG5cdHZhciBxID0gW20wKmlOLCBtMSppTiwgbTIqaU4sIG0zKmlOXTtcblx0dmFyIGVNcTI1NSA9IE0uZG90KE0uc21sKDI1NSxxKSxiKTtcblx0XG5cdHJldHVybiB7ICBDb3Y6UmosIHE6cSwgZTpiLCBMOm1pLCAgZU1xMjU1OmVNcTI1NSwgZU1xIDogTS5kb3QoYixxKSxcblx0XHRcdFx0cmdiYTogKCgoTWF0aC5yb3VuZCgyNTUqcVszXSk8PDI0KSB8IChNYXRoLnJvdW5kKDI1NSpxWzJdKTw8MTYpIHwgIChNYXRoLnJvdW5kKDI1NSpxWzFdKTw8OCkgfCAoTWF0aC5yb3VuZCgyNTUqcVswXSk8PDApKT4+PjApICB9O1xufVxuVVBORy5NNCA9IHtcblx0bXVsdFZlYyA6IGZ1bmN0aW9uKG0sdikge1xuXHRcdFx0cmV0dXJuIFtcblx0XHRcdFx0bVsgMF0qdlswXSArIG1bIDFdKnZbMV0gKyBtWyAyXSp2WzJdICsgbVsgM10qdlszXSxcblx0XHRcdFx0bVsgNF0qdlswXSArIG1bIDVdKnZbMV0gKyBtWyA2XSp2WzJdICsgbVsgN10qdlszXSxcblx0XHRcdFx0bVsgOF0qdlswXSArIG1bIDldKnZbMV0gKyBtWzEwXSp2WzJdICsgbVsxMV0qdlszXSxcblx0XHRcdFx0bVsxMl0qdlswXSArIG1bMTNdKnZbMV0gKyBtWzE0XSp2WzJdICsgbVsxNV0qdlszXVxuXHRcdFx0XTtcblx0fSxcblx0ZG90IDogZnVuY3Rpb24oeCx5KSB7ICByZXR1cm4gIHhbMF0qeVswXSt4WzFdKnlbMV0reFsyXSp5WzJdK3hbM10qeVszXTsgIH0sXG5cdHNtbCA6IGZ1bmN0aW9uKGEseSkgeyAgcmV0dXJuIFthKnlbMF0sYSp5WzFdLGEqeVsyXSxhKnlbM11dOyAgfVxufVxuXG5VUE5HLmVuY29kZS5jb25jYXRSR0JBID0gZnVuY3Rpb24oYnVmcykge1xuXHR2YXIgdGxlbiA9IDA7XG5cdGZvcih2YXIgaT0wOyBpPGJ1ZnMubGVuZ3RoOyBpKyspIHRsZW4gKz0gYnVmc1tpXS5ieXRlTGVuZ3RoO1xuXHR2YXIgbmltZyA9IG5ldyBVaW50OEFycmF5KHRsZW4pLCBub2ZmPTA7XG5cdGZvcih2YXIgaT0wOyBpPGJ1ZnMubGVuZ3RoOyBpKyspIHtcblx0XHR2YXIgaW1nID0gbmV3IFVpbnQ4QXJyYXkoYnVmc1tpXSksIGlsID0gaW1nLmxlbmd0aDtcblx0XHRmb3IodmFyIGo9MDsgajxpbDsgais9NCkgeyAgXG5cdFx0XHR2YXIgcj1pbWdbal0sIGc9aW1nW2orMV0sIGI9aW1nW2orMl0sIGEgPSBpbWdbaiszXTtcblx0XHRcdGlmKGE9PTApIHI9Zz1iPTA7XG5cdFx0XHRuaW1nW25vZmYral09cjsgIG5pbWdbbm9mZitqKzFdPWc7ICBuaW1nW25vZmYraisyXT1iOyAgbmltZ1tub2ZmK2orM109YTsgIH1cblx0XHRub2ZmICs9IGlsO1xuXHR9XG5cdHJldHVybiBuaW1nLmJ1ZmZlcjtcbn1cblxuZXhwb3J0IGRlZmF1bHQgVVBORztcblxuIl0sIm5hbWVzIjpbXSwiaWdub3JlTGlzdCI6WzBdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/@pdf-lib+upng@1.0.1/node_modules/@pdf-lib/upng/UPNG.js\n");

/***/ })

};
;