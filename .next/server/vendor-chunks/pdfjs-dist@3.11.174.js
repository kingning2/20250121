/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/pdfjs-dist@3.11.174";
exports.ids = ["vendor-chunks/pdfjs-dist@3.11.174"];
exports.modules = {

/***/ "(ssr)/./node_modules/.pnpm/pdfjs-dist@3.11.174/node_modules/pdfjs-dist/legacy/build/pdf.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/.pnpm/pdfjs-dist@3.11.174/node_modules/pdfjs-dist/legacy/build/pdf.js ***!
  \********************************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("/**\n * @licstart The following is the entire license notice for the\n * JavaScript code in this page\n *\n * Copyright 2023 Mozilla Foundation\n *\n * Licensed under the Apache License, Version 2.0 (the \"License\");\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     http://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an \"AS IS\" BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n *\n * @licend The above is the entire license notice for the\n * JavaScript code in this page\n */\n\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = root.pdfjsLib = factory();\n\telse {}\n})(globalThis, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \t\"use strict\";\n/******/ \tvar __webpack_modules__ = ([\n/* 0 */,\n/* 1 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.VerbosityLevel = exports.Util = exports.UnknownErrorException = exports.UnexpectedResponseException = exports.TextRenderingMode = exports.RenderingIntentFlag = exports.PromiseCapability = exports.PermissionFlag = exports.PasswordResponses = exports.PasswordException = exports.PageActionEventType = exports.OPS = exports.MissingPDFException = exports.MAX_IMAGE_SIZE_TO_CACHE = exports.LINE_FACTOR = exports.LINE_DESCENT_FACTOR = exports.InvalidPDFException = exports.ImageKind = exports.IDENTITY_MATRIX = exports.FormatError = exports.FeatureTest = exports.FONT_IDENTITY_MATRIX = exports.DocumentActionEventType = exports.CMapCompressionType = exports.BaseException = exports.BASELINE_FACTOR = exports.AnnotationType = exports.AnnotationReplyType = exports.AnnotationPrefix = exports.AnnotationMode = exports.AnnotationFlag = exports.AnnotationFieldFlag = exports.AnnotationEditorType = exports.AnnotationEditorPrefix = exports.AnnotationEditorParamsType = exports.AnnotationBorderStyleType = exports.AnnotationActionEventType = exports.AbortException = void 0;\nexports.assert = assert;\nexports.bytesToString = bytesToString;\nexports.createValidAbsoluteUrl = createValidAbsoluteUrl;\nexports.getModificationDate = getModificationDate;\nexports.getUuid = getUuid;\nexports.getVerbosityLevel = getVerbosityLevel;\nexports.info = info;\nexports.isArrayBuffer = isArrayBuffer;\nexports.isArrayEqual = isArrayEqual;\nexports.isNodeJS = void 0;\nexports.normalizeUnicode = normalizeUnicode;\nexports.objectFromMap = objectFromMap;\nexports.objectSize = objectSize;\nexports.setVerbosityLevel = setVerbosityLevel;\nexports.shadow = shadow;\nexports.string32 = string32;\nexports.stringToBytes = stringToBytes;\nexports.stringToPDFString = stringToPDFString;\nexports.stringToUTF8String = stringToUTF8String;\nexports.unreachable = unreachable;\nexports.utf8StringToString = utf8StringToString;\nexports.warn = warn;\n__w_pdfjs_require__(2);\n__w_pdfjs_require__(84);\n__w_pdfjs_require__(86);\n__w_pdfjs_require__(87);\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\nconst isNodeJS = typeof process === \"object\" && process + \"\" === \"[object process]\" && !process.versions.nw && !(process.versions.electron && process.type && process.type !== \"browser\");\nexports.isNodeJS = isNodeJS;\nconst IDENTITY_MATRIX = [1, 0, 0, 1, 0, 0];\nexports.IDENTITY_MATRIX = IDENTITY_MATRIX;\nconst FONT_IDENTITY_MATRIX = [0.001, 0, 0, 0.001, 0, 0];\nexports.FONT_IDENTITY_MATRIX = FONT_IDENTITY_MATRIX;\nconst MAX_IMAGE_SIZE_TO_CACHE = 10e6;\nexports.MAX_IMAGE_SIZE_TO_CACHE = MAX_IMAGE_SIZE_TO_CACHE;\nconst LINE_FACTOR = 1.35;\nexports.LINE_FACTOR = LINE_FACTOR;\nconst LINE_DESCENT_FACTOR = 0.35;\nexports.LINE_DESCENT_FACTOR = LINE_DESCENT_FACTOR;\nconst BASELINE_FACTOR = LINE_DESCENT_FACTOR / LINE_FACTOR;\nexports.BASELINE_FACTOR = BASELINE_FACTOR;\nconst RenderingIntentFlag = {\n  ANY: 0x01,\n  DISPLAY: 0x02,\n  PRINT: 0x04,\n  SAVE: 0x08,\n  ANNOTATIONS_FORMS: 0x10,\n  ANNOTATIONS_STORAGE: 0x20,\n  ANNOTATIONS_DISABLE: 0x40,\n  OPLIST: 0x100\n};\nexports.RenderingIntentFlag = RenderingIntentFlag;\nconst AnnotationMode = {\n  DISABLE: 0,\n  ENABLE: 1,\n  ENABLE_FORMS: 2,\n  ENABLE_STORAGE: 3\n};\nexports.AnnotationMode = AnnotationMode;\nconst AnnotationEditorPrefix = \"pdfjs_internal_editor_\";\nexports.AnnotationEditorPrefix = AnnotationEditorPrefix;\nconst AnnotationEditorType = {\n  DISABLE: -1,\n  NONE: 0,\n  FREETEXT: 3,\n  STAMP: 13,\n  INK: 15\n};\nexports.AnnotationEditorType = AnnotationEditorType;\nconst AnnotationEditorParamsType = {\n  RESIZE: 1,\n  CREATE: 2,\n  FREETEXT_SIZE: 11,\n  FREETEXT_COLOR: 12,\n  FREETEXT_OPACITY: 13,\n  INK_COLOR: 21,\n  INK_THICKNESS: 22,\n  INK_OPACITY: 23\n};\nexports.AnnotationEditorParamsType = AnnotationEditorParamsType;\nconst PermissionFlag = {\n  PRINT: 0x04,\n  MODIFY_CONTENTS: 0x08,\n  COPY: 0x10,\n  MODIFY_ANNOTATIONS: 0x20,\n  FILL_INTERACTIVE_FORMS: 0x100,\n  COPY_FOR_ACCESSIBILITY: 0x200,\n  ASSEMBLE: 0x400,\n  PRINT_HIGH_QUALITY: 0x800\n};\nexports.PermissionFlag = PermissionFlag;\nconst TextRenderingMode = {\n  FILL: 0,\n  STROKE: 1,\n  FILL_STROKE: 2,\n  INVISIBLE: 3,\n  FILL_ADD_TO_PATH: 4,\n  STROKE_ADD_TO_PATH: 5,\n  FILL_STROKE_ADD_TO_PATH: 6,\n  ADD_TO_PATH: 7,\n  FILL_STROKE_MASK: 3,\n  ADD_TO_PATH_FLAG: 4\n};\nexports.TextRenderingMode = TextRenderingMode;\nconst ImageKind = {\n  GRAYSCALE_1BPP: 1,\n  RGB_24BPP: 2,\n  RGBA_32BPP: 3\n};\nexports.ImageKind = ImageKind;\nconst AnnotationType = {\n  TEXT: 1,\n  LINK: 2,\n  FREETEXT: 3,\n  LINE: 4,\n  SQUARE: 5,\n  CIRCLE: 6,\n  POLYGON: 7,\n  POLYLINE: 8,\n  HIGHLIGHT: 9,\n  UNDERLINE: 10,\n  SQUIGGLY: 11,\n  STRIKEOUT: 12,\n  STAMP: 13,\n  CARET: 14,\n  INK: 15,\n  POPUP: 16,\n  FILEATTACHMENT: 17,\n  SOUND: 18,\n  MOVIE: 19,\n  WIDGET: 20,\n  SCREEN: 21,\n  PRINTERMARK: 22,\n  TRAPNET: 23,\n  WATERMARK: 24,\n  THREED: 25,\n  REDACT: 26\n};\nexports.AnnotationType = AnnotationType;\nconst AnnotationReplyType = {\n  GROUP: \"Group\",\n  REPLY: \"R\"\n};\nexports.AnnotationReplyType = AnnotationReplyType;\nconst AnnotationFlag = {\n  INVISIBLE: 0x01,\n  HIDDEN: 0x02,\n  PRINT: 0x04,\n  NOZOOM: 0x08,\n  NOROTATE: 0x10,\n  NOVIEW: 0x20,\n  READONLY: 0x40,\n  LOCKED: 0x80,\n  TOGGLENOVIEW: 0x100,\n  LOCKEDCONTENTS: 0x200\n};\nexports.AnnotationFlag = AnnotationFlag;\nconst AnnotationFieldFlag = {\n  READONLY: 0x0000001,\n  REQUIRED: 0x0000002,\n  NOEXPORT: 0x0000004,\n  MULTILINE: 0x0001000,\n  PASSWORD: 0x0002000,\n  NOTOGGLETOOFF: 0x0004000,\n  RADIO: 0x0008000,\n  PUSHBUTTON: 0x0010000,\n  COMBO: 0x0020000,\n  EDIT: 0x0040000,\n  SORT: 0x0080000,\n  FILESELECT: 0x0100000,\n  MULTISELECT: 0x0200000,\n  DONOTSPELLCHECK: 0x0400000,\n  DONOTSCROLL: 0x0800000,\n  COMB: 0x1000000,\n  RICHTEXT: 0x2000000,\n  RADIOSINUNISON: 0x2000000,\n  COMMITONSELCHANGE: 0x4000000\n};\nexports.AnnotationFieldFlag = AnnotationFieldFlag;\nconst AnnotationBorderStyleType = {\n  SOLID: 1,\n  DASHED: 2,\n  BEVELED: 3,\n  INSET: 4,\n  UNDERLINE: 5\n};\nexports.AnnotationBorderStyleType = AnnotationBorderStyleType;\nconst AnnotationActionEventType = {\n  E: \"Mouse Enter\",\n  X: \"Mouse Exit\",\n  D: \"Mouse Down\",\n  U: \"Mouse Up\",\n  Fo: \"Focus\",\n  Bl: \"Blur\",\n  PO: \"PageOpen\",\n  PC: \"PageClose\",\n  PV: \"PageVisible\",\n  PI: \"PageInvisible\",\n  K: \"Keystroke\",\n  F: \"Format\",\n  V: \"Validate\",\n  C: \"Calculate\"\n};\nexports.AnnotationActionEventType = AnnotationActionEventType;\nconst DocumentActionEventType = {\n  WC: \"WillClose\",\n  WS: \"WillSave\",\n  DS: \"DidSave\",\n  WP: \"WillPrint\",\n  DP: \"DidPrint\"\n};\nexports.DocumentActionEventType = DocumentActionEventType;\nconst PageActionEventType = {\n  O: \"PageOpen\",\n  C: \"PageClose\"\n};\nexports.PageActionEventType = PageActionEventType;\nconst VerbosityLevel = {\n  ERRORS: 0,\n  WARNINGS: 1,\n  INFOS: 5\n};\nexports.VerbosityLevel = VerbosityLevel;\nconst CMapCompressionType = {\n  NONE: 0,\n  BINARY: 1\n};\nexports.CMapCompressionType = CMapCompressionType;\nconst OPS = {\n  dependency: 1,\n  setLineWidth: 2,\n  setLineCap: 3,\n  setLineJoin: 4,\n  setMiterLimit: 5,\n  setDash: 6,\n  setRenderingIntent: 7,\n  setFlatness: 8,\n  setGState: 9,\n  save: 10,\n  restore: 11,\n  transform: 12,\n  moveTo: 13,\n  lineTo: 14,\n  curveTo: 15,\n  curveTo2: 16,\n  curveTo3: 17,\n  closePath: 18,\n  rectangle: 19,\n  stroke: 20,\n  closeStroke: 21,\n  fill: 22,\n  eoFill: 23,\n  fillStroke: 24,\n  eoFillStroke: 25,\n  closeFillStroke: 26,\n  closeEOFillStroke: 27,\n  endPath: 28,\n  clip: 29,\n  eoClip: 30,\n  beginText: 31,\n  endText: 32,\n  setCharSpacing: 33,\n  setWordSpacing: 34,\n  setHScale: 35,\n  setLeading: 36,\n  setFont: 37,\n  setTextRenderingMode: 38,\n  setTextRise: 39,\n  moveText: 40,\n  setLeadingMoveText: 41,\n  setTextMatrix: 42,\n  nextLine: 43,\n  showText: 44,\n  showSpacedText: 45,\n  nextLineShowText: 46,\n  nextLineSetSpacingShowText: 47,\n  setCharWidth: 48,\n  setCharWidthAndBounds: 49,\n  setStrokeColorSpace: 50,\n  setFillColorSpace: 51,\n  setStrokeColor: 52,\n  setStrokeColorN: 53,\n  setFillColor: 54,\n  setFillColorN: 55,\n  setStrokeGray: 56,\n  setFillGray: 57,\n  setStrokeRGBColor: 58,\n  setFillRGBColor: 59,\n  setStrokeCMYKColor: 60,\n  setFillCMYKColor: 61,\n  shadingFill: 62,\n  beginInlineImage: 63,\n  beginImageData: 64,\n  endInlineImage: 65,\n  paintXObject: 66,\n  markPoint: 67,\n  markPointProps: 68,\n  beginMarkedContent: 69,\n  beginMarkedContentProps: 70,\n  endMarkedContent: 71,\n  beginCompat: 72,\n  endCompat: 73,\n  paintFormXObjectBegin: 74,\n  paintFormXObjectEnd: 75,\n  beginGroup: 76,\n  endGroup: 77,\n  beginAnnotation: 80,\n  endAnnotation: 81,\n  paintImageMaskXObject: 83,\n  paintImageMaskXObjectGroup: 84,\n  paintImageXObject: 85,\n  paintInlineImageXObject: 86,\n  paintInlineImageXObjectGroup: 87,\n  paintImageXObjectRepeat: 88,\n  paintImageMaskXObjectRepeat: 89,\n  paintSolidColorImageMask: 90,\n  constructPath: 91\n};\nexports.OPS = OPS;\nconst PasswordResponses = {\n  NEED_PASSWORD: 1,\n  INCORRECT_PASSWORD: 2\n};\nexports.PasswordResponses = PasswordResponses;\nlet verbosity = VerbosityLevel.WARNINGS;\nfunction setVerbosityLevel(level) {\n  if (Number.isInteger(level)) {\n    verbosity = level;\n  }\n}\nfunction getVerbosityLevel() {\n  return verbosity;\n}\nfunction info(msg) {\n  if (verbosity >= VerbosityLevel.INFOS) {\n    console.log(`Info: ${msg}`);\n  }\n}\nfunction warn(msg) {\n  if (verbosity >= VerbosityLevel.WARNINGS) {\n    console.log(`Warning: ${msg}`);\n  }\n}\nfunction unreachable(msg) {\n  throw new Error(msg);\n}\nfunction assert(cond, msg) {\n  if (!cond) {\n    unreachable(msg);\n  }\n}\nfunction _isValidProtocol(url) {\n  switch (url?.protocol) {\n    case \"http:\":\n    case \"https:\":\n    case \"ftp:\":\n    case \"mailto:\":\n    case \"tel:\":\n      return true;\n    default:\n      return false;\n  }\n}\nfunction createValidAbsoluteUrl(url) {\n  let baseUrl = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n  let options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n  if (!url) {\n    return null;\n  }\n  try {\n    if (options && typeof url === \"string\") {\n      if (options.addDefaultProtocol && url.startsWith(\"www.\")) {\n        const dots = url.match(/\\./g);\n        if (dots?.length >= 2) {\n          url = `http://${url}`;\n        }\n      }\n      if (options.tryConvertEncoding) {\n        try {\n          url = stringToUTF8String(url);\n        } catch {}\n      }\n    }\n    const absoluteUrl = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    if (_isValidProtocol(absoluteUrl)) {\n      return absoluteUrl;\n    }\n  } catch {}\n  return null;\n}\nfunction shadow(obj, prop, value) {\n  let nonSerializable = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n  Object.defineProperty(obj, prop, {\n    value,\n    enumerable: !nonSerializable,\n    configurable: true,\n    writable: false\n  });\n  return value;\n}\nconst BaseException = function BaseExceptionClosure() {\n  function BaseException(message, name) {\n    if (this.constructor === BaseException) {\n      unreachable(\"Cannot initialize BaseException.\");\n    }\n    this.message = message;\n    this.name = name;\n  }\n  BaseException.prototype = new Error();\n  BaseException.constructor = BaseException;\n  return BaseException;\n}();\nexports.BaseException = BaseException;\nclass PasswordException extends BaseException {\n  constructor(msg, code) {\n    super(msg, \"PasswordException\");\n    this.code = code;\n  }\n}\nexports.PasswordException = PasswordException;\nclass UnknownErrorException extends BaseException {\n  constructor(msg, details) {\n    super(msg, \"UnknownErrorException\");\n    this.details = details;\n  }\n}\nexports.UnknownErrorException = UnknownErrorException;\nclass InvalidPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"InvalidPDFException\");\n  }\n}\nexports.InvalidPDFException = InvalidPDFException;\nclass MissingPDFException extends BaseException {\n  constructor(msg) {\n    super(msg, \"MissingPDFException\");\n  }\n}\nexports.MissingPDFException = MissingPDFException;\nclass UnexpectedResponseException extends BaseException {\n  constructor(msg, status) {\n    super(msg, \"UnexpectedResponseException\");\n    this.status = status;\n  }\n}\nexports.UnexpectedResponseException = UnexpectedResponseException;\nclass FormatError extends BaseException {\n  constructor(msg) {\n    super(msg, \"FormatError\");\n  }\n}\nexports.FormatError = FormatError;\nclass AbortException extends BaseException {\n  constructor(msg) {\n    super(msg, \"AbortException\");\n  }\n}\nexports.AbortException = AbortException;\nfunction bytesToString(bytes) {\n  if (typeof bytes !== \"object\" || bytes?.length === undefined) {\n    unreachable(\"Invalid argument for bytesToString\");\n  }\n  const length = bytes.length;\n  const MAX_ARGUMENT_COUNT = 8192;\n  if (length < MAX_ARGUMENT_COUNT) {\n    return String.fromCharCode.apply(null, bytes);\n  }\n  const strBuf = [];\n  for (let i = 0; i < length; i += MAX_ARGUMENT_COUNT) {\n    const chunkEnd = Math.min(i + MAX_ARGUMENT_COUNT, length);\n    const chunk = bytes.subarray(i, chunkEnd);\n    strBuf.push(String.fromCharCode.apply(null, chunk));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToBytes(str) {\n  if (typeof str !== \"string\") {\n    unreachable(\"Invalid argument for stringToBytes\");\n  }\n  const length = str.length;\n  const bytes = new Uint8Array(length);\n  for (let i = 0; i < length; ++i) {\n    bytes[i] = str.charCodeAt(i) & 0xff;\n  }\n  return bytes;\n}\nfunction string32(value) {\n  return String.fromCharCode(value >> 24 & 0xff, value >> 16 & 0xff, value >> 8 & 0xff, value & 0xff);\n}\nfunction objectSize(obj) {\n  return Object.keys(obj).length;\n}\nfunction objectFromMap(map) {\n  const obj = Object.create(null);\n  for (const [key, value] of map) {\n    obj[key] = value;\n  }\n  return obj;\n}\nfunction isLittleEndian() {\n  const buffer8 = new Uint8Array(4);\n  buffer8[0] = 1;\n  const view32 = new Uint32Array(buffer8.buffer, 0, 1);\n  return view32[0] === 1;\n}\nfunction isEvalSupported() {\n  try {\n    new Function(\"\");\n    return true;\n  } catch {\n    return false;\n  }\n}\nclass FeatureTest {\n  static get isLittleEndian() {\n    return shadow(this, \"isLittleEndian\", isLittleEndian());\n  }\n  static get isEvalSupported() {\n    return shadow(this, \"isEvalSupported\", isEvalSupported());\n  }\n  static get isOffscreenCanvasSupported() {\n    return shadow(this, \"isOffscreenCanvasSupported\", typeof OffscreenCanvas !== \"undefined\");\n  }\n  static get platform() {\n    if (typeof navigator === \"undefined\") {\n      return shadow(this, \"platform\", {\n        isWin: false,\n        isMac: false\n      });\n    }\n    return shadow(this, \"platform\", {\n      isWin: navigator.platform.includes(\"Win\"),\n      isMac: navigator.platform.includes(\"Mac\")\n    });\n  }\n  static get isCSSRoundSupported() {\n    return shadow(this, \"isCSSRoundSupported\", globalThis.CSS?.supports?.(\"width: round(1.5px, 1px)\"));\n  }\n}\nexports.FeatureTest = FeatureTest;\nconst hexNumbers = [...Array(256).keys()].map(n => n.toString(16).padStart(2, \"0\"));\nclass Util {\n  static makeHexColor(r, g, b) {\n    return `#${hexNumbers[r]}${hexNumbers[g]}${hexNumbers[b]}`;\n  }\n  static scaleMinMax(transform, minMax) {\n    let temp;\n    if (transform[0]) {\n      if (transform[0] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[1];\n        minMax[1] = temp;\n      }\n      minMax[0] *= transform[0];\n      minMax[1] *= transform[0];\n      if (transform[3] < 0) {\n        temp = minMax[2];\n        minMax[2] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[2] *= transform[3];\n      minMax[3] *= transform[3];\n    } else {\n      temp = minMax[0];\n      minMax[0] = minMax[2];\n      minMax[2] = temp;\n      temp = minMax[1];\n      minMax[1] = minMax[3];\n      minMax[3] = temp;\n      if (transform[1] < 0) {\n        temp = minMax[2];\n        minMax[2] = minMax[3];\n        minMax[3] = temp;\n      }\n      minMax[2] *= transform[1];\n      minMax[3] *= transform[1];\n      if (transform[2] < 0) {\n        temp = minMax[0];\n        minMax[0] = minMax[1];\n        minMax[1] = temp;\n      }\n      minMax[0] *= transform[2];\n      minMax[1] *= transform[2];\n    }\n    minMax[0] += transform[4];\n    minMax[1] += transform[4];\n    minMax[2] += transform[5];\n    minMax[3] += transform[5];\n  }\n  static transform(m1, m2) {\n    return [m1[0] * m2[0] + m1[2] * m2[1], m1[1] * m2[0] + m1[3] * m2[1], m1[0] * m2[2] + m1[2] * m2[3], m1[1] * m2[2] + m1[3] * m2[3], m1[0] * m2[4] + m1[2] * m2[5] + m1[4], m1[1] * m2[4] + m1[3] * m2[5] + m1[5]];\n  }\n  static applyTransform(p, m) {\n    const xt = p[0] * m[0] + p[1] * m[2] + m[4];\n    const yt = p[0] * m[1] + p[1] * m[3] + m[5];\n    return [xt, yt];\n  }\n  static applyInverseTransform(p, m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    const xt = (p[0] * m[3] - p[1] * m[2] + m[2] * m[5] - m[4] * m[3]) / d;\n    const yt = (-p[0] * m[1] + p[1] * m[0] + m[4] * m[1] - m[5] * m[0]) / d;\n    return [xt, yt];\n  }\n  static getAxialAlignedBoundingBox(r, m) {\n    const p1 = this.applyTransform(r, m);\n    const p2 = this.applyTransform(r.slice(2, 4), m);\n    const p3 = this.applyTransform([r[0], r[3]], m);\n    const p4 = this.applyTransform([r[2], r[1]], m);\n    return [Math.min(p1[0], p2[0], p3[0], p4[0]), Math.min(p1[1], p2[1], p3[1], p4[1]), Math.max(p1[0], p2[0], p3[0], p4[0]), Math.max(p1[1], p2[1], p3[1], p4[1])];\n  }\n  static inverseTransform(m) {\n    const d = m[0] * m[3] - m[1] * m[2];\n    return [m[3] / d, -m[1] / d, -m[2] / d, m[0] / d, (m[2] * m[5] - m[4] * m[3]) / d, (m[4] * m[1] - m[5] * m[0]) / d];\n  }\n  static singularValueDecompose2dScale(m) {\n    const transpose = [m[0], m[2], m[1], m[3]];\n    const a = m[0] * transpose[0] + m[1] * transpose[2];\n    const b = m[0] * transpose[1] + m[1] * transpose[3];\n    const c = m[2] * transpose[0] + m[3] * transpose[2];\n    const d = m[2] * transpose[1] + m[3] * transpose[3];\n    const first = (a + d) / 2;\n    const second = Math.sqrt((a + d) ** 2 - 4 * (a * d - c * b)) / 2;\n    const sx = first + second || 1;\n    const sy = first - second || 1;\n    return [Math.sqrt(sx), Math.sqrt(sy)];\n  }\n  static normalizeRect(rect) {\n    const r = rect.slice(0);\n    if (rect[0] > rect[2]) {\n      r[0] = rect[2];\n      r[2] = rect[0];\n    }\n    if (rect[1] > rect[3]) {\n      r[1] = rect[3];\n      r[3] = rect[1];\n    }\n    return r;\n  }\n  static intersect(rect1, rect2) {\n    const xLow = Math.max(Math.min(rect1[0], rect1[2]), Math.min(rect2[0], rect2[2]));\n    const xHigh = Math.min(Math.max(rect1[0], rect1[2]), Math.max(rect2[0], rect2[2]));\n    if (xLow > xHigh) {\n      return null;\n    }\n    const yLow = Math.max(Math.min(rect1[1], rect1[3]), Math.min(rect2[1], rect2[3]));\n    const yHigh = Math.min(Math.max(rect1[1], rect1[3]), Math.max(rect2[1], rect2[3]));\n    if (yLow > yHigh) {\n      return null;\n    }\n    return [xLow, yLow, xHigh, yHigh];\n  }\n  static bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3) {\n    const tvalues = [],\n      bounds = [[], []];\n    let a, b, c, t, t1, t2, b2ac, sqrtb2ac;\n    for (let i = 0; i < 2; ++i) {\n      if (i === 0) {\n        b = 6 * x0 - 12 * x1 + 6 * x2;\n        a = -3 * x0 + 9 * x1 - 9 * x2 + 3 * x3;\n        c = 3 * x1 - 3 * x0;\n      } else {\n        b = 6 * y0 - 12 * y1 + 6 * y2;\n        a = -3 * y0 + 9 * y1 - 9 * y2 + 3 * y3;\n        c = 3 * y1 - 3 * y0;\n      }\n      if (Math.abs(a) < 1e-12) {\n        if (Math.abs(b) < 1e-12) {\n          continue;\n        }\n        t = -c / b;\n        if (0 < t && t < 1) {\n          tvalues.push(t);\n        }\n        continue;\n      }\n      b2ac = b * b - 4 * c * a;\n      sqrtb2ac = Math.sqrt(b2ac);\n      if (b2ac < 0) {\n        continue;\n      }\n      t1 = (-b + sqrtb2ac) / (2 * a);\n      if (0 < t1 && t1 < 1) {\n        tvalues.push(t1);\n      }\n      t2 = (-b - sqrtb2ac) / (2 * a);\n      if (0 < t2 && t2 < 1) {\n        tvalues.push(t2);\n      }\n    }\n    let j = tvalues.length,\n      mt;\n    const jlen = j;\n    while (j--) {\n      t = tvalues[j];\n      mt = 1 - t;\n      bounds[0][j] = mt * mt * mt * x0 + 3 * mt * mt * t * x1 + 3 * mt * t * t * x2 + t * t * t * x3;\n      bounds[1][j] = mt * mt * mt * y0 + 3 * mt * mt * t * y1 + 3 * mt * t * t * y2 + t * t * t * y3;\n    }\n    bounds[0][jlen] = x0;\n    bounds[1][jlen] = y0;\n    bounds[0][jlen + 1] = x3;\n    bounds[1][jlen + 1] = y3;\n    bounds[0].length = bounds[1].length = jlen + 2;\n    return [Math.min(...bounds[0]), Math.min(...bounds[1]), Math.max(...bounds[0]), Math.max(...bounds[1])];\n  }\n}\nexports.Util = Util;\nconst PDFStringTranslateTable = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2d8, 0x2c7, 0x2c6, 0x2d9, 0x2dd, 0x2db, 0x2da, 0x2dc, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0x2022, 0x2020, 0x2021, 0x2026, 0x2014, 0x2013, 0x192, 0x2044, 0x2039, 0x203a, 0x2212, 0x2030, 0x201e, 0x201c, 0x201d, 0x2018, 0x2019, 0x201a, 0x2122, 0xfb01, 0xfb02, 0x141, 0x152, 0x160, 0x178, 0x17d, 0x131, 0x142, 0x153, 0x161, 0x17e, 0, 0x20ac];\nfunction stringToPDFString(str) {\n  if (str[0] >= \"\\xEF\") {\n    let encoding;\n    if (str[0] === \"\\xFE\" && str[1] === \"\\xFF\") {\n      encoding = \"utf-16be\";\n    } else if (str[0] === \"\\xFF\" && str[1] === \"\\xFE\") {\n      encoding = \"utf-16le\";\n    } else if (str[0] === \"\\xEF\" && str[1] === \"\\xBB\" && str[2] === \"\\xBF\") {\n      encoding = \"utf-8\";\n    }\n    if (encoding) {\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = stringToBytes(str);\n        return decoder.decode(buffer);\n      } catch (ex) {\n        warn(`stringToPDFString: \"${ex}\".`);\n      }\n    }\n  }\n  const strBuf = [];\n  for (let i = 0, ii = str.length; i < ii; i++) {\n    const code = PDFStringTranslateTable[str.charCodeAt(i)];\n    strBuf.push(code ? String.fromCharCode(code) : str.charAt(i));\n  }\n  return strBuf.join(\"\");\n}\nfunction stringToUTF8String(str) {\n  return decodeURIComponent(escape(str));\n}\nfunction utf8StringToString(str) {\n  return unescape(encodeURIComponent(str));\n}\nfunction isArrayBuffer(v) {\n  return typeof v === \"object\" && v?.byteLength !== undefined;\n}\nfunction isArrayEqual(arr1, arr2) {\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n  for (let i = 0, ii = arr1.length; i < ii; i++) {\n    if (arr1[i] !== arr2[i]) {\n      return false;\n    }\n  }\n  return true;\n}\nfunction getModificationDate() {\n  let date = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : new Date();\n  const buffer = [date.getUTCFullYear().toString(), (date.getUTCMonth() + 1).toString().padStart(2, \"0\"), date.getUTCDate().toString().padStart(2, \"0\"), date.getUTCHours().toString().padStart(2, \"0\"), date.getUTCMinutes().toString().padStart(2, \"0\"), date.getUTCSeconds().toString().padStart(2, \"0\")];\n  return buffer.join(\"\");\n}\nclass PromiseCapability {\n  #settled = false;\n  constructor() {\n    this.promise = new Promise((resolve, reject) => {\n      this.resolve = data => {\n        this.#settled = true;\n        resolve(data);\n      };\n      this.reject = reason => {\n        this.#settled = true;\n        reject(reason);\n      };\n    });\n  }\n  get settled() {\n    return this.#settled;\n  }\n}\nexports.PromiseCapability = PromiseCapability;\nlet NormalizeRegex = null;\nlet NormalizationMap = null;\nfunction normalizeUnicode(str) {\n  if (!NormalizeRegex) {\n    NormalizeRegex = /([\\u00a0\\u00b5\\u037e\\u0eb3\\u2000-\\u200a\\u202f\\u2126\\ufb00-\\ufb04\\ufb06\\ufb20-\\ufb36\\ufb38-\\ufb3c\\ufb3e\\ufb40-\\ufb41\\ufb43-\\ufb44\\ufb46-\\ufba1\\ufba4-\\ufba9\\ufbae-\\ufbb1\\ufbd3-\\ufbdc\\ufbde-\\ufbe7\\ufbea-\\ufbf8\\ufbfc-\\ufbfd\\ufc00-\\ufc5d\\ufc64-\\ufcf1\\ufcf5-\\ufd3d\\ufd88\\ufdf4\\ufdfa-\\ufdfb\\ufe71\\ufe77\\ufe79\\ufe7b\\ufe7d]+)|(\\ufb05+)/gu;\n    NormalizationMap = new Map([[\"ﬅ\", \"ſt\"]]);\n  }\n  return str.replaceAll(NormalizeRegex, (_, p1, p2) => {\n    return p1 ? p1.normalize(\"NFKC\") : NormalizationMap.get(p2);\n  });\n}\nfunction getUuid() {\n  if (typeof crypto !== \"undefined\" && typeof crypto?.randomUUID === \"function\") {\n    return crypto.randomUUID();\n  }\n  const buf = new Uint8Array(32);\n  if (typeof crypto !== \"undefined\" && typeof crypto?.getRandomValues === \"function\") {\n    crypto.getRandomValues(buf);\n  } else {\n    for (let i = 0; i < 32; i++) {\n      buf[i] = Math.floor(Math.random() * 255);\n    }\n  }\n  return bytesToString(buf);\n}\nconst AnnotationPrefix = \"pdfjs_internal_id_\";\nexports.AnnotationPrefix = AnnotationPrefix;\n\n/***/ }),\n/* 2 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar global = __w_pdfjs_require__(4);\nvar apply = __w_pdfjs_require__(69);\nvar wrapErrorConstructorWithCause = __w_pdfjs_require__(70);\nvar WEB_ASSEMBLY = 'WebAssembly';\nvar WebAssembly = global[WEB_ASSEMBLY];\nvar FORCED = Error('e', { cause: 7 }).cause !== 7;\nvar exportGlobalErrorCauseWrapper = function (ERROR_NAME, wrapper) {\n var O = {};\n O[ERROR_NAME] = wrapErrorConstructorWithCause(ERROR_NAME, wrapper, FORCED);\n $({\n  global: true,\n  constructor: true,\n  arity: 1,\n  forced: FORCED\n }, O);\n};\nvar exportWebAssemblyErrorCauseWrapper = function (ERROR_NAME, wrapper) {\n if (WebAssembly && WebAssembly[ERROR_NAME]) {\n  var O = {};\n  O[ERROR_NAME] = wrapErrorConstructorWithCause(WEB_ASSEMBLY + '.' + ERROR_NAME, wrapper, FORCED);\n  $({\n   target: WEB_ASSEMBLY,\n   stat: true,\n   constructor: true,\n   arity: 1,\n   forced: FORCED\n  }, O);\n }\n};\nexportGlobalErrorCauseWrapper('Error', function (init) {\n return function Error(message) {\n  return apply(init, this, arguments);\n };\n});\nexportGlobalErrorCauseWrapper('EvalError', function (init) {\n return function EvalError(message) {\n  return apply(init, this, arguments);\n };\n});\nexportGlobalErrorCauseWrapper('RangeError', function (init) {\n return function RangeError(message) {\n  return apply(init, this, arguments);\n };\n});\nexportGlobalErrorCauseWrapper('ReferenceError', function (init) {\n return function ReferenceError(message) {\n  return apply(init, this, arguments);\n };\n});\nexportGlobalErrorCauseWrapper('SyntaxError', function (init) {\n return function SyntaxError(message) {\n  return apply(init, this, arguments);\n };\n});\nexportGlobalErrorCauseWrapper('TypeError', function (init) {\n return function TypeError(message) {\n  return apply(init, this, arguments);\n };\n});\nexportGlobalErrorCauseWrapper('URIError', function (init) {\n return function URIError(message) {\n  return apply(init, this, arguments);\n };\n});\nexportWebAssemblyErrorCauseWrapper('CompileError', function (init) {\n return function CompileError(message) {\n  return apply(init, this, arguments);\n };\n});\nexportWebAssemblyErrorCauseWrapper('LinkError', function (init) {\n return function LinkError(message) {\n  return apply(init, this, arguments);\n };\n});\nexportWebAssemblyErrorCauseWrapper('RuntimeError', function (init) {\n return function RuntimeError(message) {\n  return apply(init, this, arguments);\n };\n});\n\n/***/ }),\n/* 3 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar getOwnPropertyDescriptor = (__w_pdfjs_require__(5).f);\nvar createNonEnumerableProperty = __w_pdfjs_require__(44);\nvar defineBuiltIn = __w_pdfjs_require__(48);\nvar defineGlobalProperty = __w_pdfjs_require__(38);\nvar copyConstructorProperties = __w_pdfjs_require__(56);\nvar isForced = __w_pdfjs_require__(68);\nmodule.exports = function (options, source) {\n var TARGET = options.target;\n var GLOBAL = options.global;\n var STATIC = options.stat;\n var FORCED, target, key, targetProperty, sourceProperty, descriptor;\n if (GLOBAL) {\n  target = global;\n } else if (STATIC) {\n  target = global[TARGET] || defineGlobalProperty(TARGET, {});\n } else {\n  target = (global[TARGET] || {}).prototype;\n }\n if (target)\n  for (key in source) {\n   sourceProperty = source[key];\n   if (options.dontCallGetSet) {\n    descriptor = getOwnPropertyDescriptor(target, key);\n    targetProperty = descriptor && descriptor.value;\n   } else\n    targetProperty = target[key];\n   FORCED = isForced(GLOBAL ? key : TARGET + (STATIC ? '.' : '#') + key, options.forced);\n   if (!FORCED && targetProperty !== undefined) {\n    if (typeof sourceProperty == typeof targetProperty)\n     continue;\n    copyConstructorProperties(sourceProperty, targetProperty);\n   }\n   if (options.sham || targetProperty && targetProperty.sham) {\n    createNonEnumerableProperty(sourceProperty, 'sham', true);\n   }\n   defineBuiltIn(target, key, sourceProperty, options);\n  }\n};\n\n/***/ }),\n/* 4 */\n/***/ (function(module) {\n\n\nvar check = function (it) {\n return it && it.Math === Math && it;\n};\nmodule.exports = check(typeof globalThis == 'object' && globalThis) || check(typeof window == 'object' && window) || check(typeof self == 'object' && self) || check(typeof global == 'object' && global) || (function () {\n return this;\n}()) || this || Function('return this')();\n\n/***/ }),\n/* 5 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar call = __w_pdfjs_require__(8);\nvar propertyIsEnumerableModule = __w_pdfjs_require__(10);\nvar createPropertyDescriptor = __w_pdfjs_require__(11);\nvar toIndexedObject = __w_pdfjs_require__(12);\nvar toPropertyKey = __w_pdfjs_require__(18);\nvar hasOwn = __w_pdfjs_require__(39);\nvar IE8_DOM_DEFINE = __w_pdfjs_require__(42);\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nexports.f = DESCRIPTORS ? $getOwnPropertyDescriptor : function getOwnPropertyDescriptor(O, P) {\n O = toIndexedObject(O);\n P = toPropertyKey(P);\n if (IE8_DOM_DEFINE)\n  try {\n   return $getOwnPropertyDescriptor(O, P);\n  } catch (error) {\n  }\n if (hasOwn(O, P))\n  return createPropertyDescriptor(!call(propertyIsEnumerableModule.f, O, P), O[P]);\n};\n\n/***/ }),\n/* 6 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar fails = __w_pdfjs_require__(7);\nmodule.exports = !fails(function () {\n return Object.defineProperty({}, 1, {\n  get: function () {\n   return 7;\n  }\n })[1] !== 7;\n});\n\n/***/ }),\n/* 7 */\n/***/ ((module) => {\n\n\nmodule.exports = function (exec) {\n try {\n  return !!exec();\n } catch (error) {\n  return true;\n }\n};\n\n/***/ }),\n/* 8 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar NATIVE_BIND = __w_pdfjs_require__(9);\nvar call = Function.prototype.call;\nmodule.exports = NATIVE_BIND ? call.bind(call) : function () {\n return call.apply(call, arguments);\n};\n\n/***/ }),\n/* 9 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar fails = __w_pdfjs_require__(7);\nmodule.exports = !fails(function () {\n var test = function () {\n }.bind();\n return typeof test != 'function' || test.hasOwnProperty('prototype');\n});\n\n/***/ }),\n/* 10 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\nvar $propertyIsEnumerable = {}.propertyIsEnumerable;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar NASHORN_BUG = getOwnPropertyDescriptor && !$propertyIsEnumerable.call({ 1: 2 }, 1);\nexports.f = NASHORN_BUG ? function propertyIsEnumerable(V) {\n var descriptor = getOwnPropertyDescriptor(this, V);\n return !!descriptor && descriptor.enumerable;\n} : $propertyIsEnumerable;\n\n/***/ }),\n/* 11 */\n/***/ ((module) => {\n\n\nmodule.exports = function (bitmap, value) {\n return {\n  enumerable: !(bitmap & 1),\n  configurable: !(bitmap & 2),\n  writable: !(bitmap & 4),\n  value: value\n };\n};\n\n/***/ }),\n/* 12 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar IndexedObject = __w_pdfjs_require__(13);\nvar requireObjectCoercible = __w_pdfjs_require__(16);\nmodule.exports = function (it) {\n return IndexedObject(requireObjectCoercible(it));\n};\n\n/***/ }),\n/* 13 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar fails = __w_pdfjs_require__(7);\nvar classof = __w_pdfjs_require__(15);\nvar $Object = Object;\nvar split = uncurryThis(''.split);\nmodule.exports = fails(function () {\n return !$Object('z').propertyIsEnumerable(0);\n}) ? function (it) {\n return classof(it) === 'String' ? split(it, '') : $Object(it);\n} : $Object;\n\n/***/ }),\n/* 14 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar NATIVE_BIND = __w_pdfjs_require__(9);\nvar FunctionPrototype = Function.prototype;\nvar call = FunctionPrototype.call;\nvar uncurryThisWithBind = NATIVE_BIND && FunctionPrototype.bind.bind(call, call);\nmodule.exports = NATIVE_BIND ? uncurryThisWithBind : function (fn) {\n return function () {\n  return call.apply(fn, arguments);\n };\n};\n\n/***/ }),\n/* 15 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar toString = uncurryThis({}.toString);\nvar stringSlice = uncurryThis(''.slice);\nmodule.exports = function (it) {\n return stringSlice(toString(it), 8, -1);\n};\n\n/***/ }),\n/* 16 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar isNullOrUndefined = __w_pdfjs_require__(17);\nvar $TypeError = TypeError;\nmodule.exports = function (it) {\n if (isNullOrUndefined(it))\n  throw $TypeError(\"Can't call method on \" + it);\n return it;\n};\n\n/***/ }),\n/* 17 */\n/***/ ((module) => {\n\n\nmodule.exports = function (it) {\n return it === null || it === undefined;\n};\n\n/***/ }),\n/* 18 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toPrimitive = __w_pdfjs_require__(19);\nvar isSymbol = __w_pdfjs_require__(23);\nmodule.exports = function (argument) {\n var key = toPrimitive(argument, 'string');\n return isSymbol(key) ? key : key + '';\n};\n\n/***/ }),\n/* 19 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar call = __w_pdfjs_require__(8);\nvar isObject = __w_pdfjs_require__(20);\nvar isSymbol = __w_pdfjs_require__(23);\nvar getMethod = __w_pdfjs_require__(30);\nvar ordinaryToPrimitive = __w_pdfjs_require__(33);\nvar wellKnownSymbol = __w_pdfjs_require__(34);\nvar $TypeError = TypeError;\nvar TO_PRIMITIVE = wellKnownSymbol('toPrimitive');\nmodule.exports = function (input, pref) {\n if (!isObject(input) || isSymbol(input))\n  return input;\n var exoticToPrim = getMethod(input, TO_PRIMITIVE);\n var result;\n if (exoticToPrim) {\n  if (pref === undefined)\n   pref = 'default';\n  result = call(exoticToPrim, input, pref);\n  if (!isObject(result) || isSymbol(result))\n   return result;\n  throw $TypeError(\"Can't convert object to primitive value\");\n }\n if (pref === undefined)\n  pref = 'number';\n return ordinaryToPrimitive(input, pref);\n};\n\n/***/ }),\n/* 20 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar isCallable = __w_pdfjs_require__(21);\nvar $documentAll = __w_pdfjs_require__(22);\nvar documentAll = $documentAll.all;\nmodule.exports = $documentAll.IS_HTMLDDA ? function (it) {\n return typeof it == 'object' ? it !== null : isCallable(it) || it === documentAll;\n} : function (it) {\n return typeof it == 'object' ? it !== null : isCallable(it);\n};\n\n/***/ }),\n/* 21 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $documentAll = __w_pdfjs_require__(22);\nvar documentAll = $documentAll.all;\nmodule.exports = $documentAll.IS_HTMLDDA ? function (argument) {\n return typeof argument == 'function' || argument === documentAll;\n} : function (argument) {\n return typeof argument == 'function';\n};\n\n/***/ }),\n/* 22 */\n/***/ ((module) => {\n\n\nvar documentAll = typeof document == 'object' && document.all;\nvar IS_HTMLDDA = typeof documentAll == 'undefined' && documentAll !== undefined;\nmodule.exports = {\n all: documentAll,\n IS_HTMLDDA: IS_HTMLDDA\n};\n\n/***/ }),\n/* 23 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar getBuiltIn = __w_pdfjs_require__(24);\nvar isCallable = __w_pdfjs_require__(21);\nvar isPrototypeOf = __w_pdfjs_require__(25);\nvar USE_SYMBOL_AS_UID = __w_pdfjs_require__(26);\nvar $Object = Object;\nmodule.exports = USE_SYMBOL_AS_UID ? function (it) {\n return typeof it == 'symbol';\n} : function (it) {\n var $Symbol = getBuiltIn('Symbol');\n return isCallable($Symbol) && isPrototypeOf($Symbol.prototype, $Object(it));\n};\n\n/***/ }),\n/* 24 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar isCallable = __w_pdfjs_require__(21);\nvar aFunction = function (argument) {\n return isCallable(argument) ? argument : undefined;\n};\nmodule.exports = function (namespace, method) {\n return arguments.length < 2 ? aFunction(global[namespace]) : global[namespace] && global[namespace][method];\n};\n\n/***/ }),\n/* 25 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nmodule.exports = uncurryThis({}.isPrototypeOf);\n\n/***/ }),\n/* 26 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar NATIVE_SYMBOL = __w_pdfjs_require__(27);\nmodule.exports = NATIVE_SYMBOL && !Symbol.sham && typeof Symbol.iterator == 'symbol';\n\n/***/ }),\n/* 27 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar V8_VERSION = __w_pdfjs_require__(28);\nvar fails = __w_pdfjs_require__(7);\nvar global = __w_pdfjs_require__(4);\nvar $String = global.String;\nmodule.exports = !!Object.getOwnPropertySymbols && !fails(function () {\n var symbol = Symbol('symbol detection');\n return !$String(symbol) || !(Object(symbol) instanceof Symbol) || !Symbol.sham && V8_VERSION && V8_VERSION < 41;\n});\n\n/***/ }),\n/* 28 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar userAgent = __w_pdfjs_require__(29);\nvar process = global.process;\nvar Deno = global.Deno;\nvar versions = process && process.versions || Deno && Deno.version;\nvar v8 = versions && versions.v8;\nvar match, version;\nif (v8) {\n match = v8.split('.');\n version = match[0] > 0 && match[0] < 4 ? 1 : +(match[0] + match[1]);\n}\nif (!version && userAgent) {\n match = userAgent.match(/Edge\\/(\\d+)/);\n if (!match || match[1] >= 74) {\n  match = userAgent.match(/Chrome\\/(\\d+)/);\n  if (match)\n   version = +match[1];\n }\n}\nmodule.exports = version;\n\n/***/ }),\n/* 29 */\n/***/ ((module) => {\n\n\nmodule.exports = typeof navigator != 'undefined' && String(navigator.userAgent) || '';\n\n/***/ }),\n/* 30 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar aCallable = __w_pdfjs_require__(31);\nvar isNullOrUndefined = __w_pdfjs_require__(17);\nmodule.exports = function (V, P) {\n var func = V[P];\n return isNullOrUndefined(func) ? undefined : aCallable(func);\n};\n\n/***/ }),\n/* 31 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar isCallable = __w_pdfjs_require__(21);\nvar tryToString = __w_pdfjs_require__(32);\nvar $TypeError = TypeError;\nmodule.exports = function (argument) {\n if (isCallable(argument))\n  return argument;\n throw $TypeError(tryToString(argument) + ' is not a function');\n};\n\n/***/ }),\n/* 32 */\n/***/ ((module) => {\n\n\nvar $String = String;\nmodule.exports = function (argument) {\n try {\n  return $String(argument);\n } catch (error) {\n  return 'Object';\n }\n};\n\n/***/ }),\n/* 33 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar call = __w_pdfjs_require__(8);\nvar isCallable = __w_pdfjs_require__(21);\nvar isObject = __w_pdfjs_require__(20);\nvar $TypeError = TypeError;\nmodule.exports = function (input, pref) {\n var fn, val;\n if (pref === 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))\n  return val;\n if (isCallable(fn = input.valueOf) && !isObject(val = call(fn, input)))\n  return val;\n if (pref !== 'string' && isCallable(fn = input.toString) && !isObject(val = call(fn, input)))\n  return val;\n throw $TypeError(\"Can't convert object to primitive value\");\n};\n\n/***/ }),\n/* 34 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar shared = __w_pdfjs_require__(35);\nvar hasOwn = __w_pdfjs_require__(39);\nvar uid = __w_pdfjs_require__(41);\nvar NATIVE_SYMBOL = __w_pdfjs_require__(27);\nvar USE_SYMBOL_AS_UID = __w_pdfjs_require__(26);\nvar Symbol = global.Symbol;\nvar WellKnownSymbolsStore = shared('wks');\nvar createWellKnownSymbol = USE_SYMBOL_AS_UID ? Symbol['for'] || Symbol : Symbol && Symbol.withoutSetter || uid;\nmodule.exports = function (name) {\n if (!hasOwn(WellKnownSymbolsStore, name)) {\n  WellKnownSymbolsStore[name] = NATIVE_SYMBOL && hasOwn(Symbol, name) ? Symbol[name] : createWellKnownSymbol('Symbol.' + name);\n }\n return WellKnownSymbolsStore[name];\n};\n\n/***/ }),\n/* 35 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar IS_PURE = __w_pdfjs_require__(36);\nvar store = __w_pdfjs_require__(37);\n(module.exports = function (key, value) {\n return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n version: '3.32.2',\n mode: IS_PURE ? 'pure' : 'global',\n copyright: '© 2014-2023 Denis Pushkarev (zloirock.ru)',\n license: 'https://github.com/zloirock/core-js/blob/v3.32.2/LICENSE',\n source: 'https://github.com/zloirock/core-js'\n});\n\n/***/ }),\n/* 36 */\n/***/ ((module) => {\n\n\nmodule.exports = false;\n\n/***/ }),\n/* 37 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar defineGlobalProperty = __w_pdfjs_require__(38);\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || defineGlobalProperty(SHARED, {});\nmodule.exports = store;\n\n/***/ }),\n/* 38 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar defineProperty = Object.defineProperty;\nmodule.exports = function (key, value) {\n try {\n  defineProperty(global, key, {\n   value: value,\n   configurable: true,\n   writable: true\n  });\n } catch (error) {\n  global[key] = value;\n }\n return value;\n};\n\n/***/ }),\n/* 39 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar toObject = __w_pdfjs_require__(40);\nvar hasOwnProperty = uncurryThis({}.hasOwnProperty);\nmodule.exports = Object.hasOwn || function hasOwn(it, key) {\n return hasOwnProperty(toObject(it), key);\n};\n\n/***/ }),\n/* 40 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar requireObjectCoercible = __w_pdfjs_require__(16);\nvar $Object = Object;\nmodule.exports = function (argument) {\n return $Object(requireObjectCoercible(argument));\n};\n\n/***/ }),\n/* 41 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar id = 0;\nvar postfix = Math.random();\nvar toString = uncurryThis(1.0.toString);\nmodule.exports = function (key) {\n return 'Symbol(' + (key === undefined ? '' : key) + ')_' + toString(++id + postfix, 36);\n};\n\n/***/ }),\n/* 42 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar fails = __w_pdfjs_require__(7);\nvar createElement = __w_pdfjs_require__(43);\nmodule.exports = !DESCRIPTORS && !fails(function () {\n return Object.defineProperty(createElement('div'), 'a', {\n  get: function () {\n   return 7;\n  }\n }).a !== 7;\n});\n\n/***/ }),\n/* 43 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar isObject = __w_pdfjs_require__(20);\nvar document = global.document;\nvar EXISTS = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n return EXISTS ? document.createElement(it) : {};\n};\n\n/***/ }),\n/* 44 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar definePropertyModule = __w_pdfjs_require__(45);\nvar createPropertyDescriptor = __w_pdfjs_require__(11);\nmodule.exports = DESCRIPTORS ? function (object, key, value) {\n return definePropertyModule.f(object, key, createPropertyDescriptor(1, value));\n} : function (object, key, value) {\n object[key] = value;\n return object;\n};\n\n/***/ }),\n/* 45 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar IE8_DOM_DEFINE = __w_pdfjs_require__(42);\nvar V8_PROTOTYPE_DEFINE_BUG = __w_pdfjs_require__(46);\nvar anObject = __w_pdfjs_require__(47);\nvar toPropertyKey = __w_pdfjs_require__(18);\nvar $TypeError = TypeError;\nvar $defineProperty = Object.defineProperty;\nvar $getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar ENUMERABLE = 'enumerable';\nvar CONFIGURABLE = 'configurable';\nvar WRITABLE = 'writable';\nexports.f = DESCRIPTORS ? V8_PROTOTYPE_DEFINE_BUG ? function defineProperty(O, P, Attributes) {\n anObject(O);\n P = toPropertyKey(P);\n anObject(Attributes);\n if (typeof O === 'function' && P === 'prototype' && 'value' in Attributes && WRITABLE in Attributes && !Attributes[WRITABLE]) {\n  var current = $getOwnPropertyDescriptor(O, P);\n  if (current && current[WRITABLE]) {\n   O[P] = Attributes.value;\n   Attributes = {\n    configurable: CONFIGURABLE in Attributes ? Attributes[CONFIGURABLE] : current[CONFIGURABLE],\n    enumerable: ENUMERABLE in Attributes ? Attributes[ENUMERABLE] : current[ENUMERABLE],\n    writable: false\n   };\n  }\n }\n return $defineProperty(O, P, Attributes);\n} : $defineProperty : function defineProperty(O, P, Attributes) {\n anObject(O);\n P = toPropertyKey(P);\n anObject(Attributes);\n if (IE8_DOM_DEFINE)\n  try {\n   return $defineProperty(O, P, Attributes);\n  } catch (error) {\n  }\n if ('get' in Attributes || 'set' in Attributes)\n  throw $TypeError('Accessors not supported');\n if ('value' in Attributes)\n  O[P] = Attributes.value;\n return O;\n};\n\n/***/ }),\n/* 46 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar fails = __w_pdfjs_require__(7);\nmodule.exports = DESCRIPTORS && fails(function () {\n return Object.defineProperty(function () {\n }, 'prototype', {\n  value: 42,\n  writable: false\n }).prototype !== 42;\n});\n\n/***/ }),\n/* 47 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar isObject = __w_pdfjs_require__(20);\nvar $String = String;\nvar $TypeError = TypeError;\nmodule.exports = function (argument) {\n if (isObject(argument))\n  return argument;\n throw $TypeError($String(argument) + ' is not an object');\n};\n\n/***/ }),\n/* 48 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar isCallable = __w_pdfjs_require__(21);\nvar definePropertyModule = __w_pdfjs_require__(45);\nvar makeBuiltIn = __w_pdfjs_require__(49);\nvar defineGlobalProperty = __w_pdfjs_require__(38);\nmodule.exports = function (O, key, value, options) {\n if (!options)\n  options = {};\n var simple = options.enumerable;\n var name = options.name !== undefined ? options.name : key;\n if (isCallable(value))\n  makeBuiltIn(value, name, options);\n if (options.global) {\n  if (simple)\n   O[key] = value;\n  else\n   defineGlobalProperty(key, value);\n } else {\n  try {\n   if (!options.unsafe)\n    delete O[key];\n   else if (O[key])\n    simple = true;\n  } catch (error) {\n  }\n  if (simple)\n   O[key] = value;\n  else\n   definePropertyModule.f(O, key, {\n    value: value,\n    enumerable: false,\n    configurable: !options.nonConfigurable,\n    writable: !options.nonWritable\n   });\n }\n return O;\n};\n\n/***/ }),\n/* 49 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar fails = __w_pdfjs_require__(7);\nvar isCallable = __w_pdfjs_require__(21);\nvar hasOwn = __w_pdfjs_require__(39);\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar CONFIGURABLE_FUNCTION_NAME = (__w_pdfjs_require__(50).CONFIGURABLE);\nvar inspectSource = __w_pdfjs_require__(51);\nvar InternalStateModule = __w_pdfjs_require__(52);\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\nvar $String = String;\nvar defineProperty = Object.defineProperty;\nvar stringSlice = uncurryThis(''.slice);\nvar replace = uncurryThis(''.replace);\nvar join = uncurryThis([].join);\nvar CONFIGURABLE_LENGTH = DESCRIPTORS && !fails(function () {\n return defineProperty(function () {\n }, 'length', { value: 8 }).length !== 8;\n});\nvar TEMPLATE = String(String).split('String');\nvar makeBuiltIn = module.exports = function (value, name, options) {\n if (stringSlice($String(name), 0, 7) === 'Symbol(') {\n  name = '[' + replace($String(name), /^Symbol\\(([^)]*)\\)/, '$1') + ']';\n }\n if (options && options.getter)\n  name = 'get ' + name;\n if (options && options.setter)\n  name = 'set ' + name;\n if (!hasOwn(value, 'name') || CONFIGURABLE_FUNCTION_NAME && value.name !== name) {\n  if (DESCRIPTORS)\n   defineProperty(value, 'name', {\n    value: name,\n    configurable: true\n   });\n  else\n   value.name = name;\n }\n if (CONFIGURABLE_LENGTH && options && hasOwn(options, 'arity') && value.length !== options.arity) {\n  defineProperty(value, 'length', { value: options.arity });\n }\n try {\n  if (options && hasOwn(options, 'constructor') && options.constructor) {\n   if (DESCRIPTORS)\n    defineProperty(value, 'prototype', { writable: false });\n  } else if (value.prototype)\n   value.prototype = undefined;\n } catch (error) {\n }\n var state = enforceInternalState(value);\n if (!hasOwn(state, 'source')) {\n  state.source = join(TEMPLATE, typeof name == 'string' ? name : '');\n }\n return value;\n};\nFunction.prototype.toString = makeBuiltIn(function toString() {\n return isCallable(this) && getInternalState(this).source || inspectSource(this);\n}, 'toString');\n\n/***/ }),\n/* 50 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar hasOwn = __w_pdfjs_require__(39);\nvar FunctionPrototype = Function.prototype;\nvar getDescriptor = DESCRIPTORS && Object.getOwnPropertyDescriptor;\nvar EXISTS = hasOwn(FunctionPrototype, 'name');\nvar PROPER = EXISTS && function something() {\n}.name === 'something';\nvar CONFIGURABLE = EXISTS && (!DESCRIPTORS || DESCRIPTORS && getDescriptor(FunctionPrototype, 'name').configurable);\nmodule.exports = {\n EXISTS: EXISTS,\n PROPER: PROPER,\n CONFIGURABLE: CONFIGURABLE\n};\n\n/***/ }),\n/* 51 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar isCallable = __w_pdfjs_require__(21);\nvar store = __w_pdfjs_require__(37);\nvar functionToString = uncurryThis(Function.toString);\nif (!isCallable(store.inspectSource)) {\n store.inspectSource = function (it) {\n  return functionToString(it);\n };\n}\nmodule.exports = store.inspectSource;\n\n/***/ }),\n/* 52 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar NATIVE_WEAK_MAP = __w_pdfjs_require__(53);\nvar global = __w_pdfjs_require__(4);\nvar isObject = __w_pdfjs_require__(20);\nvar createNonEnumerableProperty = __w_pdfjs_require__(44);\nvar hasOwn = __w_pdfjs_require__(39);\nvar shared = __w_pdfjs_require__(37);\nvar sharedKey = __w_pdfjs_require__(54);\nvar hiddenKeys = __w_pdfjs_require__(55);\nvar OBJECT_ALREADY_INITIALIZED = 'Object already initialized';\nvar TypeError = global.TypeError;\nvar WeakMap = global.WeakMap;\nvar set, get, has;\nvar enforce = function (it) {\n return has(it) ? get(it) : set(it, {});\n};\nvar getterFor = function (TYPE) {\n return function (it) {\n  var state;\n  if (!isObject(it) || (state = get(it)).type !== TYPE) {\n   throw TypeError('Incompatible receiver, ' + TYPE + ' required');\n  }\n  return state;\n };\n};\nif (NATIVE_WEAK_MAP || shared.state) {\n var store = shared.state || (shared.state = new WeakMap());\n store.get = store.get;\n store.has = store.has;\n store.set = store.set;\n set = function (it, metadata) {\n  if (store.has(it))\n   throw TypeError(OBJECT_ALREADY_INITIALIZED);\n  metadata.facade = it;\n  store.set(it, metadata);\n  return metadata;\n };\n get = function (it) {\n  return store.get(it) || {};\n };\n has = function (it) {\n  return store.has(it);\n };\n} else {\n var STATE = sharedKey('state');\n hiddenKeys[STATE] = true;\n set = function (it, metadata) {\n  if (hasOwn(it, STATE))\n   throw TypeError(OBJECT_ALREADY_INITIALIZED);\n  metadata.facade = it;\n  createNonEnumerableProperty(it, STATE, metadata);\n  return metadata;\n };\n get = function (it) {\n  return hasOwn(it, STATE) ? it[STATE] : {};\n };\n has = function (it) {\n  return hasOwn(it, STATE);\n };\n}\nmodule.exports = {\n set: set,\n get: get,\n has: has,\n enforce: enforce,\n getterFor: getterFor\n};\n\n/***/ }),\n/* 53 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar isCallable = __w_pdfjs_require__(21);\nvar WeakMap = global.WeakMap;\nmodule.exports = isCallable(WeakMap) && /native code/.test(String(WeakMap));\n\n/***/ }),\n/* 54 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar shared = __w_pdfjs_require__(35);\nvar uid = __w_pdfjs_require__(41);\nvar keys = shared('keys');\nmodule.exports = function (key) {\n return keys[key] || (keys[key] = uid(key));\n};\n\n/***/ }),\n/* 55 */\n/***/ ((module) => {\n\n\nmodule.exports = {};\n\n/***/ }),\n/* 56 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar hasOwn = __w_pdfjs_require__(39);\nvar ownKeys = __w_pdfjs_require__(57);\nvar getOwnPropertyDescriptorModule = __w_pdfjs_require__(5);\nvar definePropertyModule = __w_pdfjs_require__(45);\nmodule.exports = function (target, source, exceptions) {\n var keys = ownKeys(source);\n var defineProperty = definePropertyModule.f;\n var getOwnPropertyDescriptor = getOwnPropertyDescriptorModule.f;\n for (var i = 0; i < keys.length; i++) {\n  var key = keys[i];\n  if (!hasOwn(target, key) && !(exceptions && hasOwn(exceptions, key))) {\n   defineProperty(target, key, getOwnPropertyDescriptor(source, key));\n  }\n }\n};\n\n/***/ }),\n/* 57 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar getBuiltIn = __w_pdfjs_require__(24);\nvar uncurryThis = __w_pdfjs_require__(14);\nvar getOwnPropertyNamesModule = __w_pdfjs_require__(58);\nvar getOwnPropertySymbolsModule = __w_pdfjs_require__(67);\nvar anObject = __w_pdfjs_require__(47);\nvar concat = uncurryThis([].concat);\nmodule.exports = getBuiltIn('Reflect', 'ownKeys') || function ownKeys(it) {\n var keys = getOwnPropertyNamesModule.f(anObject(it));\n var getOwnPropertySymbols = getOwnPropertySymbolsModule.f;\n return getOwnPropertySymbols ? concat(keys, getOwnPropertySymbols(it)) : keys;\n};\n\n/***/ }),\n/* 58 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\nvar internalObjectKeys = __w_pdfjs_require__(59);\nvar enumBugKeys = __w_pdfjs_require__(66);\nvar hiddenKeys = enumBugKeys.concat('length', 'prototype');\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n return internalObjectKeys(O, hiddenKeys);\n};\n\n/***/ }),\n/* 59 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar hasOwn = __w_pdfjs_require__(39);\nvar toIndexedObject = __w_pdfjs_require__(12);\nvar indexOf = (__w_pdfjs_require__(60).indexOf);\nvar hiddenKeys = __w_pdfjs_require__(55);\nvar push = uncurryThis([].push);\nmodule.exports = function (object, names) {\n var O = toIndexedObject(object);\n var i = 0;\n var result = [];\n var key;\n for (key in O)\n  !hasOwn(hiddenKeys, key) && hasOwn(O, key) && push(result, key);\n while (names.length > i)\n  if (hasOwn(O, key = names[i++])) {\n   ~indexOf(result, key) || push(result, key);\n  }\n return result;\n};\n\n/***/ }),\n/* 60 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toIndexedObject = __w_pdfjs_require__(12);\nvar toAbsoluteIndex = __w_pdfjs_require__(61);\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nvar createMethod = function (IS_INCLUDES) {\n return function ($this, el, fromIndex) {\n  var O = toIndexedObject($this);\n  var length = lengthOfArrayLike(O);\n  var index = toAbsoluteIndex(fromIndex, length);\n  var value;\n  if (IS_INCLUDES && el !== el)\n   while (length > index) {\n    value = O[index++];\n    if (value !== value)\n     return true;\n   }\n  else\n   for (; length > index; index++) {\n    if ((IS_INCLUDES || index in O) && O[index] === el)\n     return IS_INCLUDES || index || 0;\n   }\n  return !IS_INCLUDES && -1;\n };\n};\nmodule.exports = {\n includes: createMethod(true),\n indexOf: createMethod(false)\n};\n\n/***/ }),\n/* 61 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toIntegerOrInfinity = __w_pdfjs_require__(62);\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n var integer = toIntegerOrInfinity(index);\n return integer < 0 ? max(integer + length, 0) : min(integer, length);\n};\n\n/***/ }),\n/* 62 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar trunc = __w_pdfjs_require__(63);\nmodule.exports = function (argument) {\n var number = +argument;\n return number !== number || number === 0 ? 0 : trunc(number);\n};\n\n/***/ }),\n/* 63 */\n/***/ ((module) => {\n\n\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = Math.trunc || function trunc(x) {\n var n = +x;\n return (n > 0 ? floor : ceil)(n);\n};\n\n/***/ }),\n/* 64 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toLength = __w_pdfjs_require__(65);\nmodule.exports = function (obj) {\n return toLength(obj.length);\n};\n\n/***/ }),\n/* 65 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toIntegerOrInfinity = __w_pdfjs_require__(62);\nvar min = Math.min;\nmodule.exports = function (argument) {\n return argument > 0 ? min(toIntegerOrInfinity(argument), 0x1FFFFFFFFFFFFF) : 0;\n};\n\n/***/ }),\n/* 66 */\n/***/ ((module) => {\n\n\nmodule.exports = [\n 'constructor',\n 'hasOwnProperty',\n 'isPrototypeOf',\n 'propertyIsEnumerable',\n 'toLocaleString',\n 'toString',\n 'valueOf'\n];\n\n/***/ }),\n/* 67 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\nexports.f = Object.getOwnPropertySymbols;\n\n/***/ }),\n/* 68 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar fails = __w_pdfjs_require__(7);\nvar isCallable = __w_pdfjs_require__(21);\nvar replacement = /#|\\.prototype\\./;\nvar isForced = function (feature, detection) {\n var value = data[normalize(feature)];\n return value === POLYFILL ? true : value === NATIVE ? false : isCallable(detection) ? fails(detection) : !!detection;\n};\nvar normalize = isForced.normalize = function (string) {\n return String(string).replace(replacement, '.').toLowerCase();\n};\nvar data = isForced.data = {};\nvar NATIVE = isForced.NATIVE = 'N';\nvar POLYFILL = isForced.POLYFILL = 'P';\nmodule.exports = isForced;\n\n/***/ }),\n/* 69 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar NATIVE_BIND = __w_pdfjs_require__(9);\nvar FunctionPrototype = Function.prototype;\nvar apply = FunctionPrototype.apply;\nvar call = FunctionPrototype.call;\nmodule.exports = typeof Reflect == 'object' && Reflect.apply || (NATIVE_BIND ? call.bind(apply) : function () {\n return call.apply(apply, arguments);\n});\n\n/***/ }),\n/* 70 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar getBuiltIn = __w_pdfjs_require__(24);\nvar hasOwn = __w_pdfjs_require__(39);\nvar createNonEnumerableProperty = __w_pdfjs_require__(44);\nvar isPrototypeOf = __w_pdfjs_require__(25);\nvar setPrototypeOf = __w_pdfjs_require__(71);\nvar copyConstructorProperties = __w_pdfjs_require__(56);\nvar proxyAccessor = __w_pdfjs_require__(74);\nvar inheritIfRequired = __w_pdfjs_require__(75);\nvar normalizeStringArgument = __w_pdfjs_require__(76);\nvar installErrorCause = __w_pdfjs_require__(80);\nvar installErrorStack = __w_pdfjs_require__(81);\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar IS_PURE = __w_pdfjs_require__(36);\nmodule.exports = function (FULL_NAME, wrapper, FORCED, IS_AGGREGATE_ERROR) {\n var STACK_TRACE_LIMIT = 'stackTraceLimit';\n var OPTIONS_POSITION = IS_AGGREGATE_ERROR ? 2 : 1;\n var path = FULL_NAME.split('.');\n var ERROR_NAME = path[path.length - 1];\n var OriginalError = getBuiltIn.apply(null, path);\n if (!OriginalError)\n  return;\n var OriginalErrorPrototype = OriginalError.prototype;\n if (!IS_PURE && hasOwn(OriginalErrorPrototype, 'cause'))\n  delete OriginalErrorPrototype.cause;\n if (!FORCED)\n  return OriginalError;\n var BaseError = getBuiltIn('Error');\n var WrappedError = wrapper(function (a, b) {\n  var message = normalizeStringArgument(IS_AGGREGATE_ERROR ? b : a, undefined);\n  var result = IS_AGGREGATE_ERROR ? new OriginalError(a) : new OriginalError();\n  if (message !== undefined)\n   createNonEnumerableProperty(result, 'message', message);\n  installErrorStack(result, WrappedError, result.stack, 2);\n  if (this && isPrototypeOf(OriginalErrorPrototype, this))\n   inheritIfRequired(result, this, WrappedError);\n  if (arguments.length > OPTIONS_POSITION)\n   installErrorCause(result, arguments[OPTIONS_POSITION]);\n  return result;\n });\n WrappedError.prototype = OriginalErrorPrototype;\n if (ERROR_NAME !== 'Error') {\n  if (setPrototypeOf)\n   setPrototypeOf(WrappedError, BaseError);\n  else\n   copyConstructorProperties(WrappedError, BaseError, { name: true });\n } else if (DESCRIPTORS && STACK_TRACE_LIMIT in OriginalError) {\n  proxyAccessor(WrappedError, OriginalError, STACK_TRACE_LIMIT);\n  proxyAccessor(WrappedError, OriginalError, 'prepareStackTrace');\n }\n copyConstructorProperties(WrappedError, OriginalError);\n if (!IS_PURE)\n  try {\n   if (OriginalErrorPrototype.name !== ERROR_NAME) {\n    createNonEnumerableProperty(OriginalErrorPrototype, 'name', ERROR_NAME);\n   }\n   OriginalErrorPrototype.constructor = WrappedError;\n  } catch (error) {\n  }\n return WrappedError;\n};\n\n/***/ }),\n/* 71 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThisAccessor = __w_pdfjs_require__(72);\nvar anObject = __w_pdfjs_require__(47);\nvar aPossiblePrototype = __w_pdfjs_require__(73);\nmodule.exports = Object.setPrototypeOf || ('__proto__' in {} ? (function () {\n var CORRECT_SETTER = false;\n var test = {};\n var setter;\n try {\n  setter = uncurryThisAccessor(Object.prototype, '__proto__', 'set');\n  setter(test, []);\n  CORRECT_SETTER = test instanceof Array;\n } catch (error) {\n }\n return function setPrototypeOf(O, proto) {\n  anObject(O);\n  aPossiblePrototype(proto);\n  if (CORRECT_SETTER)\n   setter(O, proto);\n  else\n   O.__proto__ = proto;\n  return O;\n };\n}()) : undefined);\n\n/***/ }),\n/* 72 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar aCallable = __w_pdfjs_require__(31);\nmodule.exports = function (object, key, method) {\n try {\n  return uncurryThis(aCallable(Object.getOwnPropertyDescriptor(object, key)[method]));\n } catch (error) {\n }\n};\n\n/***/ }),\n/* 73 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar isCallable = __w_pdfjs_require__(21);\nvar $String = String;\nvar $TypeError = TypeError;\nmodule.exports = function (argument) {\n if (typeof argument == 'object' || isCallable(argument))\n  return argument;\n throw $TypeError(\"Can't set \" + $String(argument) + ' as a prototype');\n};\n\n/***/ }),\n/* 74 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar defineProperty = (__w_pdfjs_require__(45).f);\nmodule.exports = function (Target, Source, key) {\n key in Target || defineProperty(Target, key, {\n  configurable: true,\n  get: function () {\n   return Source[key];\n  },\n  set: function (it) {\n   Source[key] = it;\n  }\n });\n};\n\n/***/ }),\n/* 75 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar isCallable = __w_pdfjs_require__(21);\nvar isObject = __w_pdfjs_require__(20);\nvar setPrototypeOf = __w_pdfjs_require__(71);\nmodule.exports = function ($this, dummy, Wrapper) {\n var NewTarget, NewTargetPrototype;\n if (setPrototypeOf && isCallable(NewTarget = dummy.constructor) && NewTarget !== Wrapper && isObject(NewTargetPrototype = NewTarget.prototype) && NewTargetPrototype !== Wrapper.prototype)\n  setPrototypeOf($this, NewTargetPrototype);\n return $this;\n};\n\n/***/ }),\n/* 76 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toString = __w_pdfjs_require__(77);\nmodule.exports = function (argument, $default) {\n return argument === undefined ? arguments.length < 2 ? '' : $default : toString(argument);\n};\n\n/***/ }),\n/* 77 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar classof = __w_pdfjs_require__(78);\nvar $String = String;\nmodule.exports = function (argument) {\n if (classof(argument) === 'Symbol')\n  throw TypeError('Cannot convert a Symbol value to a string');\n return $String(argument);\n};\n\n/***/ }),\n/* 78 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar TO_STRING_TAG_SUPPORT = __w_pdfjs_require__(79);\nvar isCallable = __w_pdfjs_require__(21);\nvar classofRaw = __w_pdfjs_require__(15);\nvar wellKnownSymbol = __w_pdfjs_require__(34);\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar $Object = Object;\nvar CORRECT_ARGUMENTS = classofRaw((function () {\n return arguments;\n}())) === 'Arguments';\nvar tryGet = function (it, key) {\n try {\n  return it[key];\n } catch (error) {\n }\n};\nmodule.exports = TO_STRING_TAG_SUPPORT ? classofRaw : function (it) {\n var O, tag, result;\n return it === undefined ? 'Undefined' : it === null ? 'Null' : typeof (tag = tryGet(O = $Object(it), TO_STRING_TAG)) == 'string' ? tag : CORRECT_ARGUMENTS ? classofRaw(O) : (result = classofRaw(O)) === 'Object' && isCallable(O.callee) ? 'Arguments' : result;\n};\n\n/***/ }),\n/* 79 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar wellKnownSymbol = __w_pdfjs_require__(34);\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar test = {};\ntest[TO_STRING_TAG] = 'z';\nmodule.exports = String(test) === '[object z]';\n\n/***/ }),\n/* 80 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar isObject = __w_pdfjs_require__(20);\nvar createNonEnumerableProperty = __w_pdfjs_require__(44);\nmodule.exports = function (O, options) {\n if (isObject(options) && 'cause' in options) {\n  createNonEnumerableProperty(O, 'cause', options.cause);\n }\n};\n\n/***/ }),\n/* 81 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar createNonEnumerableProperty = __w_pdfjs_require__(44);\nvar clearErrorStack = __w_pdfjs_require__(82);\nvar ERROR_STACK_INSTALLABLE = __w_pdfjs_require__(83);\nvar captureStackTrace = Error.captureStackTrace;\nmodule.exports = function (error, C, stack, dropEntries) {\n if (ERROR_STACK_INSTALLABLE) {\n  if (captureStackTrace)\n   captureStackTrace(error, C);\n  else\n   createNonEnumerableProperty(error, 'stack', clearErrorStack(stack, dropEntries));\n }\n};\n\n/***/ }),\n/* 82 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar $Error = Error;\nvar replace = uncurryThis(''.replace);\nvar TEST = function (arg) {\n return String($Error(arg).stack);\n}('zxcasd');\nvar V8_OR_CHAKRA_STACK_ENTRY = /\\n\\s*at [^:]*:[^\\n]*/;\nvar IS_V8_OR_CHAKRA_STACK = V8_OR_CHAKRA_STACK_ENTRY.test(TEST);\nmodule.exports = function (stack, dropEntries) {\n if (IS_V8_OR_CHAKRA_STACK && typeof stack == 'string' && !$Error.prepareStackTrace) {\n  while (dropEntries--)\n   stack = replace(stack, V8_OR_CHAKRA_STACK_ENTRY, '');\n }\n return stack;\n};\n\n/***/ }),\n/* 83 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar fails = __w_pdfjs_require__(7);\nvar createPropertyDescriptor = __w_pdfjs_require__(11);\nmodule.exports = !fails(function () {\n var error = Error('a');\n if (!('stack' in error))\n  return true;\n Object.defineProperty(error, 'stack', createPropertyDescriptor(1, 7));\n return error.stack !== 7;\n});\n\n/***/ }),\n/* 84 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar defineBuiltIn = __w_pdfjs_require__(48);\nvar uncurryThis = __w_pdfjs_require__(14);\nvar toString = __w_pdfjs_require__(77);\nvar validateArgumentsLength = __w_pdfjs_require__(85);\nvar $URLSearchParams = URLSearchParams;\nvar URLSearchParamsPrototype = $URLSearchParams.prototype;\nvar append = uncurryThis(URLSearchParamsPrototype.append);\nvar $delete = uncurryThis(URLSearchParamsPrototype['delete']);\nvar forEach = uncurryThis(URLSearchParamsPrototype.forEach);\nvar push = uncurryThis([].push);\nvar params = new $URLSearchParams('a=1&a=2&b=3');\nparams['delete']('a', 1);\nparams['delete']('b', undefined);\nif (params + '' !== 'a=2') {\n defineBuiltIn(URLSearchParamsPrototype, 'delete', function (name) {\n  var length = arguments.length;\n  var $value = length < 2 ? undefined : arguments[1];\n  if (length && $value === undefined)\n   return $delete(this, name);\n  var entries = [];\n  forEach(this, function (v, k) {\n   push(entries, {\n    key: k,\n    value: v\n   });\n  });\n  validateArgumentsLength(length, 1);\n  var key = toString(name);\n  var value = toString($value);\n  var index = 0;\n  var dindex = 0;\n  var found = false;\n  var entriesLength = entries.length;\n  var entry;\n  while (index < entriesLength) {\n   entry = entries[index++];\n   if (found || entry.key === key) {\n    found = true;\n    $delete(this, entry.key);\n   } else\n    dindex++;\n  }\n  while (dindex < entriesLength) {\n   entry = entries[dindex++];\n   if (!(entry.key === key && entry.value === value))\n    append(this, entry.key, entry.value);\n  }\n }, {\n  enumerable: true,\n  unsafe: true\n });\n}\n\n/***/ }),\n/* 85 */\n/***/ ((module) => {\n\n\nvar $TypeError = TypeError;\nmodule.exports = function (passed, required) {\n if (passed < required)\n  throw $TypeError('Not enough arguments');\n return passed;\n};\n\n/***/ }),\n/* 86 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar defineBuiltIn = __w_pdfjs_require__(48);\nvar uncurryThis = __w_pdfjs_require__(14);\nvar toString = __w_pdfjs_require__(77);\nvar validateArgumentsLength = __w_pdfjs_require__(85);\nvar $URLSearchParams = URLSearchParams;\nvar URLSearchParamsPrototype = $URLSearchParams.prototype;\nvar getAll = uncurryThis(URLSearchParamsPrototype.getAll);\nvar $has = uncurryThis(URLSearchParamsPrototype.has);\nvar params = new $URLSearchParams('a=1');\nif (params.has('a', 2) || !params.has('a', undefined)) {\n defineBuiltIn(URLSearchParamsPrototype, 'has', function has(name) {\n  var length = arguments.length;\n  var $value = length < 2 ? undefined : arguments[1];\n  if (length && $value === undefined)\n   return $has(this, name);\n  var values = getAll(this, name);\n  validateArgumentsLength(length, 1);\n  var value = toString($value);\n  var index = 0;\n  while (index < values.length) {\n   if (values[index++] === value)\n    return true;\n  }\n  return false;\n }, {\n  enumerable: true,\n  unsafe: true\n });\n}\n\n/***/ }),\n/* 87 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar uncurryThis = __w_pdfjs_require__(14);\nvar defineBuiltInAccessor = __w_pdfjs_require__(88);\nvar URLSearchParamsPrototype = URLSearchParams.prototype;\nvar forEach = uncurryThis(URLSearchParamsPrototype.forEach);\nif (DESCRIPTORS && !('size' in URLSearchParamsPrototype)) {\n defineBuiltInAccessor(URLSearchParamsPrototype, 'size', {\n  get: function size() {\n   var count = 0;\n   forEach(this, function () {\n    count++;\n   });\n   return count;\n  },\n  configurable: true,\n  enumerable: true\n });\n}\n\n/***/ }),\n/* 88 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar makeBuiltIn = __w_pdfjs_require__(49);\nvar defineProperty = __w_pdfjs_require__(45);\nmodule.exports = function (target, name, descriptor) {\n if (descriptor.get)\n  makeBuiltIn(descriptor.get, name, { getter: true });\n if (descriptor.set)\n  makeBuiltIn(descriptor.set, name, { setter: true });\n return defineProperty.f(target, name, descriptor);\n};\n\n/***/ }),\n/* 89 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar toObject = __w_pdfjs_require__(40);\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nvar setArrayLength = __w_pdfjs_require__(90);\nvar doesNotExceedSafeInteger = __w_pdfjs_require__(92);\nvar fails = __w_pdfjs_require__(7);\nvar INCORRECT_TO_LENGTH = fails(function () {\n return [].push.call({ length: 0x100000000 }, 1) !== 4294967297;\n});\nvar properErrorOnNonWritableLength = function () {\n try {\n  Object.defineProperty([], 'length', { writable: false }).push();\n } catch (error) {\n  return error instanceof TypeError;\n }\n};\nvar FORCED = INCORRECT_TO_LENGTH || !properErrorOnNonWritableLength();\n$({\n target: 'Array',\n proto: true,\n arity: 1,\n forced: FORCED\n}, {\n push: function push(item) {\n  var O = toObject(this);\n  var len = lengthOfArrayLike(O);\n  var argCount = arguments.length;\n  doesNotExceedSafeInteger(len + argCount);\n  for (var i = 0; i < argCount; i++) {\n   O[len] = arguments[i];\n   len++;\n  }\n  setArrayLength(O, len);\n  return len;\n }\n});\n\n/***/ }),\n/* 90 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar isArray = __w_pdfjs_require__(91);\nvar $TypeError = TypeError;\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar SILENT_ON_NON_WRITABLE_LENGTH_SET = DESCRIPTORS && !(function () {\n if (this !== undefined)\n  return true;\n try {\n  Object.defineProperty([], 'length', { writable: false }).length = 1;\n } catch (error) {\n  return error instanceof TypeError;\n }\n}());\nmodule.exports = SILENT_ON_NON_WRITABLE_LENGTH_SET ? function (O, length) {\n if (isArray(O) && !getOwnPropertyDescriptor(O, 'length').writable) {\n  throw $TypeError('Cannot set read only .length');\n }\n return O.length = length;\n} : function (O, length) {\n return O.length = length;\n};\n\n/***/ }),\n/* 91 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar classof = __w_pdfjs_require__(15);\nmodule.exports = Array.isArray || function isArray(argument) {\n return classof(argument) === 'Array';\n};\n\n/***/ }),\n/* 92 */\n/***/ ((module) => {\n\n\nvar $TypeError = TypeError;\nvar MAX_SAFE_INTEGER = 0x1FFFFFFFFFFFFF;\nmodule.exports = function (it) {\n if (it > MAX_SAFE_INTEGER)\n  throw $TypeError('Maximum allowed index exceeded');\n return it;\n};\n\n/***/ }),\n/* 93 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar ArrayBufferViewCore = __w_pdfjs_require__(94);\nvar $findLast = (__w_pdfjs_require__(98).findLast);\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nexportTypedArrayMethod('findLast', function findLast(predicate) {\n return $findLast(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n/***/ }),\n/* 94 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar NATIVE_ARRAY_BUFFER = __w_pdfjs_require__(95);\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar global = __w_pdfjs_require__(4);\nvar isCallable = __w_pdfjs_require__(21);\nvar isObject = __w_pdfjs_require__(20);\nvar hasOwn = __w_pdfjs_require__(39);\nvar classof = __w_pdfjs_require__(78);\nvar tryToString = __w_pdfjs_require__(32);\nvar createNonEnumerableProperty = __w_pdfjs_require__(44);\nvar defineBuiltIn = __w_pdfjs_require__(48);\nvar defineBuiltInAccessor = __w_pdfjs_require__(88);\nvar isPrototypeOf = __w_pdfjs_require__(25);\nvar getPrototypeOf = __w_pdfjs_require__(96);\nvar setPrototypeOf = __w_pdfjs_require__(71);\nvar wellKnownSymbol = __w_pdfjs_require__(34);\nvar uid = __w_pdfjs_require__(41);\nvar InternalStateModule = __w_pdfjs_require__(52);\nvar enforceInternalState = InternalStateModule.enforce;\nvar getInternalState = InternalStateModule.get;\nvar Int8Array = global.Int8Array;\nvar Int8ArrayPrototype = Int8Array && Int8Array.prototype;\nvar Uint8ClampedArray = global.Uint8ClampedArray;\nvar Uint8ClampedArrayPrototype = Uint8ClampedArray && Uint8ClampedArray.prototype;\nvar TypedArray = Int8Array && getPrototypeOf(Int8Array);\nvar TypedArrayPrototype = Int8ArrayPrototype && getPrototypeOf(Int8ArrayPrototype);\nvar ObjectPrototype = Object.prototype;\nvar TypeError = global.TypeError;\nvar TO_STRING_TAG = wellKnownSymbol('toStringTag');\nvar TYPED_ARRAY_TAG = uid('TYPED_ARRAY_TAG');\nvar TYPED_ARRAY_CONSTRUCTOR = 'TypedArrayConstructor';\nvar NATIVE_ARRAY_BUFFER_VIEWS = NATIVE_ARRAY_BUFFER && !!setPrototypeOf && classof(global.opera) !== 'Opera';\nvar TYPED_ARRAY_TAG_REQUIRED = false;\nvar NAME, Constructor, Prototype;\nvar TypedArrayConstructorsList = {\n Int8Array: 1,\n Uint8Array: 1,\n Uint8ClampedArray: 1,\n Int16Array: 2,\n Uint16Array: 2,\n Int32Array: 4,\n Uint32Array: 4,\n Float32Array: 4,\n Float64Array: 8\n};\nvar BigIntArrayConstructorsList = {\n BigInt64Array: 8,\n BigUint64Array: 8\n};\nvar isView = function isView(it) {\n if (!isObject(it))\n  return false;\n var klass = classof(it);\n return klass === 'DataView' || hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);\n};\nvar getTypedArrayConstructor = function (it) {\n var proto = getPrototypeOf(it);\n if (!isObject(proto))\n  return;\n var state = getInternalState(proto);\n return state && hasOwn(state, TYPED_ARRAY_CONSTRUCTOR) ? state[TYPED_ARRAY_CONSTRUCTOR] : getTypedArrayConstructor(proto);\n};\nvar isTypedArray = function (it) {\n if (!isObject(it))\n  return false;\n var klass = classof(it);\n return hasOwn(TypedArrayConstructorsList, klass) || hasOwn(BigIntArrayConstructorsList, klass);\n};\nvar aTypedArray = function (it) {\n if (isTypedArray(it))\n  return it;\n throw TypeError('Target is not a typed array');\n};\nvar aTypedArrayConstructor = function (C) {\n if (isCallable(C) && (!setPrototypeOf || isPrototypeOf(TypedArray, C)))\n  return C;\n throw TypeError(tryToString(C) + ' is not a typed array constructor');\n};\nvar exportTypedArrayMethod = function (KEY, property, forced, options) {\n if (!DESCRIPTORS)\n  return;\n if (forced)\n  for (var ARRAY in TypedArrayConstructorsList) {\n   var TypedArrayConstructor = global[ARRAY];\n   if (TypedArrayConstructor && hasOwn(TypedArrayConstructor.prototype, KEY))\n    try {\n     delete TypedArrayConstructor.prototype[KEY];\n    } catch (error) {\n     try {\n      TypedArrayConstructor.prototype[KEY] = property;\n     } catch (error2) {\n     }\n    }\n  }\n if (!TypedArrayPrototype[KEY] || forced) {\n  defineBuiltIn(TypedArrayPrototype, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && Int8ArrayPrototype[KEY] || property, options);\n }\n};\nvar exportTypedArrayStaticMethod = function (KEY, property, forced) {\n var ARRAY, TypedArrayConstructor;\n if (!DESCRIPTORS)\n  return;\n if (setPrototypeOf) {\n  if (forced)\n   for (ARRAY in TypedArrayConstructorsList) {\n    TypedArrayConstructor = global[ARRAY];\n    if (TypedArrayConstructor && hasOwn(TypedArrayConstructor, KEY))\n     try {\n      delete TypedArrayConstructor[KEY];\n     } catch (error) {\n     }\n   }\n  if (!TypedArray[KEY] || forced) {\n   try {\n    return defineBuiltIn(TypedArray, KEY, forced ? property : NATIVE_ARRAY_BUFFER_VIEWS && TypedArray[KEY] || property);\n   } catch (error) {\n   }\n  } else\n   return;\n }\n for (ARRAY in TypedArrayConstructorsList) {\n  TypedArrayConstructor = global[ARRAY];\n  if (TypedArrayConstructor && (!TypedArrayConstructor[KEY] || forced)) {\n   defineBuiltIn(TypedArrayConstructor, KEY, property);\n  }\n }\n};\nfor (NAME in TypedArrayConstructorsList) {\n Constructor = global[NAME];\n Prototype = Constructor && Constructor.prototype;\n if (Prototype)\n  enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n else\n  NATIVE_ARRAY_BUFFER_VIEWS = false;\n}\nfor (NAME in BigIntArrayConstructorsList) {\n Constructor = global[NAME];\n Prototype = Constructor && Constructor.prototype;\n if (Prototype)\n  enforceInternalState(Prototype)[TYPED_ARRAY_CONSTRUCTOR] = Constructor;\n}\nif (!NATIVE_ARRAY_BUFFER_VIEWS || !isCallable(TypedArray) || TypedArray === Function.prototype) {\n TypedArray = function TypedArray() {\n  throw TypeError('Incorrect invocation');\n };\n if (NATIVE_ARRAY_BUFFER_VIEWS)\n  for (NAME in TypedArrayConstructorsList) {\n   if (global[NAME])\n    setPrototypeOf(global[NAME], TypedArray);\n  }\n}\nif (!NATIVE_ARRAY_BUFFER_VIEWS || !TypedArrayPrototype || TypedArrayPrototype === ObjectPrototype) {\n TypedArrayPrototype = TypedArray.prototype;\n if (NATIVE_ARRAY_BUFFER_VIEWS)\n  for (NAME in TypedArrayConstructorsList) {\n   if (global[NAME])\n    setPrototypeOf(global[NAME].prototype, TypedArrayPrototype);\n  }\n}\nif (NATIVE_ARRAY_BUFFER_VIEWS && getPrototypeOf(Uint8ClampedArrayPrototype) !== TypedArrayPrototype) {\n setPrototypeOf(Uint8ClampedArrayPrototype, TypedArrayPrototype);\n}\nif (DESCRIPTORS && !hasOwn(TypedArrayPrototype, TO_STRING_TAG)) {\n TYPED_ARRAY_TAG_REQUIRED = true;\n defineBuiltInAccessor(TypedArrayPrototype, TO_STRING_TAG, {\n  configurable: true,\n  get: function () {\n   return isObject(this) ? this[TYPED_ARRAY_TAG] : undefined;\n  }\n });\n for (NAME in TypedArrayConstructorsList)\n  if (global[NAME]) {\n   createNonEnumerableProperty(global[NAME], TYPED_ARRAY_TAG, NAME);\n  }\n}\nmodule.exports = {\n NATIVE_ARRAY_BUFFER_VIEWS: NATIVE_ARRAY_BUFFER_VIEWS,\n TYPED_ARRAY_TAG: TYPED_ARRAY_TAG_REQUIRED && TYPED_ARRAY_TAG,\n aTypedArray: aTypedArray,\n aTypedArrayConstructor: aTypedArrayConstructor,\n exportTypedArrayMethod: exportTypedArrayMethod,\n exportTypedArrayStaticMethod: exportTypedArrayStaticMethod,\n getTypedArrayConstructor: getTypedArrayConstructor,\n isView: isView,\n isTypedArray: isTypedArray,\n TypedArray: TypedArray,\n TypedArrayPrototype: TypedArrayPrototype\n};\n\n/***/ }),\n/* 95 */\n/***/ ((module) => {\n\n\nmodule.exports = typeof ArrayBuffer != 'undefined' && typeof DataView != 'undefined';\n\n/***/ }),\n/* 96 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar hasOwn = __w_pdfjs_require__(39);\nvar isCallable = __w_pdfjs_require__(21);\nvar toObject = __w_pdfjs_require__(40);\nvar sharedKey = __w_pdfjs_require__(54);\nvar CORRECT_PROTOTYPE_GETTER = __w_pdfjs_require__(97);\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar $Object = Object;\nvar ObjectPrototype = $Object.prototype;\nmodule.exports = CORRECT_PROTOTYPE_GETTER ? $Object.getPrototypeOf : function (O) {\n var object = toObject(O);\n if (hasOwn(object, IE_PROTO))\n  return object[IE_PROTO];\n var constructor = object.constructor;\n if (isCallable(constructor) && object instanceof constructor) {\n  return constructor.prototype;\n }\n return object instanceof $Object ? ObjectPrototype : null;\n};\n\n/***/ }),\n/* 97 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar fails = __w_pdfjs_require__(7);\nmodule.exports = !fails(function () {\n function F() {\n }\n F.prototype.constructor = null;\n return Object.getPrototypeOf(new F()) !== F.prototype;\n});\n\n/***/ }),\n/* 98 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar bind = __w_pdfjs_require__(99);\nvar IndexedObject = __w_pdfjs_require__(13);\nvar toObject = __w_pdfjs_require__(40);\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nvar createMethod = function (TYPE) {\n var IS_FIND_LAST_INDEX = TYPE === 1;\n return function ($this, callbackfn, that) {\n  var O = toObject($this);\n  var self = IndexedObject(O);\n  var boundFunction = bind(callbackfn, that);\n  var index = lengthOfArrayLike(self);\n  var value, result;\n  while (index-- > 0) {\n   value = self[index];\n   result = boundFunction(value, index, O);\n   if (result)\n    switch (TYPE) {\n    case 0:\n     return value;\n    case 1:\n     return index;\n    }\n  }\n  return IS_FIND_LAST_INDEX ? -1 : undefined;\n };\n};\nmodule.exports = {\n findLast: createMethod(0),\n findLastIndex: createMethod(1)\n};\n\n/***/ }),\n/* 99 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(100);\nvar aCallable = __w_pdfjs_require__(31);\nvar NATIVE_BIND = __w_pdfjs_require__(9);\nvar bind = uncurryThis(uncurryThis.bind);\nmodule.exports = function (fn, that) {\n aCallable(fn);\n return that === undefined ? fn : NATIVE_BIND ? bind(fn, that) : function () {\n  return fn.apply(that, arguments);\n };\n};\n\n/***/ }),\n/* 100 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar classofRaw = __w_pdfjs_require__(15);\nvar uncurryThis = __w_pdfjs_require__(14);\nmodule.exports = function (fn) {\n if (classofRaw(fn) === 'Function')\n  return uncurryThis(fn);\n};\n\n/***/ }),\n/* 101 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar ArrayBufferViewCore = __w_pdfjs_require__(94);\nvar $findLastIndex = (__w_pdfjs_require__(98).findLastIndex);\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nexportTypedArrayMethod('findLastIndex', function findLastIndex(predicate) {\n return $findLastIndex(aTypedArray(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n});\n\n/***/ }),\n/* 102 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar call = __w_pdfjs_require__(8);\nvar ArrayBufferViewCore = __w_pdfjs_require__(94);\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nvar toOffset = __w_pdfjs_require__(103);\nvar toIndexedObject = __w_pdfjs_require__(40);\nvar fails = __w_pdfjs_require__(7);\nvar RangeError = global.RangeError;\nvar Int8Array = global.Int8Array;\nvar Int8ArrayPrototype = Int8Array && Int8Array.prototype;\nvar $set = Int8ArrayPrototype && Int8ArrayPrototype.set;\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS = !fails(function () {\n var array = new Uint8ClampedArray(2);\n call($set, array, {\n  length: 1,\n  0: 3\n }, 1);\n return array[1] !== 3;\n});\nvar TO_OBJECT_BUG = WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS && ArrayBufferViewCore.NATIVE_ARRAY_BUFFER_VIEWS && fails(function () {\n var array = new Int8Array(2);\n array.set(1);\n array.set('2', 1);\n return array[0] !== 0 || array[1] !== 2;\n});\nexportTypedArrayMethod('set', function set(arrayLike) {\n aTypedArray(this);\n var offset = toOffset(arguments.length > 1 ? arguments[1] : undefined, 1);\n var src = toIndexedObject(arrayLike);\n if (WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS)\n  return call($set, this, src, offset);\n var length = this.length;\n var len = lengthOfArrayLike(src);\n var index = 0;\n if (len + offset > length)\n  throw RangeError('Wrong length');\n while (index < len)\n  this[offset + index] = src[index++];\n}, !WORKS_WITH_OBJECTS_AND_GENERIC_ON_TYPED_ARRAYS || TO_OBJECT_BUG);\n\n/***/ }),\n/* 103 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toPositiveInteger = __w_pdfjs_require__(104);\nvar $RangeError = RangeError;\nmodule.exports = function (it, BYTES) {\n var offset = toPositiveInteger(it);\n if (offset % BYTES)\n  throw $RangeError('Wrong offset');\n return offset;\n};\n\n/***/ }),\n/* 104 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toIntegerOrInfinity = __w_pdfjs_require__(62);\nvar $RangeError = RangeError;\nmodule.exports = function (it) {\n var result = toIntegerOrInfinity(it);\n if (result < 0)\n  throw $RangeError(\"The argument can't be less than 0\");\n return result;\n};\n\n/***/ }),\n/* 105 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar arrayToReversed = __w_pdfjs_require__(106);\nvar ArrayBufferViewCore = __w_pdfjs_require__(94);\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;\nexportTypedArrayMethod('toReversed', function toReversed() {\n return arrayToReversed(aTypedArray(this), getTypedArrayConstructor(this));\n});\n\n/***/ }),\n/* 106 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nmodule.exports = function (O, C) {\n var len = lengthOfArrayLike(O);\n var A = new C(len);\n var k = 0;\n for (; k < len; k++)\n  A[k] = O[len - k - 1];\n return A;\n};\n\n/***/ }),\n/* 107 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar ArrayBufferViewCore = __w_pdfjs_require__(94);\nvar uncurryThis = __w_pdfjs_require__(14);\nvar aCallable = __w_pdfjs_require__(31);\nvar arrayFromConstructorAndList = __w_pdfjs_require__(108);\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar sort = uncurryThis(ArrayBufferViewCore.TypedArrayPrototype.sort);\nexportTypedArrayMethod('toSorted', function toSorted(compareFn) {\n if (compareFn !== undefined)\n  aCallable(compareFn);\n var O = aTypedArray(this);\n var A = arrayFromConstructorAndList(getTypedArrayConstructor(O), O);\n return sort(A, compareFn);\n});\n\n/***/ }),\n/* 108 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nmodule.exports = function (Constructor, list) {\n var index = 0;\n var length = lengthOfArrayLike(list);\n var result = new Constructor(length);\n while (length > index)\n  result[index] = list[index++];\n return result;\n};\n\n/***/ }),\n/* 109 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar arrayWith = __w_pdfjs_require__(110);\nvar ArrayBufferViewCore = __w_pdfjs_require__(94);\nvar isBigIntArray = __w_pdfjs_require__(111);\nvar toIntegerOrInfinity = __w_pdfjs_require__(62);\nvar toBigInt = __w_pdfjs_require__(112);\nvar aTypedArray = ArrayBufferViewCore.aTypedArray;\nvar getTypedArrayConstructor = ArrayBufferViewCore.getTypedArrayConstructor;\nvar exportTypedArrayMethod = ArrayBufferViewCore.exportTypedArrayMethod;\nvar PROPER_ORDER = !!(function () {\n try {\n  new Int8Array(1)['with'](2, {\n   valueOf: function () {\n    throw 8;\n   }\n  });\n } catch (error) {\n  return error === 8;\n }\n}());\nexportTypedArrayMethod('with', {\n 'with': function (index, value) {\n  var O = aTypedArray(this);\n  var relativeIndex = toIntegerOrInfinity(index);\n  var actualValue = isBigIntArray(O) ? toBigInt(value) : +value;\n  return arrayWith(O, getTypedArrayConstructor(O), relativeIndex, actualValue);\n }\n}['with'], !PROPER_ORDER);\n\n/***/ }),\n/* 110 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nvar toIntegerOrInfinity = __w_pdfjs_require__(62);\nvar $RangeError = RangeError;\nmodule.exports = function (O, C, index, value) {\n var len = lengthOfArrayLike(O);\n var relativeIndex = toIntegerOrInfinity(index);\n var actualIndex = relativeIndex < 0 ? len + relativeIndex : relativeIndex;\n if (actualIndex >= len || actualIndex < 0)\n  throw $RangeError('Incorrect index');\n var A = new C(len);\n var k = 0;\n for (; k < len; k++)\n  A[k] = k === actualIndex ? value : O[k];\n return A;\n};\n\n/***/ }),\n/* 111 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar classof = __w_pdfjs_require__(78);\nmodule.exports = function (it) {\n var klass = classof(it);\n return klass === 'BigInt64Array' || klass === 'BigUint64Array';\n};\n\n/***/ }),\n/* 112 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toPrimitive = __w_pdfjs_require__(19);\nvar $TypeError = TypeError;\nmodule.exports = function (argument) {\n var prim = toPrimitive(argument, 'number');\n if (typeof prim == 'number')\n  throw $TypeError(\"Can't convert number to bigint\");\n return BigInt(prim);\n};\n\n/***/ }),\n/* 113 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar defineBuiltInAccessor = __w_pdfjs_require__(88);\nvar isDetached = __w_pdfjs_require__(114);\nvar ArrayBufferPrototype = ArrayBuffer.prototype;\nif (DESCRIPTORS && !('detached' in ArrayBufferPrototype)) {\n defineBuiltInAccessor(ArrayBufferPrototype, 'detached', {\n  configurable: true,\n  get: function detached() {\n   return isDetached(this);\n  }\n });\n}\n\n/***/ }),\n/* 114 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar arrayBufferByteLength = __w_pdfjs_require__(115);\nvar slice = uncurryThis(ArrayBuffer.prototype.slice);\nmodule.exports = function (O) {\n if (arrayBufferByteLength(O) !== 0)\n  return false;\n try {\n  slice(O, 0, 0);\n  return false;\n } catch (error) {\n  return true;\n }\n};\n\n/***/ }),\n/* 115 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThisAccessor = __w_pdfjs_require__(72);\nvar classof = __w_pdfjs_require__(15);\nvar $TypeError = TypeError;\nmodule.exports = uncurryThisAccessor(ArrayBuffer.prototype, 'byteLength', 'get') || function (O) {\n if (classof(O) !== 'ArrayBuffer')\n  throw $TypeError('ArrayBuffer expected');\n return O.byteLength;\n};\n\n/***/ }),\n/* 116 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar $transfer = __w_pdfjs_require__(117);\nif ($transfer)\n $({\n  target: 'ArrayBuffer',\n  proto: true\n }, {\n  transfer: function transfer() {\n   return $transfer(this, arguments.length ? arguments[0] : undefined, true);\n  }\n });\n\n/***/ }),\n/* 117 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar uncurryThis = __w_pdfjs_require__(14);\nvar uncurryThisAccessor = __w_pdfjs_require__(72);\nvar toIndex = __w_pdfjs_require__(118);\nvar isDetached = __w_pdfjs_require__(114);\nvar arrayBufferByteLength = __w_pdfjs_require__(115);\nvar PROPER_TRANSFER = __w_pdfjs_require__(119);\nvar TypeError = global.TypeError;\nvar structuredClone = global.structuredClone;\nvar ArrayBuffer = global.ArrayBuffer;\nvar DataView = global.DataView;\nvar min = Math.min;\nvar ArrayBufferPrototype = ArrayBuffer.prototype;\nvar DataViewPrototype = DataView.prototype;\nvar slice = uncurryThis(ArrayBufferPrototype.slice);\nvar isResizable = uncurryThisAccessor(ArrayBufferPrototype, 'resizable', 'get');\nvar maxByteLength = uncurryThisAccessor(ArrayBufferPrototype, 'maxByteLength', 'get');\nvar getInt8 = uncurryThis(DataViewPrototype.getInt8);\nvar setInt8 = uncurryThis(DataViewPrototype.setInt8);\nmodule.exports = PROPER_TRANSFER && function (arrayBuffer, newLength, preserveResizability) {\n var byteLength = arrayBufferByteLength(arrayBuffer);\n var newByteLength = newLength === undefined ? byteLength : toIndex(newLength);\n var fixedLength = !isResizable || !isResizable(arrayBuffer);\n if (isDetached(arrayBuffer))\n  throw TypeError('ArrayBuffer is detached');\n var newBuffer = structuredClone(arrayBuffer, { transfer: [arrayBuffer] });\n if (byteLength === newByteLength && (preserveResizability || fixedLength))\n  return newBuffer;\n if (byteLength >= newByteLength && (!preserveResizability || fixedLength))\n  return slice(newBuffer, 0, newByteLength);\n var options = preserveResizability && !fixedLength && maxByteLength ? { maxByteLength: maxByteLength(newBuffer) } : undefined;\n var newNewBuffer = new ArrayBuffer(newByteLength, options);\n var a = new DataView(newBuffer);\n var b = new DataView(newNewBuffer);\n var copyLength = min(newByteLength, byteLength);\n for (var i = 0; i < copyLength; i++)\n  setInt8(b, i, getInt8(a, i));\n return newNewBuffer;\n};\n\n/***/ }),\n/* 118 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toIntegerOrInfinity = __w_pdfjs_require__(62);\nvar toLength = __w_pdfjs_require__(65);\nvar $RangeError = RangeError;\nmodule.exports = function (it) {\n if (it === undefined)\n  return 0;\n var number = toIntegerOrInfinity(it);\n var length = toLength(number);\n if (number !== length)\n  throw $RangeError('Wrong length or index');\n return length;\n};\n\n/***/ }),\n/* 119 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar fails = __w_pdfjs_require__(7);\nvar V8 = __w_pdfjs_require__(28);\nvar IS_BROWSER = __w_pdfjs_require__(120);\nvar IS_DENO = __w_pdfjs_require__(121);\nvar IS_NODE = __w_pdfjs_require__(122);\nvar structuredClone = global.structuredClone;\nmodule.exports = !!structuredClone && !fails(function () {\n if (IS_DENO && V8 > 92 || IS_NODE && V8 > 94 || IS_BROWSER && V8 > 97)\n  return false;\n var buffer = new ArrayBuffer(8);\n var clone = structuredClone(buffer, { transfer: [buffer] });\n return buffer.byteLength !== 0 || clone.byteLength !== 8;\n});\n\n/***/ }),\n/* 120 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar IS_DENO = __w_pdfjs_require__(121);\nvar IS_NODE = __w_pdfjs_require__(122);\nmodule.exports = !IS_DENO && !IS_NODE && typeof window == 'object' && typeof document == 'object';\n\n/***/ }),\n/* 121 */\n/***/ ((module) => {\n\n\nmodule.exports = typeof Deno == 'object' && Deno && typeof Deno.version == 'object';\n\n/***/ }),\n/* 122 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar global = __w_pdfjs_require__(4);\nvar classof = __w_pdfjs_require__(15);\nmodule.exports = classof(global.process) === 'process';\n\n/***/ }),\n/* 123 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar $transfer = __w_pdfjs_require__(117);\nif ($transfer)\n $({\n  target: 'ArrayBuffer',\n  proto: true\n }, {\n  transferToFixedLength: function transferToFixedLength() {\n   return $transfer(this, arguments.length ? arguments[0] : undefined, false);\n  }\n });\n\n/***/ }),\n/* 124 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.RenderTask = exports.PDFWorkerUtil = exports.PDFWorker = exports.PDFPageProxy = exports.PDFDocumentProxy = exports.PDFDocumentLoadingTask = exports.PDFDataRangeTransport = exports.LoopbackPort = exports.DefaultStandardFontDataFactory = exports.DefaultFilterFactory = exports.DefaultCanvasFactory = exports.DefaultCMapReaderFactory = void 0;\nObject.defineProperty(exports, \"SVGGraphics\", ({\n  enumerable: true,\n  get: function () {\n    return _displaySvg.SVGGraphics;\n  }\n}));\nexports.build = void 0;\nexports.getDocument = getDocument;\nexports.version = void 0;\n__w_pdfjs_require__(84);\n__w_pdfjs_require__(86);\n__w_pdfjs_require__(87);\n__w_pdfjs_require__(2);\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(125);\n__w_pdfjs_require__(136);\n__w_pdfjs_require__(138);\n__w_pdfjs_require__(141);\n__w_pdfjs_require__(143);\n__w_pdfjs_require__(145);\n__w_pdfjs_require__(147);\n__w_pdfjs_require__(149);\n__w_pdfjs_require__(152);\nvar _util = __w_pdfjs_require__(1);\nvar _annotation_storage = __w_pdfjs_require__(163);\nvar _display_utils = __w_pdfjs_require__(168);\nvar _font_loader = __w_pdfjs_require__(171);\nvar _displayNode_utils = __w_pdfjs_require__(172);\nvar _canvas = __w_pdfjs_require__(173);\nvar _worker_options = __w_pdfjs_require__(176);\nvar _message_handler = __w_pdfjs_require__(177);\nvar _metadata = __w_pdfjs_require__(178);\nvar _optional_content_config = __w_pdfjs_require__(179);\nvar _transport_stream = __w_pdfjs_require__(180);\nvar _displayFetch_stream = __w_pdfjs_require__(181);\nvar _displayNetwork = __w_pdfjs_require__(184);\nvar _displayNode_stream = __w_pdfjs_require__(185);\nvar _displaySvg = __w_pdfjs_require__(186);\nvar _xfa_text = __w_pdfjs_require__(194);\nconst DEFAULT_RANGE_CHUNK_SIZE = 65536;\nconst RENDERING_CANCELLED_TIMEOUT = 100;\nconst DELAYED_CLEANUP_TIMEOUT = 5000;\nconst DefaultCanvasFactory = _util.isNodeJS ? _displayNode_utils.NodeCanvasFactory : _display_utils.DOMCanvasFactory;\nexports.DefaultCanvasFactory = DefaultCanvasFactory;\nconst DefaultCMapReaderFactory = _util.isNodeJS ? _displayNode_utils.NodeCMapReaderFactory : _display_utils.DOMCMapReaderFactory;\nexports.DefaultCMapReaderFactory = DefaultCMapReaderFactory;\nconst DefaultFilterFactory = _util.isNodeJS ? _displayNode_utils.NodeFilterFactory : _display_utils.DOMFilterFactory;\nexports.DefaultFilterFactory = DefaultFilterFactory;\nconst DefaultStandardFontDataFactory = _util.isNodeJS ? _displayNode_utils.NodeStandardFontDataFactory : _display_utils.DOMStandardFontDataFactory;\nexports.DefaultStandardFontDataFactory = DefaultStandardFontDataFactory;\nfunction getDocument(src) {\n  if (typeof src === \"string\" || src instanceof URL) {\n    src = {\n      url: src\n    };\n  } else if ((0, _util.isArrayBuffer)(src)) {\n    src = {\n      data: src\n    };\n  }\n  if (typeof src !== \"object\") {\n    throw new Error(\"Invalid parameter in getDocument, need parameter object.\");\n  }\n  if (!src.url && !src.data && !src.range) {\n    throw new Error(\"Invalid parameter object: need either .data, .range or .url\");\n  }\n  const task = new PDFDocumentLoadingTask();\n  const {\n    docId\n  } = task;\n  const url = src.url ? getUrlProp(src.url) : null;\n  const data = src.data ? getDataProp(src.data) : null;\n  const httpHeaders = src.httpHeaders || null;\n  const withCredentials = src.withCredentials === true;\n  const password = src.password ?? null;\n  const rangeTransport = src.range instanceof PDFDataRangeTransport ? src.range : null;\n  const rangeChunkSize = Number.isInteger(src.rangeChunkSize) && src.rangeChunkSize > 0 ? src.rangeChunkSize : DEFAULT_RANGE_CHUNK_SIZE;\n  let worker = src.worker instanceof PDFWorker ? src.worker : null;\n  const verbosity = src.verbosity;\n  const docBaseUrl = typeof src.docBaseUrl === \"string\" && !(0, _display_utils.isDataScheme)(src.docBaseUrl) ? src.docBaseUrl : null;\n  const cMapUrl = typeof src.cMapUrl === \"string\" ? src.cMapUrl : null;\n  const cMapPacked = src.cMapPacked !== false;\n  const CMapReaderFactory = src.CMapReaderFactory || DefaultCMapReaderFactory;\n  const standardFontDataUrl = typeof src.standardFontDataUrl === \"string\" ? src.standardFontDataUrl : null;\n  const StandardFontDataFactory = src.StandardFontDataFactory || DefaultStandardFontDataFactory;\n  const ignoreErrors = src.stopAtErrors !== true;\n  const maxImageSize = Number.isInteger(src.maxImageSize) && src.maxImageSize > -1 ? src.maxImageSize : -1;\n  const isEvalSupported = src.isEvalSupported !== false;\n  const isOffscreenCanvasSupported = typeof src.isOffscreenCanvasSupported === \"boolean\" ? src.isOffscreenCanvasSupported : !_util.isNodeJS;\n  const canvasMaxAreaInBytes = Number.isInteger(src.canvasMaxAreaInBytes) ? src.canvasMaxAreaInBytes : -1;\n  const disableFontFace = typeof src.disableFontFace === \"boolean\" ? src.disableFontFace : _util.isNodeJS;\n  const fontExtraProperties = src.fontExtraProperties === true;\n  const enableXfa = src.enableXfa === true;\n  const ownerDocument = src.ownerDocument || globalThis.document;\n  const disableRange = src.disableRange === true;\n  const disableStream = src.disableStream === true;\n  const disableAutoFetch = src.disableAutoFetch === true;\n  const pdfBug = src.pdfBug === true;\n  const length = rangeTransport ? rangeTransport.length : src.length ?? NaN;\n  const useSystemFonts = typeof src.useSystemFonts === \"boolean\" ? src.useSystemFonts : !_util.isNodeJS && !disableFontFace;\n  const useWorkerFetch = typeof src.useWorkerFetch === \"boolean\" ? src.useWorkerFetch : CMapReaderFactory === _display_utils.DOMCMapReaderFactory && StandardFontDataFactory === _display_utils.DOMStandardFontDataFactory && cMapUrl && standardFontDataUrl && (0, _display_utils.isValidFetchUrl)(cMapUrl, document.baseURI) && (0, _display_utils.isValidFetchUrl)(standardFontDataUrl, document.baseURI);\n  const canvasFactory = src.canvasFactory || new DefaultCanvasFactory({\n    ownerDocument\n  });\n  const filterFactory = src.filterFactory || new DefaultFilterFactory({\n    docId,\n    ownerDocument\n  });\n  const styleElement = null;\n  (0, _util.setVerbosityLevel)(verbosity);\n  const transportFactory = {\n    canvasFactory,\n    filterFactory\n  };\n  if (!useWorkerFetch) {\n    transportFactory.cMapReaderFactory = new CMapReaderFactory({\n      baseUrl: cMapUrl,\n      isCompressed: cMapPacked\n    });\n    transportFactory.standardFontDataFactory = new StandardFontDataFactory({\n      baseUrl: standardFontDataUrl\n    });\n  }\n  if (!worker) {\n    const workerParams = {\n      verbosity,\n      port: _worker_options.GlobalWorkerOptions.workerPort\n    };\n    worker = workerParams.port ? PDFWorker.fromPort(workerParams) : new PDFWorker(workerParams);\n    task._worker = worker;\n  }\n  const fetchDocParams = {\n    docId,\n    apiVersion: '3.11.174',\n    data,\n    password,\n    disableAutoFetch,\n    rangeChunkSize,\n    length,\n    docBaseUrl,\n    enableXfa,\n    evaluatorOptions: {\n      maxImageSize,\n      disableFontFace,\n      ignoreErrors,\n      isEvalSupported,\n      isOffscreenCanvasSupported,\n      canvasMaxAreaInBytes,\n      fontExtraProperties,\n      useSystemFonts,\n      cMapUrl: useWorkerFetch ? cMapUrl : null,\n      standardFontDataUrl: useWorkerFetch ? standardFontDataUrl : null\n    }\n  };\n  const transportParams = {\n    ignoreErrors,\n    isEvalSupported,\n    disableFontFace,\n    fontExtraProperties,\n    enableXfa,\n    ownerDocument,\n    disableAutoFetch,\n    pdfBug,\n    styleElement\n  };\n  worker.promise.then(function () {\n    if (task.destroyed) {\n      throw new Error(\"Loading aborted\");\n    }\n    const workerIdPromise = _fetchDocument(worker, fetchDocParams);\n    const networkStreamPromise = new Promise(function (resolve) {\n      let networkStream;\n      if (rangeTransport) {\n        networkStream = new _transport_stream.PDFDataTransportStream({\n          length,\n          initialData: rangeTransport.initialData,\n          progressiveDone: rangeTransport.progressiveDone,\n          contentDispositionFilename: rangeTransport.contentDispositionFilename,\n          disableRange,\n          disableStream\n        }, rangeTransport);\n      } else if (!data) {\n        const createPDFNetworkStream = params => {\n          if (_util.isNodeJS) {\n            return new _displayNode_stream.PDFNodeStream(params);\n          }\n          return (0, _display_utils.isValidFetchUrl)(params.url) ? new _displayFetch_stream.PDFFetchStream(params) : new _displayNetwork.PDFNetworkStream(params);\n        };\n        networkStream = createPDFNetworkStream({\n          url,\n          length,\n          httpHeaders,\n          withCredentials,\n          rangeChunkSize,\n          disableRange,\n          disableStream\n        });\n      }\n      resolve(networkStream);\n    });\n    return Promise.all([workerIdPromise, networkStreamPromise]).then(function (_ref) {\n      let [workerId, networkStream] = _ref;\n      if (task.destroyed) {\n        throw new Error(\"Loading aborted\");\n      }\n      const messageHandler = new _message_handler.MessageHandler(docId, workerId, worker.port);\n      const transport = new WorkerTransport(messageHandler, task, networkStream, transportParams, transportFactory);\n      task._transport = transport;\n      messageHandler.send(\"Ready\", null);\n    });\n  }).catch(task._capability.reject);\n  return task;\n}\nasync function _fetchDocument(worker, source) {\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n  const workerId = await worker.messageHandler.sendWithPromise(\"GetDocRequest\", source, source.data ? [source.data.buffer] : null);\n  if (worker.destroyed) {\n    throw new Error(\"Worker was destroyed\");\n  }\n  return workerId;\n}\nfunction getUrlProp(val) {\n  if (val instanceof URL) {\n    return val.href;\n  }\n  try {\n    return new URL(val, window.location).href;\n  } catch {\n    if (_util.isNodeJS && typeof val === \"string\") {\n      return val;\n    }\n  }\n  throw new Error(\"Invalid PDF url data: \" + \"either string or URL-object is expected in the url property.\");\n}\nfunction getDataProp(val) {\n  if (_util.isNodeJS && typeof Buffer !== \"undefined\" && val instanceof Buffer) {\n    throw new Error(\"Please provide binary data as `Uint8Array`, rather than `Buffer`.\");\n  }\n  if (val instanceof Uint8Array && val.byteLength === val.buffer.byteLength) {\n    return val;\n  }\n  if (typeof val === \"string\") {\n    return (0, _util.stringToBytes)(val);\n  }\n  if (typeof val === \"object\" && !isNaN(val?.length) || (0, _util.isArrayBuffer)(val)) {\n    return new Uint8Array(val);\n  }\n  throw new Error(\"Invalid PDF binary data: either TypedArray, \" + \"string, or array-like object is expected in the data property.\");\n}\nclass PDFDocumentLoadingTask {\n  static #docId = 0;\n  constructor() {\n    this._capability = new _util.PromiseCapability();\n    this._transport = null;\n    this._worker = null;\n    this.docId = `d${PDFDocumentLoadingTask.#docId++}`;\n    this.destroyed = false;\n    this.onPassword = null;\n    this.onProgress = null;\n  }\n  get promise() {\n    return this._capability.promise;\n  }\n  async destroy() {\n    this.destroyed = true;\n    try {\n      if (this._worker?.port) {\n        this._worker._pendingDestroy = true;\n      }\n      await this._transport?.destroy();\n    } catch (ex) {\n      if (this._worker?.port) {\n        delete this._worker._pendingDestroy;\n      }\n      throw ex;\n    }\n    this._transport = null;\n    if (this._worker) {\n      this._worker.destroy();\n      this._worker = null;\n    }\n  }\n}\nexports.PDFDocumentLoadingTask = PDFDocumentLoadingTask;\nclass PDFDataRangeTransport {\n  constructor(length, initialData) {\n    let progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this.length = length;\n    this.initialData = initialData;\n    this.progressiveDone = progressiveDone;\n    this.contentDispositionFilename = contentDispositionFilename;\n    this._rangeListeners = [];\n    this._progressListeners = [];\n    this._progressiveReadListeners = [];\n    this._progressiveDoneListeners = [];\n    this._readyCapability = new _util.PromiseCapability();\n  }\n  addRangeListener(listener) {\n    this._rangeListeners.push(listener);\n  }\n  addProgressListener(listener) {\n    this._progressListeners.push(listener);\n  }\n  addProgressiveReadListener(listener) {\n    this._progressiveReadListeners.push(listener);\n  }\n  addProgressiveDoneListener(listener) {\n    this._progressiveDoneListeners.push(listener);\n  }\n  onDataRange(begin, chunk) {\n    for (const listener of this._rangeListeners) {\n      listener(begin, chunk);\n    }\n  }\n  onDataProgress(loaded, total) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressListeners) {\n        listener(loaded, total);\n      }\n    });\n  }\n  onDataProgressiveRead(chunk) {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveReadListeners) {\n        listener(chunk);\n      }\n    });\n  }\n  onDataProgressiveDone() {\n    this._readyCapability.promise.then(() => {\n      for (const listener of this._progressiveDoneListeners) {\n        listener();\n      }\n    });\n  }\n  transportReady() {\n    this._readyCapability.resolve();\n  }\n  requestDataRange(begin, end) {\n    (0, _util.unreachable)(\"Abstract method PDFDataRangeTransport.requestDataRange\");\n  }\n  abort() {}\n}\nexports.PDFDataRangeTransport = PDFDataRangeTransport;\nclass PDFDocumentProxy {\n  constructor(pdfInfo, transport) {\n    this._pdfInfo = pdfInfo;\n    this._transport = transport;\n    Object.defineProperty(this, \"getJavaScript\", {\n      value: () => {\n        (0, _display_utils.deprecated)(\"`PDFDocumentProxy.getJavaScript`, \" + \"please use `PDFDocumentProxy.getJSActions` instead.\");\n        return this.getJSActions().then(js => {\n          if (!js) {\n            return js;\n          }\n          const jsArr = [];\n          for (const name in js) {\n            jsArr.push(...js[name]);\n          }\n          return jsArr;\n        });\n      }\n    });\n  }\n  get annotationStorage() {\n    return this._transport.annotationStorage;\n  }\n  get filterFactory() {\n    return this._transport.filterFactory;\n  }\n  get numPages() {\n    return this._pdfInfo.numPages;\n  }\n  get fingerprints() {\n    return this._pdfInfo.fingerprints;\n  }\n  get isPureXfa() {\n    return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n  }\n  get allXfaHtml() {\n    return this._transport._htmlForXfa;\n  }\n  getPage(pageNumber) {\n    return this._transport.getPage(pageNumber);\n  }\n  getPageIndex(ref) {\n    return this._transport.getPageIndex(ref);\n  }\n  getDestinations() {\n    return this._transport.getDestinations();\n  }\n  getDestination(id) {\n    return this._transport.getDestination(id);\n  }\n  getPageLabels() {\n    return this._transport.getPageLabels();\n  }\n  getPageLayout() {\n    return this._transport.getPageLayout();\n  }\n  getPageMode() {\n    return this._transport.getPageMode();\n  }\n  getViewerPreferences() {\n    return this._transport.getViewerPreferences();\n  }\n  getOpenAction() {\n    return this._transport.getOpenAction();\n  }\n  getAttachments() {\n    return this._transport.getAttachments();\n  }\n  getJSActions() {\n    return this._transport.getDocJSActions();\n  }\n  getOutline() {\n    return this._transport.getOutline();\n  }\n  getOptionalContentConfig() {\n    return this._transport.getOptionalContentConfig();\n  }\n  getPermissions() {\n    return this._transport.getPermissions();\n  }\n  getMetadata() {\n    return this._transport.getMetadata();\n  }\n  getMarkInfo() {\n    return this._transport.getMarkInfo();\n  }\n  getData() {\n    return this._transport.getData();\n  }\n  saveDocument() {\n    return this._transport.saveDocument();\n  }\n  getDownloadInfo() {\n    return this._transport.downloadInfoCapability.promise;\n  }\n  cleanup() {\n    let keepLoadedFonts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    return this._transport.startCleanup(keepLoadedFonts || this.isPureXfa);\n  }\n  destroy() {\n    return this.loadingTask.destroy();\n  }\n  get loadingParams() {\n    return this._transport.loadingParams;\n  }\n  get loadingTask() {\n    return this._transport.loadingTask;\n  }\n  getFieldObjects() {\n    return this._transport.getFieldObjects();\n  }\n  hasJSActions() {\n    return this._transport.hasJSActions();\n  }\n  getCalculationOrderIds() {\n    return this._transport.getCalculationOrderIds();\n  }\n}\nexports.PDFDocumentProxy = PDFDocumentProxy;\nclass PDFPageProxy {\n  #delayedCleanupTimeout = null;\n  #pendingCleanup = false;\n  constructor(pageIndex, pageInfo, transport) {\n    let pdfBug = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    this._pageIndex = pageIndex;\n    this._pageInfo = pageInfo;\n    this._transport = transport;\n    this._stats = pdfBug ? new _display_utils.StatTimer() : null;\n    this._pdfBug = pdfBug;\n    this.commonObjs = transport.commonObjs;\n    this.objs = new PDFObjects();\n    this._maybeCleanupAfterRender = false;\n    this._intentStates = new Map();\n    this.destroyed = false;\n  }\n  get pageNumber() {\n    return this._pageIndex + 1;\n  }\n  get rotate() {\n    return this._pageInfo.rotate;\n  }\n  get ref() {\n    return this._pageInfo.ref;\n  }\n  get userUnit() {\n    return this._pageInfo.userUnit;\n  }\n  get view() {\n    return this._pageInfo.view;\n  }\n  getViewport() {\n    let {\n      scale,\n      rotation = this.rotate,\n      offsetX = 0,\n      offsetY = 0,\n      dontFlip = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new _display_utils.PageViewport({\n      viewBox: this.view,\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n  getAnnotations() {\n    let {\n      intent = \"display\"\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const intentArgs = this._transport.getRenderingIntent(intent);\n    return this._transport.getAnnotations(this._pageIndex, intentArgs.renderingIntent);\n  }\n  getJSActions() {\n    return this._transport.getPageJSActions(this._pageIndex);\n  }\n  get filterFactory() {\n    return this._transport.filterFactory;\n  }\n  get isPureXfa() {\n    return (0, _util.shadow)(this, \"isPureXfa\", !!this._transport._htmlForXfa);\n  }\n  async getXfa() {\n    return this._transport._htmlForXfa?.children[this._pageIndex] || null;\n  }\n  render(_ref2) {\n    let {\n      canvasContext,\n      viewport,\n      intent = \"display\",\n      annotationMode = _util.AnnotationMode.ENABLE,\n      transform = null,\n      background = null,\n      optionalContentConfigPromise = null,\n      annotationCanvasMap = null,\n      pageColors = null,\n      printAnnotationStorage = null\n    } = _ref2;\n    this._stats?.time(\"Overall\");\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage);\n    this.#pendingCleanup = false;\n    this.#abortDelayedCleanup();\n    if (!optionalContentConfigPromise) {\n      optionalContentConfigPromise = this._transport.getOptionalContentConfig();\n    }\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n    const intentPrint = !!(intentArgs.renderingIntent & _util.RenderingIntentFlag.PRINT);\n    if (!intentState.displayReadyCapability) {\n      intentState.displayReadyCapability = new _util.PromiseCapability();\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n      this._stats?.time(\"Page Request\");\n      this._pumpOperatorList(intentArgs);\n    }\n    const complete = error => {\n      intentState.renderTasks.delete(internalRenderTask);\n      if (this._maybeCleanupAfterRender || intentPrint) {\n        this.#pendingCleanup = true;\n      }\n      this.#tryCleanup(!intentPrint);\n      if (error) {\n        internalRenderTask.capability.reject(error);\n        this._abortOperatorList({\n          intentState,\n          reason: error instanceof Error ? error : new Error(error)\n        });\n      } else {\n        internalRenderTask.capability.resolve();\n      }\n      this._stats?.timeEnd(\"Rendering\");\n      this._stats?.timeEnd(\"Overall\");\n    };\n    const internalRenderTask = new InternalRenderTask({\n      callback: complete,\n      params: {\n        canvasContext,\n        viewport,\n        transform,\n        background\n      },\n      objs: this.objs,\n      commonObjs: this.commonObjs,\n      annotationCanvasMap,\n      operatorList: intentState.operatorList,\n      pageIndex: this._pageIndex,\n      canvasFactory: this._transport.canvasFactory,\n      filterFactory: this._transport.filterFactory,\n      useRequestAnimationFrame: !intentPrint,\n      pdfBug: this._pdfBug,\n      pageColors\n    });\n    (intentState.renderTasks ||= new Set()).add(internalRenderTask);\n    const renderTask = internalRenderTask.task;\n    Promise.all([intentState.displayReadyCapability.promise, optionalContentConfigPromise]).then(_ref3 => {\n      let [transparency, optionalContentConfig] = _ref3;\n      if (this.destroyed) {\n        complete();\n        return;\n      }\n      this._stats?.time(\"Rendering\");\n      internalRenderTask.initializeGraphics({\n        transparency,\n        optionalContentConfig\n      });\n      internalRenderTask.operatorListChanged();\n    }).catch(complete);\n    return renderTask;\n  }\n  getOperatorList() {\n    let {\n      intent = \"display\",\n      annotationMode = _util.AnnotationMode.ENABLE,\n      printAnnotationStorage = null\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    function operatorListChanged() {\n      if (intentState.operatorList.lastChunk) {\n        intentState.opListReadCapability.resolve(intentState.operatorList);\n        intentState.renderTasks.delete(opListTask);\n      }\n    }\n    const intentArgs = this._transport.getRenderingIntent(intent, annotationMode, printAnnotationStorage, true);\n    let intentState = this._intentStates.get(intentArgs.cacheKey);\n    if (!intentState) {\n      intentState = Object.create(null);\n      this._intentStates.set(intentArgs.cacheKey, intentState);\n    }\n    let opListTask;\n    if (!intentState.opListReadCapability) {\n      opListTask = Object.create(null);\n      opListTask.operatorListChanged = operatorListChanged;\n      intentState.opListReadCapability = new _util.PromiseCapability();\n      (intentState.renderTasks ||= new Set()).add(opListTask);\n      intentState.operatorList = {\n        fnArray: [],\n        argsArray: [],\n        lastChunk: false,\n        separateAnnots: null\n      };\n      this._stats?.time(\"Page Request\");\n      this._pumpOperatorList(intentArgs);\n    }\n    return intentState.opListReadCapability.promise;\n  }\n  streamTextContent() {\n    let {\n      includeMarkedContent = false,\n      disableNormalization = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    const TEXT_CONTENT_CHUNK_SIZE = 100;\n    return this._transport.messageHandler.sendWithStream(\"GetTextContent\", {\n      pageIndex: this._pageIndex,\n      includeMarkedContent: includeMarkedContent === true,\n      disableNormalization: disableNormalization === true\n    }, {\n      highWaterMark: TEXT_CONTENT_CHUNK_SIZE,\n      size(textContent) {\n        return textContent.items.length;\n      }\n    });\n  }\n  getTextContent() {\n    let params = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    if (this._transport._htmlForXfa) {\n      return this.getXfa().then(xfa => {\n        return _xfa_text.XfaText.textContent(xfa);\n      });\n    }\n    const readableStream = this.streamTextContent(params);\n    return new Promise(function (resolve, reject) {\n      function pump() {\n        reader.read().then(function (_ref4) {\n          let {\n            value,\n            done\n          } = _ref4;\n          if (done) {\n            resolve(textContent);\n            return;\n          }\n          Object.assign(textContent.styles, value.styles);\n          textContent.items.push(...value.items);\n          pump();\n        }, reject);\n      }\n      const reader = readableStream.getReader();\n      const textContent = {\n        items: [],\n        styles: Object.create(null)\n      };\n      pump();\n    });\n  }\n  getStructTree() {\n    return this._transport.getStructTree(this._pageIndex);\n  }\n  _destroy() {\n    this.destroyed = true;\n    const waitOn = [];\n    for (const intentState of this._intentStates.values()) {\n      this._abortOperatorList({\n        intentState,\n        reason: new Error(\"Page was destroyed.\"),\n        force: true\n      });\n      if (intentState.opListReadCapability) {\n        continue;\n      }\n      for (const internalRenderTask of intentState.renderTasks) {\n        waitOn.push(internalRenderTask.completed);\n        internalRenderTask.cancel();\n      }\n    }\n    this.objs.clear();\n    this.#pendingCleanup = false;\n    this.#abortDelayedCleanup();\n    return Promise.all(waitOn);\n  }\n  cleanup() {\n    let resetStats = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.#pendingCleanup = true;\n    const success = this.#tryCleanup(false);\n    if (resetStats && success) {\n      this._stats &&= new _display_utils.StatTimer();\n    }\n    return success;\n  }\n  #tryCleanup() {\n    let delayed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.#abortDelayedCleanup();\n    if (!this.#pendingCleanup || this.destroyed) {\n      return false;\n    }\n    if (delayed) {\n      this.#delayedCleanupTimeout = setTimeout(() => {\n        this.#delayedCleanupTimeout = null;\n        this.#tryCleanup(false);\n      }, DELAYED_CLEANUP_TIMEOUT);\n      return false;\n    }\n    for (const {\n      renderTasks,\n      operatorList\n    } of this._intentStates.values()) {\n      if (renderTasks.size > 0 || !operatorList.lastChunk) {\n        return false;\n      }\n    }\n    this._intentStates.clear();\n    this.objs.clear();\n    this.#pendingCleanup = false;\n    return true;\n  }\n  #abortDelayedCleanup() {\n    if (this.#delayedCleanupTimeout) {\n      clearTimeout(this.#delayedCleanupTimeout);\n      this.#delayedCleanupTimeout = null;\n    }\n  }\n  _startRenderPage(transparency, cacheKey) {\n    const intentState = this._intentStates.get(cacheKey);\n    if (!intentState) {\n      return;\n    }\n    this._stats?.timeEnd(\"Page Request\");\n    intentState.displayReadyCapability?.resolve(transparency);\n  }\n  _renderPageChunk(operatorListChunk, intentState) {\n    for (let i = 0, ii = operatorListChunk.length; i < ii; i++) {\n      intentState.operatorList.fnArray.push(operatorListChunk.fnArray[i]);\n      intentState.operatorList.argsArray.push(operatorListChunk.argsArray[i]);\n    }\n    intentState.operatorList.lastChunk = operatorListChunk.lastChunk;\n    intentState.operatorList.separateAnnots = operatorListChunk.separateAnnots;\n    for (const internalRenderTask of intentState.renderTasks) {\n      internalRenderTask.operatorListChanged();\n    }\n    if (operatorListChunk.lastChunk) {\n      this.#tryCleanup(true);\n    }\n  }\n  _pumpOperatorList(_ref5) {\n    let {\n      renderingIntent,\n      cacheKey,\n      annotationStorageSerializable\n    } = _ref5;\n    const {\n      map,\n      transfers\n    } = annotationStorageSerializable;\n    const readableStream = this._transport.messageHandler.sendWithStream(\"GetOperatorList\", {\n      pageIndex: this._pageIndex,\n      intent: renderingIntent,\n      cacheKey,\n      annotationStorage: map\n    }, transfers);\n    const reader = readableStream.getReader();\n    const intentState = this._intentStates.get(cacheKey);\n    intentState.streamReader = reader;\n    const pump = () => {\n      reader.read().then(_ref6 => {\n        let {\n          value,\n          done\n        } = _ref6;\n        if (done) {\n          intentState.streamReader = null;\n          return;\n        }\n        if (this._transport.destroyed) {\n          return;\n        }\n        this._renderPageChunk(value, intentState);\n        pump();\n      }, reason => {\n        intentState.streamReader = null;\n        if (this._transport.destroyed) {\n          return;\n        }\n        if (intentState.operatorList) {\n          intentState.operatorList.lastChunk = true;\n          for (const internalRenderTask of intentState.renderTasks) {\n            internalRenderTask.operatorListChanged();\n          }\n          this.#tryCleanup(true);\n        }\n        if (intentState.displayReadyCapability) {\n          intentState.displayReadyCapability.reject(reason);\n        } else if (intentState.opListReadCapability) {\n          intentState.opListReadCapability.reject(reason);\n        } else {\n          throw reason;\n        }\n      });\n    };\n    pump();\n  }\n  _abortOperatorList(_ref7) {\n    let {\n      intentState,\n      reason,\n      force = false\n    } = _ref7;\n    if (!intentState.streamReader) {\n      return;\n    }\n    if (intentState.streamReaderCancelTimeout) {\n      clearTimeout(intentState.streamReaderCancelTimeout);\n      intentState.streamReaderCancelTimeout = null;\n    }\n    if (!force) {\n      if (intentState.renderTasks.size > 0) {\n        return;\n      }\n      if (reason instanceof _display_utils.RenderingCancelledException) {\n        let delay = RENDERING_CANCELLED_TIMEOUT;\n        if (reason.extraDelay > 0 && reason.extraDelay < 1000) {\n          delay += reason.extraDelay;\n        }\n        intentState.streamReaderCancelTimeout = setTimeout(() => {\n          intentState.streamReaderCancelTimeout = null;\n          this._abortOperatorList({\n            intentState,\n            reason,\n            force: true\n          });\n        }, delay);\n        return;\n      }\n    }\n    intentState.streamReader.cancel(new _util.AbortException(reason.message)).catch(() => {});\n    intentState.streamReader = null;\n    if (this._transport.destroyed) {\n      return;\n    }\n    for (const [curCacheKey, curIntentState] of this._intentStates) {\n      if (curIntentState === intentState) {\n        this._intentStates.delete(curCacheKey);\n        break;\n      }\n    }\n    this.cleanup();\n  }\n  get stats() {\n    return this._stats;\n  }\n}\nexports.PDFPageProxy = PDFPageProxy;\nclass LoopbackPort {\n  #listeners = new Set();\n  #deferred = Promise.resolve();\n  postMessage(obj, transfer) {\n    const event = {\n      data: structuredClone(obj, null)\n    };\n    this.#deferred.then(() => {\n      for (const listener of this.#listeners) {\n        listener.call(this, event);\n      }\n    });\n  }\n  addEventListener(name, listener) {\n    this.#listeners.add(listener);\n  }\n  removeEventListener(name, listener) {\n    this.#listeners.delete(listener);\n  }\n  terminate() {\n    this.#listeners.clear();\n  }\n}\nexports.LoopbackPort = LoopbackPort;\nconst PDFWorkerUtil = {\n  isWorkerDisabled: false,\n  fallbackWorkerSrc: null,\n  fakeWorkerId: 0\n};\nexports.PDFWorkerUtil = PDFWorkerUtil;\n{\n  if (_util.isNodeJS && \"function\" === \"function\") {\n    PDFWorkerUtil.isWorkerDisabled = true;\n    PDFWorkerUtil.fallbackWorkerSrc = \"./pdf.worker.js\";\n  } else if (typeof document === \"object\") {\n    const pdfjsFilePath = document?.currentScript?.src;\n    if (pdfjsFilePath) {\n      PDFWorkerUtil.fallbackWorkerSrc = pdfjsFilePath.replace(/(\\.(?:min\\.)?js)(\\?.*)?$/i, \".worker$1$2\");\n    }\n  }\n  PDFWorkerUtil.isSameOrigin = function (baseUrl, otherUrl) {\n    let base;\n    try {\n      base = new URL(baseUrl);\n      if (!base.origin || base.origin === \"null\") {\n        return false;\n      }\n    } catch {\n      return false;\n    }\n    const other = new URL(otherUrl, base);\n    return base.origin === other.origin;\n  };\n  PDFWorkerUtil.createCDNWrapper = function (url) {\n    const wrapper = `importScripts(\"${url}\");`;\n    return URL.createObjectURL(new Blob([wrapper]));\n  };\n}\nclass PDFWorker {\n  static #workerPorts;\n  constructor() {\n    let {\n      name = null,\n      port = null,\n      verbosity = (0, _util.getVerbosityLevel)()\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    this.name = name;\n    this.destroyed = false;\n    this.verbosity = verbosity;\n    this._readyCapability = new _util.PromiseCapability();\n    this._port = null;\n    this._webWorker = null;\n    this._messageHandler = null;\n    if (port) {\n      if (PDFWorker.#workerPorts?.has(port)) {\n        throw new Error(\"Cannot use more than one PDFWorker per port.\");\n      }\n      (PDFWorker.#workerPorts ||= new WeakMap()).set(port, this);\n      this._initializeFromPort(port);\n      return;\n    }\n    this._initialize();\n  }\n  get promise() {\n    return this._readyCapability.promise;\n  }\n  get port() {\n    return this._port;\n  }\n  get messageHandler() {\n    return this._messageHandler;\n  }\n  _initializeFromPort(port) {\n    this._port = port;\n    this._messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", port);\n    this._messageHandler.on(\"ready\", function () {});\n    this._readyCapability.resolve();\n    this._messageHandler.send(\"configure\", {\n      verbosity: this.verbosity\n    });\n  }\n  _initialize() {\n    if (!PDFWorkerUtil.isWorkerDisabled && !PDFWorker._mainThreadWorkerMessageHandler) {\n      let {\n        workerSrc\n      } = PDFWorker;\n      try {\n        if (!PDFWorkerUtil.isSameOrigin(window.location.href, workerSrc)) {\n          workerSrc = PDFWorkerUtil.createCDNWrapper(new URL(workerSrc, window.location).href);\n        }\n        const worker = new Worker(workerSrc);\n        const messageHandler = new _message_handler.MessageHandler(\"main\", \"worker\", worker);\n        const terminateEarly = () => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          messageHandler.destroy();\n          worker.terminate();\n          if (this.destroyed) {\n            this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n          } else {\n            this._setupFakeWorker();\n          }\n        };\n        const onWorkerError = () => {\n          if (!this._webWorker) {\n            terminateEarly();\n          }\n        };\n        worker.addEventListener(\"error\", onWorkerError);\n        messageHandler.on(\"test\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n          if (data) {\n            this._messageHandler = messageHandler;\n            this._port = worker;\n            this._webWorker = worker;\n            this._readyCapability.resolve();\n            messageHandler.send(\"configure\", {\n              verbosity: this.verbosity\n            });\n          } else {\n            this._setupFakeWorker();\n            messageHandler.destroy();\n            worker.terminate();\n          }\n        });\n        messageHandler.on(\"ready\", data => {\n          worker.removeEventListener(\"error\", onWorkerError);\n          if (this.destroyed) {\n            terminateEarly();\n            return;\n          }\n          try {\n            sendTest();\n          } catch {\n            this._setupFakeWorker();\n          }\n        });\n        const sendTest = () => {\n          const testObj = new Uint8Array();\n          messageHandler.send(\"test\", testObj, [testObj.buffer]);\n        };\n        sendTest();\n        return;\n      } catch {\n        (0, _util.info)(\"The worker has been disabled.\");\n      }\n    }\n    this._setupFakeWorker();\n  }\n  _setupFakeWorker() {\n    if (!PDFWorkerUtil.isWorkerDisabled) {\n      (0, _util.warn)(\"Setting up fake worker.\");\n      PDFWorkerUtil.isWorkerDisabled = true;\n    }\n    PDFWorker._setupFakeWorkerGlobal.then(WorkerMessageHandler => {\n      if (this.destroyed) {\n        this._readyCapability.reject(new Error(\"Worker was destroyed\"));\n        return;\n      }\n      const port = new LoopbackPort();\n      this._port = port;\n      const id = `fake${PDFWorkerUtil.fakeWorkerId++}`;\n      const workerHandler = new _message_handler.MessageHandler(id + \"_worker\", id, port);\n      WorkerMessageHandler.setup(workerHandler, port);\n      const messageHandler = new _message_handler.MessageHandler(id, id + \"_worker\", port);\n      this._messageHandler = messageHandler;\n      this._readyCapability.resolve();\n      messageHandler.send(\"configure\", {\n        verbosity: this.verbosity\n      });\n    }).catch(reason => {\n      this._readyCapability.reject(new Error(`Setting up fake worker failed: \"${reason.message}\".`));\n    });\n  }\n  destroy() {\n    this.destroyed = true;\n    if (this._webWorker) {\n      this._webWorker.terminate();\n      this._webWorker = null;\n    }\n    PDFWorker.#workerPorts?.delete(this._port);\n    this._port = null;\n    if (this._messageHandler) {\n      this._messageHandler.destroy();\n      this._messageHandler = null;\n    }\n  }\n  static fromPort(params) {\n    if (!params?.port) {\n      throw new Error(\"PDFWorker.fromPort - invalid method signature.\");\n    }\n    const cachedPort = this.#workerPorts?.get(params.port);\n    if (cachedPort) {\n      if (cachedPort._pendingDestroy) {\n        throw new Error(\"PDFWorker.fromPort - the worker is being destroyed.\\n\" + \"Please remember to await `PDFDocumentLoadingTask.destroy()`-calls.\");\n      }\n      return cachedPort;\n    }\n    return new PDFWorker(params);\n  }\n  static get workerSrc() {\n    if (_worker_options.GlobalWorkerOptions.workerSrc) {\n      return _worker_options.GlobalWorkerOptions.workerSrc;\n    }\n    if (PDFWorkerUtil.fallbackWorkerSrc !== null) {\n      if (!_util.isNodeJS) {\n        (0, _display_utils.deprecated)('No \"GlobalWorkerOptions.workerSrc\" specified.');\n      }\n      return PDFWorkerUtil.fallbackWorkerSrc;\n    }\n    throw new Error('No \"GlobalWorkerOptions.workerSrc\" specified.');\n  }\n  static get _mainThreadWorkerMessageHandler() {\n    try {\n      return globalThis.pdfjsWorker?.WorkerMessageHandler || null;\n    } catch {\n      return null;\n    }\n  }\n  static get _setupFakeWorkerGlobal() {\n    const loader = async () => {\n      const mainWorkerMessageHandler = this._mainThreadWorkerMessageHandler;\n      if (mainWorkerMessageHandler) {\n        return mainWorkerMessageHandler;\n      }\n      if (_util.isNodeJS && \"function\" === \"function\") {\n        const worker = eval(\"require\")(this.workerSrc);\n        return worker.WorkerMessageHandler;\n      }\n      await (0, _display_utils.loadScript)(this.workerSrc);\n      return window.pdfjsWorker.WorkerMessageHandler;\n    };\n    return (0, _util.shadow)(this, \"_setupFakeWorkerGlobal\", loader());\n  }\n}\nexports.PDFWorker = PDFWorker;\nclass WorkerTransport {\n  #methodPromises = new Map();\n  #pageCache = new Map();\n  #pagePromises = new Map();\n  #passwordCapability = null;\n  constructor(messageHandler, loadingTask, networkStream, params, factory) {\n    this.messageHandler = messageHandler;\n    this.loadingTask = loadingTask;\n    this.commonObjs = new PDFObjects();\n    this.fontLoader = new _font_loader.FontLoader({\n      ownerDocument: params.ownerDocument,\n      styleElement: params.styleElement\n    });\n    this._params = params;\n    this.canvasFactory = factory.canvasFactory;\n    this.filterFactory = factory.filterFactory;\n    this.cMapReaderFactory = factory.cMapReaderFactory;\n    this.standardFontDataFactory = factory.standardFontDataFactory;\n    this.destroyed = false;\n    this.destroyCapability = null;\n    this._networkStream = networkStream;\n    this._fullReader = null;\n    this._lastProgress = null;\n    this.downloadInfoCapability = new _util.PromiseCapability();\n    this.setupMessageHandler();\n  }\n  #cacheSimpleMethod(name) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const cachedPromise = this.#methodPromises.get(name);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(name, data);\n    this.#methodPromises.set(name, promise);\n    return promise;\n  }\n  get annotationStorage() {\n    return (0, _util.shadow)(this, \"annotationStorage\", new _annotation_storage.AnnotationStorage());\n  }\n  getRenderingIntent(intent) {\n    let annotationMode = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : _util.AnnotationMode.ENABLE;\n    let printAnnotationStorage = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;\n    let isOpList = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : false;\n    let renderingIntent = _util.RenderingIntentFlag.DISPLAY;\n    let annotationStorageSerializable = _annotation_storage.SerializableEmpty;\n    switch (intent) {\n      case \"any\":\n        renderingIntent = _util.RenderingIntentFlag.ANY;\n        break;\n      case \"display\":\n        break;\n      case \"print\":\n        renderingIntent = _util.RenderingIntentFlag.PRINT;\n        break;\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid intent: ${intent}`);\n    }\n    switch (annotationMode) {\n      case _util.AnnotationMode.DISABLE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_DISABLE;\n        break;\n      case _util.AnnotationMode.ENABLE:\n        break;\n      case _util.AnnotationMode.ENABLE_FORMS:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_FORMS;\n        break;\n      case _util.AnnotationMode.ENABLE_STORAGE:\n        renderingIntent += _util.RenderingIntentFlag.ANNOTATIONS_STORAGE;\n        const annotationStorage = renderingIntent & _util.RenderingIntentFlag.PRINT && printAnnotationStorage instanceof _annotation_storage.PrintAnnotationStorage ? printAnnotationStorage : this.annotationStorage;\n        annotationStorageSerializable = annotationStorage.serializable;\n        break;\n      default:\n        (0, _util.warn)(`getRenderingIntent - invalid annotationMode: ${annotationMode}`);\n    }\n    if (isOpList) {\n      renderingIntent += _util.RenderingIntentFlag.OPLIST;\n    }\n    return {\n      renderingIntent,\n      cacheKey: `${renderingIntent}_${annotationStorageSerializable.hash}`,\n      annotationStorageSerializable\n    };\n  }\n  destroy() {\n    if (this.destroyCapability) {\n      return this.destroyCapability.promise;\n    }\n    this.destroyed = true;\n    this.destroyCapability = new _util.PromiseCapability();\n    this.#passwordCapability?.reject(new Error(\"Worker was destroyed during onPassword callback\"));\n    const waitOn = [];\n    for (const page of this.#pageCache.values()) {\n      waitOn.push(page._destroy());\n    }\n    this.#pageCache.clear();\n    this.#pagePromises.clear();\n    if (this.hasOwnProperty(\"annotationStorage\")) {\n      this.annotationStorage.resetModified();\n    }\n    const terminated = this.messageHandler.sendWithPromise(\"Terminate\", null);\n    waitOn.push(terminated);\n    Promise.all(waitOn).then(() => {\n      this.commonObjs.clear();\n      this.fontLoader.clear();\n      this.#methodPromises.clear();\n      this.filterFactory.destroy();\n      this._networkStream?.cancelAllRequests(new _util.AbortException(\"Worker was terminated.\"));\n      if (this.messageHandler) {\n        this.messageHandler.destroy();\n        this.messageHandler = null;\n      }\n      this.destroyCapability.resolve();\n    }, this.destroyCapability.reject);\n    return this.destroyCapability.promise;\n  }\n  setupMessageHandler() {\n    const {\n      messageHandler,\n      loadingTask\n    } = this;\n    messageHandler.on(\"GetReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetReader - no `IPDFStream` instance available.\");\n      this._fullReader = this._networkStream.getFullReader();\n      this._fullReader.onProgress = evt => {\n        this._lastProgress = {\n          loaded: evt.loaded,\n          total: evt.total\n        };\n      };\n      sink.onPull = () => {\n        this._fullReader.read().then(function (_ref8) {\n          let {\n            value,\n            done\n          } = _ref8;\n          if (done) {\n            sink.close();\n            return;\n          }\n          (0, _util.assert)(value instanceof ArrayBuffer, \"GetReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n      sink.onCancel = reason => {\n        this._fullReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"ReaderHeadersReady\", data => {\n      const headersCapability = new _util.PromiseCapability();\n      const fullReader = this._fullReader;\n      fullReader.headersReady.then(() => {\n        if (!fullReader.isStreamingSupported || !fullReader.isRangeSupported) {\n          if (this._lastProgress) {\n            loadingTask.onProgress?.(this._lastProgress);\n          }\n          fullReader.onProgress = evt => {\n            loadingTask.onProgress?.({\n              loaded: evt.loaded,\n              total: evt.total\n            });\n          };\n        }\n        headersCapability.resolve({\n          isStreamingSupported: fullReader.isStreamingSupported,\n          isRangeSupported: fullReader.isRangeSupported,\n          contentLength: fullReader.contentLength\n        });\n      }, headersCapability.reject);\n      return headersCapability.promise;\n    });\n    messageHandler.on(\"GetRangeReader\", (data, sink) => {\n      (0, _util.assert)(this._networkStream, \"GetRangeReader - no `IPDFStream` instance available.\");\n      const rangeReader = this._networkStream.getRangeReader(data.begin, data.end);\n      if (!rangeReader) {\n        sink.close();\n        return;\n      }\n      sink.onPull = () => {\n        rangeReader.read().then(function (_ref9) {\n          let {\n            value,\n            done\n          } = _ref9;\n          if (done) {\n            sink.close();\n            return;\n          }\n          (0, _util.assert)(value instanceof ArrayBuffer, \"GetRangeReader - expected an ArrayBuffer.\");\n          sink.enqueue(new Uint8Array(value), 1, [value]);\n        }).catch(reason => {\n          sink.error(reason);\n        });\n      };\n      sink.onCancel = reason => {\n        rangeReader.cancel(reason);\n        sink.ready.catch(readyReason => {\n          if (this.destroyed) {\n            return;\n          }\n          throw readyReason;\n        });\n      };\n    });\n    messageHandler.on(\"GetDoc\", _ref10 => {\n      let {\n        pdfInfo\n      } = _ref10;\n      this._numPages = pdfInfo.numPages;\n      this._htmlForXfa = pdfInfo.htmlForXfa;\n      delete pdfInfo.htmlForXfa;\n      loadingTask._capability.resolve(new PDFDocumentProxy(pdfInfo, this));\n    });\n    messageHandler.on(\"DocException\", function (ex) {\n      let reason;\n      switch (ex.name) {\n        case \"PasswordException\":\n          reason = new _util.PasswordException(ex.message, ex.code);\n          break;\n        case \"InvalidPDFException\":\n          reason = new _util.InvalidPDFException(ex.message);\n          break;\n        case \"MissingPDFException\":\n          reason = new _util.MissingPDFException(ex.message);\n          break;\n        case \"UnexpectedResponseException\":\n          reason = new _util.UnexpectedResponseException(ex.message, ex.status);\n          break;\n        case \"UnknownErrorException\":\n          reason = new _util.UnknownErrorException(ex.message, ex.details);\n          break;\n        default:\n          (0, _util.unreachable)(\"DocException - expected a valid Error.\");\n      }\n      loadingTask._capability.reject(reason);\n    });\n    messageHandler.on(\"PasswordRequest\", exception => {\n      this.#passwordCapability = new _util.PromiseCapability();\n      if (loadingTask.onPassword) {\n        const updatePassword = password => {\n          if (password instanceof Error) {\n            this.#passwordCapability.reject(password);\n          } else {\n            this.#passwordCapability.resolve({\n              password\n            });\n          }\n        };\n        try {\n          loadingTask.onPassword(updatePassword, exception.code);\n        } catch (ex) {\n          this.#passwordCapability.reject(ex);\n        }\n      } else {\n        this.#passwordCapability.reject(new _util.PasswordException(exception.message, exception.code));\n      }\n      return this.#passwordCapability.promise;\n    });\n    messageHandler.on(\"DataLoaded\", data => {\n      loadingTask.onProgress?.({\n        loaded: data.length,\n        total: data.length\n      });\n      this.downloadInfoCapability.resolve(data);\n    });\n    messageHandler.on(\"StartRenderPage\", data => {\n      if (this.destroyed) {\n        return;\n      }\n      const page = this.#pageCache.get(data.pageIndex);\n      page._startRenderPage(data.transparency, data.cacheKey);\n    });\n    messageHandler.on(\"commonobj\", _ref11 => {\n      let [id, type, exportedData] = _ref11;\n      if (this.destroyed) {\n        return;\n      }\n      if (this.commonObjs.has(id)) {\n        return;\n      }\n      switch (type) {\n        case \"Font\":\n          const params = this._params;\n          if (\"error\" in exportedData) {\n            const exportedError = exportedData.error;\n            (0, _util.warn)(`Error during font loading: ${exportedError}`);\n            this.commonObjs.resolve(id, exportedError);\n            break;\n          }\n          const inspectFont = params.pdfBug && globalThis.FontInspector?.enabled ? (font, url) => globalThis.FontInspector.fontAdded(font, url) : null;\n          const font = new _font_loader.FontFaceObject(exportedData, {\n            isEvalSupported: params.isEvalSupported,\n            disableFontFace: params.disableFontFace,\n            ignoreErrors: params.ignoreErrors,\n            inspectFont\n          });\n          this.fontLoader.bind(font).catch(reason => {\n            return messageHandler.sendWithPromise(\"FontFallback\", {\n              id\n            });\n          }).finally(() => {\n            if (!params.fontExtraProperties && font.data) {\n              font.data = null;\n            }\n            this.commonObjs.resolve(id, font);\n          });\n          break;\n        case \"FontPath\":\n        case \"Image\":\n        case \"Pattern\":\n          this.commonObjs.resolve(id, exportedData);\n          break;\n        default:\n          throw new Error(`Got unknown common object type ${type}`);\n      }\n    });\n    messageHandler.on(\"obj\", _ref12 => {\n      let [id, pageIndex, type, imageData] = _ref12;\n      if (this.destroyed) {\n        return;\n      }\n      const pageProxy = this.#pageCache.get(pageIndex);\n      if (pageProxy.objs.has(id)) {\n        return;\n      }\n      switch (type) {\n        case \"Image\":\n          pageProxy.objs.resolve(id, imageData);\n          if (imageData) {\n            let length;\n            if (imageData.bitmap) {\n              const {\n                width,\n                height\n              } = imageData;\n              length = width * height * 4;\n            } else {\n              length = imageData.data?.length || 0;\n            }\n            if (length > _util.MAX_IMAGE_SIZE_TO_CACHE) {\n              pageProxy._maybeCleanupAfterRender = true;\n            }\n          }\n          break;\n        case \"Pattern\":\n          pageProxy.objs.resolve(id, imageData);\n          break;\n        default:\n          throw new Error(`Got unknown object type ${type}`);\n      }\n    });\n    messageHandler.on(\"DocProgress\", data => {\n      if (this.destroyed) {\n        return;\n      }\n      loadingTask.onProgress?.({\n        loaded: data.loaded,\n        total: data.total\n      });\n    });\n    messageHandler.on(\"FetchBuiltInCMap\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n      if (!this.cMapReaderFactory) {\n        return Promise.reject(new Error(\"CMapReaderFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n      return this.cMapReaderFactory.fetch(data);\n    });\n    messageHandler.on(\"FetchStandardFontData\", data => {\n      if (this.destroyed) {\n        return Promise.reject(new Error(\"Worker was destroyed.\"));\n      }\n      if (!this.standardFontDataFactory) {\n        return Promise.reject(new Error(\"StandardFontDataFactory not initialized, see the `useWorkerFetch` parameter.\"));\n      }\n      return this.standardFontDataFactory.fetch(data);\n    });\n  }\n  getData() {\n    return this.messageHandler.sendWithPromise(\"GetData\", null);\n  }\n  saveDocument() {\n    if (this.annotationStorage.size <= 0) {\n      (0, _util.warn)(\"saveDocument called while `annotationStorage` is empty, \" + \"please use the getData-method instead.\");\n    }\n    const {\n      map,\n      transfers\n    } = this.annotationStorage.serializable;\n    return this.messageHandler.sendWithPromise(\"SaveDocument\", {\n      isPureXfa: !!this._htmlForXfa,\n      numPages: this._numPages,\n      annotationStorage: map,\n      filename: this._fullReader?.filename ?? null\n    }, transfers).finally(() => {\n      this.annotationStorage.resetModified();\n    });\n  }\n  getPage(pageNumber) {\n    if (!Number.isInteger(pageNumber) || pageNumber <= 0 || pageNumber > this._numPages) {\n      return Promise.reject(new Error(\"Invalid page request.\"));\n    }\n    const pageIndex = pageNumber - 1,\n      cachedPromise = this.#pagePromises.get(pageIndex);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(\"GetPage\", {\n      pageIndex\n    }).then(pageInfo => {\n      if (this.destroyed) {\n        throw new Error(\"Transport destroyed\");\n      }\n      const page = new PDFPageProxy(pageIndex, pageInfo, this, this._params.pdfBug);\n      this.#pageCache.set(pageIndex, page);\n      return page;\n    });\n    this.#pagePromises.set(pageIndex, promise);\n    return promise;\n  }\n  getPageIndex(ref) {\n    if (typeof ref !== \"object\" || ref === null || !Number.isInteger(ref.num) || ref.num < 0 || !Number.isInteger(ref.gen) || ref.gen < 0) {\n      return Promise.reject(new Error(\"Invalid pageIndex request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetPageIndex\", {\n      num: ref.num,\n      gen: ref.gen\n    });\n  }\n  getAnnotations(pageIndex, intent) {\n    return this.messageHandler.sendWithPromise(\"GetAnnotations\", {\n      pageIndex,\n      intent\n    });\n  }\n  getFieldObjects() {\n    return this.#cacheSimpleMethod(\"GetFieldObjects\");\n  }\n  hasJSActions() {\n    return this.#cacheSimpleMethod(\"HasJSActions\");\n  }\n  getCalculationOrderIds() {\n    return this.messageHandler.sendWithPromise(\"GetCalculationOrderIds\", null);\n  }\n  getDestinations() {\n    return this.messageHandler.sendWithPromise(\"GetDestinations\", null);\n  }\n  getDestination(id) {\n    if (typeof id !== \"string\") {\n      return Promise.reject(new Error(\"Invalid destination request.\"));\n    }\n    return this.messageHandler.sendWithPromise(\"GetDestination\", {\n      id\n    });\n  }\n  getPageLabels() {\n    return this.messageHandler.sendWithPromise(\"GetPageLabels\", null);\n  }\n  getPageLayout() {\n    return this.messageHandler.sendWithPromise(\"GetPageLayout\", null);\n  }\n  getPageMode() {\n    return this.messageHandler.sendWithPromise(\"GetPageMode\", null);\n  }\n  getViewerPreferences() {\n    return this.messageHandler.sendWithPromise(\"GetViewerPreferences\", null);\n  }\n  getOpenAction() {\n    return this.messageHandler.sendWithPromise(\"GetOpenAction\", null);\n  }\n  getAttachments() {\n    return this.messageHandler.sendWithPromise(\"GetAttachments\", null);\n  }\n  getDocJSActions() {\n    return this.#cacheSimpleMethod(\"GetDocJSActions\");\n  }\n  getPageJSActions(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetPageJSActions\", {\n      pageIndex\n    });\n  }\n  getStructTree(pageIndex) {\n    return this.messageHandler.sendWithPromise(\"GetStructTree\", {\n      pageIndex\n    });\n  }\n  getOutline() {\n    return this.messageHandler.sendWithPromise(\"GetOutline\", null);\n  }\n  getOptionalContentConfig() {\n    return this.messageHandler.sendWithPromise(\"GetOptionalContentConfig\", null).then(results => {\n      return new _optional_content_config.OptionalContentConfig(results);\n    });\n  }\n  getPermissions() {\n    return this.messageHandler.sendWithPromise(\"GetPermissions\", null);\n  }\n  getMetadata() {\n    const name = \"GetMetadata\",\n      cachedPromise = this.#methodPromises.get(name);\n    if (cachedPromise) {\n      return cachedPromise;\n    }\n    const promise = this.messageHandler.sendWithPromise(name, null).then(results => {\n      return {\n        info: results[0],\n        metadata: results[1] ? new _metadata.Metadata(results[1]) : null,\n        contentDispositionFilename: this._fullReader?.filename ?? null,\n        contentLength: this._fullReader?.contentLength ?? null\n      };\n    });\n    this.#methodPromises.set(name, promise);\n    return promise;\n  }\n  getMarkInfo() {\n    return this.messageHandler.sendWithPromise(\"GetMarkInfo\", null);\n  }\n  async startCleanup() {\n    let keepLoadedFonts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.destroyed) {\n      return;\n    }\n    await this.messageHandler.sendWithPromise(\"Cleanup\", null);\n    for (const page of this.#pageCache.values()) {\n      const cleanupSuccessful = page.cleanup();\n      if (!cleanupSuccessful) {\n        throw new Error(`startCleanup: Page ${page.pageNumber} is currently rendering.`);\n      }\n    }\n    this.commonObjs.clear();\n    if (!keepLoadedFonts) {\n      this.fontLoader.clear();\n    }\n    this.#methodPromises.clear();\n    this.filterFactory.destroy(true);\n  }\n  get loadingParams() {\n    const {\n      disableAutoFetch,\n      enableXfa\n    } = this._params;\n    return (0, _util.shadow)(this, \"loadingParams\", {\n      disableAutoFetch,\n      enableXfa\n    });\n  }\n}\nclass PDFObjects {\n  #objs = Object.create(null);\n  #ensureObj(objId) {\n    return this.#objs[objId] ||= {\n      capability: new _util.PromiseCapability(),\n      data: null\n    };\n  }\n  get(objId) {\n    let callback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (callback) {\n      const obj = this.#ensureObj(objId);\n      obj.capability.promise.then(() => callback(obj.data));\n      return null;\n    }\n    const obj = this.#objs[objId];\n    if (!obj?.capability.settled) {\n      throw new Error(`Requesting object that isn't resolved yet ${objId}.`);\n    }\n    return obj.data;\n  }\n  has(objId) {\n    const obj = this.#objs[objId];\n    return obj?.capability.settled || false;\n  }\n  resolve(objId) {\n    let data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const obj = this.#ensureObj(objId);\n    obj.data = data;\n    obj.capability.resolve();\n  }\n  clear() {\n    for (const objId in this.#objs) {\n      const {\n        data\n      } = this.#objs[objId];\n      data?.bitmap?.close();\n    }\n    this.#objs = Object.create(null);\n  }\n}\nclass RenderTask {\n  #internalRenderTask = null;\n  constructor(internalRenderTask) {\n    this.#internalRenderTask = internalRenderTask;\n    this.onContinue = null;\n  }\n  get promise() {\n    return this.#internalRenderTask.capability.promise;\n  }\n  cancel() {\n    let extraDelay = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n    this.#internalRenderTask.cancel(null, extraDelay);\n  }\n  get separateAnnots() {\n    const {\n      separateAnnots\n    } = this.#internalRenderTask.operatorList;\n    if (!separateAnnots) {\n      return false;\n    }\n    const {\n      annotationCanvasMap\n    } = this.#internalRenderTask;\n    return separateAnnots.form || separateAnnots.canvas && annotationCanvasMap?.size > 0;\n  }\n}\nexports.RenderTask = RenderTask;\nclass InternalRenderTask {\n  static #canvasInUse = new WeakSet();\n  constructor(_ref13) {\n    let {\n      callback,\n      params,\n      objs,\n      commonObjs,\n      annotationCanvasMap,\n      operatorList,\n      pageIndex,\n      canvasFactory,\n      filterFactory,\n      useRequestAnimationFrame = false,\n      pdfBug = false,\n      pageColors = null\n    } = _ref13;\n    this.callback = callback;\n    this.params = params;\n    this.objs = objs;\n    this.commonObjs = commonObjs;\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.operatorListIdx = null;\n    this.operatorList = operatorList;\n    this._pageIndex = pageIndex;\n    this.canvasFactory = canvasFactory;\n    this.filterFactory = filterFactory;\n    this._pdfBug = pdfBug;\n    this.pageColors = pageColors;\n    this.running = false;\n    this.graphicsReadyCallback = null;\n    this.graphicsReady = false;\n    this._useRequestAnimationFrame = useRequestAnimationFrame === true && typeof window !== \"undefined\";\n    this.cancelled = false;\n    this.capability = new _util.PromiseCapability();\n    this.task = new RenderTask(this);\n    this._cancelBound = this.cancel.bind(this);\n    this._continueBound = this._continue.bind(this);\n    this._scheduleNextBound = this._scheduleNext.bind(this);\n    this._nextBound = this._next.bind(this);\n    this._canvas = params.canvasContext.canvas;\n  }\n  get completed() {\n    return this.capability.promise.catch(function () {});\n  }\n  initializeGraphics(_ref14) {\n    let {\n      transparency = false,\n      optionalContentConfig\n    } = _ref14;\n    if (this.cancelled) {\n      return;\n    }\n    if (this._canvas) {\n      if (InternalRenderTask.#canvasInUse.has(this._canvas)) {\n        throw new Error(\"Cannot use the same canvas during multiple render() operations. \" + \"Use different canvas or ensure previous operations were \" + \"cancelled or completed.\");\n      }\n      InternalRenderTask.#canvasInUse.add(this._canvas);\n    }\n    if (this._pdfBug && globalThis.StepperManager?.enabled) {\n      this.stepper = globalThis.StepperManager.create(this._pageIndex);\n      this.stepper.init(this.operatorList);\n      this.stepper.nextBreakPoint = this.stepper.getNextBreakPoint();\n    }\n    const {\n      canvasContext,\n      viewport,\n      transform,\n      background\n    } = this.params;\n    this.gfx = new _canvas.CanvasGraphics(canvasContext, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n      optionalContentConfig\n    }, this.annotationCanvasMap, this.pageColors);\n    this.gfx.beginDrawing({\n      transform,\n      viewport,\n      transparency,\n      background\n    });\n    this.operatorListIdx = 0;\n    this.graphicsReady = true;\n    this.graphicsReadyCallback?.();\n  }\n  cancel() {\n    let error = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;\n    let extraDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    this.running = false;\n    this.cancelled = true;\n    this.gfx?.endDrawing();\n    InternalRenderTask.#canvasInUse.delete(this._canvas);\n    this.callback(error || new _display_utils.RenderingCancelledException(`Rendering cancelled, page ${this._pageIndex + 1}`, extraDelay));\n  }\n  operatorListChanged() {\n    if (!this.graphicsReady) {\n      this.graphicsReadyCallback ||= this._continueBound;\n      return;\n    }\n    this.stepper?.updateOperatorList(this.operatorList);\n    if (this.running) {\n      return;\n    }\n    this._continue();\n  }\n  _continue() {\n    this.running = true;\n    if (this.cancelled) {\n      return;\n    }\n    if (this.task.onContinue) {\n      this.task.onContinue(this._scheduleNextBound);\n    } else {\n      this._scheduleNext();\n    }\n  }\n  _scheduleNext() {\n    if (this._useRequestAnimationFrame) {\n      window.requestAnimationFrame(() => {\n        this._nextBound().catch(this._cancelBound);\n      });\n    } else {\n      Promise.resolve().then(this._nextBound).catch(this._cancelBound);\n    }\n  }\n  async _next() {\n    if (this.cancelled) {\n      return;\n    }\n    this.operatorListIdx = this.gfx.executeOperatorList(this.operatorList, this.operatorListIdx, this._continueBound, this.stepper);\n    if (this.operatorListIdx === this.operatorList.argsArray.length) {\n      this.running = false;\n      if (this.operatorList.lastChunk) {\n        this.gfx.endDrawing();\n        InternalRenderTask.#canvasInUse.delete(this._canvas);\n        this.callback();\n      }\n    }\n  }\n}\nconst version = '3.11.174';\nexports.version = version;\nconst build = 'ce8716743';\nexports.build = build;\n\n/***/ }),\n/* 125 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar difference = __w_pdfjs_require__(126);\nvar setMethodAcceptSetLike = __w_pdfjs_require__(135);\n$({\n target: 'Set',\n proto: true,\n real: true,\n forced: !setMethodAcceptSetLike('difference')\n}, { difference: difference });\n\n/***/ }),\n/* 126 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar aSet = __w_pdfjs_require__(127);\nvar SetHelpers = __w_pdfjs_require__(128);\nvar clone = __w_pdfjs_require__(129);\nvar size = __w_pdfjs_require__(132);\nvar getSetRecord = __w_pdfjs_require__(133);\nvar iterateSet = __w_pdfjs_require__(130);\nvar iterateSimple = __w_pdfjs_require__(131);\nvar has = SetHelpers.has;\nvar remove = SetHelpers.remove;\nmodule.exports = function difference(other) {\n var O = aSet(this);\n var otherRec = getSetRecord(other);\n var result = clone(O);\n if (size(O) <= otherRec.size)\n  iterateSet(O, function (e) {\n   if (otherRec.includes(e))\n    remove(result, e);\n  });\n else\n  iterateSimple(otherRec.getIterator(), function (e) {\n   if (has(O, e))\n    remove(result, e);\n  });\n return result;\n};\n\n/***/ }),\n/* 127 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar has = (__w_pdfjs_require__(128).has);\nmodule.exports = function (it) {\n has(it);\n return it;\n};\n\n/***/ }),\n/* 128 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar SetPrototype = Set.prototype;\nmodule.exports = {\n Set: Set,\n add: uncurryThis(SetPrototype.add),\n has: uncurryThis(SetPrototype.has),\n remove: uncurryThis(SetPrototype['delete']),\n proto: SetPrototype\n};\n\n/***/ }),\n/* 129 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar SetHelpers = __w_pdfjs_require__(128);\nvar iterate = __w_pdfjs_require__(130);\nvar Set = SetHelpers.Set;\nvar add = SetHelpers.add;\nmodule.exports = function (set) {\n var result = new Set();\n iterate(set, function (it) {\n  add(result, it);\n });\n return result;\n};\n\n/***/ }),\n/* 130 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar iterateSimple = __w_pdfjs_require__(131);\nvar SetHelpers = __w_pdfjs_require__(128);\nvar Set = SetHelpers.Set;\nvar SetPrototype = SetHelpers.proto;\nvar forEach = uncurryThis(SetPrototype.forEach);\nvar keys = uncurryThis(SetPrototype.keys);\nvar next = keys(new Set()).next;\nmodule.exports = function (set, fn, interruptible) {\n return interruptible ? iterateSimple({\n  iterator: keys(set),\n  next: next\n }, fn) : forEach(set, fn);\n};\n\n/***/ }),\n/* 131 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar call = __w_pdfjs_require__(8);\nmodule.exports = function (record, fn, ITERATOR_INSTEAD_OF_RECORD) {\n var iterator = ITERATOR_INSTEAD_OF_RECORD ? record : record.iterator;\n var next = record.next;\n var step, result;\n while (!(step = call(next, iterator)).done) {\n  result = fn(step.value);\n  if (result !== undefined)\n   return result;\n }\n};\n\n/***/ }),\n/* 132 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThisAccessor = __w_pdfjs_require__(72);\nvar SetHelpers = __w_pdfjs_require__(128);\nmodule.exports = uncurryThisAccessor(SetHelpers.proto, 'size', 'get') || function (set) {\n return set.size;\n};\n\n/***/ }),\n/* 133 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar aCallable = __w_pdfjs_require__(31);\nvar anObject = __w_pdfjs_require__(47);\nvar call = __w_pdfjs_require__(8);\nvar toIntegerOrInfinity = __w_pdfjs_require__(62);\nvar getIteratorDirect = __w_pdfjs_require__(134);\nvar INVALID_SIZE = 'Invalid size';\nvar $RangeError = RangeError;\nvar $TypeError = TypeError;\nvar max = Math.max;\nvar SetRecord = function (set, size, has, keys) {\n this.set = set;\n this.size = size;\n this.has = has;\n this.keys = keys;\n};\nSetRecord.prototype = {\n getIterator: function () {\n  return getIteratorDirect(anObject(call(this.keys, this.set)));\n },\n includes: function (it) {\n  return call(this.has, this.set, it);\n }\n};\nmodule.exports = function (obj) {\n anObject(obj);\n var numSize = +obj.size;\n if (numSize !== numSize)\n  throw $TypeError(INVALID_SIZE);\n var intSize = toIntegerOrInfinity(numSize);\n if (intSize < 0)\n  throw $RangeError(INVALID_SIZE);\n return new SetRecord(obj, max(intSize, 0), aCallable(obj.has), aCallable(obj.keys));\n};\n\n/***/ }),\n/* 134 */\n/***/ ((module) => {\n\n\nmodule.exports = function (obj) {\n return {\n  iterator: obj,\n  next: obj.next,\n  done: false\n };\n};\n\n/***/ }),\n/* 135 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar getBuiltIn = __w_pdfjs_require__(24);\nvar createSetLike = function (size) {\n return {\n  size: size,\n  has: function () {\n   return false;\n  },\n  keys: function () {\n   return {\n    next: function () {\n     return { done: true };\n    }\n   };\n  }\n };\n};\nmodule.exports = function (name) {\n var Set = getBuiltIn('Set');\n try {\n  new Set()[name](createSetLike(0));\n  try {\n   new Set()[name](createSetLike(-1));\n   return false;\n  } catch (error2) {\n   return true;\n  }\n } catch (error) {\n  return false;\n }\n};\n\n/***/ }),\n/* 136 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar fails = __w_pdfjs_require__(7);\nvar intersection = __w_pdfjs_require__(137);\nvar setMethodAcceptSetLike = __w_pdfjs_require__(135);\nvar INCORRECT = !setMethodAcceptSetLike('intersection') || fails(function () {\n return Array.from(new Set([\n  1,\n  2,\n  3\n ]).intersection(new Set([\n  3,\n  2\n ]))) !== '3,2';\n});\n$({\n target: 'Set',\n proto: true,\n real: true,\n forced: INCORRECT\n}, { intersection: intersection });\n\n/***/ }),\n/* 137 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar aSet = __w_pdfjs_require__(127);\nvar SetHelpers = __w_pdfjs_require__(128);\nvar size = __w_pdfjs_require__(132);\nvar getSetRecord = __w_pdfjs_require__(133);\nvar iterateSet = __w_pdfjs_require__(130);\nvar iterateSimple = __w_pdfjs_require__(131);\nvar Set = SetHelpers.Set;\nvar add = SetHelpers.add;\nvar has = SetHelpers.has;\nmodule.exports = function intersection(other) {\n var O = aSet(this);\n var otherRec = getSetRecord(other);\n var result = new Set();\n if (size(O) > otherRec.size) {\n  iterateSimple(otherRec.getIterator(), function (e) {\n   if (has(O, e))\n    add(result, e);\n  });\n } else {\n  iterateSet(O, function (e) {\n   if (otherRec.includes(e))\n    add(result, e);\n  });\n }\n return result;\n};\n\n/***/ }),\n/* 138 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar isDisjointFrom = __w_pdfjs_require__(139);\nvar setMethodAcceptSetLike = __w_pdfjs_require__(135);\n$({\n target: 'Set',\n proto: true,\n real: true,\n forced: !setMethodAcceptSetLike('isDisjointFrom')\n}, { isDisjointFrom: isDisjointFrom });\n\n/***/ }),\n/* 139 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar aSet = __w_pdfjs_require__(127);\nvar has = (__w_pdfjs_require__(128).has);\nvar size = __w_pdfjs_require__(132);\nvar getSetRecord = __w_pdfjs_require__(133);\nvar iterateSet = __w_pdfjs_require__(130);\nvar iterateSimple = __w_pdfjs_require__(131);\nvar iteratorClose = __w_pdfjs_require__(140);\nmodule.exports = function isDisjointFrom(other) {\n var O = aSet(this);\n var otherRec = getSetRecord(other);\n if (size(O) <= otherRec.size)\n  return iterateSet(O, function (e) {\n   if (otherRec.includes(e))\n    return false;\n  }, true) !== false;\n var iterator = otherRec.getIterator();\n return iterateSimple(iterator, function (e) {\n  if (has(O, e))\n   return iteratorClose(iterator, 'normal', false);\n }) !== false;\n};\n\n/***/ }),\n/* 140 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar call = __w_pdfjs_require__(8);\nvar anObject = __w_pdfjs_require__(47);\nvar getMethod = __w_pdfjs_require__(30);\nmodule.exports = function (iterator, kind, value) {\n var innerResult, innerError;\n anObject(iterator);\n try {\n  innerResult = getMethod(iterator, 'return');\n  if (!innerResult) {\n   if (kind === 'throw')\n    throw value;\n   return value;\n  }\n  innerResult = call(innerResult, iterator);\n } catch (error) {\n  innerError = true;\n  innerResult = error;\n }\n if (kind === 'throw')\n  throw value;\n if (innerError)\n  throw innerResult;\n anObject(innerResult);\n return value;\n};\n\n/***/ }),\n/* 141 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar isSubsetOf = __w_pdfjs_require__(142);\nvar setMethodAcceptSetLike = __w_pdfjs_require__(135);\n$({\n target: 'Set',\n proto: true,\n real: true,\n forced: !setMethodAcceptSetLike('isSubsetOf')\n}, { isSubsetOf: isSubsetOf });\n\n/***/ }),\n/* 142 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar aSet = __w_pdfjs_require__(127);\nvar size = __w_pdfjs_require__(132);\nvar iterate = __w_pdfjs_require__(130);\nvar getSetRecord = __w_pdfjs_require__(133);\nmodule.exports = function isSubsetOf(other) {\n var O = aSet(this);\n var otherRec = getSetRecord(other);\n if (size(O) > otherRec.size)\n  return false;\n return iterate(O, function (e) {\n  if (!otherRec.includes(e))\n   return false;\n }, true) !== false;\n};\n\n/***/ }),\n/* 143 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar isSupersetOf = __w_pdfjs_require__(144);\nvar setMethodAcceptSetLike = __w_pdfjs_require__(135);\n$({\n target: 'Set',\n proto: true,\n real: true,\n forced: !setMethodAcceptSetLike('isSupersetOf')\n}, { isSupersetOf: isSupersetOf });\n\n/***/ }),\n/* 144 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar aSet = __w_pdfjs_require__(127);\nvar has = (__w_pdfjs_require__(128).has);\nvar size = __w_pdfjs_require__(132);\nvar getSetRecord = __w_pdfjs_require__(133);\nvar iterateSimple = __w_pdfjs_require__(131);\nvar iteratorClose = __w_pdfjs_require__(140);\nmodule.exports = function isSupersetOf(other) {\n var O = aSet(this);\n var otherRec = getSetRecord(other);\n if (size(O) < otherRec.size)\n  return false;\n var iterator = otherRec.getIterator();\n return iterateSimple(iterator, function (e) {\n  if (!has(O, e))\n   return iteratorClose(iterator, 'normal', false);\n }) !== false;\n};\n\n/***/ }),\n/* 145 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar symmetricDifference = __w_pdfjs_require__(146);\nvar setMethodAcceptSetLike = __w_pdfjs_require__(135);\n$({\n target: 'Set',\n proto: true,\n real: true,\n forced: !setMethodAcceptSetLike('symmetricDifference')\n}, { symmetricDifference: symmetricDifference });\n\n/***/ }),\n/* 146 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar aSet = __w_pdfjs_require__(127);\nvar SetHelpers = __w_pdfjs_require__(128);\nvar clone = __w_pdfjs_require__(129);\nvar getSetRecord = __w_pdfjs_require__(133);\nvar iterateSimple = __w_pdfjs_require__(131);\nvar add = SetHelpers.add;\nvar has = SetHelpers.has;\nvar remove = SetHelpers.remove;\nmodule.exports = function symmetricDifference(other) {\n var O = aSet(this);\n var keysIter = getSetRecord(other).getIterator();\n var result = clone(O);\n iterateSimple(keysIter, function (e) {\n  if (has(O, e))\n   remove(result, e);\n  else\n   add(result, e);\n });\n return result;\n};\n\n/***/ }),\n/* 147 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar union = __w_pdfjs_require__(148);\nvar setMethodAcceptSetLike = __w_pdfjs_require__(135);\n$({\n target: 'Set',\n proto: true,\n real: true,\n forced: !setMethodAcceptSetLike('union')\n}, { union: union });\n\n/***/ }),\n/* 148 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar aSet = __w_pdfjs_require__(127);\nvar add = (__w_pdfjs_require__(128).add);\nvar clone = __w_pdfjs_require__(129);\nvar getSetRecord = __w_pdfjs_require__(133);\nvar iterateSimple = __w_pdfjs_require__(131);\nmodule.exports = function union(other) {\n var O = aSet(this);\n var keysIter = getSetRecord(other).getIterator();\n var result = clone(O);\n iterateSimple(keysIter, function (it) {\n  add(result, it);\n });\n return result;\n};\n\n/***/ }),\n/* 149 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar global = __w_pdfjs_require__(4);\nvar getBuiltIn = __w_pdfjs_require__(24);\nvar createPropertyDescriptor = __w_pdfjs_require__(11);\nvar defineProperty = (__w_pdfjs_require__(45).f);\nvar hasOwn = __w_pdfjs_require__(39);\nvar anInstance = __w_pdfjs_require__(150);\nvar inheritIfRequired = __w_pdfjs_require__(75);\nvar normalizeStringArgument = __w_pdfjs_require__(76);\nvar DOMExceptionConstants = __w_pdfjs_require__(151);\nvar clearErrorStack = __w_pdfjs_require__(82);\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar IS_PURE = __w_pdfjs_require__(36);\nvar DOM_EXCEPTION = 'DOMException';\nvar Error = getBuiltIn('Error');\nvar NativeDOMException = getBuiltIn(DOM_EXCEPTION);\nvar $DOMException = function DOMException() {\n anInstance(this, DOMExceptionPrototype);\n var argumentsLength = arguments.length;\n var message = normalizeStringArgument(argumentsLength < 1 ? undefined : arguments[0]);\n var name = normalizeStringArgument(argumentsLength < 2 ? undefined : arguments[1], 'Error');\n var that = new NativeDOMException(message, name);\n var error = Error(message);\n error.name = DOM_EXCEPTION;\n defineProperty(that, 'stack', createPropertyDescriptor(1, clearErrorStack(error.stack, 1)));\n inheritIfRequired(that, this, $DOMException);\n return that;\n};\nvar DOMExceptionPrototype = $DOMException.prototype = NativeDOMException.prototype;\nvar ERROR_HAS_STACK = 'stack' in Error(DOM_EXCEPTION);\nvar DOM_EXCEPTION_HAS_STACK = 'stack' in new NativeDOMException(1, 2);\nvar descriptor = NativeDOMException && DESCRIPTORS && Object.getOwnPropertyDescriptor(global, DOM_EXCEPTION);\nvar BUGGY_DESCRIPTOR = !!descriptor && !(descriptor.writable && descriptor.configurable);\nvar FORCED_CONSTRUCTOR = ERROR_HAS_STACK && !BUGGY_DESCRIPTOR && !DOM_EXCEPTION_HAS_STACK;\n$({\n global: true,\n constructor: true,\n forced: IS_PURE || FORCED_CONSTRUCTOR\n}, { DOMException: FORCED_CONSTRUCTOR ? $DOMException : NativeDOMException });\nvar PolyfilledDOMException = getBuiltIn(DOM_EXCEPTION);\nvar PolyfilledDOMExceptionPrototype = PolyfilledDOMException.prototype;\nif (PolyfilledDOMExceptionPrototype.constructor !== PolyfilledDOMException) {\n if (!IS_PURE) {\n  defineProperty(PolyfilledDOMExceptionPrototype, 'constructor', createPropertyDescriptor(1, PolyfilledDOMException));\n }\n for (var key in DOMExceptionConstants)\n  if (hasOwn(DOMExceptionConstants, key)) {\n   var constant = DOMExceptionConstants[key];\n   var constantName = constant.s;\n   if (!hasOwn(PolyfilledDOMException, constantName)) {\n    defineProperty(PolyfilledDOMException, constantName, createPropertyDescriptor(6, constant.c));\n   }\n  }\n}\n\n/***/ }),\n/* 150 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar isPrototypeOf = __w_pdfjs_require__(25);\nvar $TypeError = TypeError;\nmodule.exports = function (it, Prototype) {\n if (isPrototypeOf(Prototype, it))\n  return it;\n throw $TypeError('Incorrect invocation');\n};\n\n/***/ }),\n/* 151 */\n/***/ ((module) => {\n\n\nmodule.exports = {\n IndexSizeError: {\n  s: 'INDEX_SIZE_ERR',\n  c: 1,\n  m: 1\n },\n DOMStringSizeError: {\n  s: 'DOMSTRING_SIZE_ERR',\n  c: 2,\n  m: 0\n },\n HierarchyRequestError: {\n  s: 'HIERARCHY_REQUEST_ERR',\n  c: 3,\n  m: 1\n },\n WrongDocumentError: {\n  s: 'WRONG_DOCUMENT_ERR',\n  c: 4,\n  m: 1\n },\n InvalidCharacterError: {\n  s: 'INVALID_CHARACTER_ERR',\n  c: 5,\n  m: 1\n },\n NoDataAllowedError: {\n  s: 'NO_DATA_ALLOWED_ERR',\n  c: 6,\n  m: 0\n },\n NoModificationAllowedError: {\n  s: 'NO_MODIFICATION_ALLOWED_ERR',\n  c: 7,\n  m: 1\n },\n NotFoundError: {\n  s: 'NOT_FOUND_ERR',\n  c: 8,\n  m: 1\n },\n NotSupportedError: {\n  s: 'NOT_SUPPORTED_ERR',\n  c: 9,\n  m: 1\n },\n InUseAttributeError: {\n  s: 'INUSE_ATTRIBUTE_ERR',\n  c: 10,\n  m: 1\n },\n InvalidStateError: {\n  s: 'INVALID_STATE_ERR',\n  c: 11,\n  m: 1\n },\n SyntaxError: {\n  s: 'SYNTAX_ERR',\n  c: 12,\n  m: 1\n },\n InvalidModificationError: {\n  s: 'INVALID_MODIFICATION_ERR',\n  c: 13,\n  m: 1\n },\n NamespaceError: {\n  s: 'NAMESPACE_ERR',\n  c: 14,\n  m: 1\n },\n InvalidAccessError: {\n  s: 'INVALID_ACCESS_ERR',\n  c: 15,\n  m: 1\n },\n ValidationError: {\n  s: 'VALIDATION_ERR',\n  c: 16,\n  m: 0\n },\n TypeMismatchError: {\n  s: 'TYPE_MISMATCH_ERR',\n  c: 17,\n  m: 1\n },\n SecurityError: {\n  s: 'SECURITY_ERR',\n  c: 18,\n  m: 1\n },\n NetworkError: {\n  s: 'NETWORK_ERR',\n  c: 19,\n  m: 1\n },\n AbortError: {\n  s: 'ABORT_ERR',\n  c: 20,\n  m: 1\n },\n URLMismatchError: {\n  s: 'URL_MISMATCH_ERR',\n  c: 21,\n  m: 1\n },\n QuotaExceededError: {\n  s: 'QUOTA_EXCEEDED_ERR',\n  c: 22,\n  m: 1\n },\n TimeoutError: {\n  s: 'TIMEOUT_ERR',\n  c: 23,\n  m: 1\n },\n InvalidNodeTypeError: {\n  s: 'INVALID_NODE_TYPE_ERR',\n  c: 24,\n  m: 1\n },\n DataCloneError: {\n  s: 'DATA_CLONE_ERR',\n  c: 25,\n  m: 1\n }\n};\n\n/***/ }),\n/* 152 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar IS_PURE = __w_pdfjs_require__(36);\nvar $ = __w_pdfjs_require__(3);\nvar global = __w_pdfjs_require__(4);\nvar getBuiltin = __w_pdfjs_require__(24);\nvar uncurryThis = __w_pdfjs_require__(14);\nvar fails = __w_pdfjs_require__(7);\nvar uid = __w_pdfjs_require__(41);\nvar isCallable = __w_pdfjs_require__(21);\nvar isConstructor = __w_pdfjs_require__(153);\nvar isNullOrUndefined = __w_pdfjs_require__(17);\nvar isObject = __w_pdfjs_require__(20);\nvar isSymbol = __w_pdfjs_require__(23);\nvar iterate = __w_pdfjs_require__(154);\nvar anObject = __w_pdfjs_require__(47);\nvar classof = __w_pdfjs_require__(78);\nvar hasOwn = __w_pdfjs_require__(39);\nvar createProperty = __w_pdfjs_require__(159);\nvar createNonEnumerableProperty = __w_pdfjs_require__(44);\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nvar validateArgumentsLength = __w_pdfjs_require__(85);\nvar getRegExpFlags = __w_pdfjs_require__(160);\nvar MapHelpers = __w_pdfjs_require__(162);\nvar SetHelpers = __w_pdfjs_require__(128);\nvar ERROR_STACK_INSTALLABLE = __w_pdfjs_require__(83);\nvar PROPER_TRANSFER = __w_pdfjs_require__(119);\nvar Object = global.Object;\nvar Array = global.Array;\nvar Date = global.Date;\nvar Error = global.Error;\nvar EvalError = global.EvalError;\nvar RangeError = global.RangeError;\nvar ReferenceError = global.ReferenceError;\nvar SyntaxError = global.SyntaxError;\nvar TypeError = global.TypeError;\nvar URIError = global.URIError;\nvar PerformanceMark = global.PerformanceMark;\nvar WebAssembly = global.WebAssembly;\nvar CompileError = WebAssembly && WebAssembly.CompileError || Error;\nvar LinkError = WebAssembly && WebAssembly.LinkError || Error;\nvar RuntimeError = WebAssembly && WebAssembly.RuntimeError || Error;\nvar DOMException = getBuiltin('DOMException');\nvar Map = MapHelpers.Map;\nvar mapHas = MapHelpers.has;\nvar mapGet = MapHelpers.get;\nvar mapSet = MapHelpers.set;\nvar Set = SetHelpers.Set;\nvar setAdd = SetHelpers.add;\nvar objectKeys = getBuiltin('Object', 'keys');\nvar push = uncurryThis([].push);\nvar thisBooleanValue = uncurryThis(true.valueOf);\nvar thisNumberValue = uncurryThis(1.0.valueOf);\nvar thisStringValue = uncurryThis(''.valueOf);\nvar thisTimeValue = uncurryThis(Date.prototype.getTime);\nvar PERFORMANCE_MARK = uid('structuredClone');\nvar DATA_CLONE_ERROR = 'DataCloneError';\nvar TRANSFERRING = 'Transferring';\nvar checkBasicSemantic = function (structuredCloneImplementation) {\n return !fails(function () {\n  var set1 = new global.Set([7]);\n  var set2 = structuredCloneImplementation(set1);\n  var number = structuredCloneImplementation(Object(7));\n  return set2 === set1 || !set2.has(7) || typeof number != 'object' || +number !== 7;\n }) && structuredCloneImplementation;\n};\nvar checkErrorsCloning = function (structuredCloneImplementation, $Error) {\n return !fails(function () {\n  var error = new $Error();\n  var test = structuredCloneImplementation({\n   a: error,\n   b: error\n  });\n  return !(test && test.a === test.b && test.a instanceof $Error && test.a.stack === error.stack);\n });\n};\nvar checkNewErrorsCloningSemantic = function (structuredCloneImplementation) {\n return !fails(function () {\n  var test = structuredCloneImplementation(new global.AggregateError([1], PERFORMANCE_MARK, { cause: 3 }));\n  return test.name !== 'AggregateError' || test.errors[0] !== 1 || test.message !== PERFORMANCE_MARK || test.cause !== 3;\n });\n};\nvar nativeStructuredClone = global.structuredClone;\nvar FORCED_REPLACEMENT = IS_PURE || !checkErrorsCloning(nativeStructuredClone, Error) || !checkErrorsCloning(nativeStructuredClone, DOMException) || !checkNewErrorsCloningSemantic(nativeStructuredClone);\nvar structuredCloneFromMark = !nativeStructuredClone && checkBasicSemantic(function (value) {\n return new PerformanceMark(PERFORMANCE_MARK, { detail: value }).detail;\n});\nvar nativeRestrictedStructuredClone = checkBasicSemantic(nativeStructuredClone) || structuredCloneFromMark;\nvar throwUncloneable = function (type) {\n throw new DOMException('Uncloneable type: ' + type, DATA_CLONE_ERROR);\n};\nvar throwUnpolyfillable = function (type, action) {\n throw new DOMException((action || 'Cloning') + ' of ' + type + ' cannot be properly polyfilled in this engine', DATA_CLONE_ERROR);\n};\nvar tryNativeRestrictedStructuredClone = function (value, type) {\n if (!nativeRestrictedStructuredClone)\n  throwUnpolyfillable(type);\n return nativeRestrictedStructuredClone(value);\n};\nvar createDataTransfer = function () {\n var dataTransfer;\n try {\n  dataTransfer = new global.DataTransfer();\n } catch (error) {\n  try {\n   dataTransfer = new global.ClipboardEvent('').clipboardData;\n  } catch (error2) {\n  }\n }\n return dataTransfer && dataTransfer.items && dataTransfer.files ? dataTransfer : null;\n};\nvar cloneBuffer = function (value, map, $type) {\n if (mapHas(map, value))\n  return mapGet(map, value);\n var type = $type || classof(value);\n var clone, length, options, source, target, i;\n if (type === 'SharedArrayBuffer') {\n  if (nativeRestrictedStructuredClone)\n   clone = nativeRestrictedStructuredClone(value);\n  else\n   clone = value;\n } else {\n  var DataView = global.DataView;\n  if (!DataView && typeof value.slice != 'function')\n   throwUnpolyfillable('ArrayBuffer');\n  try {\n   if (typeof value.slice == 'function' && !value.resizable) {\n    clone = value.slice(0);\n   } else {\n    length = value.byteLength;\n    options = 'maxByteLength' in value ? { maxByteLength: value.maxByteLength } : undefined;\n    clone = new ArrayBuffer(length, options);\n    source = new DataView(value);\n    target = new DataView(clone);\n    for (i = 0; i < length; i++) {\n     target.setUint8(i, source.getUint8(i));\n    }\n   }\n  } catch (error) {\n   throw new DOMException('ArrayBuffer is detached', DATA_CLONE_ERROR);\n  }\n }\n mapSet(map, value, clone);\n return clone;\n};\nvar cloneView = function (value, type, offset, length, map) {\n var C = global[type];\n if (!isObject(C))\n  throwUnpolyfillable(type);\n return new C(cloneBuffer(value.buffer, map), offset, length);\n};\nvar Placeholder = function (object, type, metadata) {\n this.object = object;\n this.type = type;\n this.metadata = metadata;\n};\nvar structuredCloneInternal = function (value, map, transferredBuffers) {\n if (isSymbol(value))\n  throwUncloneable('Symbol');\n if (!isObject(value))\n  return value;\n if (map) {\n  if (mapHas(map, value))\n   return mapGet(map, value);\n } else\n  map = new Map();\n var type = classof(value);\n var C, name, cloned, dataTransfer, i, length, keys, key;\n switch (type) {\n case 'Array':\n  cloned = Array(lengthOfArrayLike(value));\n  break;\n case 'Object':\n  cloned = {};\n  break;\n case 'Map':\n  cloned = new Map();\n  break;\n case 'Set':\n  cloned = new Set();\n  break;\n case 'RegExp':\n  cloned = new RegExp(value.source, getRegExpFlags(value));\n  break;\n case 'Error':\n  name = value.name;\n  switch (name) {\n  case 'AggregateError':\n   cloned = getBuiltin('AggregateError')([]);\n   break;\n  case 'EvalError':\n   cloned = EvalError();\n   break;\n  case 'RangeError':\n   cloned = RangeError();\n   break;\n  case 'ReferenceError':\n   cloned = ReferenceError();\n   break;\n  case 'SyntaxError':\n   cloned = SyntaxError();\n   break;\n  case 'TypeError':\n   cloned = TypeError();\n   break;\n  case 'URIError':\n   cloned = URIError();\n   break;\n  case 'CompileError':\n   cloned = CompileError();\n   break;\n  case 'LinkError':\n   cloned = LinkError();\n   break;\n  case 'RuntimeError':\n   cloned = RuntimeError();\n   break;\n  default:\n   cloned = Error();\n  }\n  break;\n case 'DOMException':\n  cloned = new DOMException(value.message, value.name);\n  break;\n case 'ArrayBuffer':\n case 'SharedArrayBuffer':\n  cloned = transferredBuffers ? new Placeholder(value, type) : cloneBuffer(value, map, type);\n  break;\n case 'DataView':\n case 'Int8Array':\n case 'Uint8Array':\n case 'Uint8ClampedArray':\n case 'Int16Array':\n case 'Uint16Array':\n case 'Int32Array':\n case 'Uint32Array':\n case 'Float16Array':\n case 'Float32Array':\n case 'Float64Array':\n case 'BigInt64Array':\n case 'BigUint64Array':\n  length = type === 'DataView' ? value.byteLength : value.length;\n  cloned = transferredBuffers ? new Placeholder(value, type, {\n   offset: value.byteOffset,\n   length: length\n  }) : cloneView(value, type, value.byteOffset, length, map);\n  break;\n case 'DOMQuad':\n  try {\n   cloned = new DOMQuad(structuredCloneInternal(value.p1, map, transferredBuffers), structuredCloneInternal(value.p2, map, transferredBuffers), structuredCloneInternal(value.p3, map, transferredBuffers), structuredCloneInternal(value.p4, map, transferredBuffers));\n  } catch (error) {\n   cloned = tryNativeRestrictedStructuredClone(value, type);\n  }\n  break;\n case 'File':\n  if (nativeRestrictedStructuredClone)\n   try {\n    cloned = nativeRestrictedStructuredClone(value);\n    if (classof(cloned) !== type)\n     cloned = undefined;\n   } catch (error) {\n   }\n  if (!cloned)\n   try {\n    cloned = new File([value], value.name, value);\n   } catch (error) {\n   }\n  if (!cloned)\n   throwUnpolyfillable(type);\n  break;\n case 'FileList':\n  dataTransfer = createDataTransfer();\n  if (dataTransfer) {\n   for (i = 0, length = lengthOfArrayLike(value); i < length; i++) {\n    dataTransfer.items.add(structuredCloneInternal(value[i], map, transferredBuffers));\n   }\n   cloned = dataTransfer.files;\n  } else\n   cloned = tryNativeRestrictedStructuredClone(value, type);\n  break;\n case 'ImageData':\n  try {\n   cloned = new ImageData(structuredCloneInternal(value.data, map, transferredBuffers), value.width, value.height, { colorSpace: value.colorSpace });\n  } catch (error) {\n   cloned = tryNativeRestrictedStructuredClone(value, type);\n  }\n  break;\n default:\n  if (nativeRestrictedStructuredClone) {\n   cloned = nativeRestrictedStructuredClone(value);\n  } else\n   switch (type) {\n   case 'BigInt':\n    cloned = Object(value.valueOf());\n    break;\n   case 'Boolean':\n    cloned = Object(thisBooleanValue(value));\n    break;\n   case 'Number':\n    cloned = Object(thisNumberValue(value));\n    break;\n   case 'String':\n    cloned = Object(thisStringValue(value));\n    break;\n   case 'Date':\n    cloned = new Date(thisTimeValue(value));\n    break;\n   case 'Blob':\n    try {\n     cloned = value.slice(0, value.size, value.type);\n    } catch (error) {\n     throwUnpolyfillable(type);\n    }\n    break;\n   case 'DOMPoint':\n   case 'DOMPointReadOnly':\n    C = global[type];\n    try {\n     cloned = C.fromPoint ? C.fromPoint(value) : new C(value.x, value.y, value.z, value.w);\n    } catch (error) {\n     throwUnpolyfillable(type);\n    }\n    break;\n   case 'DOMRect':\n   case 'DOMRectReadOnly':\n    C = global[type];\n    try {\n     cloned = C.fromRect ? C.fromRect(value) : new C(value.x, value.y, value.width, value.height);\n    } catch (error) {\n     throwUnpolyfillable(type);\n    }\n    break;\n   case 'DOMMatrix':\n   case 'DOMMatrixReadOnly':\n    C = global[type];\n    try {\n     cloned = C.fromMatrix ? C.fromMatrix(value) : new C(value);\n    } catch (error) {\n     throwUnpolyfillable(type);\n    }\n    break;\n   case 'AudioData':\n   case 'VideoFrame':\n    if (!isCallable(value.clone))\n     throwUnpolyfillable(type);\n    try {\n     cloned = value.clone();\n    } catch (error) {\n     throwUncloneable(type);\n    }\n    break;\n   case 'CropTarget':\n   case 'CryptoKey':\n   case 'FileSystemDirectoryHandle':\n   case 'FileSystemFileHandle':\n   case 'FileSystemHandle':\n   case 'GPUCompilationInfo':\n   case 'GPUCompilationMessage':\n   case 'ImageBitmap':\n   case 'RTCCertificate':\n   case 'WebAssembly.Module':\n    throwUnpolyfillable(type);\n   default:\n    throwUncloneable(type);\n   }\n }\n mapSet(map, value, cloned);\n switch (type) {\n case 'Array':\n case 'Object':\n  keys = objectKeys(value);\n  for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {\n   key = keys[i];\n   createProperty(cloned, key, structuredCloneInternal(value[key], map, transferredBuffers));\n  }\n  break;\n case 'Map':\n  value.forEach(function (v, k) {\n   mapSet(cloned, structuredCloneInternal(k, map, transferredBuffers), structuredCloneInternal(v, map, transferredBuffers));\n  });\n  break;\n case 'Set':\n  value.forEach(function (v) {\n   setAdd(cloned, structuredCloneInternal(v, map, transferredBuffers));\n  });\n  break;\n case 'Error':\n  createNonEnumerableProperty(cloned, 'message', structuredCloneInternal(value.message, map, transferredBuffers));\n  if (hasOwn(value, 'cause')) {\n   createNonEnumerableProperty(cloned, 'cause', structuredCloneInternal(value.cause, map, transferredBuffers));\n  }\n  if (name === 'AggregateError') {\n   cloned.errors = structuredCloneInternal(value.errors, map, transferredBuffers);\n  }\n case 'DOMException':\n  if (ERROR_STACK_INSTALLABLE) {\n   createNonEnumerableProperty(cloned, 'stack', structuredCloneInternal(value.stack, map, transferredBuffers));\n  }\n }\n return cloned;\n};\nvar replacePlaceholders = function (value, map) {\n if (!isObject(value))\n  return value;\n if (mapHas(map, value))\n  return mapGet(map, value);\n var type, object, metadata, i, length, keys, key, replacement;\n if (value instanceof Placeholder) {\n  type = value.type;\n  object = value.object;\n  switch (type) {\n  case 'ArrayBuffer':\n  case 'SharedArrayBuffer':\n   replacement = cloneBuffer(object, map, type);\n   break;\n  case 'DataView':\n  case 'Int8Array':\n  case 'Uint8Array':\n  case 'Uint8ClampedArray':\n  case 'Int16Array':\n  case 'Uint16Array':\n  case 'Int32Array':\n  case 'Uint32Array':\n  case 'Float16Array':\n  case 'Float32Array':\n  case 'Float64Array':\n  case 'BigInt64Array':\n  case 'BigUint64Array':\n   metadata = value.metadata;\n   replacement = cloneView(object, type, metadata.offset, metadata.length, map);\n  }\n } else\n  switch (classof(value)) {\n  case 'Array':\n  case 'Object':\n   keys = objectKeys(value);\n   for (i = 0, length = lengthOfArrayLike(keys); i < length; i++) {\n    key = keys[i];\n    value[key] = replacePlaceholders(value[key], map);\n   }\n   break;\n  case 'Map':\n   replacement = new Map();\n   value.forEach(function (v, k) {\n    mapSet(replacement, replacePlaceholders(k, map), replacePlaceholders(v, map));\n   });\n   break;\n  case 'Set':\n   replacement = new Set();\n   value.forEach(function (v) {\n    setAdd(replacement, replacePlaceholders(v, map));\n   });\n   break;\n  case 'Error':\n   value.message = replacePlaceholders(value.message, map);\n   if (hasOwn(value, 'cause')) {\n    value.cause = replacePlaceholders(value.cause, map);\n   }\n   if (value.name === 'AggregateError') {\n    value.errors = replacePlaceholders(value.errors, map);\n   }\n  case 'DOMException':\n   if (ERROR_STACK_INSTALLABLE) {\n    value.stack = replacePlaceholders(value.stack, map);\n   }\n  }\n mapSet(map, value, replacement || value);\n return replacement || value;\n};\nvar tryToTransfer = function (rawTransfer, map) {\n if (!isObject(rawTransfer))\n  throw TypeError('Transfer option cannot be converted to a sequence');\n var transfer = [];\n iterate(rawTransfer, function (value) {\n  push(transfer, anObject(value));\n });\n var i = 0;\n var length = lengthOfArrayLike(transfer);\n var buffers = [];\n var value, type, C, transferred, canvas, context;\n while (i < length) {\n  value = transfer[i++];\n  type = classof(value);\n  if (type === 'ArrayBuffer') {\n   push(buffers, value);\n   continue;\n  }\n  if (mapHas(map, value))\n   throw new DOMException('Duplicate transferable', DATA_CLONE_ERROR);\n  if (PROPER_TRANSFER) {\n   transferred = nativeStructuredClone(value, { transfer: [value] });\n  } else\n   switch (type) {\n   case 'ImageBitmap':\n    C = global.OffscreenCanvas;\n    if (!isConstructor(C))\n     throwUnpolyfillable(type, TRANSFERRING);\n    try {\n     canvas = new C(value.width, value.height);\n     context = canvas.getContext('bitmaprenderer');\n     context.transferFromImageBitmap(value);\n     transferred = canvas.transferToImageBitmap();\n    } catch (error) {\n    }\n    break;\n   case 'AudioData':\n   case 'VideoFrame':\n    if (!isCallable(value.clone) || !isCallable(value.close))\n     throwUnpolyfillable(type, TRANSFERRING);\n    try {\n     transferred = value.clone();\n     value.close();\n    } catch (error) {\n    }\n    break;\n   case 'MediaSourceHandle':\n   case 'MessagePort':\n   case 'OffscreenCanvas':\n   case 'ReadableStream':\n   case 'TransformStream':\n   case 'WritableStream':\n    throwUnpolyfillable(type, TRANSFERRING);\n   }\n  if (transferred === undefined)\n   throw new DOMException('This object cannot be transferred: ' + type, DATA_CLONE_ERROR);\n  mapSet(map, value, transferred);\n }\n return buffers;\n};\nvar tryToTransferBuffers = function (transfer, map) {\n var i = 0;\n var length = lengthOfArrayLike(transfer);\n var value, transferred;\n while (i < length) {\n  value = transfer[i++];\n  if (mapHas(map, value))\n   throw new DOMException('Duplicate transferable', DATA_CLONE_ERROR);\n  if (PROPER_TRANSFER) {\n   transferred = nativeStructuredClone(value, { transfer: [value] });\n  } else {\n   if (!isCallable(value.transfer))\n    throwUnpolyfillable('ArrayBuffer', TRANSFERRING);\n   transferred = value.transfer();\n  }\n  mapSet(map, value, transferred);\n }\n};\n$({\n global: true,\n enumerable: true,\n sham: !PROPER_TRANSFER,\n forced: FORCED_REPLACEMENT\n}, {\n structuredClone: function structuredClone(value) {\n  var options = validateArgumentsLength(arguments.length, 1) > 1 && !isNullOrUndefined(arguments[1]) ? anObject(arguments[1]) : undefined;\n  var transfer = options ? options.transfer : undefined;\n  var transferredBuffers = false;\n  var map, buffers;\n  if (transfer !== undefined) {\n   map = new Map();\n   buffers = tryToTransfer(transfer, map);\n   transferredBuffers = !!lengthOfArrayLike(buffers);\n  }\n  var clone = structuredCloneInternal(value, map, transferredBuffers);\n  if (transferredBuffers) {\n   map = new Map();\n   tryToTransferBuffers(transfer, map);\n   clone = replacePlaceholders(clone, map);\n  }\n  return clone;\n }\n});\n\n/***/ }),\n/* 153 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar fails = __w_pdfjs_require__(7);\nvar isCallable = __w_pdfjs_require__(21);\nvar classof = __w_pdfjs_require__(78);\nvar getBuiltIn = __w_pdfjs_require__(24);\nvar inspectSource = __w_pdfjs_require__(51);\nvar noop = function () {\n};\nvar empty = [];\nvar construct = getBuiltIn('Reflect', 'construct');\nvar constructorRegExp = /^\\s*(?:class|function)\\b/;\nvar exec = uncurryThis(constructorRegExp.exec);\nvar INCORRECT_TO_STRING = !constructorRegExp.exec(noop);\nvar isConstructorModern = function isConstructor(argument) {\n if (!isCallable(argument))\n  return false;\n try {\n  construct(noop, empty, argument);\n  return true;\n } catch (error) {\n  return false;\n }\n};\nvar isConstructorLegacy = function isConstructor(argument) {\n if (!isCallable(argument))\n  return false;\n switch (classof(argument)) {\n case 'AsyncFunction':\n case 'GeneratorFunction':\n case 'AsyncGeneratorFunction':\n  return false;\n }\n try {\n  return INCORRECT_TO_STRING || !!exec(constructorRegExp, inspectSource(argument));\n } catch (error) {\n  return true;\n }\n};\nisConstructorLegacy.sham = true;\nmodule.exports = !construct || fails(function () {\n var called;\n return isConstructorModern(isConstructorModern.call) || !isConstructorModern(Object) || !isConstructorModern(function () {\n  called = true;\n }) || called;\n}) ? isConstructorLegacy : isConstructorModern;\n\n/***/ }),\n/* 154 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar bind = __w_pdfjs_require__(99);\nvar call = __w_pdfjs_require__(8);\nvar anObject = __w_pdfjs_require__(47);\nvar tryToString = __w_pdfjs_require__(32);\nvar isArrayIteratorMethod = __w_pdfjs_require__(155);\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nvar isPrototypeOf = __w_pdfjs_require__(25);\nvar getIterator = __w_pdfjs_require__(157);\nvar getIteratorMethod = __w_pdfjs_require__(158);\nvar iteratorClose = __w_pdfjs_require__(140);\nvar $TypeError = TypeError;\nvar Result = function (stopped, result) {\n this.stopped = stopped;\n this.result = result;\n};\nvar ResultPrototype = Result.prototype;\nmodule.exports = function (iterable, unboundFunction, options) {\n var that = options && options.that;\n var AS_ENTRIES = !!(options && options.AS_ENTRIES);\n var IS_RECORD = !!(options && options.IS_RECORD);\n var IS_ITERATOR = !!(options && options.IS_ITERATOR);\n var INTERRUPTED = !!(options && options.INTERRUPTED);\n var fn = bind(unboundFunction, that);\n var iterator, iterFn, index, length, result, next, step;\n var stop = function (condition) {\n  if (iterator)\n   iteratorClose(iterator, 'normal', condition);\n  return new Result(true, condition);\n };\n var callFn = function (value) {\n  if (AS_ENTRIES) {\n   anObject(value);\n   return INTERRUPTED ? fn(value[0], value[1], stop) : fn(value[0], value[1]);\n  }\n  return INTERRUPTED ? fn(value, stop) : fn(value);\n };\n if (IS_RECORD) {\n  iterator = iterable.iterator;\n } else if (IS_ITERATOR) {\n  iterator = iterable;\n } else {\n  iterFn = getIteratorMethod(iterable);\n  if (!iterFn)\n   throw $TypeError(tryToString(iterable) + ' is not iterable');\n  if (isArrayIteratorMethod(iterFn)) {\n   for (index = 0, length = lengthOfArrayLike(iterable); length > index; index++) {\n    result = callFn(iterable[index]);\n    if (result && isPrototypeOf(ResultPrototype, result))\n     return result;\n   }\n   return new Result(false);\n  }\n  iterator = getIterator(iterable, iterFn);\n }\n next = IS_RECORD ? iterable.next : iterator.next;\n while (!(step = call(next, iterator)).done) {\n  try {\n   result = callFn(step.value);\n  } catch (error) {\n   iteratorClose(iterator, 'throw', error);\n  }\n  if (typeof result == 'object' && result && isPrototypeOf(ResultPrototype, result))\n   return result;\n }\n return new Result(false);\n};\n\n/***/ }),\n/* 155 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar wellKnownSymbol = __w_pdfjs_require__(34);\nvar Iterators = __w_pdfjs_require__(156);\nvar ITERATOR = wellKnownSymbol('iterator');\nvar ArrayPrototype = Array.prototype;\nmodule.exports = function (it) {\n return it !== undefined && (Iterators.Array === it || ArrayPrototype[ITERATOR] === it);\n};\n\n/***/ }),\n/* 156 */\n/***/ ((module) => {\n\n\nmodule.exports = {};\n\n/***/ }),\n/* 157 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar call = __w_pdfjs_require__(8);\nvar aCallable = __w_pdfjs_require__(31);\nvar anObject = __w_pdfjs_require__(47);\nvar tryToString = __w_pdfjs_require__(32);\nvar getIteratorMethod = __w_pdfjs_require__(158);\nvar $TypeError = TypeError;\nmodule.exports = function (argument, usingIterator) {\n var iteratorMethod = arguments.length < 2 ? getIteratorMethod(argument) : usingIterator;\n if (aCallable(iteratorMethod))\n  return anObject(call(iteratorMethod, argument));\n throw $TypeError(tryToString(argument) + ' is not iterable');\n};\n\n/***/ }),\n/* 158 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar classof = __w_pdfjs_require__(78);\nvar getMethod = __w_pdfjs_require__(30);\nvar isNullOrUndefined = __w_pdfjs_require__(17);\nvar Iterators = __w_pdfjs_require__(156);\nvar wellKnownSymbol = __w_pdfjs_require__(34);\nvar ITERATOR = wellKnownSymbol('iterator');\nmodule.exports = function (it) {\n if (!isNullOrUndefined(it))\n  return getMethod(it, ITERATOR) || getMethod(it, '@@iterator') || Iterators[classof(it)];\n};\n\n/***/ }),\n/* 159 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar toPropertyKey = __w_pdfjs_require__(18);\nvar definePropertyModule = __w_pdfjs_require__(45);\nvar createPropertyDescriptor = __w_pdfjs_require__(11);\nmodule.exports = function (object, key, value) {\n var propertyKey = toPropertyKey(key);\n if (propertyKey in object)\n  definePropertyModule.f(object, propertyKey, createPropertyDescriptor(0, value));\n else\n  object[propertyKey] = value;\n};\n\n/***/ }),\n/* 160 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar call = __w_pdfjs_require__(8);\nvar hasOwn = __w_pdfjs_require__(39);\nvar isPrototypeOf = __w_pdfjs_require__(25);\nvar regExpFlags = __w_pdfjs_require__(161);\nvar RegExpPrototype = RegExp.prototype;\nmodule.exports = function (R) {\n var flags = R.flags;\n return flags === undefined && !('flags' in RegExpPrototype) && !hasOwn(R, 'flags') && isPrototypeOf(RegExpPrototype, R) ? call(regExpFlags, R) : flags;\n};\n\n/***/ }),\n/* 161 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar anObject = __w_pdfjs_require__(47);\nmodule.exports = function () {\n var that = anObject(this);\n var result = '';\n if (that.hasIndices)\n  result += 'd';\n if (that.global)\n  result += 'g';\n if (that.ignoreCase)\n  result += 'i';\n if (that.multiline)\n  result += 'm';\n if (that.dotAll)\n  result += 's';\n if (that.unicode)\n  result += 'u';\n if (that.unicodeSets)\n  result += 'v';\n if (that.sticky)\n  result += 'y';\n return result;\n};\n\n/***/ }),\n/* 162 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar MapPrototype = Map.prototype;\nmodule.exports = {\n Map: Map,\n set: uncurryThis(MapPrototype.set),\n get: uncurryThis(MapPrototype.get),\n has: uncurryThis(MapPrototype.has),\n remove: uncurryThis(MapPrototype['delete']),\n proto: MapPrototype\n};\n\n/***/ }),\n/* 163 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SerializableEmpty = exports.PrintAnnotationStorage = exports.AnnotationStorage = void 0;\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(149);\n__w_pdfjs_require__(152);\nvar _util = __w_pdfjs_require__(1);\nvar _editor = __w_pdfjs_require__(164);\nvar _murmurhash = __w_pdfjs_require__(170);\nconst SerializableEmpty = Object.freeze({\n  map: null,\n  hash: \"\",\n  transfers: undefined\n});\nexports.SerializableEmpty = SerializableEmpty;\nclass AnnotationStorage {\n  #modified = false;\n  #storage = new Map();\n  constructor() {\n    this.onSetModified = null;\n    this.onResetModified = null;\n    this.onAnnotationEditor = null;\n  }\n  getValue(key, defaultValue) {\n    const value = this.#storage.get(key);\n    if (value === undefined) {\n      return defaultValue;\n    }\n    return Object.assign(defaultValue, value);\n  }\n  getRawValue(key) {\n    return this.#storage.get(key);\n  }\n  remove(key) {\n    this.#storage.delete(key);\n    if (this.#storage.size === 0) {\n      this.resetModified();\n    }\n    if (typeof this.onAnnotationEditor === \"function\") {\n      for (const value of this.#storage.values()) {\n        if (value instanceof _editor.AnnotationEditor) {\n          return;\n        }\n      }\n      this.onAnnotationEditor(null);\n    }\n  }\n  setValue(key, value) {\n    const obj = this.#storage.get(key);\n    let modified = false;\n    if (obj !== undefined) {\n      for (const [entry, val] of Object.entries(value)) {\n        if (obj[entry] !== val) {\n          modified = true;\n          obj[entry] = val;\n        }\n      }\n    } else {\n      modified = true;\n      this.#storage.set(key, value);\n    }\n    if (modified) {\n      this.#setModified();\n    }\n    if (value instanceof _editor.AnnotationEditor && typeof this.onAnnotationEditor === \"function\") {\n      this.onAnnotationEditor(value.constructor._type);\n    }\n  }\n  has(key) {\n    return this.#storage.has(key);\n  }\n  getAll() {\n    return this.#storage.size > 0 ? (0, _util.objectFromMap)(this.#storage) : null;\n  }\n  setAll(obj) {\n    for (const [key, val] of Object.entries(obj)) {\n      this.setValue(key, val);\n    }\n  }\n  get size() {\n    return this.#storage.size;\n  }\n  #setModified() {\n    if (!this.#modified) {\n      this.#modified = true;\n      if (typeof this.onSetModified === \"function\") {\n        this.onSetModified();\n      }\n    }\n  }\n  resetModified() {\n    if (this.#modified) {\n      this.#modified = false;\n      if (typeof this.onResetModified === \"function\") {\n        this.onResetModified();\n      }\n    }\n  }\n  get print() {\n    return new PrintAnnotationStorage(this);\n  }\n  get serializable() {\n    if (this.#storage.size === 0) {\n      return SerializableEmpty;\n    }\n    const map = new Map(),\n      hash = new _murmurhash.MurmurHash3_64(),\n      transfers = [];\n    const context = Object.create(null);\n    let hasBitmap = false;\n    for (const [key, val] of this.#storage) {\n      const serialized = val instanceof _editor.AnnotationEditor ? val.serialize(false, context) : val;\n      if (serialized) {\n        map.set(key, serialized);\n        hash.update(`${key}:${JSON.stringify(serialized)}`);\n        hasBitmap ||= !!serialized.bitmap;\n      }\n    }\n    if (hasBitmap) {\n      for (const value of map.values()) {\n        if (value.bitmap) {\n          transfers.push(value.bitmap);\n        }\n      }\n    }\n    return map.size > 0 ? {\n      map,\n      hash: hash.hexdigest(),\n      transfers\n    } : SerializableEmpty;\n  }\n}\nexports.AnnotationStorage = AnnotationStorage;\nclass PrintAnnotationStorage extends AnnotationStorage {\n  #serializable;\n  constructor(parent) {\n    super();\n    const {\n      map,\n      hash,\n      transfers\n    } = parent.serializable;\n    const clone = structuredClone(map, null);\n    this.#serializable = {\n      map: clone,\n      hash,\n      transfers\n    };\n  }\n  get print() {\n    (0, _util.unreachable)(\"Should not call PrintAnnotationStorage.print\");\n  }\n  get serializable() {\n    return this.#serializable;\n  }\n}\nexports.PrintAnnotationStorage = PrintAnnotationStorage;\n\n/***/ }),\n/* 164 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationEditor = void 0;\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(2);\nvar _tools = __w_pdfjs_require__(165);\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(168);\nclass AnnotationEditor {\n  #altText = \"\";\n  #altTextDecorative = false;\n  #altTextButton = null;\n  #altTextTooltip = null;\n  #altTextTooltipTimeout = null;\n  #keepAspectRatio = false;\n  #resizersDiv = null;\n  #boundFocusin = this.focusin.bind(this);\n  #boundFocusout = this.focusout.bind(this);\n  #hasBeenClicked = false;\n  #isEditing = false;\n  #isInEditMode = false;\n  _initialOptions = Object.create(null);\n  _uiManager = null;\n  _focusEventsAllowed = true;\n  _l10nPromise = null;\n  #isDraggable = false;\n  #zIndex = AnnotationEditor._zIndex++;\n  static _borderLineWidth = -1;\n  static _colorManager = new _tools.ColorManager();\n  static _zIndex = 1;\n  static SMALL_EDITOR_SIZE = 0;\n  constructor(parameters) {\n    if (this.constructor === AnnotationEditor) {\n      (0, _util.unreachable)(\"Cannot initialize AnnotationEditor.\");\n    }\n    this.parent = parameters.parent;\n    this.id = parameters.id;\n    this.width = this.height = null;\n    this.pageIndex = parameters.parent.pageIndex;\n    this.name = parameters.name;\n    this.div = null;\n    this._uiManager = parameters.uiManager;\n    this.annotationElementId = null;\n    this._willKeepAspectRatio = false;\n    this._initialOptions.isCentered = parameters.isCentered;\n    this._structTreeParentId = null;\n    const {\n      rotation,\n      rawDims: {\n        pageWidth,\n        pageHeight,\n        pageX,\n        pageY\n      }\n    } = this.parent.viewport;\n    this.rotation = rotation;\n    this.pageRotation = (360 + rotation - this._uiManager.viewParameters.rotation) % 360;\n    this.pageDimensions = [pageWidth, pageHeight];\n    this.pageTranslation = [pageX, pageY];\n    const [width, height] = this.parentDimensions;\n    this.x = parameters.x / width;\n    this.y = parameters.y / height;\n    this.isAttachedToDOM = false;\n    this.deleted = false;\n  }\n  get editorType() {\n    return Object.getPrototypeOf(this).constructor._type;\n  }\n  static get _defaultLineColor() {\n    return (0, _util.shadow)(this, \"_defaultLineColor\", this._colorManager.getHexCode(\"CanvasText\"));\n  }\n  static deleteAnnotationElement(editor) {\n    const fakeEditor = new FakeEditor({\n      id: editor.parent.getNextId(),\n      parent: editor.parent,\n      uiManager: editor._uiManager\n    });\n    fakeEditor.annotationElementId = editor.annotationElementId;\n    fakeEditor.deleted = true;\n    fakeEditor._uiManager.addToAnnotationStorage(fakeEditor);\n  }\n  static initialize(l10n) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    AnnotationEditor._l10nPromise ||= new Map([\"editor_alt_text_button_label\", \"editor_alt_text_edit_button_label\", \"editor_alt_text_decorative_tooltip\"].map(str => [str, l10n.get(str)]));\n    if (options?.strings) {\n      for (const str of options.strings) {\n        AnnotationEditor._l10nPromise.set(str, l10n.get(str));\n      }\n    }\n    if (AnnotationEditor._borderLineWidth !== -1) {\n      return;\n    }\n    const style = getComputedStyle(document.documentElement);\n    AnnotationEditor._borderLineWidth = parseFloat(style.getPropertyValue(\"--outline-width\")) || 0;\n  }\n  static updateDefaultParams(_type, _value) {}\n  static get defaultPropertiesToUpdate() {\n    return [];\n  }\n  static isHandlingMimeForPasting(mime) {\n    return false;\n  }\n  static paste(item, parent) {\n    (0, _util.unreachable)(\"Not implemented\");\n  }\n  get propertiesToUpdate() {\n    return [];\n  }\n  get _isDraggable() {\n    return this.#isDraggable;\n  }\n  set _isDraggable(value) {\n    this.#isDraggable = value;\n    this.div?.classList.toggle(\"draggable\", value);\n  }\n  center() {\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    switch (this.parentRotation) {\n      case 90:\n        this.x -= this.height * pageHeight / (pageWidth * 2);\n        this.y += this.width * pageWidth / (pageHeight * 2);\n        break;\n      case 180:\n        this.x += this.width / 2;\n        this.y += this.height / 2;\n        break;\n      case 270:\n        this.x += this.height * pageHeight / (pageWidth * 2);\n        this.y -= this.width * pageWidth / (pageHeight * 2);\n        break;\n      default:\n        this.x -= this.width / 2;\n        this.y -= this.height / 2;\n        break;\n    }\n    this.fixAndSetPosition();\n  }\n  addCommands(params) {\n    this._uiManager.addCommands(params);\n  }\n  get currentLayer() {\n    return this._uiManager.currentLayer;\n  }\n  setInBackground() {\n    this.div.style.zIndex = 0;\n  }\n  setInForeground() {\n    this.div.style.zIndex = this.#zIndex;\n  }\n  setParent(parent) {\n    if (parent !== null) {\n      this.pageIndex = parent.pageIndex;\n      this.pageDimensions = parent.pageDimensions;\n    }\n    this.parent = parent;\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    if (!this.#hasBeenClicked) {\n      this.parent.setSelected(this);\n    } else {\n      this.#hasBeenClicked = false;\n    }\n  }\n  focusout(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    if (!this.isAttachedToDOM) {\n      return;\n    }\n    const target = event.relatedTarget;\n    if (target?.closest(`#${this.id}`)) {\n      return;\n    }\n    event.preventDefault();\n    if (!this.parent?.isMultipleSelection) {\n      this.commitOrRemove();\n    }\n  }\n  commitOrRemove() {\n    if (this.isEmpty()) {\n      this.remove();\n    } else {\n      this.commit();\n    }\n  }\n  commit() {\n    this.addToAnnotationStorage();\n  }\n  addToAnnotationStorage() {\n    this._uiManager.addToAnnotationStorage(this);\n  }\n  setAt(x, y, tx, ty) {\n    const [width, height] = this.parentDimensions;\n    [tx, ty] = this.screenToPageTranslation(tx, ty);\n    this.x = (x + tx) / width;\n    this.y = (y + ty) / height;\n    this.fixAndSetPosition();\n  }\n  #translate(_ref, x, y) {\n    let [width, height] = _ref;\n    [x, y] = this.screenToPageTranslation(x, y);\n    this.x += x / width;\n    this.y += y / height;\n    this.fixAndSetPosition();\n  }\n  translate(x, y) {\n    this.#translate(this.parentDimensions, x, y);\n  }\n  translateInPage(x, y) {\n    this.#translate(this.pageDimensions, x, y);\n    this.div.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n  drag(tx, ty) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.x += tx / parentWidth;\n    this.y += ty / parentHeight;\n    if (this.parent && (this.x < 0 || this.x > 1 || this.y < 0 || this.y > 1)) {\n      const {\n        x,\n        y\n      } = this.div.getBoundingClientRect();\n      if (this.parent.findNewParent(this, x, y)) {\n        this.x -= Math.floor(this.x);\n        this.y -= Math.floor(this.y);\n      }\n    }\n    let {\n      x,\n      y\n    } = this;\n    const [bx, by] = this.#getBaseTranslation();\n    x += bx;\n    y += by;\n    this.div.style.left = `${(100 * x).toFixed(2)}%`;\n    this.div.style.top = `${(100 * y).toFixed(2)}%`;\n    this.div.scrollIntoView({\n      block: \"nearest\"\n    });\n  }\n  #getBaseTranslation() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const {\n      _borderLineWidth\n    } = AnnotationEditor;\n    const x = _borderLineWidth / parentWidth;\n    const y = _borderLineWidth / parentHeight;\n    switch (this.rotation) {\n      case 90:\n        return [-x, y];\n      case 180:\n        return [x, y];\n      case 270:\n        return [x, -y];\n      default:\n        return [-x, -y];\n    }\n  }\n  fixAndSetPosition() {\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    let {\n      x,\n      y,\n      width,\n      height\n    } = this;\n    width *= pageWidth;\n    height *= pageHeight;\n    x *= pageWidth;\n    y *= pageHeight;\n    switch (this.rotation) {\n      case 0:\n        x = Math.max(0, Math.min(pageWidth - width, x));\n        y = Math.max(0, Math.min(pageHeight - height, y));\n        break;\n      case 90:\n        x = Math.max(0, Math.min(pageWidth - height, x));\n        y = Math.min(pageHeight, Math.max(width, y));\n        break;\n      case 180:\n        x = Math.min(pageWidth, Math.max(width, x));\n        y = Math.min(pageHeight, Math.max(height, y));\n        break;\n      case 270:\n        x = Math.min(pageWidth, Math.max(height, x));\n        y = Math.max(0, Math.min(pageHeight - width, y));\n        break;\n    }\n    this.x = x /= pageWidth;\n    this.y = y /= pageHeight;\n    const [bx, by] = this.#getBaseTranslation();\n    x += bx;\n    y += by;\n    const {\n      style\n    } = this.div;\n    style.left = `${(100 * x).toFixed(2)}%`;\n    style.top = `${(100 * y).toFixed(2)}%`;\n    this.moveInDOM();\n  }\n  static #rotatePoint(x, y, angle) {\n    switch (angle) {\n      case 90:\n        return [y, -x];\n      case 180:\n        return [-x, -y];\n      case 270:\n        return [-y, x];\n      default:\n        return [x, y];\n    }\n  }\n  screenToPageTranslation(x, y) {\n    return AnnotationEditor.#rotatePoint(x, y, this.parentRotation);\n  }\n  pageTranslationToScreen(x, y) {\n    return AnnotationEditor.#rotatePoint(x, y, 360 - this.parentRotation);\n  }\n  #getRotationMatrix(rotation) {\n    switch (rotation) {\n      case 90:\n        {\n          const [pageWidth, pageHeight] = this.pageDimensions;\n          return [0, -pageWidth / pageHeight, pageHeight / pageWidth, 0];\n        }\n      case 180:\n        return [-1, 0, 0, -1];\n      case 270:\n        {\n          const [pageWidth, pageHeight] = this.pageDimensions;\n          return [0, pageWidth / pageHeight, -pageHeight / pageWidth, 0];\n        }\n      default:\n        return [1, 0, 0, 1];\n    }\n  }\n  get parentScale() {\n    return this._uiManager.viewParameters.realScale;\n  }\n  get parentRotation() {\n    return (this._uiManager.viewParameters.rotation + this.pageRotation) % 360;\n  }\n  get parentDimensions() {\n    const {\n      parentScale,\n      pageDimensions: [pageWidth, pageHeight]\n    } = this;\n    const scaledWidth = pageWidth * parentScale;\n    const scaledHeight = pageHeight * parentScale;\n    return _util.FeatureTest.isCSSRoundSupported ? [Math.round(scaledWidth), Math.round(scaledHeight)] : [scaledWidth, scaledHeight];\n  }\n  setDims(width, height) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.div.style.width = `${(100 * width / parentWidth).toFixed(2)}%`;\n    if (!this.#keepAspectRatio) {\n      this.div.style.height = `${(100 * height / parentHeight).toFixed(2)}%`;\n    }\n    this.#altTextButton?.classList.toggle(\"small\", width < AnnotationEditor.SMALL_EDITOR_SIZE || height < AnnotationEditor.SMALL_EDITOR_SIZE);\n  }\n  fixDims() {\n    const {\n      style\n    } = this.div;\n    const {\n      height,\n      width\n    } = style;\n    const widthPercent = width.endsWith(\"%\");\n    const heightPercent = !this.#keepAspectRatio && height.endsWith(\"%\");\n    if (widthPercent && heightPercent) {\n      return;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    if (!widthPercent) {\n      style.width = `${(100 * parseFloat(width) / parentWidth).toFixed(2)}%`;\n    }\n    if (!this.#keepAspectRatio && !heightPercent) {\n      style.height = `${(100 * parseFloat(height) / parentHeight).toFixed(2)}%`;\n    }\n  }\n  getInitialTranslation() {\n    return [0, 0];\n  }\n  #createResizers() {\n    if (this.#resizersDiv) {\n      return;\n    }\n    this.#resizersDiv = document.createElement(\"div\");\n    this.#resizersDiv.classList.add(\"resizers\");\n    const classes = [\"topLeft\", \"topRight\", \"bottomRight\", \"bottomLeft\"];\n    if (!this._willKeepAspectRatio) {\n      classes.push(\"topMiddle\", \"middleRight\", \"bottomMiddle\", \"middleLeft\");\n    }\n    for (const name of classes) {\n      const div = document.createElement(\"div\");\n      this.#resizersDiv.append(div);\n      div.classList.add(\"resizer\", name);\n      div.addEventListener(\"pointerdown\", this.#resizerPointerdown.bind(this, name));\n      div.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n    }\n    this.div.prepend(this.#resizersDiv);\n  }\n  #resizerPointerdown(name, event) {\n    event.preventDefault();\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    const boundResizerPointermove = this.#resizerPointermove.bind(this, name);\n    const savedDraggable = this._isDraggable;\n    this._isDraggable = false;\n    const pointerMoveOptions = {\n      passive: true,\n      capture: true\n    };\n    window.addEventListener(\"pointermove\", boundResizerPointermove, pointerMoveOptions);\n    const savedX = this.x;\n    const savedY = this.y;\n    const savedWidth = this.width;\n    const savedHeight = this.height;\n    const savedParentCursor = this.parent.div.style.cursor;\n    const savedCursor = this.div.style.cursor;\n    this.div.style.cursor = this.parent.div.style.cursor = window.getComputedStyle(event.target).cursor;\n    const pointerUpCallback = () => {\n      this._isDraggable = savedDraggable;\n      window.removeEventListener(\"pointerup\", pointerUpCallback);\n      window.removeEventListener(\"blur\", pointerUpCallback);\n      window.removeEventListener(\"pointermove\", boundResizerPointermove, pointerMoveOptions);\n      this.parent.div.style.cursor = savedParentCursor;\n      this.div.style.cursor = savedCursor;\n      const newX = this.x;\n      const newY = this.y;\n      const newWidth = this.width;\n      const newHeight = this.height;\n      if (newX === savedX && newY === savedY && newWidth === savedWidth && newHeight === savedHeight) {\n        return;\n      }\n      this.addCommands({\n        cmd: () => {\n          this.width = newWidth;\n          this.height = newHeight;\n          this.x = newX;\n          this.y = newY;\n          const [parentWidth, parentHeight] = this.parentDimensions;\n          this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n          this.fixAndSetPosition();\n        },\n        undo: () => {\n          this.width = savedWidth;\n          this.height = savedHeight;\n          this.x = savedX;\n          this.y = savedY;\n          const [parentWidth, parentHeight] = this.parentDimensions;\n          this.setDims(parentWidth * savedWidth, parentHeight * savedHeight);\n          this.fixAndSetPosition();\n        },\n        mustExec: true\n      });\n    };\n    window.addEventListener(\"pointerup\", pointerUpCallback);\n    window.addEventListener(\"blur\", pointerUpCallback);\n  }\n  #resizerPointermove(name, event) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const savedX = this.x;\n    const savedY = this.y;\n    const savedWidth = this.width;\n    const savedHeight = this.height;\n    const minWidth = AnnotationEditor.MIN_SIZE / parentWidth;\n    const minHeight = AnnotationEditor.MIN_SIZE / parentHeight;\n    const round = x => Math.round(x * 10000) / 10000;\n    const rotationMatrix = this.#getRotationMatrix(this.rotation);\n    const transf = (x, y) => [rotationMatrix[0] * x + rotationMatrix[2] * y, rotationMatrix[1] * x + rotationMatrix[3] * y];\n    const invRotationMatrix = this.#getRotationMatrix(360 - this.rotation);\n    const invTransf = (x, y) => [invRotationMatrix[0] * x + invRotationMatrix[2] * y, invRotationMatrix[1] * x + invRotationMatrix[3] * y];\n    let getPoint;\n    let getOpposite;\n    let isDiagonal = false;\n    let isHorizontal = false;\n    switch (name) {\n      case \"topLeft\":\n        isDiagonal = true;\n        getPoint = (w, h) => [0, 0];\n        getOpposite = (w, h) => [w, h];\n        break;\n      case \"topMiddle\":\n        getPoint = (w, h) => [w / 2, 0];\n        getOpposite = (w, h) => [w / 2, h];\n        break;\n      case \"topRight\":\n        isDiagonal = true;\n        getPoint = (w, h) => [w, 0];\n        getOpposite = (w, h) => [0, h];\n        break;\n      case \"middleRight\":\n        isHorizontal = true;\n        getPoint = (w, h) => [w, h / 2];\n        getOpposite = (w, h) => [0, h / 2];\n        break;\n      case \"bottomRight\":\n        isDiagonal = true;\n        getPoint = (w, h) => [w, h];\n        getOpposite = (w, h) => [0, 0];\n        break;\n      case \"bottomMiddle\":\n        getPoint = (w, h) => [w / 2, h];\n        getOpposite = (w, h) => [w / 2, 0];\n        break;\n      case \"bottomLeft\":\n        isDiagonal = true;\n        getPoint = (w, h) => [0, h];\n        getOpposite = (w, h) => [w, 0];\n        break;\n      case \"middleLeft\":\n        isHorizontal = true;\n        getPoint = (w, h) => [0, h / 2];\n        getOpposite = (w, h) => [w, h / 2];\n        break;\n    }\n    const point = getPoint(savedWidth, savedHeight);\n    const oppositePoint = getOpposite(savedWidth, savedHeight);\n    let transfOppositePoint = transf(...oppositePoint);\n    const oppositeX = round(savedX + transfOppositePoint[0]);\n    const oppositeY = round(savedY + transfOppositePoint[1]);\n    let ratioX = 1;\n    let ratioY = 1;\n    let [deltaX, deltaY] = this.screenToPageTranslation(event.movementX, event.movementY);\n    [deltaX, deltaY] = invTransf(deltaX / parentWidth, deltaY / parentHeight);\n    if (isDiagonal) {\n      const oldDiag = Math.hypot(savedWidth, savedHeight);\n      ratioX = ratioY = Math.max(Math.min(Math.hypot(oppositePoint[0] - point[0] - deltaX, oppositePoint[1] - point[1] - deltaY) / oldDiag, 1 / savedWidth, 1 / savedHeight), minWidth / savedWidth, minHeight / savedHeight);\n    } else if (isHorizontal) {\n      ratioX = Math.max(minWidth, Math.min(1, Math.abs(oppositePoint[0] - point[0] - deltaX))) / savedWidth;\n    } else {\n      ratioY = Math.max(minHeight, Math.min(1, Math.abs(oppositePoint[1] - point[1] - deltaY))) / savedHeight;\n    }\n    const newWidth = round(savedWidth * ratioX);\n    const newHeight = round(savedHeight * ratioY);\n    transfOppositePoint = transf(...getOpposite(newWidth, newHeight));\n    const newX = oppositeX - transfOppositePoint[0];\n    const newY = oppositeY - transfOppositePoint[1];\n    this.width = newWidth;\n    this.height = newHeight;\n    this.x = newX;\n    this.y = newY;\n    this.setDims(parentWidth * newWidth, parentHeight * newHeight);\n    this.fixAndSetPosition();\n  }\n  async addAltTextButton() {\n    if (this.#altTextButton) {\n      return;\n    }\n    const altText = this.#altTextButton = document.createElement(\"button\");\n    altText.className = \"altText\";\n    const msg = await AnnotationEditor._l10nPromise.get(\"editor_alt_text_button_label\");\n    altText.textContent = msg;\n    altText.setAttribute(\"aria-label\", msg);\n    altText.tabIndex = \"0\";\n    altText.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n    altText.addEventListener(\"pointerdown\", event => event.stopPropagation());\n    altText.addEventListener(\"click\", event => {\n      event.preventDefault();\n      this._uiManager.editAltText(this);\n    }, {\n      capture: true\n    });\n    altText.addEventListener(\"keydown\", event => {\n      if (event.target === altText && event.key === \"Enter\") {\n        event.preventDefault();\n        this._uiManager.editAltText(this);\n      }\n    });\n    this.#setAltTextButtonState();\n    this.div.append(altText);\n    if (!AnnotationEditor.SMALL_EDITOR_SIZE) {\n      const PERCENT = 40;\n      AnnotationEditor.SMALL_EDITOR_SIZE = Math.min(128, Math.round(altText.getBoundingClientRect().width * (1 + PERCENT / 100)));\n    }\n  }\n  async #setAltTextButtonState() {\n    const button = this.#altTextButton;\n    if (!button) {\n      return;\n    }\n    if (!this.#altText && !this.#altTextDecorative) {\n      button.classList.remove(\"done\");\n      this.#altTextTooltip?.remove();\n      return;\n    }\n    AnnotationEditor._l10nPromise.get(\"editor_alt_text_edit_button_label\").then(msg => {\n      button.setAttribute(\"aria-label\", msg);\n    });\n    let tooltip = this.#altTextTooltip;\n    if (!tooltip) {\n      this.#altTextTooltip = tooltip = document.createElement(\"span\");\n      tooltip.className = \"tooltip\";\n      tooltip.setAttribute(\"role\", \"tooltip\");\n      const id = tooltip.id = `alt-text-tooltip-${this.id}`;\n      button.setAttribute(\"aria-describedby\", id);\n      const DELAY_TO_SHOW_TOOLTIP = 100;\n      button.addEventListener(\"mouseenter\", () => {\n        this.#altTextTooltipTimeout = setTimeout(() => {\n          this.#altTextTooltipTimeout = null;\n          this.#altTextTooltip.classList.add(\"show\");\n          this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n            source: this,\n            details: {\n              type: \"editing\",\n              subtype: this.editorType,\n              data: {\n                action: \"alt_text_tooltip\"\n              }\n            }\n          });\n        }, DELAY_TO_SHOW_TOOLTIP);\n      });\n      button.addEventListener(\"mouseleave\", () => {\n        clearTimeout(this.#altTextTooltipTimeout);\n        this.#altTextTooltipTimeout = null;\n        this.#altTextTooltip?.classList.remove(\"show\");\n      });\n    }\n    button.classList.add(\"done\");\n    tooltip.innerText = this.#altTextDecorative ? await AnnotationEditor._l10nPromise.get(\"editor_alt_text_decorative_tooltip\") : this.#altText;\n    if (!tooltip.parentNode) {\n      button.append(tooltip);\n    }\n  }\n  getClientDimensions() {\n    return this.div.getBoundingClientRect();\n  }\n  get altTextData() {\n    return {\n      altText: this.#altText,\n      decorative: this.#altTextDecorative\n    };\n  }\n  set altTextData(_ref2) {\n    let {\n      altText,\n      decorative\n    } = _ref2;\n    if (this.#altText === altText && this.#altTextDecorative === decorative) {\n      return;\n    }\n    this.#altText = altText;\n    this.#altTextDecorative = decorative;\n    this.#setAltTextButtonState();\n  }\n  render() {\n    this.div = document.createElement(\"div\");\n    this.div.setAttribute(\"data-editor-rotation\", (360 - this.rotation) % 360);\n    this.div.className = this.name;\n    this.div.setAttribute(\"id\", this.id);\n    this.div.setAttribute(\"tabIndex\", 0);\n    this.setInForeground();\n    this.div.addEventListener(\"focusin\", this.#boundFocusin);\n    this.div.addEventListener(\"focusout\", this.#boundFocusout);\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    if (this.parentRotation % 180 !== 0) {\n      this.div.style.maxWidth = `${(100 * parentHeight / parentWidth).toFixed(2)}%`;\n      this.div.style.maxHeight = `${(100 * parentWidth / parentHeight).toFixed(2)}%`;\n    }\n    const [tx, ty] = this.getInitialTranslation();\n    this.translate(tx, ty);\n    (0, _tools.bindEvents)(this, this.div, [\"pointerdown\"]);\n    return this.div;\n  }\n  pointerdown(event) {\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      event.preventDefault();\n      return;\n    }\n    this.#hasBeenClicked = true;\n    this.#setUpDragSession(event);\n  }\n  #setUpDragSession(event) {\n    if (!this._isDraggable) {\n      return;\n    }\n    const isSelected = this._uiManager.isSelected(this);\n    this._uiManager.setUpDragSession();\n    let pointerMoveOptions, pointerMoveCallback;\n    if (isSelected) {\n      pointerMoveOptions = {\n        passive: true,\n        capture: true\n      };\n      pointerMoveCallback = e => {\n        const [tx, ty] = this.screenToPageTranslation(e.movementX, e.movementY);\n        this._uiManager.dragSelectedEditors(tx, ty);\n      };\n      window.addEventListener(\"pointermove\", pointerMoveCallback, pointerMoveOptions);\n    }\n    const pointerUpCallback = () => {\n      window.removeEventListener(\"pointerup\", pointerUpCallback);\n      window.removeEventListener(\"blur\", pointerUpCallback);\n      if (isSelected) {\n        window.removeEventListener(\"pointermove\", pointerMoveCallback, pointerMoveOptions);\n      }\n      this.#hasBeenClicked = false;\n      if (!this._uiManager.endDragSession()) {\n        const {\n          isMac\n        } = _util.FeatureTest.platform;\n        if (event.ctrlKey && !isMac || event.shiftKey || event.metaKey && isMac) {\n          this.parent.toggleSelected(this);\n        } else {\n          this.parent.setSelected(this);\n        }\n      }\n    };\n    window.addEventListener(\"pointerup\", pointerUpCallback);\n    window.addEventListener(\"blur\", pointerUpCallback);\n  }\n  moveInDOM() {\n    this.parent?.moveEditorInDOM(this);\n  }\n  _setParentAndPosition(parent, x, y) {\n    parent.changeParent(this);\n    this.x = x;\n    this.y = y;\n    this.fixAndSetPosition();\n  }\n  getRect(tx, ty) {\n    const scale = this.parentScale;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const [pageX, pageY] = this.pageTranslation;\n    const shiftX = tx / scale;\n    const shiftY = ty / scale;\n    const x = this.x * pageWidth;\n    const y = this.y * pageHeight;\n    const width = this.width * pageWidth;\n    const height = this.height * pageHeight;\n    switch (this.rotation) {\n      case 0:\n        return [x + shiftX + pageX, pageHeight - y - shiftY - height + pageY, x + shiftX + width + pageX, pageHeight - y - shiftY + pageY];\n      case 90:\n        return [x + shiftY + pageX, pageHeight - y + shiftX + pageY, x + shiftY + height + pageX, pageHeight - y + shiftX + width + pageY];\n      case 180:\n        return [x - shiftX - width + pageX, pageHeight - y + shiftY + pageY, x - shiftX + pageX, pageHeight - y + shiftY + height + pageY];\n      case 270:\n        return [x - shiftY - height + pageX, pageHeight - y - shiftX - width + pageY, x - shiftY + pageX, pageHeight - y - shiftX + pageY];\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n  getRectInCurrentCoords(rect, pageHeight) {\n    const [x1, y1, x2, y2] = rect;\n    const width = x2 - x1;\n    const height = y2 - y1;\n    switch (this.rotation) {\n      case 0:\n        return [x1, pageHeight - y2, width, height];\n      case 90:\n        return [x1, pageHeight - y1, height, width];\n      case 180:\n        return [x2, pageHeight - y1, width, height];\n      case 270:\n        return [x2, pageHeight - y2, height, width];\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n  }\n  onceAdded() {}\n  isEmpty() {\n    return false;\n  }\n  enableEditMode() {\n    this.#isInEditMode = true;\n  }\n  disableEditMode() {\n    this.#isInEditMode = false;\n  }\n  isInEditMode() {\n    return this.#isInEditMode;\n  }\n  shouldGetKeyboardEvents() {\n    return false;\n  }\n  needsToBeRebuilt() {\n    return this.div && !this.isAttachedToDOM;\n  }\n  rebuild() {\n    this.div?.addEventListener(\"focusin\", this.#boundFocusin);\n    this.div?.addEventListener(\"focusout\", this.#boundFocusout);\n  }\n  serialize() {\n    let isForCopying = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    (0, _util.unreachable)(\"An editor must be serializable\");\n  }\n  static deserialize(data, parent, uiManager) {\n    const editor = new this.prototype.constructor({\n      parent,\n      id: parent.getNextId(),\n      uiManager\n    });\n    editor.rotation = data.rotation;\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const [x, y, width, height] = editor.getRectInCurrentCoords(data.rect, pageHeight);\n    editor.x = x / pageWidth;\n    editor.y = y / pageHeight;\n    editor.width = width / pageWidth;\n    editor.height = height / pageHeight;\n    return editor;\n  }\n  remove() {\n    this.div.removeEventListener(\"focusin\", this.#boundFocusin);\n    this.div.removeEventListener(\"focusout\", this.#boundFocusout);\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n    if (this.parent) {\n      this.parent.remove(this);\n    } else {\n      this._uiManager.removeEditor(this);\n    }\n    this.#altTextButton?.remove();\n    this.#altTextButton = null;\n    this.#altTextTooltip = null;\n  }\n  get isResizable() {\n    return false;\n  }\n  makeResizable() {\n    if (this.isResizable) {\n      this.#createResizers();\n      this.#resizersDiv.classList.remove(\"hidden\");\n    }\n  }\n  select() {\n    this.makeResizable();\n    this.div?.classList.add(\"selectedEditor\");\n  }\n  unselect() {\n    this.#resizersDiv?.classList.add(\"hidden\");\n    this.div?.classList.remove(\"selectedEditor\");\n    if (this.div?.contains(document.activeElement)) {\n      this._uiManager.currentLayer.div.focus();\n    }\n  }\n  updateParams(type, value) {}\n  disableEditing() {\n    if (this.#altTextButton) {\n      this.#altTextButton.hidden = true;\n    }\n  }\n  enableEditing() {\n    if (this.#altTextButton) {\n      this.#altTextButton.hidden = false;\n    }\n  }\n  enterInEditMode() {}\n  get contentDiv() {\n    return this.div;\n  }\n  get isEditing() {\n    return this.#isEditing;\n  }\n  set isEditing(value) {\n    this.#isEditing = value;\n    if (!this.parent) {\n      return;\n    }\n    if (value) {\n      this.parent.setSelected(this);\n      this.parent.setActiveEditor(this);\n    } else {\n      this.parent.setActiveEditor(null);\n    }\n  }\n  setAspectRatio(width, height) {\n    this.#keepAspectRatio = true;\n    const aspectRatio = width / height;\n    const {\n      style\n    } = this.div;\n    style.aspectRatio = aspectRatio;\n    style.height = \"auto\";\n  }\n  static get MIN_SIZE() {\n    return 16;\n  }\n}\nexports.AnnotationEditor = AnnotationEditor;\nclass FakeEditor extends AnnotationEditor {\n  constructor(params) {\n    super(params);\n    this.annotationElementId = params.annotationElementId;\n    this.deleted = true;\n  }\n  serialize() {\n    return {\n      id: this.annotationElementId,\n      deleted: true,\n      pageIndex: this.pageIndex\n    };\n  }\n}\n\n/***/ }),\n/* 165 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.KeyboardManager = exports.CommandManager = exports.ColorManager = exports.AnnotationEditorUIManager = void 0;\nexports.bindEvents = bindEvents;\nexports.opacityToHex = opacityToHex;\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\n__w_pdfjs_require__(2);\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(125);\n__w_pdfjs_require__(136);\n__w_pdfjs_require__(138);\n__w_pdfjs_require__(141);\n__w_pdfjs_require__(143);\n__w_pdfjs_require__(145);\n__w_pdfjs_require__(147);\n__w_pdfjs_require__(166);\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(168);\nfunction bindEvents(obj, element, names) {\n  for (const name of names) {\n    element.addEventListener(name, obj[name].bind(obj));\n  }\n}\nfunction opacityToHex(opacity) {\n  return Math.round(Math.min(255, Math.max(1, 255 * opacity))).toString(16).padStart(2, \"0\");\n}\nclass IdManager {\n  #id = 0;\n  getId() {\n    return `${_util.AnnotationEditorPrefix}${this.#id++}`;\n  }\n}\nclass ImageManager {\n  #baseId = (0, _util.getUuid)();\n  #id = 0;\n  #cache = null;\n  static get _isSVGFittingCanvas() {\n    const svg = `data:image/svg+xml;charset=UTF-8,<svg viewBox=\"0 0 1 1\" width=\"1\" height=\"1\" xmlns=\"http://www.w3.org/2000/svg\"><rect width=\"1\" height=\"1\" style=\"fill:red;\"/></svg>`;\n    const canvas = new OffscreenCanvas(1, 3);\n    const ctx = canvas.getContext(\"2d\");\n    const image = new Image();\n    image.src = svg;\n    const promise = image.decode().then(() => {\n      ctx.drawImage(image, 0, 0, 1, 1, 0, 0, 1, 3);\n      return new Uint32Array(ctx.getImageData(0, 0, 1, 1).data.buffer)[0] === 0;\n    });\n    return (0, _util.shadow)(this, \"_isSVGFittingCanvas\", promise);\n  }\n  async #get(key, rawData) {\n    this.#cache ||= new Map();\n    let data = this.#cache.get(key);\n    if (data === null) {\n      return null;\n    }\n    if (data?.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    try {\n      data ||= {\n        bitmap: null,\n        id: `image_${this.#baseId}_${this.#id++}`,\n        refCounter: 0,\n        isSvg: false\n      };\n      let image;\n      if (typeof rawData === \"string\") {\n        data.url = rawData;\n        const response = await fetch(rawData);\n        if (!response.ok) {\n          throw new Error(response.statusText);\n        }\n        image = await response.blob();\n      } else {\n        image = data.file = rawData;\n      }\n      if (image.type === \"image/svg+xml\") {\n        const mustRemoveAspectRatioPromise = ImageManager._isSVGFittingCanvas;\n        const fileReader = new FileReader();\n        const imageElement = new Image();\n        const imagePromise = new Promise((resolve, reject) => {\n          imageElement.onload = () => {\n            data.bitmap = imageElement;\n            data.isSvg = true;\n            resolve();\n          };\n          fileReader.onload = async () => {\n            const url = data.svgUrl = fileReader.result;\n            imageElement.src = (await mustRemoveAspectRatioPromise) ? `${url}#svgView(preserveAspectRatio(none))` : url;\n          };\n          imageElement.onerror = fileReader.onerror = reject;\n        });\n        fileReader.readAsDataURL(image);\n        await imagePromise;\n      } else {\n        data.bitmap = await createImageBitmap(image);\n      }\n      data.refCounter = 1;\n    } catch (e) {\n      console.error(e);\n      data = null;\n    }\n    this.#cache.set(key, data);\n    if (data) {\n      this.#cache.set(data.id, data);\n    }\n    return data;\n  }\n  async getFromFile(file) {\n    const {\n      lastModified,\n      name,\n      size,\n      type\n    } = file;\n    return this.#get(`${lastModified}_${name}_${size}_${type}`, file);\n  }\n  async getFromUrl(url) {\n    return this.#get(url, url);\n  }\n  async getFromId(id) {\n    this.#cache ||= new Map();\n    const data = this.#cache.get(id);\n    if (!data) {\n      return null;\n    }\n    if (data.bitmap) {\n      data.refCounter += 1;\n      return data;\n    }\n    if (data.file) {\n      return this.getFromFile(data.file);\n    }\n    return this.getFromUrl(data.url);\n  }\n  getSvgUrl(id) {\n    const data = this.#cache.get(id);\n    if (!data?.isSvg) {\n      return null;\n    }\n    return data.svgUrl;\n  }\n  deleteId(id) {\n    this.#cache ||= new Map();\n    const data = this.#cache.get(id);\n    if (!data) {\n      return;\n    }\n    data.refCounter -= 1;\n    if (data.refCounter !== 0) {\n      return;\n    }\n    data.bitmap = null;\n  }\n  isValidId(id) {\n    return id.startsWith(`image_${this.#baseId}_`);\n  }\n}\nclass CommandManager {\n  #commands = [];\n  #locked = false;\n  #maxSize;\n  #position = -1;\n  constructor() {\n    let maxSize = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 128;\n    this.#maxSize = maxSize;\n  }\n  add(_ref) {\n    let {\n      cmd,\n      undo,\n      mustExec,\n      type = NaN,\n      overwriteIfSameType = false,\n      keepUndo = false\n    } = _ref;\n    if (mustExec) {\n      cmd();\n    }\n    if (this.#locked) {\n      return;\n    }\n    const save = {\n      cmd,\n      undo,\n      type\n    };\n    if (this.#position === -1) {\n      if (this.#commands.length > 0) {\n        this.#commands.length = 0;\n      }\n      this.#position = 0;\n      this.#commands.push(save);\n      return;\n    }\n    if (overwriteIfSameType && this.#commands[this.#position].type === type) {\n      if (keepUndo) {\n        save.undo = this.#commands[this.#position].undo;\n      }\n      this.#commands[this.#position] = save;\n      return;\n    }\n    const next = this.#position + 1;\n    if (next === this.#maxSize) {\n      this.#commands.splice(0, 1);\n    } else {\n      this.#position = next;\n      if (next < this.#commands.length) {\n        this.#commands.splice(next);\n      }\n    }\n    this.#commands.push(save);\n  }\n  undo() {\n    if (this.#position === -1) {\n      return;\n    }\n    this.#locked = true;\n    this.#commands[this.#position].undo();\n    this.#locked = false;\n    this.#position -= 1;\n  }\n  redo() {\n    if (this.#position < this.#commands.length - 1) {\n      this.#position += 1;\n      this.#locked = true;\n      this.#commands[this.#position].cmd();\n      this.#locked = false;\n    }\n  }\n  hasSomethingToUndo() {\n    return this.#position !== -1;\n  }\n  hasSomethingToRedo() {\n    return this.#position < this.#commands.length - 1;\n  }\n  destroy() {\n    this.#commands = null;\n  }\n}\nexports.CommandManager = CommandManager;\nclass KeyboardManager {\n  constructor(callbacks) {\n    this.buffer = [];\n    this.callbacks = new Map();\n    this.allKeys = new Set();\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    for (const [keys, callback, options = {}] of callbacks) {\n      for (const key of keys) {\n        const isMacKey = key.startsWith(\"mac+\");\n        if (isMac && isMacKey) {\n          this.callbacks.set(key.slice(4), {\n            callback,\n            options\n          });\n          this.allKeys.add(key.split(\"+\").at(-1));\n        } else if (!isMac && !isMacKey) {\n          this.callbacks.set(key, {\n            callback,\n            options\n          });\n          this.allKeys.add(key.split(\"+\").at(-1));\n        }\n      }\n    }\n  }\n  #serialize(event) {\n    if (event.altKey) {\n      this.buffer.push(\"alt\");\n    }\n    if (event.ctrlKey) {\n      this.buffer.push(\"ctrl\");\n    }\n    if (event.metaKey) {\n      this.buffer.push(\"meta\");\n    }\n    if (event.shiftKey) {\n      this.buffer.push(\"shift\");\n    }\n    this.buffer.push(event.key);\n    const str = this.buffer.join(\"+\");\n    this.buffer.length = 0;\n    return str;\n  }\n  exec(self, event) {\n    if (!this.allKeys.has(event.key)) {\n      return;\n    }\n    const info = this.callbacks.get(this.#serialize(event));\n    if (!info) {\n      return;\n    }\n    const {\n      callback,\n      options: {\n        bubbles = false,\n        args = [],\n        checker = null\n      }\n    } = info;\n    if (checker && !checker(self, event)) {\n      return;\n    }\n    callback.bind(self, ...args)();\n    if (!bubbles) {\n      event.stopPropagation();\n      event.preventDefault();\n    }\n  }\n}\nexports.KeyboardManager = KeyboardManager;\nclass ColorManager {\n  static _colorsMapping = new Map([[\"CanvasText\", [0, 0, 0]], [\"Canvas\", [255, 255, 255]]]);\n  get _colors() {\n    const colors = new Map([[\"CanvasText\", null], [\"Canvas\", null]]);\n    (0, _display_utils.getColorValues)(colors);\n    return (0, _util.shadow)(this, \"_colors\", colors);\n  }\n  convert(color) {\n    const rgb = (0, _display_utils.getRGB)(color);\n    if (!window.matchMedia(\"(forced-colors: active)\").matches) {\n      return rgb;\n    }\n    for (const [name, RGB] of this._colors) {\n      if (RGB.every((x, i) => x === rgb[i])) {\n        return ColorManager._colorsMapping.get(name);\n      }\n    }\n    return rgb;\n  }\n  getHexCode(name) {\n    const rgb = this._colors.get(name);\n    if (!rgb) {\n      return name;\n    }\n    return _util.Util.makeHexColor(...rgb);\n  }\n}\nexports.ColorManager = ColorManager;\nclass AnnotationEditorUIManager {\n  #activeEditor = null;\n  #allEditors = new Map();\n  #allLayers = new Map();\n  #altTextManager = null;\n  #annotationStorage = null;\n  #commandManager = new CommandManager();\n  #currentPageIndex = 0;\n  #deletedAnnotationsElementIds = new Set();\n  #draggingEditors = null;\n  #editorTypes = null;\n  #editorsToRescale = new Set();\n  #filterFactory = null;\n  #idManager = new IdManager();\n  #isEnabled = false;\n  #isWaiting = false;\n  #lastActiveElement = null;\n  #mode = _util.AnnotationEditorType.NONE;\n  #selectedEditors = new Set();\n  #pageColors = null;\n  #boundBlur = this.blur.bind(this);\n  #boundFocus = this.focus.bind(this);\n  #boundCopy = this.copy.bind(this);\n  #boundCut = this.cut.bind(this);\n  #boundPaste = this.paste.bind(this);\n  #boundKeydown = this.keydown.bind(this);\n  #boundOnEditingAction = this.onEditingAction.bind(this);\n  #boundOnPageChanging = this.onPageChanging.bind(this);\n  #boundOnScaleChanging = this.onScaleChanging.bind(this);\n  #boundOnRotationChanging = this.onRotationChanging.bind(this);\n  #previousStates = {\n    isEditing: false,\n    isEmpty: true,\n    hasSomethingToUndo: false,\n    hasSomethingToRedo: false,\n    hasSelectedEditor: false\n  };\n  #translation = [0, 0];\n  #translationTimeoutId = null;\n  #container = null;\n  #viewer = null;\n  static TRANSLATE_SMALL = 1;\n  static TRANSLATE_BIG = 10;\n  static get _keyboardManager() {\n    const proto = AnnotationEditorUIManager.prototype;\n    const arrowChecker = self => {\n      const {\n        activeElement\n      } = document;\n      return activeElement && self.#container.contains(activeElement) && self.hasSomethingToControl();\n    };\n    const small = this.TRANSLATE_SMALL;\n    const big = this.TRANSLATE_BIG;\n    return (0, _util.shadow)(this, \"_keyboardManager\", new KeyboardManager([[[\"ctrl+a\", \"mac+meta+a\"], proto.selectAll], [[\"ctrl+z\", \"mac+meta+z\"], proto.undo], [[\"ctrl+y\", \"ctrl+shift+z\", \"mac+meta+shift+z\", \"ctrl+shift+Z\", \"mac+meta+shift+Z\"], proto.redo], [[\"Backspace\", \"alt+Backspace\", \"ctrl+Backspace\", \"shift+Backspace\", \"mac+Backspace\", \"mac+alt+Backspace\", \"mac+ctrl+Backspace\", \"Delete\", \"ctrl+Delete\", \"shift+Delete\", \"mac+Delete\"], proto.delete], [[\"Escape\", \"mac+Escape\"], proto.unselectAll], [[\"ArrowLeft\", \"mac+ArrowLeft\"], proto.translateSelectedEditors, {\n      args: [-small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], proto.translateSelectedEditors, {\n      args: [-big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto.translateSelectedEditors, {\n      args: [small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], proto.translateSelectedEditors, {\n      args: [big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto.translateSelectedEditors, {\n      args: [0, -small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], proto.translateSelectedEditors, {\n      args: [0, -big],\n      checker: arrowChecker\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto.translateSelectedEditors, {\n      args: [0, small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], proto.translateSelectedEditors, {\n      args: [0, big],\n      checker: arrowChecker\n    }]]));\n  }\n  constructor(container, viewer, altTextManager, eventBus, pdfDocument, pageColors) {\n    this.#container = container;\n    this.#viewer = viewer;\n    this.#altTextManager = altTextManager;\n    this._eventBus = eventBus;\n    this._eventBus._on(\"editingaction\", this.#boundOnEditingAction);\n    this._eventBus._on(\"pagechanging\", this.#boundOnPageChanging);\n    this._eventBus._on(\"scalechanging\", this.#boundOnScaleChanging);\n    this._eventBus._on(\"rotationchanging\", this.#boundOnRotationChanging);\n    this.#annotationStorage = pdfDocument.annotationStorage;\n    this.#filterFactory = pdfDocument.filterFactory;\n    this.#pageColors = pageColors;\n    this.viewParameters = {\n      realScale: _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS,\n      rotation: 0\n    };\n  }\n  destroy() {\n    this.#removeKeyboardManager();\n    this.#removeFocusManager();\n    this._eventBus._off(\"editingaction\", this.#boundOnEditingAction);\n    this._eventBus._off(\"pagechanging\", this.#boundOnPageChanging);\n    this._eventBus._off(\"scalechanging\", this.#boundOnScaleChanging);\n    this._eventBus._off(\"rotationchanging\", this.#boundOnRotationChanging);\n    for (const layer of this.#allLayers.values()) {\n      layer.destroy();\n    }\n    this.#allLayers.clear();\n    this.#allEditors.clear();\n    this.#editorsToRescale.clear();\n    this.#activeEditor = null;\n    this.#selectedEditors.clear();\n    this.#commandManager.destroy();\n    this.#altTextManager.destroy();\n  }\n  get hcmFilter() {\n    return (0, _util.shadow)(this, \"hcmFilter\", this.#pageColors ? this.#filterFactory.addHCMFilter(this.#pageColors.foreground, this.#pageColors.background) : \"none\");\n  }\n  get direction() {\n    return (0, _util.shadow)(this, \"direction\", getComputedStyle(this.#container).direction);\n  }\n  editAltText(editor) {\n    this.#altTextManager?.editAltText(this, editor);\n  }\n  onPageChanging(_ref2) {\n    let {\n      pageNumber\n    } = _ref2;\n    this.#currentPageIndex = pageNumber - 1;\n  }\n  focusMainContainer() {\n    this.#container.focus();\n  }\n  findParent(x, y) {\n    for (const layer of this.#allLayers.values()) {\n      const {\n        x: layerX,\n        y: layerY,\n        width,\n        height\n      } = layer.div.getBoundingClientRect();\n      if (x >= layerX && x <= layerX + width && y >= layerY && y <= layerY + height) {\n        return layer;\n      }\n    }\n    return null;\n  }\n  disableUserSelect() {\n    let value = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    this.#viewer.classList.toggle(\"noUserSelect\", value);\n  }\n  addShouldRescale(editor) {\n    this.#editorsToRescale.add(editor);\n  }\n  removeShouldRescale(editor) {\n    this.#editorsToRescale.delete(editor);\n  }\n  onScaleChanging(_ref3) {\n    let {\n      scale\n    } = _ref3;\n    this.commitOrRemove();\n    this.viewParameters.realScale = scale * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS;\n    for (const editor of this.#editorsToRescale) {\n      editor.onScaleChanging();\n    }\n  }\n  onRotationChanging(_ref4) {\n    let {\n      pagesRotation\n    } = _ref4;\n    this.commitOrRemove();\n    this.viewParameters.rotation = pagesRotation;\n  }\n  addToAnnotationStorage(editor) {\n    if (!editor.isEmpty() && this.#annotationStorage && !this.#annotationStorage.has(editor.id)) {\n      this.#annotationStorage.setValue(editor.id, editor);\n    }\n  }\n  #addFocusManager() {\n    window.addEventListener(\"focus\", this.#boundFocus);\n    window.addEventListener(\"blur\", this.#boundBlur);\n  }\n  #removeFocusManager() {\n    window.removeEventListener(\"focus\", this.#boundFocus);\n    window.removeEventListener(\"blur\", this.#boundBlur);\n  }\n  blur() {\n    if (!this.hasSelection) {\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    for (const editor of this.#selectedEditors) {\n      if (editor.div.contains(activeElement)) {\n        this.#lastActiveElement = [editor, activeElement];\n        editor._focusEventsAllowed = false;\n        break;\n      }\n    }\n  }\n  focus() {\n    if (!this.#lastActiveElement) {\n      return;\n    }\n    const [lastEditor, lastActiveElement] = this.#lastActiveElement;\n    this.#lastActiveElement = null;\n    lastActiveElement.addEventListener(\"focusin\", () => {\n      lastEditor._focusEventsAllowed = true;\n    }, {\n      once: true\n    });\n    lastActiveElement.focus();\n  }\n  #addKeyboardManager() {\n    window.addEventListener(\"keydown\", this.#boundKeydown, {\n      capture: true\n    });\n  }\n  #removeKeyboardManager() {\n    window.removeEventListener(\"keydown\", this.#boundKeydown, {\n      capture: true\n    });\n  }\n  #addCopyPasteListeners() {\n    document.addEventListener(\"copy\", this.#boundCopy);\n    document.addEventListener(\"cut\", this.#boundCut);\n    document.addEventListener(\"paste\", this.#boundPaste);\n  }\n  #removeCopyPasteListeners() {\n    document.removeEventListener(\"copy\", this.#boundCopy);\n    document.removeEventListener(\"cut\", this.#boundCut);\n    document.removeEventListener(\"paste\", this.#boundPaste);\n  }\n  addEditListeners() {\n    this.#addKeyboardManager();\n    this.#addCopyPasteListeners();\n  }\n  removeEditListeners() {\n    this.#removeKeyboardManager();\n    this.#removeCopyPasteListeners();\n  }\n  copy(event) {\n    event.preventDefault();\n    this.#activeEditor?.commitOrRemove();\n    if (!this.hasSelection) {\n      return;\n    }\n    const editors = [];\n    for (const editor of this.#selectedEditors) {\n      const serialized = editor.serialize(true);\n      if (serialized) {\n        editors.push(serialized);\n      }\n    }\n    if (editors.length === 0) {\n      return;\n    }\n    event.clipboardData.setData(\"application/pdfjs\", JSON.stringify(editors));\n  }\n  cut(event) {\n    this.copy(event);\n    this.delete();\n  }\n  paste(event) {\n    event.preventDefault();\n    const {\n      clipboardData\n    } = event;\n    for (const item of clipboardData.items) {\n      for (const editorType of this.#editorTypes) {\n        if (editorType.isHandlingMimeForPasting(item.type)) {\n          editorType.paste(item, this.currentLayer);\n          return;\n        }\n      }\n    }\n    let data = clipboardData.getData(\"application/pdfjs\");\n    if (!data) {\n      return;\n    }\n    try {\n      data = JSON.parse(data);\n    } catch (ex) {\n      (0, _util.warn)(`paste: \"${ex.message}\".`);\n      return;\n    }\n    if (!Array.isArray(data)) {\n      return;\n    }\n    this.unselectAll();\n    const layer = this.currentLayer;\n    try {\n      const newEditors = [];\n      for (const editor of data) {\n        const deserializedEditor = layer.deserialize(editor);\n        if (!deserializedEditor) {\n          return;\n        }\n        newEditors.push(deserializedEditor);\n      }\n      const cmd = () => {\n        for (const editor of newEditors) {\n          this.#addEditorToLayer(editor);\n        }\n        this.#selectEditors(newEditors);\n      };\n      const undo = () => {\n        for (const editor of newEditors) {\n          editor.remove();\n        }\n      };\n      this.addCommands({\n        cmd,\n        undo,\n        mustExec: true\n      });\n    } catch (ex) {\n      (0, _util.warn)(`paste: \"${ex.message}\".`);\n    }\n  }\n  keydown(event) {\n    if (!this.getActive()?.shouldGetKeyboardEvents()) {\n      AnnotationEditorUIManager._keyboardManager.exec(this, event);\n    }\n  }\n  onEditingAction(details) {\n    if ([\"undo\", \"redo\", \"delete\", \"selectAll\"].includes(details.name)) {\n      this[details.name]();\n    }\n  }\n  #dispatchUpdateStates(details) {\n    const hasChanged = Object.entries(details).some(_ref5 => {\n      let [key, value] = _ref5;\n      return this.#previousStates[key] !== value;\n    });\n    if (hasChanged) {\n      this._eventBus.dispatch(\"annotationeditorstateschanged\", {\n        source: this,\n        details: Object.assign(this.#previousStates, details)\n      });\n    }\n  }\n  #dispatchUpdateUI(details) {\n    this._eventBus.dispatch(\"annotationeditorparamschanged\", {\n      source: this,\n      details\n    });\n  }\n  setEditingState(isEditing) {\n    if (isEditing) {\n      this.#addFocusManager();\n      this.#addKeyboardManager();\n      this.#addCopyPasteListeners();\n      this.#dispatchUpdateStates({\n        isEditing: this.#mode !== _util.AnnotationEditorType.NONE,\n        isEmpty: this.#isEmpty(),\n        hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n        hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n        hasSelectedEditor: false\n      });\n    } else {\n      this.#removeFocusManager();\n      this.#removeKeyboardManager();\n      this.#removeCopyPasteListeners();\n      this.#dispatchUpdateStates({\n        isEditing: false\n      });\n      this.disableUserSelect(false);\n    }\n  }\n  registerEditorTypes(types) {\n    if (this.#editorTypes) {\n      return;\n    }\n    this.#editorTypes = types;\n    for (const editorType of this.#editorTypes) {\n      this.#dispatchUpdateUI(editorType.defaultPropertiesToUpdate);\n    }\n  }\n  getId() {\n    return this.#idManager.getId();\n  }\n  get currentLayer() {\n    return this.#allLayers.get(this.#currentPageIndex);\n  }\n  getLayer(pageIndex) {\n    return this.#allLayers.get(pageIndex);\n  }\n  get currentPageIndex() {\n    return this.#currentPageIndex;\n  }\n  addLayer(layer) {\n    this.#allLayers.set(layer.pageIndex, layer);\n    if (this.#isEnabled) {\n      layer.enable();\n    } else {\n      layer.disable();\n    }\n  }\n  removeLayer(layer) {\n    this.#allLayers.delete(layer.pageIndex);\n  }\n  updateMode(mode) {\n    let editId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (this.#mode === mode) {\n      return;\n    }\n    this.#mode = mode;\n    if (mode === _util.AnnotationEditorType.NONE) {\n      this.setEditingState(false);\n      this.#disableAll();\n      return;\n    }\n    this.setEditingState(true);\n    this.#enableAll();\n    this.unselectAll();\n    for (const layer of this.#allLayers.values()) {\n      layer.updateMode(mode);\n    }\n    if (!editId) {\n      return;\n    }\n    for (const editor of this.#allEditors.values()) {\n      if (editor.annotationElementId === editId) {\n        this.setSelected(editor);\n        editor.enterInEditMode();\n        break;\n      }\n    }\n  }\n  updateToolbar(mode) {\n    if (mode === this.#mode) {\n      return;\n    }\n    this._eventBus.dispatch(\"switchannotationeditormode\", {\n      source: this,\n      mode\n    });\n  }\n  updateParams(type, value) {\n    if (!this.#editorTypes) {\n      return;\n    }\n    if (type === _util.AnnotationEditorParamsType.CREATE) {\n      this.currentLayer.addNewEditor(type);\n      return;\n    }\n    for (const editor of this.#selectedEditors) {\n      editor.updateParams(type, value);\n    }\n    for (const editorType of this.#editorTypes) {\n      editorType.updateDefaultParams(type, value);\n    }\n  }\n  enableWaiting() {\n    let mustWait = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.#isWaiting === mustWait) {\n      return;\n    }\n    this.#isWaiting = mustWait;\n    for (const layer of this.#allLayers.values()) {\n      if (mustWait) {\n        layer.disableClick();\n      } else {\n        layer.enableClick();\n      }\n      layer.div.classList.toggle(\"waiting\", mustWait);\n    }\n  }\n  #enableAll() {\n    if (!this.#isEnabled) {\n      this.#isEnabled = true;\n      for (const layer of this.#allLayers.values()) {\n        layer.enable();\n      }\n    }\n  }\n  #disableAll() {\n    this.unselectAll();\n    if (this.#isEnabled) {\n      this.#isEnabled = false;\n      for (const layer of this.#allLayers.values()) {\n        layer.disable();\n      }\n    }\n  }\n  getEditors(pageIndex) {\n    const editors = [];\n    for (const editor of this.#allEditors.values()) {\n      if (editor.pageIndex === pageIndex) {\n        editors.push(editor);\n      }\n    }\n    return editors;\n  }\n  getEditor(id) {\n    return this.#allEditors.get(id);\n  }\n  addEditor(editor) {\n    this.#allEditors.set(editor.id, editor);\n  }\n  removeEditor(editor) {\n    this.#allEditors.delete(editor.id);\n    this.unselect(editor);\n    if (!editor.annotationElementId || !this.#deletedAnnotationsElementIds.has(editor.annotationElementId)) {\n      this.#annotationStorage?.remove(editor.id);\n    }\n  }\n  addDeletedAnnotationElement(editor) {\n    this.#deletedAnnotationsElementIds.add(editor.annotationElementId);\n    editor.deleted = true;\n  }\n  isDeletedAnnotationElement(annotationElementId) {\n    return this.#deletedAnnotationsElementIds.has(annotationElementId);\n  }\n  removeDeletedAnnotationElement(editor) {\n    this.#deletedAnnotationsElementIds.delete(editor.annotationElementId);\n    editor.deleted = false;\n  }\n  #addEditorToLayer(editor) {\n    const layer = this.#allLayers.get(editor.pageIndex);\n    if (layer) {\n      layer.addOrRebuild(editor);\n    } else {\n      this.addEditor(editor);\n    }\n  }\n  setActiveEditor(editor) {\n    if (this.#activeEditor === editor) {\n      return;\n    }\n    this.#activeEditor = editor;\n    if (editor) {\n      this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    }\n  }\n  toggleSelected(editor) {\n    if (this.#selectedEditors.has(editor)) {\n      this.#selectedEditors.delete(editor);\n      editor.unselect();\n      this.#dispatchUpdateStates({\n        hasSelectedEditor: this.hasSelection\n      });\n      return;\n    }\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  setSelected(editor) {\n    for (const ed of this.#selectedEditors) {\n      if (ed !== editor) {\n        ed.unselect();\n      }\n    }\n    this.#selectedEditors.clear();\n    this.#selectedEditors.add(editor);\n    editor.select();\n    this.#dispatchUpdateUI(editor.propertiesToUpdate);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  isSelected(editor) {\n    return this.#selectedEditors.has(editor);\n  }\n  unselect(editor) {\n    editor.unselect();\n    this.#selectedEditors.delete(editor);\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: this.hasSelection\n    });\n  }\n  get hasSelection() {\n    return this.#selectedEditors.size !== 0;\n  }\n  undo() {\n    this.#commandManager.undo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: this.#commandManager.hasSomethingToUndo(),\n      hasSomethingToRedo: true,\n      isEmpty: this.#isEmpty()\n    });\n  }\n  redo() {\n    this.#commandManager.redo();\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: this.#commandManager.hasSomethingToRedo(),\n      isEmpty: this.#isEmpty()\n    });\n  }\n  addCommands(params) {\n    this.#commandManager.add(params);\n    this.#dispatchUpdateStates({\n      hasSomethingToUndo: true,\n      hasSomethingToRedo: false,\n      isEmpty: this.#isEmpty()\n    });\n  }\n  #isEmpty() {\n    if (this.#allEditors.size === 0) {\n      return true;\n    }\n    if (this.#allEditors.size === 1) {\n      for (const editor of this.#allEditors.values()) {\n        return editor.isEmpty();\n      }\n    }\n    return false;\n  }\n  delete() {\n    this.commitOrRemove();\n    if (!this.hasSelection) {\n      return;\n    }\n    const editors = [...this.#selectedEditors];\n    const cmd = () => {\n      for (const editor of editors) {\n        editor.remove();\n      }\n    };\n    const undo = () => {\n      for (const editor of editors) {\n        this.#addEditorToLayer(editor);\n      }\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n  commitOrRemove() {\n    this.#activeEditor?.commitOrRemove();\n  }\n  hasSomethingToControl() {\n    return this.#activeEditor || this.hasSelection;\n  }\n  #selectEditors(editors) {\n    this.#selectedEditors.clear();\n    for (const editor of editors) {\n      if (editor.isEmpty()) {\n        continue;\n      }\n      this.#selectedEditors.add(editor);\n      editor.select();\n    }\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: true\n    });\n  }\n  selectAll() {\n    for (const editor of this.#selectedEditors) {\n      editor.commit();\n    }\n    this.#selectEditors(this.#allEditors.values());\n  }\n  unselectAll() {\n    if (this.#activeEditor) {\n      this.#activeEditor.commitOrRemove();\n      return;\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    for (const editor of this.#selectedEditors) {\n      editor.unselect();\n    }\n    this.#selectedEditors.clear();\n    this.#dispatchUpdateStates({\n      hasSelectedEditor: false\n    });\n  }\n  translateSelectedEditors(x, y) {\n    let noCommit = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (!noCommit) {\n      this.commitOrRemove();\n    }\n    if (!this.hasSelection) {\n      return;\n    }\n    this.#translation[0] += x;\n    this.#translation[1] += y;\n    const [totalX, totalY] = this.#translation;\n    const editors = [...this.#selectedEditors];\n    const TIME_TO_WAIT = 1000;\n    if (this.#translationTimeoutId) {\n      clearTimeout(this.#translationTimeoutId);\n    }\n    this.#translationTimeoutId = setTimeout(() => {\n      this.#translationTimeoutId = null;\n      this.#translation[0] = this.#translation[1] = 0;\n      this.addCommands({\n        cmd: () => {\n          for (const editor of editors) {\n            if (this.#allEditors.has(editor.id)) {\n              editor.translateInPage(totalX, totalY);\n            }\n          }\n        },\n        undo: () => {\n          for (const editor of editors) {\n            if (this.#allEditors.has(editor.id)) {\n              editor.translateInPage(-totalX, -totalY);\n            }\n          }\n        },\n        mustExec: false\n      });\n    }, TIME_TO_WAIT);\n    for (const editor of editors) {\n      editor.translateInPage(x, y);\n    }\n  }\n  setUpDragSession() {\n    if (!this.hasSelection) {\n      return;\n    }\n    this.disableUserSelect(true);\n    this.#draggingEditors = new Map();\n    for (const editor of this.#selectedEditors) {\n      this.#draggingEditors.set(editor, {\n        savedX: editor.x,\n        savedY: editor.y,\n        savedPageIndex: editor.pageIndex,\n        newX: 0,\n        newY: 0,\n        newPageIndex: -1\n      });\n    }\n  }\n  endDragSession() {\n    if (!this.#draggingEditors) {\n      return false;\n    }\n    this.disableUserSelect(false);\n    const map = this.#draggingEditors;\n    this.#draggingEditors = null;\n    let mustBeAddedInUndoStack = false;\n    for (const [{\n      x,\n      y,\n      pageIndex\n    }, value] of map) {\n      value.newX = x;\n      value.newY = y;\n      value.newPageIndex = pageIndex;\n      mustBeAddedInUndoStack ||= x !== value.savedX || y !== value.savedY || pageIndex !== value.savedPageIndex;\n    }\n    if (!mustBeAddedInUndoStack) {\n      return false;\n    }\n    const move = (editor, x, y, pageIndex) => {\n      if (this.#allEditors.has(editor.id)) {\n        const parent = this.#allLayers.get(pageIndex);\n        if (parent) {\n          editor._setParentAndPosition(parent, x, y);\n        } else {\n          editor.pageIndex = pageIndex;\n          editor.x = x;\n          editor.y = y;\n        }\n      }\n    };\n    this.addCommands({\n      cmd: () => {\n        for (const [editor, {\n          newX,\n          newY,\n          newPageIndex\n        }] of map) {\n          move(editor, newX, newY, newPageIndex);\n        }\n      },\n      undo: () => {\n        for (const [editor, {\n          savedX,\n          savedY,\n          savedPageIndex\n        }] of map) {\n          move(editor, savedX, savedY, savedPageIndex);\n        }\n      },\n      mustExec: true\n    });\n    return true;\n  }\n  dragSelectedEditors(tx, ty) {\n    if (!this.#draggingEditors) {\n      return;\n    }\n    for (const editor of this.#draggingEditors.keys()) {\n      editor.drag(tx, ty);\n    }\n  }\n  rebuild(editor) {\n    if (editor.parent === null) {\n      const parent = this.getLayer(editor.pageIndex);\n      if (parent) {\n        parent.changeParent(editor);\n        parent.addOrRebuild(editor);\n      } else {\n        this.addEditor(editor);\n        this.addToAnnotationStorage(editor);\n        editor.rebuild();\n      }\n    } else {\n      editor.parent.addOrRebuild(editor);\n    }\n  }\n  isActive(editor) {\n    return this.#activeEditor === editor;\n  }\n  getActive() {\n    return this.#activeEditor;\n  }\n  getMode() {\n    return this.#mode;\n  }\n  get imageManager() {\n    return (0, _util.shadow)(this, \"imageManager\", new ImageManager());\n  }\n}\nexports.AnnotationEditorUIManager = AnnotationEditorUIManager;\n\n/***/ }),\n/* 166 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar global = __w_pdfjs_require__(4);\nvar getBuiltIn = __w_pdfjs_require__(24);\nvar uncurryThis = __w_pdfjs_require__(14);\nvar call = __w_pdfjs_require__(8);\nvar isCallable = __w_pdfjs_require__(21);\nvar isObject = __w_pdfjs_require__(20);\nvar isArray = __w_pdfjs_require__(91);\nvar hasOwn = __w_pdfjs_require__(39);\nvar toString = __w_pdfjs_require__(77);\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nvar createProperty = __w_pdfjs_require__(159);\nvar fails = __w_pdfjs_require__(7);\nvar parseJSONString = __w_pdfjs_require__(167);\nvar NATIVE_SYMBOL = __w_pdfjs_require__(27);\nvar JSON = global.JSON;\nvar Number = global.Number;\nvar SyntaxError = global.SyntaxError;\nvar nativeParse = JSON && JSON.parse;\nvar enumerableOwnProperties = getBuiltIn('Object', 'keys');\nvar getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor;\nvar at = uncurryThis(''.charAt);\nvar slice = uncurryThis(''.slice);\nvar exec = uncurryThis(/./.exec);\nvar push = uncurryThis([].push);\nvar IS_DIGIT = /^\\d$/;\nvar IS_NON_ZERO_DIGIT = /^[1-9]$/;\nvar IS_NUMBER_START = /^(?:-|\\d)$/;\nvar IS_WHITESPACE = /^[\\t\\n\\r ]$/;\nvar PRIMITIVE = 0;\nvar OBJECT = 1;\nvar $parse = function (source, reviver) {\n source = toString(source);\n var context = new Context(source, 0, '');\n var root = context.parse();\n var value = root.value;\n var endIndex = context.skip(IS_WHITESPACE, root.end);\n if (endIndex < source.length) {\n  throw SyntaxError('Unexpected extra character: \"' + at(source, endIndex) + '\" after the parsed data at: ' + endIndex);\n }\n return isCallable(reviver) ? internalize({ '': value }, '', reviver, root) : value;\n};\nvar internalize = function (holder, name, reviver, node) {\n var val = holder[name];\n var unmodified = node && val === node.value;\n var context = unmodified && typeof node.source == 'string' ? { source: node.source } : {};\n var elementRecordsLen, keys, len, i, P;\n if (isObject(val)) {\n  var nodeIsArray = isArray(val);\n  var nodes = unmodified ? node.nodes : nodeIsArray ? [] : {};\n  if (nodeIsArray) {\n   elementRecordsLen = nodes.length;\n   len = lengthOfArrayLike(val);\n   for (i = 0; i < len; i++) {\n    internalizeProperty(val, i, internalize(val, '' + i, reviver, i < elementRecordsLen ? nodes[i] : undefined));\n   }\n  } else {\n   keys = enumerableOwnProperties(val);\n   len = lengthOfArrayLike(keys);\n   for (i = 0; i < len; i++) {\n    P = keys[i];\n    internalizeProperty(val, P, internalize(val, P, reviver, hasOwn(nodes, P) ? nodes[P] : undefined));\n   }\n  }\n }\n return call(reviver, holder, name, val, context);\n};\nvar internalizeProperty = function (object, key, value) {\n if (DESCRIPTORS) {\n  var descriptor = getOwnPropertyDescriptor(object, key);\n  if (descriptor && !descriptor.configurable)\n   return;\n }\n if (value === undefined)\n  delete object[key];\n else\n  createProperty(object, key, value);\n};\nvar Node = function (value, end, source, nodes) {\n this.value = value;\n this.end = end;\n this.source = source;\n this.nodes = nodes;\n};\nvar Context = function (source, index) {\n this.source = source;\n this.index = index;\n};\nContext.prototype = {\n fork: function (nextIndex) {\n  return new Context(this.source, nextIndex);\n },\n parse: function () {\n  var source = this.source;\n  var i = this.skip(IS_WHITESPACE, this.index);\n  var fork = this.fork(i);\n  var chr = at(source, i);\n  if (exec(IS_NUMBER_START, chr))\n   return fork.number();\n  switch (chr) {\n  case '{':\n   return fork.object();\n  case '[':\n   return fork.array();\n  case '\"':\n   return fork.string();\n  case 't':\n   return fork.keyword(true);\n  case 'f':\n   return fork.keyword(false);\n  case 'n':\n   return fork.keyword(null);\n  }\n  throw SyntaxError('Unexpected character: \"' + chr + '\" at: ' + i);\n },\n node: function (type, value, start, end, nodes) {\n  return new Node(value, end, type ? null : slice(this.source, start, end), nodes);\n },\n object: function () {\n  var source = this.source;\n  var i = this.index + 1;\n  var expectKeypair = false;\n  var object = {};\n  var nodes = {};\n  while (i < source.length) {\n   i = this.until([\n    '\"',\n    '}'\n   ], i);\n   if (at(source, i) === '}' && !expectKeypair) {\n    i++;\n    break;\n   }\n   var result = this.fork(i).string();\n   var key = result.value;\n   i = result.end;\n   i = this.until([':'], i) + 1;\n   i = this.skip(IS_WHITESPACE, i);\n   result = this.fork(i).parse();\n   createProperty(nodes, key, result);\n   createProperty(object, key, result.value);\n   i = this.until([\n    ',',\n    '}'\n   ], result.end);\n   var chr = at(source, i);\n   if (chr === ',') {\n    expectKeypair = true;\n    i++;\n   } else if (chr === '}') {\n    i++;\n    break;\n   }\n  }\n  return this.node(OBJECT, object, this.index, i, nodes);\n },\n array: function () {\n  var source = this.source;\n  var i = this.index + 1;\n  var expectElement = false;\n  var array = [];\n  var nodes = [];\n  while (i < source.length) {\n   i = this.skip(IS_WHITESPACE, i);\n   if (at(source, i) === ']' && !expectElement) {\n    i++;\n    break;\n   }\n   var result = this.fork(i).parse();\n   push(nodes, result);\n   push(array, result.value);\n   i = this.until([\n    ',',\n    ']'\n   ], result.end);\n   if (at(source, i) === ',') {\n    expectElement = true;\n    i++;\n   } else if (at(source, i) === ']') {\n    i++;\n    break;\n   }\n  }\n  return this.node(OBJECT, array, this.index, i, nodes);\n },\n string: function () {\n  var index = this.index;\n  var parsed = parseJSONString(this.source, this.index + 1);\n  return this.node(PRIMITIVE, parsed.value, index, parsed.end);\n },\n number: function () {\n  var source = this.source;\n  var startIndex = this.index;\n  var i = startIndex;\n  if (at(source, i) === '-')\n   i++;\n  if (at(source, i) === '0')\n   i++;\n  else if (exec(IS_NON_ZERO_DIGIT, at(source, i)))\n   i = this.skip(IS_DIGIT, ++i);\n  else\n   throw SyntaxError('Failed to parse number at: ' + i);\n  if (at(source, i) === '.')\n   i = this.skip(IS_DIGIT, ++i);\n  if (at(source, i) === 'e' || at(source, i) === 'E') {\n   i++;\n   if (at(source, i) === '+' || at(source, i) === '-')\n    i++;\n   var exponentStartIndex = i;\n   i = this.skip(IS_DIGIT, i);\n   if (exponentStartIndex === i)\n    throw SyntaxError(\"Failed to parse number's exponent value at: \" + i);\n  }\n  return this.node(PRIMITIVE, Number(slice(source, startIndex, i)), startIndex, i);\n },\n keyword: function (value) {\n  var keyword = '' + value;\n  var index = this.index;\n  var endIndex = index + keyword.length;\n  if (slice(this.source, index, endIndex) !== keyword)\n   throw SyntaxError('Failed to parse value at: ' + index);\n  return this.node(PRIMITIVE, value, index, endIndex);\n },\n skip: function (regex, i) {\n  var source = this.source;\n  for (; i < source.length; i++)\n   if (!exec(regex, at(source, i)))\n    break;\n  return i;\n },\n until: function (array, i) {\n  i = this.skip(IS_WHITESPACE, i);\n  var chr = at(this.source, i);\n  for (var j = 0; j < array.length; j++)\n   if (array[j] === chr)\n    return i;\n  throw SyntaxError('Unexpected character: \"' + chr + '\" at: ' + i);\n }\n};\nvar NO_SOURCE_SUPPORT = fails(function () {\n var unsafeInt = '9007199254740993';\n var source;\n nativeParse(unsafeInt, function (key, value, context) {\n  source = context.source;\n });\n return source !== unsafeInt;\n});\nvar PROPER_BASE_PARSE = NATIVE_SYMBOL && !fails(function () {\n return 1 / nativeParse('-0 \\t') !== -Infinity;\n});\n$({\n target: 'JSON',\n stat: true,\n forced: NO_SOURCE_SUPPORT\n}, {\n parse: function parse(text, reviver) {\n  return PROPER_BASE_PARSE && !isCallable(reviver) ? nativeParse(text) : $parse(text, reviver);\n }\n});\n\n/***/ }),\n/* 167 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar uncurryThis = __w_pdfjs_require__(14);\nvar hasOwn = __w_pdfjs_require__(39);\nvar $SyntaxError = SyntaxError;\nvar $parseInt = parseInt;\nvar fromCharCode = String.fromCharCode;\nvar at = uncurryThis(''.charAt);\nvar slice = uncurryThis(''.slice);\nvar exec = uncurryThis(/./.exec);\nvar codePoints = {\n '\\\\\"': '\"',\n '\\\\\\\\': '\\\\',\n '\\\\/': '/',\n '\\\\b': '\\b',\n '\\\\f': '\\f',\n '\\\\n': '\\n',\n '\\\\r': '\\r',\n '\\\\t': '\\t'\n};\nvar IS_4_HEX_DIGITS = /^[\\da-f]{4}$/i;\nvar IS_C0_CONTROL_CODE = /^[\\u0000-\\u001F]$/;\nmodule.exports = function (source, i) {\n var unterminated = true;\n var value = '';\n while (i < source.length) {\n  var chr = at(source, i);\n  if (chr === '\\\\') {\n   var twoChars = slice(source, i, i + 2);\n   if (hasOwn(codePoints, twoChars)) {\n    value += codePoints[twoChars];\n    i += 2;\n   } else if (twoChars === '\\\\u') {\n    i += 2;\n    var fourHexDigits = slice(source, i, i + 4);\n    if (!exec(IS_4_HEX_DIGITS, fourHexDigits))\n     throw $SyntaxError('Bad Unicode escape at: ' + i);\n    value += fromCharCode($parseInt(fourHexDigits, 16));\n    i += 4;\n   } else\n    throw $SyntaxError('Unknown escape sequence: \"' + twoChars + '\"');\n  } else if (chr === '\"') {\n   unterminated = false;\n   i++;\n   break;\n  } else {\n   if (exec(IS_C0_CONTROL_CODE, chr))\n    throw $SyntaxError('Bad control character in string literal at: ' + i);\n   value += chr;\n   i++;\n  }\n }\n if (unterminated)\n  throw $SyntaxError('Unterminated string at: ' + i);\n return {\n  value: value,\n  end: i\n };\n};\n\n/***/ }),\n/* 168 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.StatTimer = exports.RenderingCancelledException = exports.PixelsPerInch = exports.PageViewport = exports.PDFDateString = exports.DOMStandardFontDataFactory = exports.DOMSVGFactory = exports.DOMFilterFactory = exports.DOMCanvasFactory = exports.DOMCMapReaderFactory = void 0;\nexports.deprecated = deprecated;\nexports.getColorValues = getColorValues;\nexports.getCurrentTransform = getCurrentTransform;\nexports.getCurrentTransformInverse = getCurrentTransformInverse;\nexports.getFilenameFromUrl = getFilenameFromUrl;\nexports.getPdfFilenameFromUrl = getPdfFilenameFromUrl;\nexports.getRGB = getRGB;\nexports.getXfaPageViewport = getXfaPageViewport;\nexports.isDataScheme = isDataScheme;\nexports.isPdfFile = isPdfFile;\nexports.isValidFetchUrl = isValidFetchUrl;\nexports.loadScript = loadScript;\nexports.noContextMenu = noContextMenu;\nexports.setLayerDimensions = setLayerDimensions;\n__w_pdfjs_require__(2);\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(84);\n__w_pdfjs_require__(86);\n__w_pdfjs_require__(87);\nvar _base_factory = __w_pdfjs_require__(169);\nvar _util = __w_pdfjs_require__(1);\nconst SVG_NS = \"http://www.w3.org/2000/svg\";\nclass PixelsPerInch {\n  static CSS = 96.0;\n  static PDF = 72.0;\n  static PDF_TO_CSS_UNITS = this.CSS / this.PDF;\n}\nexports.PixelsPerInch = PixelsPerInch;\nclass DOMFilterFactory extends _base_factory.BaseFilterFactory {\n  #_cache;\n  #_defs;\n  #docId;\n  #document;\n  #hcmFilter;\n  #hcmKey;\n  #hcmUrl;\n  #hcmHighlightFilter;\n  #hcmHighlightKey;\n  #hcmHighlightUrl;\n  #id = 0;\n  constructor() {\n    let {\n      docId,\n      ownerDocument = globalThis.document\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this.#docId = docId;\n    this.#document = ownerDocument;\n  }\n  get #cache() {\n    return this.#_cache ||= new Map();\n  }\n  get #defs() {\n    if (!this.#_defs) {\n      const div = this.#document.createElement(\"div\");\n      const {\n        style\n      } = div;\n      style.visibility = \"hidden\";\n      style.contain = \"strict\";\n      style.width = style.height = 0;\n      style.position = \"absolute\";\n      style.top = style.left = 0;\n      style.zIndex = -1;\n      const svg = this.#document.createElementNS(SVG_NS, \"svg\");\n      svg.setAttribute(\"width\", 0);\n      svg.setAttribute(\"height\", 0);\n      this.#_defs = this.#document.createElementNS(SVG_NS, \"defs\");\n      div.append(svg);\n      svg.append(this.#_defs);\n      this.#document.body.append(div);\n    }\n    return this.#_defs;\n  }\n  addFilter(maps) {\n    if (!maps) {\n      return \"none\";\n    }\n    let value = this.#cache.get(maps);\n    if (value) {\n      return value;\n    }\n    let tableR, tableG, tableB, key;\n    if (maps.length === 1) {\n      const mapR = maps[0];\n      const buffer = new Array(256);\n      for (let i = 0; i < 256; i++) {\n        buffer[i] = mapR[i] / 255;\n      }\n      key = tableR = tableG = tableB = buffer.join(\",\");\n    } else {\n      const [mapR, mapG, mapB] = maps;\n      const bufferR = new Array(256);\n      const bufferG = new Array(256);\n      const bufferB = new Array(256);\n      for (let i = 0; i < 256; i++) {\n        bufferR[i] = mapR[i] / 255;\n        bufferG[i] = mapG[i] / 255;\n        bufferB[i] = mapB[i] / 255;\n      }\n      tableR = bufferR.join(\",\");\n      tableG = bufferG.join(\",\");\n      tableB = bufferB.join(\",\");\n      key = `${tableR}${tableG}${tableB}`;\n    }\n    value = this.#cache.get(key);\n    if (value) {\n      this.#cache.set(maps, value);\n      return value;\n    }\n    const id = `g_${this.#docId}_transfer_map_${this.#id++}`;\n    const url = `url(#${id})`;\n    this.#cache.set(maps, url);\n    this.#cache.set(key, url);\n    const filter = this.#createFilter(id);\n    this.#addTransferMapConversion(tableR, tableG, tableB, filter);\n    return url;\n  }\n  addHCMFilter(fgColor, bgColor) {\n    const key = `${fgColor}-${bgColor}`;\n    if (this.#hcmKey === key) {\n      return this.#hcmUrl;\n    }\n    this.#hcmKey = key;\n    this.#hcmUrl = \"none\";\n    this.#hcmFilter?.remove();\n    if (!fgColor || !bgColor) {\n      return this.#hcmUrl;\n    }\n    const fgRGB = this.#getRGB(fgColor);\n    fgColor = _util.Util.makeHexColor(...fgRGB);\n    const bgRGB = this.#getRGB(bgColor);\n    bgColor = _util.Util.makeHexColor(...bgRGB);\n    this.#defs.style.color = \"\";\n    if (fgColor === \"#000000\" && bgColor === \"#ffffff\" || fgColor === bgColor) {\n      return this.#hcmUrl;\n    }\n    const map = new Array(256);\n    for (let i = 0; i <= 255; i++) {\n      const x = i / 255;\n      map[i] = x <= 0.03928 ? x / 12.92 : ((x + 0.055) / 1.055) ** 2.4;\n    }\n    const table = map.join(\",\");\n    const id = `g_${this.#docId}_hcm_filter`;\n    const filter = this.#hcmHighlightFilter = this.#createFilter(id);\n    this.#addTransferMapConversion(table, table, table, filter);\n    this.#addGrayConversion(filter);\n    const getSteps = (c, n) => {\n      const start = fgRGB[c] / 255;\n      const end = bgRGB[c] / 255;\n      const arr = new Array(n + 1);\n      for (let i = 0; i <= n; i++) {\n        arr[i] = start + i / n * (end - start);\n      }\n      return arr.join(\",\");\n    };\n    this.#addTransferMapConversion(getSteps(0, 5), getSteps(1, 5), getSteps(2, 5), filter);\n    this.#hcmUrl = `url(#${id})`;\n    return this.#hcmUrl;\n  }\n  addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {\n    const key = `${fgColor}-${bgColor}-${newFgColor}-${newBgColor}`;\n    if (this.#hcmHighlightKey === key) {\n      return this.#hcmHighlightUrl;\n    }\n    this.#hcmHighlightKey = key;\n    this.#hcmHighlightUrl = \"none\";\n    this.#hcmHighlightFilter?.remove();\n    if (!fgColor || !bgColor) {\n      return this.#hcmHighlightUrl;\n    }\n    const [fgRGB, bgRGB] = [fgColor, bgColor].map(this.#getRGB.bind(this));\n    let fgGray = Math.round(0.2126 * fgRGB[0] + 0.7152 * fgRGB[1] + 0.0722 * fgRGB[2]);\n    let bgGray = Math.round(0.2126 * bgRGB[0] + 0.7152 * bgRGB[1] + 0.0722 * bgRGB[2]);\n    let [newFgRGB, newBgRGB] = [newFgColor, newBgColor].map(this.#getRGB.bind(this));\n    if (bgGray < fgGray) {\n      [fgGray, bgGray, newFgRGB, newBgRGB] = [bgGray, fgGray, newBgRGB, newFgRGB];\n    }\n    this.#defs.style.color = \"\";\n    const getSteps = (fg, bg, n) => {\n      const arr = new Array(256);\n      const step = (bgGray - fgGray) / n;\n      const newStart = fg / 255;\n      const newStep = (bg - fg) / (255 * n);\n      let prev = 0;\n      for (let i = 0; i <= n; i++) {\n        const k = Math.round(fgGray + i * step);\n        const value = newStart + i * newStep;\n        for (let j = prev; j <= k; j++) {\n          arr[j] = value;\n        }\n        prev = k + 1;\n      }\n      for (let i = prev; i < 256; i++) {\n        arr[i] = arr[prev - 1];\n      }\n      return arr.join(\",\");\n    };\n    const id = `g_${this.#docId}_hcm_highlight_filter`;\n    const filter = this.#hcmHighlightFilter = this.#createFilter(id);\n    this.#addGrayConversion(filter);\n    this.#addTransferMapConversion(getSteps(newFgRGB[0], newBgRGB[0], 5), getSteps(newFgRGB[1], newBgRGB[1], 5), getSteps(newFgRGB[2], newBgRGB[2], 5), filter);\n    this.#hcmHighlightUrl = `url(#${id})`;\n    return this.#hcmHighlightUrl;\n  }\n  destroy() {\n    let keepHCM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (keepHCM && (this.#hcmUrl || this.#hcmHighlightUrl)) {\n      return;\n    }\n    if (this.#_defs) {\n      this.#_defs.parentNode.parentNode.remove();\n      this.#_defs = null;\n    }\n    if (this.#_cache) {\n      this.#_cache.clear();\n      this.#_cache = null;\n    }\n    this.#id = 0;\n  }\n  #addGrayConversion(filter) {\n    const feColorMatrix = this.#document.createElementNS(SVG_NS, \"feColorMatrix\");\n    feColorMatrix.setAttribute(\"type\", \"matrix\");\n    feColorMatrix.setAttribute(\"values\", \"0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0.2126 0.7152 0.0722 0 0 0 0 0 1 0\");\n    filter.append(feColorMatrix);\n  }\n  #createFilter(id) {\n    const filter = this.#document.createElementNS(SVG_NS, \"filter\");\n    filter.setAttribute(\"color-interpolation-filters\", \"sRGB\");\n    filter.setAttribute(\"id\", id);\n    this.#defs.append(filter);\n    return filter;\n  }\n  #appendFeFunc(feComponentTransfer, func, table) {\n    const feFunc = this.#document.createElementNS(SVG_NS, func);\n    feFunc.setAttribute(\"type\", \"discrete\");\n    feFunc.setAttribute(\"tableValues\", table);\n    feComponentTransfer.append(feFunc);\n  }\n  #addTransferMapConversion(rTable, gTable, bTable, filter) {\n    const feComponentTransfer = this.#document.createElementNS(SVG_NS, \"feComponentTransfer\");\n    filter.append(feComponentTransfer);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncR\", rTable);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncG\", gTable);\n    this.#appendFeFunc(feComponentTransfer, \"feFuncB\", bTable);\n  }\n  #getRGB(color) {\n    this.#defs.style.color = color;\n    return getRGB(getComputedStyle(this.#defs).getPropertyValue(\"color\"));\n  }\n}\nexports.DOMFilterFactory = DOMFilterFactory;\nclass DOMCanvasFactory extends _base_factory.BaseCanvasFactory {\n  constructor() {\n    let {\n      ownerDocument = globalThis.document\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n    this._document = ownerDocument;\n  }\n  _createCanvas(width, height) {\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = width;\n    canvas.height = height;\n    return canvas;\n  }\n}\nexports.DOMCanvasFactory = DOMCanvasFactory;\nasync function fetchData(url) {\n  let asTypedArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (isValidFetchUrl(url, document.baseURI)) {\n    const response = await fetch(url);\n    if (!response.ok) {\n      throw new Error(response.statusText);\n    }\n    return asTypedArray ? new Uint8Array(await response.arrayBuffer()) : (0, _util.stringToBytes)(await response.text());\n  }\n  return new Promise((resolve, reject) => {\n    const request = new XMLHttpRequest();\n    request.open(\"GET\", url, true);\n    if (asTypedArray) {\n      request.responseType = \"arraybuffer\";\n    }\n    request.onreadystatechange = () => {\n      if (request.readyState !== XMLHttpRequest.DONE) {\n        return;\n      }\n      if (request.status === 200 || request.status === 0) {\n        let data;\n        if (asTypedArray && request.response) {\n          data = new Uint8Array(request.response);\n        } else if (!asTypedArray && request.responseText) {\n          data = (0, _util.stringToBytes)(request.responseText);\n        }\n        if (data) {\n          resolve(data);\n          return;\n        }\n      }\n      reject(new Error(request.statusText));\n    };\n    request.send(null);\n  });\n}\nclass DOMCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url, this.isCompressed).then(data => {\n      return {\n        cMapData: data,\n        compressionType\n      };\n    });\n  }\n}\nexports.DOMCMapReaderFactory = DOMCMapReaderFactory;\nclass DOMStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url, true);\n  }\n}\nexports.DOMStandardFontDataFactory = DOMStandardFontDataFactory;\nclass DOMSVGFactory extends _base_factory.BaseSVGFactory {\n  _createSVG(type) {\n    return document.createElementNS(SVG_NS, type);\n  }\n}\nexports.DOMSVGFactory = DOMSVGFactory;\nclass PageViewport {\n  constructor(_ref) {\n    let {\n      viewBox,\n      scale,\n      rotation,\n      offsetX = 0,\n      offsetY = 0,\n      dontFlip = false\n    } = _ref;\n    this.viewBox = viewBox;\n    this.scale = scale;\n    this.rotation = rotation;\n    this.offsetX = offsetX;\n    this.offsetY = offsetY;\n    const centerX = (viewBox[2] + viewBox[0]) / 2;\n    const centerY = (viewBox[3] + viewBox[1]) / 2;\n    let rotateA, rotateB, rotateC, rotateD;\n    rotation %= 360;\n    if (rotation < 0) {\n      rotation += 360;\n    }\n    switch (rotation) {\n      case 180:\n        rotateA = -1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = 1;\n        break;\n      case 90:\n        rotateA = 0;\n        rotateB = 1;\n        rotateC = 1;\n        rotateD = 0;\n        break;\n      case 270:\n        rotateA = 0;\n        rotateB = -1;\n        rotateC = -1;\n        rotateD = 0;\n        break;\n      case 0:\n        rotateA = 1;\n        rotateB = 0;\n        rotateC = 0;\n        rotateD = -1;\n        break;\n      default:\n        throw new Error(\"PageViewport: Invalid rotation, must be a multiple of 90 degrees.\");\n    }\n    if (dontFlip) {\n      rotateC = -rotateC;\n      rotateD = -rotateD;\n    }\n    let offsetCanvasX, offsetCanvasY;\n    let width, height;\n    if (rotateA === 0) {\n      offsetCanvasX = Math.abs(centerY - viewBox[1]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerX - viewBox[0]) * scale + offsetY;\n      width = (viewBox[3] - viewBox[1]) * scale;\n      height = (viewBox[2] - viewBox[0]) * scale;\n    } else {\n      offsetCanvasX = Math.abs(centerX - viewBox[0]) * scale + offsetX;\n      offsetCanvasY = Math.abs(centerY - viewBox[1]) * scale + offsetY;\n      width = (viewBox[2] - viewBox[0]) * scale;\n      height = (viewBox[3] - viewBox[1]) * scale;\n    }\n    this.transform = [rotateA * scale, rotateB * scale, rotateC * scale, rotateD * scale, offsetCanvasX - rotateA * scale * centerX - rotateC * scale * centerY, offsetCanvasY - rotateB * scale * centerX - rotateD * scale * centerY];\n    this.width = width;\n    this.height = height;\n  }\n  get rawDims() {\n    const {\n      viewBox\n    } = this;\n    return (0, _util.shadow)(this, \"rawDims\", {\n      pageWidth: viewBox[2] - viewBox[0],\n      pageHeight: viewBox[3] - viewBox[1],\n      pageX: viewBox[0],\n      pageY: viewBox[1]\n    });\n  }\n  clone() {\n    let {\n      scale = this.scale,\n      rotation = this.rotation,\n      offsetX = this.offsetX,\n      offsetY = this.offsetY,\n      dontFlip = false\n    } = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    return new PageViewport({\n      viewBox: this.viewBox.slice(),\n      scale,\n      rotation,\n      offsetX,\n      offsetY,\n      dontFlip\n    });\n  }\n  convertToViewportPoint(x, y) {\n    return _util.Util.applyTransform([x, y], this.transform);\n  }\n  convertToViewportRectangle(rect) {\n    const topLeft = _util.Util.applyTransform([rect[0], rect[1]], this.transform);\n    const bottomRight = _util.Util.applyTransform([rect[2], rect[3]], this.transform);\n    return [topLeft[0], topLeft[1], bottomRight[0], bottomRight[1]];\n  }\n  convertToPdfPoint(x, y) {\n    return _util.Util.applyInverseTransform([x, y], this.transform);\n  }\n}\nexports.PageViewport = PageViewport;\nclass RenderingCancelledException extends _util.BaseException {\n  constructor(msg) {\n    let extraDelay = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n    super(msg, \"RenderingCancelledException\");\n    this.extraDelay = extraDelay;\n  }\n}\nexports.RenderingCancelledException = RenderingCancelledException;\nfunction isDataScheme(url) {\n  const ii = url.length;\n  let i = 0;\n  while (i < ii && url[i].trim() === \"\") {\n    i++;\n  }\n  return url.substring(i, i + 5).toLowerCase() === \"data:\";\n}\nfunction isPdfFile(filename) {\n  return typeof filename === \"string\" && /\\.pdf$/i.test(filename);\n}\nfunction getFilenameFromUrl(url) {\n  let onlyStripPath = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  if (!onlyStripPath) {\n    [url] = url.split(/[#?]/, 1);\n  }\n  return url.substring(url.lastIndexOf(\"/\") + 1);\n}\nfunction getPdfFilenameFromUrl(url) {\n  let defaultFilename = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"document.pdf\";\n  if (typeof url !== \"string\") {\n    return defaultFilename;\n  }\n  if (isDataScheme(url)) {\n    (0, _util.warn)('getPdfFilenameFromUrl: ignore \"data:\"-URL for performance reasons.');\n    return defaultFilename;\n  }\n  const reURI = /^(?:(?:[^:]+:)?\\/\\/[^/]+)?([^?#]*)(\\?[^#]*)?(#.*)?$/;\n  const reFilename = /[^/?#=]+\\.pdf\\b(?!.*\\.pdf\\b)/i;\n  const splitURI = reURI.exec(url);\n  let suggestedFilename = reFilename.exec(splitURI[1]) || reFilename.exec(splitURI[2]) || reFilename.exec(splitURI[3]);\n  if (suggestedFilename) {\n    suggestedFilename = suggestedFilename[0];\n    if (suggestedFilename.includes(\"%\")) {\n      try {\n        suggestedFilename = reFilename.exec(decodeURIComponent(suggestedFilename))[0];\n      } catch {}\n    }\n  }\n  return suggestedFilename || defaultFilename;\n}\nclass StatTimer {\n  started = Object.create(null);\n  times = [];\n  time(name) {\n    if (name in this.started) {\n      (0, _util.warn)(`Timer is already running for ${name}`);\n    }\n    this.started[name] = Date.now();\n  }\n  timeEnd(name) {\n    if (!(name in this.started)) {\n      (0, _util.warn)(`Timer has not been started for ${name}`);\n    }\n    this.times.push({\n      name,\n      start: this.started[name],\n      end: Date.now()\n    });\n    delete this.started[name];\n  }\n  toString() {\n    const outBuf = [];\n    let longest = 0;\n    for (const {\n      name\n    } of this.times) {\n      longest = Math.max(name.length, longest);\n    }\n    for (const {\n      name,\n      start,\n      end\n    } of this.times) {\n      outBuf.push(`${name.padEnd(longest)} ${end - start}ms\\n`);\n    }\n    return outBuf.join(\"\");\n  }\n}\nexports.StatTimer = StatTimer;\nfunction isValidFetchUrl(url, baseUrl) {\n  try {\n    const {\n      protocol\n    } = baseUrl ? new URL(url, baseUrl) : new URL(url);\n    return protocol === \"http:\" || protocol === \"https:\";\n  } catch {\n    return false;\n  }\n}\nfunction noContextMenu(e) {\n  e.preventDefault();\n}\nfunction loadScript(src) {\n  let removeScriptElement = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n  return new Promise((resolve, reject) => {\n    const script = document.createElement(\"script\");\n    script.src = src;\n    script.onload = function (evt) {\n      if (removeScriptElement) {\n        script.remove();\n      }\n      resolve(evt);\n    };\n    script.onerror = function () {\n      reject(new Error(`Cannot load script at: ${script.src}`));\n    };\n    (document.head || document.documentElement).append(script);\n  });\n}\nfunction deprecated(details) {\n  console.log(\"Deprecated API usage: \" + details);\n}\nlet pdfDateStringRegex;\nclass PDFDateString {\n  static toDateObject(input) {\n    if (!input || typeof input !== \"string\") {\n      return null;\n    }\n    pdfDateStringRegex ||= new RegExp(\"^D:\" + \"(\\\\d{4})\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"(\\\\d{2})?\" + \"([Z|+|-])?\" + \"(\\\\d{2})?\" + \"'?\" + \"(\\\\d{2})?\" + \"'?\");\n    const matches = pdfDateStringRegex.exec(input);\n    if (!matches) {\n      return null;\n    }\n    const year = parseInt(matches[1], 10);\n    let month = parseInt(matches[2], 10);\n    month = month >= 1 && month <= 12 ? month - 1 : 0;\n    let day = parseInt(matches[3], 10);\n    day = day >= 1 && day <= 31 ? day : 1;\n    let hour = parseInt(matches[4], 10);\n    hour = hour >= 0 && hour <= 23 ? hour : 0;\n    let minute = parseInt(matches[5], 10);\n    minute = minute >= 0 && minute <= 59 ? minute : 0;\n    let second = parseInt(matches[6], 10);\n    second = second >= 0 && second <= 59 ? second : 0;\n    const universalTimeRelation = matches[7] || \"Z\";\n    let offsetHour = parseInt(matches[8], 10);\n    offsetHour = offsetHour >= 0 && offsetHour <= 23 ? offsetHour : 0;\n    let offsetMinute = parseInt(matches[9], 10) || 0;\n    offsetMinute = offsetMinute >= 0 && offsetMinute <= 59 ? offsetMinute : 0;\n    if (universalTimeRelation === \"-\") {\n      hour += offsetHour;\n      minute += offsetMinute;\n    } else if (universalTimeRelation === \"+\") {\n      hour -= offsetHour;\n      minute -= offsetMinute;\n    }\n    return new Date(Date.UTC(year, month, day, hour, minute, second));\n  }\n}\nexports.PDFDateString = PDFDateString;\nfunction getXfaPageViewport(xfaPage, _ref2) {\n  let {\n    scale = 1,\n    rotation = 0\n  } = _ref2;\n  const {\n    width,\n    height\n  } = xfaPage.attributes.style;\n  const viewBox = [0, 0, parseInt(width), parseInt(height)];\n  return new PageViewport({\n    viewBox,\n    scale,\n    rotation\n  });\n}\nfunction getRGB(color) {\n  if (color.startsWith(\"#\")) {\n    const colorRGB = parseInt(color.slice(1), 16);\n    return [(colorRGB & 0xff0000) >> 16, (colorRGB & 0x00ff00) >> 8, colorRGB & 0x0000ff];\n  }\n  if (color.startsWith(\"rgb(\")) {\n    return color.slice(4, -1).split(\",\").map(x => parseInt(x));\n  }\n  if (color.startsWith(\"rgba(\")) {\n    return color.slice(5, -1).split(\",\").map(x => parseInt(x)).slice(0, 3);\n  }\n  (0, _util.warn)(`Not a valid color format: \"${color}\"`);\n  return [0, 0, 0];\n}\nfunction getColorValues(colors) {\n  const span = document.createElement(\"span\");\n  span.style.visibility = \"hidden\";\n  document.body.append(span);\n  for (const name of colors.keys()) {\n    span.style.color = name;\n    const computedColor = window.getComputedStyle(span).color;\n    colors.set(name, getRGB(computedColor));\n  }\n  span.remove();\n}\nfunction getCurrentTransform(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform();\n  return [a, b, c, d, e, f];\n}\nfunction getCurrentTransformInverse(ctx) {\n  const {\n    a,\n    b,\n    c,\n    d,\n    e,\n    f\n  } = ctx.getTransform().invertSelf();\n  return [a, b, c, d, e, f];\n}\nfunction setLayerDimensions(div, viewport) {\n  let mustFlip = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  let mustRotate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : true;\n  if (viewport instanceof PageViewport) {\n    const {\n      pageWidth,\n      pageHeight\n    } = viewport.rawDims;\n    const {\n      style\n    } = div;\n    const useRound = _util.FeatureTest.isCSSRoundSupported;\n    const w = `var(--scale-factor) * ${pageWidth}px`,\n      h = `var(--scale-factor) * ${pageHeight}px`;\n    const widthStr = useRound ? `round(${w}, 1px)` : `calc(${w})`,\n      heightStr = useRound ? `round(${h}, 1px)` : `calc(${h})`;\n    if (!mustFlip || viewport.rotation % 180 === 0) {\n      style.width = widthStr;\n      style.height = heightStr;\n    } else {\n      style.width = heightStr;\n      style.height = widthStr;\n    }\n  }\n  if (mustRotate) {\n    div.setAttribute(\"data-main-rotation\", viewport.rotation);\n  }\n}\n\n/***/ }),\n/* 169 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.BaseStandardFontDataFactory = exports.BaseSVGFactory = exports.BaseFilterFactory = exports.BaseCanvasFactory = exports.BaseCMapReaderFactory = void 0;\n__w_pdfjs_require__(2);\nvar _util = __w_pdfjs_require__(1);\nclass BaseFilterFactory {\n  constructor() {\n    if (this.constructor === BaseFilterFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseFilterFactory.\");\n    }\n  }\n  addFilter(maps) {\n    return \"none\";\n  }\n  addHCMFilter(fgColor, bgColor) {\n    return \"none\";\n  }\n  addHighlightHCMFilter(fgColor, bgColor, newFgColor, newBgColor) {\n    return \"none\";\n  }\n  destroy() {\n    let keepHCM = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n  }\n}\nexports.BaseFilterFactory = BaseFilterFactory;\nclass BaseCanvasFactory {\n  constructor() {\n    if (this.constructor === BaseCanvasFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCanvasFactory.\");\n    }\n  }\n  create(width, height) {\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    const canvas = this._createCanvas(width, height);\n    return {\n      canvas,\n      context: canvas.getContext(\"2d\")\n    };\n  }\n  reset(canvasAndContext, width, height) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid canvas size\");\n    }\n    canvasAndContext.canvas.width = width;\n    canvasAndContext.canvas.height = height;\n  }\n  destroy(canvasAndContext) {\n    if (!canvasAndContext.canvas) {\n      throw new Error(\"Canvas is not specified\");\n    }\n    canvasAndContext.canvas.width = 0;\n    canvasAndContext.canvas.height = 0;\n    canvasAndContext.canvas = null;\n    canvasAndContext.context = null;\n  }\n  _createCanvas(width, height) {\n    (0, _util.unreachable)(\"Abstract method `_createCanvas` called.\");\n  }\n}\nexports.BaseCanvasFactory = BaseCanvasFactory;\nclass BaseCMapReaderFactory {\n  constructor(_ref) {\n    let {\n      baseUrl = null,\n      isCompressed = true\n    } = _ref;\n    if (this.constructor === BaseCMapReaderFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseCMapReaderFactory.\");\n    }\n    this.baseUrl = baseUrl;\n    this.isCompressed = isCompressed;\n  }\n  async fetch(_ref2) {\n    let {\n      name\n    } = _ref2;\n    if (!this.baseUrl) {\n      throw new Error('The CMap \"baseUrl\" parameter must be specified, ensure that ' + 'the \"cMapUrl\" and \"cMapPacked\" API parameters are provided.');\n    }\n    if (!name) {\n      throw new Error(\"CMap name must be specified.\");\n    }\n    const url = this.baseUrl + name + (this.isCompressed ? \".bcmap\" : \"\");\n    const compressionType = this.isCompressed ? _util.CMapCompressionType.BINARY : _util.CMapCompressionType.NONE;\n    return this._fetchData(url, compressionType).catch(reason => {\n      throw new Error(`Unable to load ${this.isCompressed ? \"binary \" : \"\"}CMap at: ${url}`);\n    });\n  }\n  _fetchData(url, compressionType) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n}\nexports.BaseCMapReaderFactory = BaseCMapReaderFactory;\nclass BaseStandardFontDataFactory {\n  constructor(_ref3) {\n    let {\n      baseUrl = null\n    } = _ref3;\n    if (this.constructor === BaseStandardFontDataFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseStandardFontDataFactory.\");\n    }\n    this.baseUrl = baseUrl;\n  }\n  async fetch(_ref4) {\n    let {\n      filename\n    } = _ref4;\n    if (!this.baseUrl) {\n      throw new Error('The standard font \"baseUrl\" parameter must be specified, ensure that ' + 'the \"standardFontDataUrl\" API parameter is provided.');\n    }\n    if (!filename) {\n      throw new Error(\"Font filename must be specified.\");\n    }\n    const url = `${this.baseUrl}${filename}`;\n    return this._fetchData(url).catch(reason => {\n      throw new Error(`Unable to load font data at: ${url}`);\n    });\n  }\n  _fetchData(url) {\n    (0, _util.unreachable)(\"Abstract method `_fetchData` called.\");\n  }\n}\nexports.BaseStandardFontDataFactory = BaseStandardFontDataFactory;\nclass BaseSVGFactory {\n  constructor() {\n    if (this.constructor === BaseSVGFactory) {\n      (0, _util.unreachable)(\"Cannot initialize BaseSVGFactory.\");\n    }\n  }\n  create(width, height) {\n    let skipDimensions = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    if (width <= 0 || height <= 0) {\n      throw new Error(\"Invalid SVG dimensions\");\n    }\n    const svg = this._createSVG(\"svg:svg\");\n    svg.setAttribute(\"version\", \"1.1\");\n    if (!skipDimensions) {\n      svg.setAttribute(\"width\", `${width}px`);\n      svg.setAttribute(\"height\", `${height}px`);\n    }\n    svg.setAttribute(\"preserveAspectRatio\", \"none\");\n    svg.setAttribute(\"viewBox\", `0 0 ${width} ${height}`);\n    return svg;\n  }\n  createElement(type) {\n    if (typeof type !== \"string\") {\n      throw new Error(\"Invalid SVG element type\");\n    }\n    return this._createSVG(type);\n  }\n  _createSVG(type) {\n    (0, _util.unreachable)(\"Abstract method `_createSVG` called.\");\n  }\n}\nexports.BaseSVGFactory = BaseSVGFactory;\n\n/***/ }),\n/* 170 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MurmurHash3_64 = void 0;\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\n__w_pdfjs_require__(2);\nvar _util = __w_pdfjs_require__(1);\nconst SEED = 0xc3d2e1f0;\nconst MASK_HIGH = 0xffff0000;\nconst MASK_LOW = 0xffff;\nclass MurmurHash3_64 {\n  constructor(seed) {\n    this.h1 = seed ? seed & 0xffffffff : SEED;\n    this.h2 = seed ? seed & 0xffffffff : SEED;\n  }\n  update(input) {\n    let data, length;\n    if (typeof input === \"string\") {\n      data = new Uint8Array(input.length * 2);\n      length = 0;\n      for (let i = 0, ii = input.length; i < ii; i++) {\n        const code = input.charCodeAt(i);\n        if (code <= 0xff) {\n          data[length++] = code;\n        } else {\n          data[length++] = code >>> 8;\n          data[length++] = code & 0xff;\n        }\n      }\n    } else if ((0, _util.isArrayBuffer)(input)) {\n      data = input.slice();\n      length = data.byteLength;\n    } else {\n      throw new Error(\"Wrong data format in MurmurHash3_64_update. \" + \"Input must be a string or array.\");\n    }\n    const blockCounts = length >> 2;\n    const tailLength = length - blockCounts * 4;\n    const dataUint32 = new Uint32Array(data.buffer, 0, blockCounts);\n    let k1 = 0,\n      k2 = 0;\n    let h1 = this.h1,\n      h2 = this.h2;\n    const C1 = 0xcc9e2d51,\n      C2 = 0x1b873593;\n    const C1_LOW = C1 & MASK_LOW,\n      C2_LOW = C2 & MASK_LOW;\n    for (let i = 0; i < blockCounts; i++) {\n      if (i & 1) {\n        k1 = dataUint32[i];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        h1 ^= k1;\n        h1 = h1 << 13 | h1 >>> 19;\n        h1 = h1 * 5 + 0xe6546b64;\n      } else {\n        k2 = dataUint32[i];\n        k2 = k2 * C1 & MASK_HIGH | k2 * C1_LOW & MASK_LOW;\n        k2 = k2 << 15 | k2 >>> 17;\n        k2 = k2 * C2 & MASK_HIGH | k2 * C2_LOW & MASK_LOW;\n        h2 ^= k2;\n        h2 = h2 << 13 | h2 >>> 19;\n        h2 = h2 * 5 + 0xe6546b64;\n      }\n    }\n    k1 = 0;\n    switch (tailLength) {\n      case 3:\n        k1 ^= data[blockCounts * 4 + 2] << 16;\n      case 2:\n        k1 ^= data[blockCounts * 4 + 1] << 8;\n      case 1:\n        k1 ^= data[blockCounts * 4];\n        k1 = k1 * C1 & MASK_HIGH | k1 * C1_LOW & MASK_LOW;\n        k1 = k1 << 15 | k1 >>> 17;\n        k1 = k1 * C2 & MASK_HIGH | k1 * C2_LOW & MASK_LOW;\n        if (blockCounts & 1) {\n          h1 ^= k1;\n        } else {\n          h2 ^= k1;\n        }\n    }\n    this.h1 = h1;\n    this.h2 = h2;\n  }\n  hexdigest() {\n    let h1 = this.h1,\n      h2 = this.h2;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0xed558ccd & MASK_HIGH | h1 * 0x8ccd & MASK_LOW;\n    h2 = h2 * 0xff51afd7 & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xafd7ed55 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    h1 = h1 * 0x1a85ec53 & MASK_HIGH | h1 * 0xec53 & MASK_LOW;\n    h2 = h2 * 0xc4ceb9fe & MASK_HIGH | ((h2 << 16 | h1 >>> 16) * 0xb9fe1a85 & MASK_HIGH) >>> 16;\n    h1 ^= h2 >>> 1;\n    return (h1 >>> 0).toString(16).padStart(8, \"0\") + (h2 >>> 0).toString(16).padStart(8, \"0\");\n  }\n}\nexports.MurmurHash3_64 = MurmurHash3_64;\n\n/***/ }),\n/* 171 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FontLoader = exports.FontFaceObject = void 0;\n__w_pdfjs_require__(125);\n__w_pdfjs_require__(136);\n__w_pdfjs_require__(138);\n__w_pdfjs_require__(141);\n__w_pdfjs_require__(143);\n__w_pdfjs_require__(145);\n__w_pdfjs_require__(147);\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(149);\nvar _util = __w_pdfjs_require__(1);\nclass FontLoader {\n  #systemFonts = new Set();\n  constructor(_ref) {\n    let {\n      ownerDocument = globalThis.document,\n      styleElement = null\n    } = _ref;\n    this._document = ownerDocument;\n    this.nativeFontFaces = new Set();\n    this.styleElement = null;\n    this.loadingRequests = [];\n    this.loadTestFontId = 0;\n  }\n  addNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.add(nativeFontFace);\n    this._document.fonts.add(nativeFontFace);\n  }\n  removeNativeFontFace(nativeFontFace) {\n    this.nativeFontFaces.delete(nativeFontFace);\n    this._document.fonts.delete(nativeFontFace);\n  }\n  insertRule(rule) {\n    if (!this.styleElement) {\n      this.styleElement = this._document.createElement(\"style\");\n      this._document.documentElement.getElementsByTagName(\"head\")[0].append(this.styleElement);\n    }\n    const styleSheet = this.styleElement.sheet;\n    styleSheet.insertRule(rule, styleSheet.cssRules.length);\n  }\n  clear() {\n    for (const nativeFontFace of this.nativeFontFaces) {\n      this._document.fonts.delete(nativeFontFace);\n    }\n    this.nativeFontFaces.clear();\n    this.#systemFonts.clear();\n    if (this.styleElement) {\n      this.styleElement.remove();\n      this.styleElement = null;\n    }\n  }\n  async loadSystemFont(info) {\n    if (!info || this.#systemFonts.has(info.loadedName)) {\n      return;\n    }\n    (0, _util.assert)(!this.disableFontFace, \"loadSystemFont shouldn't be called when `disableFontFace` is set.\");\n    if (this.isFontLoadingAPISupported) {\n      const {\n        loadedName,\n        src,\n        style\n      } = info;\n      const fontFace = new FontFace(loadedName, src, style);\n      this.addNativeFontFace(fontFace);\n      try {\n        await fontFace.load();\n        this.#systemFonts.add(loadedName);\n      } catch {\n        (0, _util.warn)(`Cannot load system font: ${info.baseFontName}, installing it could help to improve PDF rendering.`);\n        this.removeNativeFontFace(fontFace);\n      }\n      return;\n    }\n    (0, _util.unreachable)(\"Not implemented: loadSystemFont without the Font Loading API.\");\n  }\n  async bind(font) {\n    if (font.attached || font.missingFile && !font.systemFontInfo) {\n      return;\n    }\n    font.attached = true;\n    if (font.systemFontInfo) {\n      await this.loadSystemFont(font.systemFontInfo);\n      return;\n    }\n    if (this.isFontLoadingAPISupported) {\n      const nativeFontFace = font.createNativeFontFace();\n      if (nativeFontFace) {\n        this.addNativeFontFace(nativeFontFace);\n        try {\n          await nativeFontFace.loaded;\n        } catch (ex) {\n          (0, _util.warn)(`Failed to load font '${nativeFontFace.family}': '${ex}'.`);\n          font.disableFontFace = true;\n          throw ex;\n        }\n      }\n      return;\n    }\n    const rule = font.createFontFaceRule();\n    if (rule) {\n      this.insertRule(rule);\n      if (this.isSyncFontLoadingSupported) {\n        return;\n      }\n      await new Promise(resolve => {\n        const request = this._queueLoadingCallback(resolve);\n        this._prepareFontLoadEvent(font, request);\n      });\n    }\n  }\n  get isFontLoadingAPISupported() {\n    const hasFonts = !!this._document?.fonts;\n    return (0, _util.shadow)(this, \"isFontLoadingAPISupported\", hasFonts);\n  }\n  get isSyncFontLoadingSupported() {\n    let supported = false;\n    if (_util.isNodeJS) {\n      supported = true;\n    } else if (typeof navigator !== \"undefined\" && /Mozilla\\/5.0.*?rv:\\d+.*? Gecko/.test(navigator.userAgent)) {\n      supported = true;\n    }\n    return (0, _util.shadow)(this, \"isSyncFontLoadingSupported\", supported);\n  }\n  _queueLoadingCallback(callback) {\n    function completeRequest() {\n      (0, _util.assert)(!request.done, \"completeRequest() cannot be called twice.\");\n      request.done = true;\n      while (loadingRequests.length > 0 && loadingRequests[0].done) {\n        const otherRequest = loadingRequests.shift();\n        setTimeout(otherRequest.callback, 0);\n      }\n    }\n    const {\n      loadingRequests\n    } = this;\n    const request = {\n      done: false,\n      complete: completeRequest,\n      callback\n    };\n    loadingRequests.push(request);\n    return request;\n  }\n  get _loadTestFont() {\n    const testFont = atob(\"T1RUTwALAIAAAwAwQ0ZGIDHtZg4AAAOYAAAAgUZGVE1lkzZwAAAEHAAAABxHREVGABQA\" + \"FQAABDgAAAAeT1MvMlYNYwkAAAEgAAAAYGNtYXABDQLUAAACNAAAAUJoZWFk/xVFDQAA\" + \"ALwAAAA2aGhlYQdkA+oAAAD0AAAAJGhtdHgD6AAAAAAEWAAAAAZtYXhwAAJQAAAAARgA\" + \"AAAGbmFtZVjmdH4AAAGAAAAAsXBvc3T/hgAzAAADeAAAACAAAQAAAAEAALZRFsRfDzz1\" + \"AAsD6AAAAADOBOTLAAAAAM4KHDwAAAAAA+gDIQAAAAgAAgAAAAAAAAABAAADIQAAAFoD\" + \"6AAAAAAD6AABAAAAAAAAAAAAAAAAAAAAAQAAUAAAAgAAAAQD6AH0AAUAAAKKArwAAACM\" + \"AooCvAAAAeAAMQECAAACAAYJAAAAAAAAAAAAAQAAAAAAAAAAAAAAAFBmRWQAwAAuAC4D\" + \"IP84AFoDIQAAAAAAAQAAAAAAAAAAACAAIAABAAAADgCuAAEAAAAAAAAAAQAAAAEAAAAA\" + \"AAEAAQAAAAEAAAAAAAIAAQAAAAEAAAAAAAMAAQAAAAEAAAAAAAQAAQAAAAEAAAAAAAUA\" + \"AQAAAAEAAAAAAAYAAQAAAAMAAQQJAAAAAgABAAMAAQQJAAEAAgABAAMAAQQJAAIAAgAB\" + \"AAMAAQQJAAMAAgABAAMAAQQJAAQAAgABAAMAAQQJAAUAAgABAAMAAQQJAAYAAgABWABY\" + \"AAAAAAAAAwAAAAMAAAAcAAEAAAAAADwAAwABAAAAHAAEACAAAAAEAAQAAQAAAC7//wAA\" + \"AC7////TAAEAAAAAAAABBgAAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA\" + \"AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAMAAAAAAAD/gwAyAAAAAQAAAAAAAAAAAAAAAAAA\" + \"AAABAAQEAAEBAQJYAAEBASH4DwD4GwHEAvgcA/gXBIwMAYuL+nz5tQXkD5j3CBLnEQAC\" + \"AQEBIVhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYAAABAQAADwACAQEEE/t3\" + \"Dov6fAH6fAT+fPp8+nwHDosMCvm1Cvm1DAz6fBQAAAAAAAABAAAAAMmJbzEAAAAAzgTj\" + \"FQAAAADOBOQpAAEAAAAAAAAADAAUAAQAAAABAAAAAgABAAAAAAAAAAAD6AAAAAAAAA==\");\n    return (0, _util.shadow)(this, \"_loadTestFont\", testFont);\n  }\n  _prepareFontLoadEvent(font, request) {\n    function int32(data, offset) {\n      return data.charCodeAt(offset) << 24 | data.charCodeAt(offset + 1) << 16 | data.charCodeAt(offset + 2) << 8 | data.charCodeAt(offset + 3) & 0xff;\n    }\n    function spliceString(s, offset, remove, insert) {\n      const chunk1 = s.substring(0, offset);\n      const chunk2 = s.substring(offset + remove);\n      return chunk1 + insert + chunk2;\n    }\n    let i, ii;\n    const canvas = this._document.createElement(\"canvas\");\n    canvas.width = 1;\n    canvas.height = 1;\n    const ctx = canvas.getContext(\"2d\");\n    let called = 0;\n    function isFontReady(name, callback) {\n      if (++called > 30) {\n        (0, _util.warn)(\"Load test font never loaded.\");\n        callback();\n        return;\n      }\n      ctx.font = \"30px \" + name;\n      ctx.fillText(\".\", 0, 20);\n      const imageData = ctx.getImageData(0, 0, 1, 1);\n      if (imageData.data[3] > 0) {\n        callback();\n        return;\n      }\n      setTimeout(isFontReady.bind(null, name, callback));\n    }\n    const loadTestFontId = `lt${Date.now()}${this.loadTestFontId++}`;\n    let data = this._loadTestFont;\n    const COMMENT_OFFSET = 976;\n    data = spliceString(data, COMMENT_OFFSET, loadTestFontId.length, loadTestFontId);\n    const CFF_CHECKSUM_OFFSET = 16;\n    const XXXX_VALUE = 0x58585858;\n    let checksum = int32(data, CFF_CHECKSUM_OFFSET);\n    for (i = 0, ii = loadTestFontId.length - 3; i < ii; i += 4) {\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId, i) | 0;\n    }\n    if (i < loadTestFontId.length) {\n      checksum = checksum - XXXX_VALUE + int32(loadTestFontId + \"XXX\", i) | 0;\n    }\n    data = spliceString(data, CFF_CHECKSUM_OFFSET, 4, (0, _util.string32)(checksum));\n    const url = `url(data:font/opentype;base64,${btoa(data)});`;\n    const rule = `@font-face {font-family:\"${loadTestFontId}\";src:${url}}`;\n    this.insertRule(rule);\n    const div = this._document.createElement(\"div\");\n    div.style.visibility = \"hidden\";\n    div.style.width = div.style.height = \"10px\";\n    div.style.position = \"absolute\";\n    div.style.top = div.style.left = \"0px\";\n    for (const name of [font.loadedName, loadTestFontId]) {\n      const span = this._document.createElement(\"span\");\n      span.textContent = \"Hi\";\n      span.style.fontFamily = name;\n      div.append(span);\n    }\n    this._document.body.append(div);\n    isFontReady(loadTestFontId, () => {\n      div.remove();\n      request.complete();\n    });\n  }\n}\nexports.FontLoader = FontLoader;\nclass FontFaceObject {\n  constructor(translatedData, _ref2) {\n    let {\n      isEvalSupported = true,\n      disableFontFace = false,\n      ignoreErrors = false,\n      inspectFont = null\n    } = _ref2;\n    this.compiledGlyphs = Object.create(null);\n    for (const i in translatedData) {\n      this[i] = translatedData[i];\n    }\n    this.isEvalSupported = isEvalSupported !== false;\n    this.disableFontFace = disableFontFace === true;\n    this.ignoreErrors = ignoreErrors === true;\n    this._inspectFont = inspectFont;\n  }\n  createNativeFontFace() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    let nativeFontFace;\n    if (!this.cssFontInfo) {\n      nativeFontFace = new FontFace(this.loadedName, this.data, {});\n    } else {\n      const css = {\n        weight: this.cssFontInfo.fontWeight\n      };\n      if (this.cssFontInfo.italicAngle) {\n        css.style = `oblique ${this.cssFontInfo.italicAngle}deg`;\n      }\n      nativeFontFace = new FontFace(this.cssFontInfo.fontFamily, this.data, css);\n    }\n    this._inspectFont?.(this);\n    return nativeFontFace;\n  }\n  createFontFaceRule() {\n    if (!this.data || this.disableFontFace) {\n      return null;\n    }\n    const data = (0, _util.bytesToString)(this.data);\n    const url = `url(data:${this.mimetype};base64,${btoa(data)});`;\n    let rule;\n    if (!this.cssFontInfo) {\n      rule = `@font-face {font-family:\"${this.loadedName}\";src:${url}}`;\n    } else {\n      let css = `font-weight: ${this.cssFontInfo.fontWeight};`;\n      if (this.cssFontInfo.italicAngle) {\n        css += `font-style: oblique ${this.cssFontInfo.italicAngle}deg;`;\n      }\n      rule = `@font-face {font-family:\"${this.cssFontInfo.fontFamily}\";${css}src:${url}}`;\n    }\n    this._inspectFont?.(this, url);\n    return rule;\n  }\n  getPathGenerator(objs, character) {\n    if (this.compiledGlyphs[character] !== undefined) {\n      return this.compiledGlyphs[character];\n    }\n    let cmds;\n    try {\n      cmds = objs.get(this.loadedName + \"_path_\" + character);\n    } catch (ex) {\n      if (!this.ignoreErrors) {\n        throw ex;\n      }\n      (0, _util.warn)(`getPathGenerator - ignoring character: \"${ex}\".`);\n      return this.compiledGlyphs[character] = function (c, size) {};\n    }\n    if (this.isEvalSupported && _util.FeatureTest.isEvalSupported) {\n      const jsBuf = [];\n      for (const current of cmds) {\n        const args = current.args !== undefined ? current.args.join(\",\") : \"\";\n        jsBuf.push(\"c.\", current.cmd, \"(\", args, \");\\n\");\n      }\n      return this.compiledGlyphs[character] = new Function(\"c\", \"size\", jsBuf.join(\"\"));\n    }\n    return this.compiledGlyphs[character] = function (c, size) {\n      for (const current of cmds) {\n        if (current.cmd === \"scale\") {\n          current.args = [size, -size];\n        }\n        c[current.cmd].apply(c, current.args);\n      }\n    };\n  }\n}\nexports.FontFaceObject = FontFaceObject;\n\n/***/ }),\n/* 172 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.NodeStandardFontDataFactory = exports.NodeFilterFactory = exports.NodeCanvasFactory = exports.NodeCMapReaderFactory = void 0;\n__w_pdfjs_require__(2);\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\nvar _base_factory = __w_pdfjs_require__(169);\nvar _util = __w_pdfjs_require__(1);\n;\n{\n  (function checkDOMMatrix() {\n    if (globalThis.DOMMatrix || !_util.isNodeJS) {\n      return;\n    }\n    try {\n      globalThis.DOMMatrix = (__webpack_require__(/*! canvas */ \"?6755\").DOMMatrix);\n    } catch (ex) {\n      (0, _util.warn)(`Cannot polyfill \\`DOMMatrix\\`, rendering may be broken: \"${ex}\".`);\n    }\n  })();\n  (function checkPath2D() {\n    if (globalThis.Path2D || !_util.isNodeJS) {\n      return;\n    }\n    try {\n      const {\n        CanvasRenderingContext2D\n      } = __webpack_require__(/*! canvas */ \"?6755\");\n      const {\n        polyfillPath2D\n      } = __webpack_require__(/*! path2d-polyfill */ \"(ssr)/./node_modules/.pnpm/path2d-polyfill@2.0.1/node_modules/path2d-polyfill/dist/path2d-node.cjs\");\n      globalThis.CanvasRenderingContext2D = CanvasRenderingContext2D;\n      polyfillPath2D(globalThis);\n    } catch (ex) {\n      (0, _util.warn)(`Cannot polyfill \\`Path2D\\`, rendering may be broken: \"${ex}\".`);\n    }\n  })();\n}\nconst fetchData = function (url) {\n  return new Promise((resolve, reject) => {\n    const fs = __webpack_require__(/*! fs */ \"fs\");\n    fs.readFile(url, (error, data) => {\n      if (error || !data) {\n        reject(new Error(error));\n        return;\n      }\n      resolve(new Uint8Array(data));\n    });\n  });\n};\nclass NodeFilterFactory extends _base_factory.BaseFilterFactory {}\nexports.NodeFilterFactory = NodeFilterFactory;\nclass NodeCanvasFactory extends _base_factory.BaseCanvasFactory {\n  _createCanvas(width, height) {\n    const Canvas = __webpack_require__(/*! canvas */ \"?6755\");\n    return Canvas.createCanvas(width, height);\n  }\n}\nexports.NodeCanvasFactory = NodeCanvasFactory;\nclass NodeCMapReaderFactory extends _base_factory.BaseCMapReaderFactory {\n  _fetchData(url, compressionType) {\n    return fetchData(url).then(data => {\n      return {\n        cMapData: data,\n        compressionType\n      };\n    });\n  }\n}\nexports.NodeCMapReaderFactory = NodeCMapReaderFactory;\nclass NodeStandardFontDataFactory extends _base_factory.BaseStandardFontDataFactory {\n  _fetchData(url) {\n    return fetchData(url);\n  }\n}\nexports.NodeStandardFontDataFactory = NodeStandardFontDataFactory;\n\n/***/ }),\n/* 173 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.CanvasGraphics = void 0;\n__w_pdfjs_require__(2);\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\n__w_pdfjs_require__(89);\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(168);\nvar _pattern_helper = __w_pdfjs_require__(174);\nvar _image_utils = __w_pdfjs_require__(175);\nconst MIN_FONT_SIZE = 16;\nconst MAX_FONT_SIZE = 100;\nconst MAX_GROUP_SIZE = 4096;\nconst EXECUTION_TIME = 15;\nconst EXECUTION_STEPS = 10;\nconst MAX_SIZE_TO_COMPILE = 1000;\nconst FULL_CHUNK_HEIGHT = 16;\nfunction mirrorContextOperations(ctx, destCtx) {\n  if (ctx._removeMirroring) {\n    throw new Error(\"Context is already forwarding operations.\");\n  }\n  ctx.__originalSave = ctx.save;\n  ctx.__originalRestore = ctx.restore;\n  ctx.__originalRotate = ctx.rotate;\n  ctx.__originalScale = ctx.scale;\n  ctx.__originalTranslate = ctx.translate;\n  ctx.__originalTransform = ctx.transform;\n  ctx.__originalSetTransform = ctx.setTransform;\n  ctx.__originalResetTransform = ctx.resetTransform;\n  ctx.__originalClip = ctx.clip;\n  ctx.__originalMoveTo = ctx.moveTo;\n  ctx.__originalLineTo = ctx.lineTo;\n  ctx.__originalBezierCurveTo = ctx.bezierCurveTo;\n  ctx.__originalRect = ctx.rect;\n  ctx.__originalClosePath = ctx.closePath;\n  ctx.__originalBeginPath = ctx.beginPath;\n  ctx._removeMirroring = () => {\n    ctx.save = ctx.__originalSave;\n    ctx.restore = ctx.__originalRestore;\n    ctx.rotate = ctx.__originalRotate;\n    ctx.scale = ctx.__originalScale;\n    ctx.translate = ctx.__originalTranslate;\n    ctx.transform = ctx.__originalTransform;\n    ctx.setTransform = ctx.__originalSetTransform;\n    ctx.resetTransform = ctx.__originalResetTransform;\n    ctx.clip = ctx.__originalClip;\n    ctx.moveTo = ctx.__originalMoveTo;\n    ctx.lineTo = ctx.__originalLineTo;\n    ctx.bezierCurveTo = ctx.__originalBezierCurveTo;\n    ctx.rect = ctx.__originalRect;\n    ctx.closePath = ctx.__originalClosePath;\n    ctx.beginPath = ctx.__originalBeginPath;\n    delete ctx._removeMirroring;\n  };\n  ctx.save = function ctxSave() {\n    destCtx.save();\n    this.__originalSave();\n  };\n  ctx.restore = function ctxRestore() {\n    destCtx.restore();\n    this.__originalRestore();\n  };\n  ctx.translate = function ctxTranslate(x, y) {\n    destCtx.translate(x, y);\n    this.__originalTranslate(x, y);\n  };\n  ctx.scale = function ctxScale(x, y) {\n    destCtx.scale(x, y);\n    this.__originalScale(x, y);\n  };\n  ctx.transform = function ctxTransform(a, b, c, d, e, f) {\n    destCtx.transform(a, b, c, d, e, f);\n    this.__originalTransform(a, b, c, d, e, f);\n  };\n  ctx.setTransform = function ctxSetTransform(a, b, c, d, e, f) {\n    destCtx.setTransform(a, b, c, d, e, f);\n    this.__originalSetTransform(a, b, c, d, e, f);\n  };\n  ctx.resetTransform = function ctxResetTransform() {\n    destCtx.resetTransform();\n    this.__originalResetTransform();\n  };\n  ctx.rotate = function ctxRotate(angle) {\n    destCtx.rotate(angle);\n    this.__originalRotate(angle);\n  };\n  ctx.clip = function ctxRotate(rule) {\n    destCtx.clip(rule);\n    this.__originalClip(rule);\n  };\n  ctx.moveTo = function (x, y) {\n    destCtx.moveTo(x, y);\n    this.__originalMoveTo(x, y);\n  };\n  ctx.lineTo = function (x, y) {\n    destCtx.lineTo(x, y);\n    this.__originalLineTo(x, y);\n  };\n  ctx.bezierCurveTo = function (cp1x, cp1y, cp2x, cp2y, x, y) {\n    destCtx.bezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n    this.__originalBezierCurveTo(cp1x, cp1y, cp2x, cp2y, x, y);\n  };\n  ctx.rect = function (x, y, width, height) {\n    destCtx.rect(x, y, width, height);\n    this.__originalRect(x, y, width, height);\n  };\n  ctx.closePath = function () {\n    destCtx.closePath();\n    this.__originalClosePath();\n  };\n  ctx.beginPath = function () {\n    destCtx.beginPath();\n    this.__originalBeginPath();\n  };\n}\nclass CachedCanvases {\n  constructor(canvasFactory) {\n    this.canvasFactory = canvasFactory;\n    this.cache = Object.create(null);\n  }\n  getCanvas(id, width, height) {\n    let canvasEntry;\n    if (this.cache[id] !== undefined) {\n      canvasEntry = this.cache[id];\n      this.canvasFactory.reset(canvasEntry, width, height);\n    } else {\n      canvasEntry = this.canvasFactory.create(width, height);\n      this.cache[id] = canvasEntry;\n    }\n    return canvasEntry;\n  }\n  delete(id) {\n    delete this.cache[id];\n  }\n  clear() {\n    for (const id in this.cache) {\n      const canvasEntry = this.cache[id];\n      this.canvasFactory.destroy(canvasEntry);\n      delete this.cache[id];\n    }\n  }\n}\nfunction drawImageAtIntegerCoords(ctx, srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH) {\n  const [a, b, c, d, tx, ty] = (0, _display_utils.getCurrentTransform)(ctx);\n  if (b === 0 && c === 0) {\n    const tlX = destX * a + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destY * d + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destX + destW) * a + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destY + destH) * d + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(Math.sign(a), 0, 0, Math.sign(d), rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rWidth, rHeight);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rWidth, rHeight];\n  }\n  if (a === 0 && d === 0) {\n    const tlX = destY * c + tx;\n    const rTlX = Math.round(tlX);\n    const tlY = destX * b + ty;\n    const rTlY = Math.round(tlY);\n    const brX = (destY + destH) * c + tx;\n    const rWidth = Math.abs(Math.round(brX) - rTlX) || 1;\n    const brY = (destX + destW) * b + ty;\n    const rHeight = Math.abs(Math.round(brY) - rTlY) || 1;\n    ctx.setTransform(0, Math.sign(b), Math.sign(c), 0, rTlX, rTlY);\n    ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, 0, 0, rHeight, rWidth);\n    ctx.setTransform(a, b, c, d, tx, ty);\n    return [rHeight, rWidth];\n  }\n  ctx.drawImage(srcImg, srcX, srcY, srcW, srcH, destX, destY, destW, destH);\n  const scaleX = Math.hypot(a, b);\n  const scaleY = Math.hypot(c, d);\n  return [scaleX * destW, scaleY * destH];\n}\nfunction compileType3Glyph(imgData) {\n  const {\n    width,\n    height\n  } = imgData;\n  if (width > MAX_SIZE_TO_COMPILE || height > MAX_SIZE_TO_COMPILE) {\n    return null;\n  }\n  const POINT_TO_PROCESS_LIMIT = 1000;\n  const POINT_TYPES = new Uint8Array([0, 2, 4, 0, 1, 0, 5, 4, 8, 10, 0, 8, 0, 2, 1, 0]);\n  const width1 = width + 1;\n  let points = new Uint8Array(width1 * (height + 1));\n  let i, j, j0;\n  const lineSize = width + 7 & ~7;\n  let data = new Uint8Array(lineSize * height),\n    pos = 0;\n  for (const elem of imgData.data) {\n    let mask = 128;\n    while (mask > 0) {\n      data[pos++] = elem & mask ? 0 : 255;\n      mask >>= 1;\n    }\n  }\n  let count = 0;\n  pos = 0;\n  if (data[pos] !== 0) {\n    points[0] = 1;\n    ++count;\n  }\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j] = data[pos] ? 2 : 1;\n      ++count;\n    }\n    pos++;\n  }\n  if (data[pos] !== 0) {\n    points[j] = 2;\n    ++count;\n  }\n  for (i = 1; i < height; i++) {\n    pos = i * lineSize;\n    j0 = i * width1;\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0] = data[pos] ? 1 : 8;\n      ++count;\n    }\n    let sum = (data[pos] ? 4 : 0) + (data[pos - lineSize] ? 8 : 0);\n    for (j = 1; j < width; j++) {\n      sum = (sum >> 2) + (data[pos + 1] ? 4 : 0) + (data[pos - lineSize + 1] ? 8 : 0);\n      if (POINT_TYPES[sum]) {\n        points[j0 + j] = POINT_TYPES[sum];\n        ++count;\n      }\n      pos++;\n    }\n    if (data[pos - lineSize] !== data[pos]) {\n      points[j0 + j] = data[pos] ? 2 : 4;\n      ++count;\n    }\n    if (count > POINT_TO_PROCESS_LIMIT) {\n      return null;\n    }\n  }\n  pos = lineSize * (height - 1);\n  j0 = i * width1;\n  if (data[pos] !== 0) {\n    points[j0] = 8;\n    ++count;\n  }\n  for (j = 1; j < width; j++) {\n    if (data[pos] !== data[pos + 1]) {\n      points[j0 + j] = data[pos] ? 4 : 8;\n      ++count;\n    }\n    pos++;\n  }\n  if (data[pos] !== 0) {\n    points[j0 + j] = 4;\n    ++count;\n  }\n  if (count > POINT_TO_PROCESS_LIMIT) {\n    return null;\n  }\n  const steps = new Int32Array([0, width1, -1, 0, -width1, 0, 0, 0, 1]);\n  const path = new Path2D();\n  for (i = 0; count && i <= height; i++) {\n    let p = i * width1;\n    const end = p + width;\n    while (p < end && !points[p]) {\n      p++;\n    }\n    if (p === end) {\n      continue;\n    }\n    path.moveTo(p % width1, i);\n    const p0 = p;\n    let type = points[p];\n    do {\n      const step = steps[type];\n      do {\n        p += step;\n      } while (!points[p]);\n      const pp = points[p];\n      if (pp !== 5 && pp !== 10) {\n        type = pp;\n        points[p] = 0;\n      } else {\n        type = pp & 0x33 * type >> 4;\n        points[p] &= type >> 2 | type << 2;\n      }\n      path.lineTo(p % width1, p / width1 | 0);\n      if (!points[p]) {\n        --count;\n      }\n    } while (p0 !== p);\n    --i;\n  }\n  data = null;\n  points = null;\n  const drawOutline = function (c) {\n    c.save();\n    c.scale(1 / width, -1 / height);\n    c.translate(0, -height);\n    c.fill(path);\n    c.beginPath();\n    c.restore();\n  };\n  return drawOutline;\n}\nclass CanvasExtraState {\n  constructor(width, height) {\n    this.alphaIsShape = false;\n    this.fontSize = 0;\n    this.fontSizeScale = 1;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.textMatrixScale = 1;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textRise = 0;\n    this.fillColor = \"#000000\";\n    this.strokeColor = \"#000000\";\n    this.patternFill = false;\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.activeSMask = null;\n    this.transferMaps = \"none\";\n    this.startNewPathAndClipBox([0, 0, width, height]);\n  }\n  clone() {\n    const clone = Object.create(this);\n    clone.clipBox = this.clipBox.slice();\n    return clone;\n  }\n  setCurrentPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n  updatePathMinMax(transform, x, y) {\n    [x, y] = _util.Util.applyTransform([x, y], transform);\n    this.minX = Math.min(this.minX, x);\n    this.minY = Math.min(this.minY, y);\n    this.maxX = Math.max(this.maxX, x);\n    this.maxY = Math.max(this.maxY, y);\n  }\n  updateRectMinMax(transform, rect) {\n    const p1 = _util.Util.applyTransform(rect, transform);\n    const p2 = _util.Util.applyTransform(rect.slice(2), transform);\n    this.minX = Math.min(this.minX, p1[0], p2[0]);\n    this.minY = Math.min(this.minY, p1[1], p2[1]);\n    this.maxX = Math.max(this.maxX, p1[0], p2[0]);\n    this.maxY = Math.max(this.maxY, p1[1], p2[1]);\n  }\n  updateScalingPathMinMax(transform, minMax) {\n    _util.Util.scaleMinMax(transform, minMax);\n    this.minX = Math.min(this.minX, minMax[0]);\n    this.maxX = Math.max(this.maxX, minMax[1]);\n    this.minY = Math.min(this.minY, minMax[2]);\n    this.maxY = Math.max(this.maxY, minMax[3]);\n  }\n  updateCurvePathMinMax(transform, x0, y0, x1, y1, x2, y2, x3, y3, minMax) {\n    const box = _util.Util.bezierBoundingBox(x0, y0, x1, y1, x2, y2, x3, y3);\n    if (minMax) {\n      minMax[0] = Math.min(minMax[0], box[0], box[2]);\n      minMax[1] = Math.max(minMax[1], box[0], box[2]);\n      minMax[2] = Math.min(minMax[2], box[1], box[3]);\n      minMax[3] = Math.max(minMax[3], box[1], box[3]);\n      return;\n    }\n    this.updateRectMinMax(transform, box);\n  }\n  getPathBoundingBox() {\n    let pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;\n    let transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const box = [this.minX, this.minY, this.maxX, this.maxY];\n    if (pathType === _pattern_helper.PathType.STROKE) {\n      if (!transform) {\n        (0, _util.unreachable)(\"Stroke bounding box must include transform.\");\n      }\n      const scale = _util.Util.singularValueDecompose2dScale(transform);\n      const xStrokePad = scale[0] * this.lineWidth / 2;\n      const yStrokePad = scale[1] * this.lineWidth / 2;\n      box[0] -= xStrokePad;\n      box[1] -= yStrokePad;\n      box[2] += xStrokePad;\n      box[3] += yStrokePad;\n    }\n    return box;\n  }\n  updateClipFromPath() {\n    const intersect = _util.Util.intersect(this.clipBox, this.getPathBoundingBox());\n    this.startNewPathAndClipBox(intersect || [0, 0, 0, 0]);\n  }\n  isEmptyClip() {\n    return this.minX === Infinity;\n  }\n  startNewPathAndClipBox(box) {\n    this.clipBox = box;\n    this.minX = Infinity;\n    this.minY = Infinity;\n    this.maxX = 0;\n    this.maxY = 0;\n  }\n  getClippedPathBoundingBox() {\n    let pathType = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _pattern_helper.PathType.FILL;\n    let transform = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    return _util.Util.intersect(this.clipBox, this.getPathBoundingBox(pathType, transform));\n  }\n}\nfunction putBinaryImageData(ctx, imgData) {\n  if (typeof ImageData !== \"undefined\" && imgData instanceof ImageData) {\n    ctx.putImageData(imgData, 0, 0);\n    return;\n  }\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0,\n    destPos;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  let i, j, thisChunkHeight, elemsInThisChunk;\n  if (imgData.kind === _util.ImageKind.GRAYSCALE_1BPP) {\n    const srcLength = src.byteLength;\n    const dest32 = new Uint32Array(dest.buffer, 0, dest.byteLength >> 2);\n    const dest32DataLength = dest32.length;\n    const fullSrcDiff = width + 7 >> 3;\n    const white = 0xffffffff;\n    const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n    for (i = 0; i < totalChunks; i++) {\n      thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n      destPos = 0;\n      for (j = 0; j < thisChunkHeight; j++) {\n        const srcDiff = srcLength - srcPos;\n        let k = 0;\n        const kEnd = srcDiff > fullSrcDiff ? width : srcDiff * 8 - 7;\n        const kEndUnrolled = kEnd & ~7;\n        let mask = 0;\n        let srcByte = 0;\n        for (; k < kEndUnrolled; k += 8) {\n          srcByte = src[srcPos++];\n          dest32[destPos++] = srcByte & 128 ? white : black;\n          dest32[destPos++] = srcByte & 64 ? white : black;\n          dest32[destPos++] = srcByte & 32 ? white : black;\n          dest32[destPos++] = srcByte & 16 ? white : black;\n          dest32[destPos++] = srcByte & 8 ? white : black;\n          dest32[destPos++] = srcByte & 4 ? white : black;\n          dest32[destPos++] = srcByte & 2 ? white : black;\n          dest32[destPos++] = srcByte & 1 ? white : black;\n        }\n        for (; k < kEnd; k++) {\n          if (mask === 0) {\n            srcByte = src[srcPos++];\n            mask = 128;\n          }\n          dest32[destPos++] = srcByte & mask ? white : black;\n          mask >>= 1;\n        }\n      }\n      while (destPos < dest32DataLength) {\n        dest32[destPos++] = 0;\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGBA_32BPP) {\n    j = 0;\n    elemsInThisChunk = width * FULL_CHUNK_HEIGHT * 4;\n    for (i = 0; i < fullChunks; i++) {\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      srcPos += elemsInThisChunk;\n      ctx.putImageData(chunkImgData, 0, j);\n      j += FULL_CHUNK_HEIGHT;\n    }\n    if (i < totalChunks) {\n      elemsInThisChunk = width * partialChunkHeight * 4;\n      dest.set(src.subarray(srcPos, srcPos + elemsInThisChunk));\n      ctx.putImageData(chunkImgData, 0, j);\n    }\n  } else if (imgData.kind === _util.ImageKind.RGB_24BPP) {\n    thisChunkHeight = FULL_CHUNK_HEIGHT;\n    elemsInThisChunk = width * thisChunkHeight;\n    for (i = 0; i < totalChunks; i++) {\n      if (i >= fullChunks) {\n        thisChunkHeight = partialChunkHeight;\n        elemsInThisChunk = width * thisChunkHeight;\n      }\n      destPos = 0;\n      for (j = elemsInThisChunk; j--;) {\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = src[srcPos++];\n        dest[destPos++] = 255;\n      }\n      ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n    }\n  } else {\n    throw new Error(`bad image kind: ${imgData.kind}`);\n  }\n}\nfunction putBinaryImageMask(ctx, imgData) {\n  if (imgData.bitmap) {\n    ctx.drawImage(imgData.bitmap, 0, 0);\n    return;\n  }\n  const height = imgData.height,\n    width = imgData.width;\n  const partialChunkHeight = height % FULL_CHUNK_HEIGHT;\n  const fullChunks = (height - partialChunkHeight) / FULL_CHUNK_HEIGHT;\n  const totalChunks = partialChunkHeight === 0 ? fullChunks : fullChunks + 1;\n  const chunkImgData = ctx.createImageData(width, FULL_CHUNK_HEIGHT);\n  let srcPos = 0;\n  const src = imgData.data;\n  const dest = chunkImgData.data;\n  for (let i = 0; i < totalChunks; i++) {\n    const thisChunkHeight = i < fullChunks ? FULL_CHUNK_HEIGHT : partialChunkHeight;\n    ({\n      srcPos\n    } = (0, _image_utils.convertBlackAndWhiteToRGBA)({\n      src,\n      srcPos,\n      dest,\n      width,\n      height: thisChunkHeight,\n      nonBlackColor: 0\n    }));\n    ctx.putImageData(chunkImgData, 0, i * FULL_CHUNK_HEIGHT);\n  }\n}\nfunction copyCtxState(sourceCtx, destCtx) {\n  const properties = [\"strokeStyle\", \"fillStyle\", \"fillRule\", \"globalAlpha\", \"lineWidth\", \"lineCap\", \"lineJoin\", \"miterLimit\", \"globalCompositeOperation\", \"font\", \"filter\"];\n  for (const property of properties) {\n    if (sourceCtx[property] !== undefined) {\n      destCtx[property] = sourceCtx[property];\n    }\n  }\n  if (sourceCtx.setLineDash !== undefined) {\n    destCtx.setLineDash(sourceCtx.getLineDash());\n    destCtx.lineDashOffset = sourceCtx.lineDashOffset;\n  }\n}\nfunction resetCtxToDefault(ctx) {\n  ctx.strokeStyle = ctx.fillStyle = \"#000000\";\n  ctx.fillRule = \"nonzero\";\n  ctx.globalAlpha = 1;\n  ctx.lineWidth = 1;\n  ctx.lineCap = \"butt\";\n  ctx.lineJoin = \"miter\";\n  ctx.miterLimit = 10;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.font = \"10px sans-serif\";\n  if (ctx.setLineDash !== undefined) {\n    ctx.setLineDash([]);\n    ctx.lineDashOffset = 0;\n  }\n  if (!_util.isNodeJS) {\n    const {\n      filter\n    } = ctx;\n    if (filter !== \"none\" && filter !== \"\") {\n      ctx.filter = \"none\";\n    }\n  }\n}\nfunction composeSMaskBackdrop(bytes, r0, g0, b0) {\n  const length = bytes.length;\n  for (let i = 3; i < length; i += 4) {\n    const alpha = bytes[i];\n    if (alpha === 0) {\n      bytes[i - 3] = r0;\n      bytes[i - 2] = g0;\n      bytes[i - 1] = b0;\n    } else if (alpha < 255) {\n      const alpha_ = 255 - alpha;\n      bytes[i - 3] = bytes[i - 3] * alpha + r0 * alpha_ >> 8;\n      bytes[i - 2] = bytes[i - 2] * alpha + g0 * alpha_ >> 8;\n      bytes[i - 1] = bytes[i - 1] * alpha + b0 * alpha_ >> 8;\n    }\n  }\n}\nfunction composeSMaskAlpha(maskData, layerData, transferMap) {\n  const length = maskData.length;\n  const scale = 1 / 255;\n  for (let i = 3; i < length; i += 4) {\n    const alpha = transferMap ? transferMap[maskData[i]] : maskData[i];\n    layerData[i] = layerData[i] * alpha * scale | 0;\n  }\n}\nfunction composeSMaskLuminosity(maskData, layerData, transferMap) {\n  const length = maskData.length;\n  for (let i = 3; i < length; i += 4) {\n    const y = maskData[i - 3] * 77 + maskData[i - 2] * 152 + maskData[i - 1] * 28;\n    layerData[i] = transferMap ? layerData[i] * transferMap[y >> 8] >> 8 : layerData[i] * y >> 16;\n  }\n}\nfunction genericComposeSMask(maskCtx, layerCtx, width, height, subtype, backdrop, transferMap, layerOffsetX, layerOffsetY, maskOffsetX, maskOffsetY) {\n  const hasBackdrop = !!backdrop;\n  const r0 = hasBackdrop ? backdrop[0] : 0;\n  const g0 = hasBackdrop ? backdrop[1] : 0;\n  const b0 = hasBackdrop ? backdrop[2] : 0;\n  const composeFn = subtype === \"Luminosity\" ? composeSMaskLuminosity : composeSMaskAlpha;\n  const PIXELS_TO_PROCESS = 1048576;\n  const chunkSize = Math.min(height, Math.ceil(PIXELS_TO_PROCESS / width));\n  for (let row = 0; row < height; row += chunkSize) {\n    const chunkHeight = Math.min(chunkSize, height - row);\n    const maskData = maskCtx.getImageData(layerOffsetX - maskOffsetX, row + (layerOffsetY - maskOffsetY), width, chunkHeight);\n    const layerData = layerCtx.getImageData(layerOffsetX, row + layerOffsetY, width, chunkHeight);\n    if (hasBackdrop) {\n      composeSMaskBackdrop(maskData.data, r0, g0, b0);\n    }\n    composeFn(maskData.data, layerData.data, transferMap);\n    layerCtx.putImageData(layerData, layerOffsetX, row + layerOffsetY);\n  }\n}\nfunction composeSMask(ctx, smask, layerCtx, layerBox) {\n  const layerOffsetX = layerBox[0];\n  const layerOffsetY = layerBox[1];\n  const layerWidth = layerBox[2] - layerOffsetX;\n  const layerHeight = layerBox[3] - layerOffsetY;\n  if (layerWidth === 0 || layerHeight === 0) {\n    return;\n  }\n  genericComposeSMask(smask.context, layerCtx, layerWidth, layerHeight, smask.subtype, smask.backdrop, smask.transferMap, layerOffsetX, layerOffsetY, smask.offsetX, smask.offsetY);\n  ctx.save();\n  ctx.globalAlpha = 1;\n  ctx.globalCompositeOperation = \"source-over\";\n  ctx.setTransform(1, 0, 0, 1, 0, 0);\n  ctx.drawImage(layerCtx.canvas, 0, 0);\n  ctx.restore();\n}\nfunction getImageSmoothingEnabled(transform, interpolate) {\n  const scale = _util.Util.singularValueDecompose2dScale(transform);\n  scale[0] = Math.fround(scale[0]);\n  scale[1] = Math.fround(scale[1]);\n  const actualScale = Math.fround((globalThis.devicePixelRatio || 1) * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n  if (interpolate !== undefined) {\n    return interpolate;\n  } else if (scale[0] <= actualScale || scale[1] <= actualScale) {\n    return true;\n  }\n  return false;\n}\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst NORMAL_CLIP = {};\nconst EO_CLIP = {};\nclass CanvasGraphics {\n  constructor(canvasCtx, commonObjs, objs, canvasFactory, filterFactory, _ref, annotationCanvasMap, pageColors) {\n    let {\n      optionalContentConfig,\n      markedContentStack = null\n    } = _ref;\n    this.ctx = canvasCtx;\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.stateStack = [];\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.res = null;\n    this.xobjs = null;\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.canvasFactory = canvasFactory;\n    this.filterFactory = filterFactory;\n    this.groupStack = [];\n    this.processingType3 = null;\n    this.baseTransform = null;\n    this.baseTransformStack = [];\n    this.groupLevel = 0;\n    this.smaskStack = [];\n    this.smaskCounter = 0;\n    this.tempSMask = null;\n    this.suspendedCtx = null;\n    this.contentVisible = true;\n    this.markedContentStack = markedContentStack || [];\n    this.optionalContentConfig = optionalContentConfig;\n    this.cachedCanvases = new CachedCanvases(this.canvasFactory);\n    this.cachedPatterns = new Map();\n    this.annotationCanvasMap = annotationCanvasMap;\n    this.viewportScale = 1;\n    this.outputScaleX = 1;\n    this.outputScaleY = 1;\n    this.pageColors = pageColors;\n    this._cachedScaleForStroking = [-1, 0];\n    this._cachedGetSinglePixelWidth = null;\n    this._cachedBitmapsMap = new Map();\n  }\n  getObject(data) {\n    let fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (typeof data === \"string\") {\n      return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n    }\n    return fallback;\n  }\n  beginDrawing(_ref2) {\n    let {\n      transform,\n      viewport,\n      transparency = false,\n      background = null\n    } = _ref2;\n    const width = this.ctx.canvas.width;\n    const height = this.ctx.canvas.height;\n    const savedFillStyle = this.ctx.fillStyle;\n    this.ctx.fillStyle = background || \"#ffffff\";\n    this.ctx.fillRect(0, 0, width, height);\n    this.ctx.fillStyle = savedFillStyle;\n    if (transparency) {\n      const transparentCanvas = this.cachedCanvases.getCanvas(\"transparent\", width, height);\n      this.compositeCtx = this.ctx;\n      this.transparentCanvas = transparentCanvas.canvas;\n      this.ctx = transparentCanvas.context;\n      this.ctx.save();\n      this.ctx.transform(...(0, _display_utils.getCurrentTransform)(this.compositeCtx));\n    }\n    this.ctx.save();\n    resetCtxToDefault(this.ctx);\n    if (transform) {\n      this.ctx.transform(...transform);\n      this.outputScaleX = transform[0];\n      this.outputScaleY = transform[0];\n    }\n    this.ctx.transform(...viewport.transform);\n    this.viewportScale = viewport.scale;\n    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n  }\n  executeOperatorList(operatorList, executionStartIdx, continueCallback, stepper) {\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    let i = executionStartIdx || 0;\n    const argsArrayLen = argsArray.length;\n    if (argsArrayLen === i) {\n      return i;\n    }\n    const chunkOperations = argsArrayLen - i > EXECUTION_STEPS && typeof continueCallback === \"function\";\n    const endTime = chunkOperations ? Date.now() + EXECUTION_TIME : 0;\n    let steps = 0;\n    const commonObjs = this.commonObjs;\n    const objs = this.objs;\n    let fnId;\n    while (true) {\n      if (stepper !== undefined && i === stepper.nextBreakPoint) {\n        stepper.breakIt(i, continueCallback);\n        return i;\n      }\n      fnId = fnArray[i];\n      if (fnId !== _util.OPS.dependency) {\n        this[fnId].apply(this, argsArray[i]);\n      } else {\n        for (const depObjId of argsArray[i]) {\n          const objsPool = depObjId.startsWith(\"g_\") ? commonObjs : objs;\n          if (!objsPool.has(depObjId)) {\n            objsPool.get(depObjId, continueCallback);\n            return i;\n          }\n        }\n      }\n      i++;\n      if (i === argsArrayLen) {\n        return i;\n      }\n      if (chunkOperations && ++steps > EXECUTION_STEPS) {\n        if (Date.now() > endTime) {\n          continueCallback();\n          return i;\n        }\n        steps = 0;\n      }\n    }\n  }\n  #restoreInitialState() {\n    while (this.stateStack.length || this.inSMaskMode) {\n      this.restore();\n    }\n    this.ctx.restore();\n    if (this.transparentCanvas) {\n      this.ctx = this.compositeCtx;\n      this.ctx.save();\n      this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n      this.ctx.drawImage(this.transparentCanvas, 0, 0);\n      this.ctx.restore();\n      this.transparentCanvas = null;\n    }\n  }\n  endDrawing() {\n    this.#restoreInitialState();\n    this.cachedCanvases.clear();\n    this.cachedPatterns.clear();\n    for (const cache of this._cachedBitmapsMap.values()) {\n      for (const canvas of cache.values()) {\n        if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement) {\n          canvas.width = canvas.height = 0;\n        }\n      }\n      cache.clear();\n    }\n    this._cachedBitmapsMap.clear();\n    this.#drawFilter();\n  }\n  #drawFilter() {\n    if (this.pageColors) {\n      const hcmFilterId = this.filterFactory.addHCMFilter(this.pageColors.foreground, this.pageColors.background);\n      if (hcmFilterId !== \"none\") {\n        const savedFilter = this.ctx.filter;\n        this.ctx.filter = hcmFilterId;\n        this.ctx.drawImage(this.ctx.canvas, 0, 0);\n        this.ctx.filter = savedFilter;\n      }\n    }\n  }\n  _scaleImage(img, inverseTransform) {\n    const width = img.width;\n    const height = img.height;\n    let widthScale = Math.max(Math.hypot(inverseTransform[0], inverseTransform[1]), 1);\n    let heightScale = Math.max(Math.hypot(inverseTransform[2], inverseTransform[3]), 1);\n    let paintWidth = width,\n      paintHeight = height;\n    let tmpCanvasId = \"prescale1\";\n    let tmpCanvas, tmpCtx;\n    while (widthScale > 2 && paintWidth > 1 || heightScale > 2 && paintHeight > 1) {\n      let newWidth = paintWidth,\n        newHeight = paintHeight;\n      if (widthScale > 2 && paintWidth > 1) {\n        newWidth = paintWidth >= 16384 ? Math.floor(paintWidth / 2) - 1 || 1 : Math.ceil(paintWidth / 2);\n        widthScale /= paintWidth / newWidth;\n      }\n      if (heightScale > 2 && paintHeight > 1) {\n        newHeight = paintHeight >= 16384 ? Math.floor(paintHeight / 2) - 1 || 1 : Math.ceil(paintHeight) / 2;\n        heightScale /= paintHeight / newHeight;\n      }\n      tmpCanvas = this.cachedCanvases.getCanvas(tmpCanvasId, newWidth, newHeight);\n      tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, newWidth, newHeight);\n      tmpCtx.drawImage(img, 0, 0, paintWidth, paintHeight, 0, 0, newWidth, newHeight);\n      img = tmpCanvas.canvas;\n      paintWidth = newWidth;\n      paintHeight = newHeight;\n      tmpCanvasId = tmpCanvasId === \"prescale1\" ? \"prescale2\" : \"prescale1\";\n    }\n    return {\n      img,\n      paintWidth,\n      paintHeight\n    };\n  }\n  _createMaskCanvas(img) {\n    const ctx = this.ctx;\n    const {\n      width,\n      height\n    } = img;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    let cache, cacheKey, scaled, maskCanvas;\n    if ((img.bitmap || img.data) && img.count > 1) {\n      const mainKey = img.bitmap || img.data.buffer;\n      cacheKey = JSON.stringify(isPatternFill ? currentTransform : [currentTransform.slice(0, 4), fillColor]);\n      cache = this._cachedBitmapsMap.get(mainKey);\n      if (!cache) {\n        cache = new Map();\n        this._cachedBitmapsMap.set(mainKey, cache);\n      }\n      const cachedImage = cache.get(cacheKey);\n      if (cachedImage && !isPatternFill) {\n        const offsetX = Math.round(Math.min(currentTransform[0], currentTransform[2]) + currentTransform[4]);\n        const offsetY = Math.round(Math.min(currentTransform[1], currentTransform[3]) + currentTransform[5]);\n        return {\n          canvas: cachedImage,\n          offsetX,\n          offsetY\n        };\n      }\n      scaled = cachedImage;\n    }\n    if (!scaled) {\n      maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      putBinaryImageMask(maskCanvas.context, img);\n    }\n    let maskToCanvas = _util.Util.transform(currentTransform, [1 / width, 0, 0, -1 / height, 0, 0]);\n    maskToCanvas = _util.Util.transform(maskToCanvas, [1, 0, 0, 1, 0, -height]);\n    const cord1 = _util.Util.applyTransform([0, 0], maskToCanvas);\n    const cord2 = _util.Util.applyTransform([width, height], maskToCanvas);\n    const rect = _util.Util.normalizeRect([cord1[0], cord1[1], cord2[0], cord2[1]]);\n    const drawnWidth = Math.round(rect[2] - rect[0]) || 1;\n    const drawnHeight = Math.round(rect[3] - rect[1]) || 1;\n    const fillCanvas = this.cachedCanvases.getCanvas(\"fillCanvas\", drawnWidth, drawnHeight);\n    const fillCtx = fillCanvas.context;\n    const offsetX = Math.min(cord1[0], cord2[0]);\n    const offsetY = Math.min(cord1[1], cord2[1]);\n    fillCtx.translate(-offsetX, -offsetY);\n    fillCtx.transform(...maskToCanvas);\n    if (!scaled) {\n      scaled = this._scaleImage(maskCanvas.canvas, (0, _display_utils.getCurrentTransformInverse)(fillCtx));\n      scaled = scaled.img;\n      if (cache && isPatternFill) {\n        cache.set(cacheKey, scaled);\n      }\n    }\n    fillCtx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(fillCtx), img.interpolate);\n    drawImageAtIntegerCoords(fillCtx, scaled, 0, 0, scaled.width, scaled.height, 0, 0, width, height);\n    fillCtx.globalCompositeOperation = \"source-in\";\n    const inverse = _util.Util.transform((0, _display_utils.getCurrentTransformInverse)(fillCtx), [1, 0, 0, 1, -offsetX, -offsetY]);\n    fillCtx.fillStyle = isPatternFill ? fillColor.getPattern(ctx, this, inverse, _pattern_helper.PathType.FILL) : fillColor;\n    fillCtx.fillRect(0, 0, width, height);\n    if (cache && !isPatternFill) {\n      this.cachedCanvases.delete(\"fillCanvas\");\n      cache.set(cacheKey, fillCanvas.canvas);\n    }\n    return {\n      canvas: fillCanvas.canvas,\n      offsetX: Math.round(offsetX),\n      offsetY: Math.round(offsetY)\n    };\n  }\n  setLineWidth(width) {\n    if (width !== this.current.lineWidth) {\n      this._cachedScaleForStroking[0] = -1;\n    }\n    this.current.lineWidth = width;\n    this.ctx.lineWidth = width;\n  }\n  setLineCap(style) {\n    this.ctx.lineCap = LINE_CAP_STYLES[style];\n  }\n  setLineJoin(style) {\n    this.ctx.lineJoin = LINE_JOIN_STYLES[style];\n  }\n  setMiterLimit(limit) {\n    this.ctx.miterLimit = limit;\n  }\n  setDash(dashArray, dashPhase) {\n    const ctx = this.ctx;\n    if (ctx.setLineDash !== undefined) {\n      ctx.setLineDash(dashArray);\n      ctx.lineDashOffset = dashPhase;\n    }\n  }\n  setRenderingIntent(intent) {}\n  setFlatness(flatness) {}\n  setGState(states) {\n    for (const [key, value] of states) {\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(value);\n          break;\n        case \"LC\":\n          this.setLineCap(value);\n          break;\n        case \"LJ\":\n          this.setLineJoin(value);\n          break;\n        case \"ML\":\n          this.setMiterLimit(value);\n          break;\n        case \"D\":\n          this.setDash(value[0], value[1]);\n          break;\n        case \"RI\":\n          this.setRenderingIntent(value);\n          break;\n        case \"FL\":\n          this.setFlatness(value);\n          break;\n        case \"Font\":\n          this.setFont(value[0], value[1]);\n          break;\n        case \"CA\":\n          this.current.strokeAlpha = value;\n          break;\n        case \"ca\":\n          this.current.fillAlpha = value;\n          this.ctx.globalAlpha = value;\n          break;\n        case \"BM\":\n          this.ctx.globalCompositeOperation = value;\n          break;\n        case \"SMask\":\n          this.current.activeSMask = value ? this.tempSMask : null;\n          this.tempSMask = null;\n          this.checkSMaskState();\n          break;\n        case \"TR\":\n          this.ctx.filter = this.current.transferMaps = this.filterFactory.addFilter(value);\n          break;\n      }\n    }\n  }\n  get inSMaskMode() {\n    return !!this.suspendedCtx;\n  }\n  checkSMaskState() {\n    const inSMaskMode = this.inSMaskMode;\n    if (this.current.activeSMask && !inSMaskMode) {\n      this.beginSMaskMode();\n    } else if (!this.current.activeSMask && inSMaskMode) {\n      this.endSMaskMode();\n    }\n  }\n  beginSMaskMode() {\n    if (this.inSMaskMode) {\n      throw new Error(\"beginSMaskMode called while already in smask mode\");\n    }\n    const drawnWidth = this.ctx.canvas.width;\n    const drawnHeight = this.ctx.canvas.height;\n    const cacheId = \"smaskGroupAt\" + this.groupLevel;\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    this.suspendedCtx = this.ctx;\n    this.ctx = scratchCanvas.context;\n    const ctx = this.ctx;\n    ctx.setTransform(...(0, _display_utils.getCurrentTransform)(this.suspendedCtx));\n    copyCtxState(this.suspendedCtx, ctx);\n    mirrorContextOperations(ctx, this.suspendedCtx);\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n  }\n  endSMaskMode() {\n    if (!this.inSMaskMode) {\n      throw new Error(\"endSMaskMode called while not in smask mode\");\n    }\n    this.ctx._removeMirroring();\n    copyCtxState(this.ctx, this.suspendedCtx);\n    this.ctx = this.suspendedCtx;\n    this.suspendedCtx = null;\n  }\n  compose(dirtyBox) {\n    if (!this.current.activeSMask) {\n      return;\n    }\n    if (!dirtyBox) {\n      dirtyBox = [0, 0, this.ctx.canvas.width, this.ctx.canvas.height];\n    } else {\n      dirtyBox[0] = Math.floor(dirtyBox[0]);\n      dirtyBox[1] = Math.floor(dirtyBox[1]);\n      dirtyBox[2] = Math.ceil(dirtyBox[2]);\n      dirtyBox[3] = Math.ceil(dirtyBox[3]);\n    }\n    const smask = this.current.activeSMask;\n    const suspendedCtx = this.suspendedCtx;\n    composeSMask(suspendedCtx, smask, this.ctx, dirtyBox);\n    this.ctx.save();\n    this.ctx.setTransform(1, 0, 0, 1, 0, 0);\n    this.ctx.clearRect(0, 0, this.ctx.canvas.width, this.ctx.canvas.height);\n    this.ctx.restore();\n  }\n  save() {\n    if (this.inSMaskMode) {\n      copyCtxState(this.ctx, this.suspendedCtx);\n      this.suspendedCtx.save();\n    } else {\n      this.ctx.save();\n    }\n    const old = this.current;\n    this.stateStack.push(old);\n    this.current = old.clone();\n  }\n  restore() {\n    if (this.stateStack.length === 0 && this.inSMaskMode) {\n      this.endSMaskMode();\n    }\n    if (this.stateStack.length !== 0) {\n      this.current = this.stateStack.pop();\n      if (this.inSMaskMode) {\n        this.suspendedCtx.restore();\n        copyCtxState(this.suspendedCtx, this.ctx);\n      } else {\n        this.ctx.restore();\n      }\n      this.checkSMaskState();\n      this.pendingClip = null;\n      this._cachedScaleForStroking[0] = -1;\n      this._cachedGetSinglePixelWidth = null;\n    }\n  }\n  transform(a, b, c, d, e, f) {\n    this.ctx.transform(a, b, c, d, e, f);\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n  }\n  constructPath(ops, args, minMax) {\n    const ctx = this.ctx;\n    const current = this.current;\n    let x = current.x,\n      y = current.y;\n    let startX, startY;\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    const isScalingMatrix = currentTransform[0] === 0 && currentTransform[3] === 0 || currentTransform[1] === 0 && currentTransform[2] === 0;\n    const minMaxForBezier = isScalingMatrix ? minMax.slice(0) : null;\n    for (let i = 0, j = 0, ii = ops.length; i < ii; i++) {\n      switch (ops[i] | 0) {\n        case _util.OPS.rectangle:\n          x = args[j++];\n          y = args[j++];\n          const width = args[j++];\n          const height = args[j++];\n          const xw = x + width;\n          const yh = y + height;\n          ctx.moveTo(x, y);\n          if (width === 0 || height === 0) {\n            ctx.lineTo(xw, yh);\n          } else {\n            ctx.lineTo(xw, y);\n            ctx.lineTo(xw, yh);\n            ctx.lineTo(x, yh);\n          }\n          if (!isScalingMatrix) {\n            current.updateRectMinMax(currentTransform, [x, y, xw, yh]);\n          }\n          ctx.closePath();\n          break;\n        case _util.OPS.moveTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.moveTo(x, y);\n          if (!isScalingMatrix) {\n            current.updatePathMinMax(currentTransform, x, y);\n          }\n          break;\n        case _util.OPS.lineTo:\n          x = args[j++];\n          y = args[j++];\n          ctx.lineTo(x, y);\n          if (!isScalingMatrix) {\n            current.updatePathMinMax(currentTransform, x, y);\n          }\n          break;\n        case _util.OPS.curveTo:\n          startX = x;\n          startY = y;\n          x = args[j + 4];\n          y = args[j + 5];\n          ctx.bezierCurveTo(args[j], args[j + 1], args[j + 2], args[j + 3], x, y);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], args[j + 2], args[j + 3], x, y, minMaxForBezier);\n          j += 6;\n          break;\n        case _util.OPS.curveTo2:\n          startX = x;\n          startY = y;\n          ctx.bezierCurveTo(x, y, args[j], args[j + 1], args[j + 2], args[j + 3]);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, x, y, args[j], args[j + 1], args[j + 2], args[j + 3], minMaxForBezier);\n          x = args[j + 2];\n          y = args[j + 3];\n          j += 4;\n          break;\n        case _util.OPS.curveTo3:\n          startX = x;\n          startY = y;\n          x = args[j + 2];\n          y = args[j + 3];\n          ctx.bezierCurveTo(args[j], args[j + 1], x, y, x, y);\n          current.updateCurvePathMinMax(currentTransform, startX, startY, args[j], args[j + 1], x, y, x, y, minMaxForBezier);\n          j += 4;\n          break;\n        case _util.OPS.closePath:\n          ctx.closePath();\n          break;\n      }\n    }\n    if (isScalingMatrix) {\n      current.updateScalingPathMinMax(currentTransform, minMaxForBezier);\n    }\n    current.setCurrentPoint(x, y);\n  }\n  closePath() {\n    this.ctx.closePath();\n  }\n  stroke() {\n    let consumePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const ctx = this.ctx;\n    const strokeColor = this.current.strokeColor;\n    ctx.globalAlpha = this.current.strokeAlpha;\n    if (this.contentVisible) {\n      if (typeof strokeColor === \"object\" && strokeColor?.getPattern) {\n        ctx.save();\n        ctx.strokeStyle = strokeColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.STROKE);\n        this.rescaleAndStroke(false);\n        ctx.restore();\n      } else {\n        this.rescaleAndStroke(true);\n      }\n    }\n    if (consumePath) {\n      this.consumePath(this.current.getClippedPathBoundingBox());\n    }\n    ctx.globalAlpha = this.current.fillAlpha;\n  }\n  closeStroke() {\n    this.closePath();\n    this.stroke();\n  }\n  fill() {\n    let consumePath = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    let needRestore = false;\n    if (isPatternFill) {\n      ctx.save();\n      ctx.fillStyle = fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n      needRestore = true;\n    }\n    const intersect = this.current.getClippedPathBoundingBox();\n    if (this.contentVisible && intersect !== null) {\n      if (this.pendingEOFill) {\n        ctx.fill(\"evenodd\");\n        this.pendingEOFill = false;\n      } else {\n        ctx.fill();\n      }\n    }\n    if (needRestore) {\n      ctx.restore();\n    }\n    if (consumePath) {\n      this.consumePath(intersect);\n    }\n  }\n  eoFill() {\n    this.pendingEOFill = true;\n    this.fill();\n  }\n  fillStroke() {\n    this.fill(false);\n    this.stroke(false);\n    this.consumePath();\n  }\n  eoFillStroke() {\n    this.pendingEOFill = true;\n    this.fillStroke();\n  }\n  closeFillStroke() {\n    this.closePath();\n    this.fillStroke();\n  }\n  closeEOFillStroke() {\n    this.pendingEOFill = true;\n    this.closePath();\n    this.fillStroke();\n  }\n  endPath() {\n    this.consumePath();\n  }\n  clip() {\n    this.pendingClip = NORMAL_CLIP;\n  }\n  eoClip() {\n    this.pendingClip = EO_CLIP;\n  }\n  beginText() {\n    this.current.textMatrix = _util.IDENTITY_MATRIX;\n    this.current.textMatrixScale = 1;\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n  endText() {\n    const paths = this.pendingTextPaths;\n    const ctx = this.ctx;\n    if (paths === undefined) {\n      ctx.beginPath();\n      return;\n    }\n    ctx.save();\n    ctx.beginPath();\n    for (const path of paths) {\n      ctx.setTransform(...path.transform);\n      ctx.translate(path.x, path.y);\n      path.addToPath(ctx, path.fontSize);\n    }\n    ctx.restore();\n    ctx.clip();\n    ctx.beginPath();\n    delete this.pendingTextPaths;\n  }\n  setCharSpacing(spacing) {\n    this.current.charSpacing = spacing;\n  }\n  setWordSpacing(spacing) {\n    this.current.wordSpacing = spacing;\n  }\n  setHScale(scale) {\n    this.current.textHScale = scale / 100;\n  }\n  setLeading(leading) {\n    this.current.leading = -leading;\n  }\n  setFont(fontRefName, size) {\n    const fontObj = this.commonObjs.get(fontRefName);\n    const current = this.current;\n    if (!fontObj) {\n      throw new Error(`Can't find font for ${fontRefName}`);\n    }\n    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n    if (current.fontMatrix[0] === 0 || current.fontMatrix[3] === 0) {\n      (0, _util.warn)(\"Invalid font matrix for font \" + fontRefName);\n    }\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n    this.current.font = fontObj;\n    this.current.fontSize = size;\n    if (fontObj.isType3Font) {\n      return;\n    }\n    const name = fontObj.loadedName || \"sans-serif\";\n    const typeface = fontObj.systemFontInfo?.css || `\"${name}\", ${fontObj.fallbackName}`;\n    let bold = \"normal\";\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    let browserFontSize = size;\n    if (size < MIN_FONT_SIZE) {\n      browserFontSize = MIN_FONT_SIZE;\n    } else if (size > MAX_FONT_SIZE) {\n      browserFontSize = MAX_FONT_SIZE;\n    }\n    this.current.fontSizeScale = size / browserFontSize;\n    this.ctx.font = `${italic} ${bold} ${browserFontSize}px ${typeface}`;\n  }\n  setTextRenderingMode(mode) {\n    this.current.textRenderingMode = mode;\n  }\n  setTextRise(rise) {\n    this.current.textRise = rise;\n  }\n  moveText(x, y) {\n    this.current.x = this.current.lineX += x;\n    this.current.y = this.current.lineY += y;\n  }\n  setLeadingMoveText(x, y) {\n    this.setLeading(-y);\n    this.moveText(x, y);\n  }\n  setTextMatrix(a, b, c, d, e, f) {\n    this.current.textMatrix = [a, b, c, d, e, f];\n    this.current.textMatrixScale = Math.hypot(a, b);\n    this.current.x = this.current.lineX = 0;\n    this.current.y = this.current.lineY = 0;\n  }\n  nextLine() {\n    this.moveText(0, this.current.leading);\n  }\n  paintChar(character, x, y, patternTransform) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const textRenderingMode = current.textRenderingMode;\n    const fontSize = current.fontSize / current.fontSizeScale;\n    const fillStrokeMode = textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n    const isAddToPathSet = !!(textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG);\n    const patternFill = current.patternFill && !font.missingFile;\n    let addToPath;\n    if (font.disableFontFace || isAddToPathSet || patternFill) {\n      addToPath = font.getPathGenerator(this.commonObjs, character);\n    }\n    if (font.disableFontFace || patternFill) {\n      ctx.save();\n      ctx.translate(x, y);\n      ctx.beginPath();\n      addToPath(ctx, fontSize);\n      if (patternTransform) {\n        ctx.setTransform(...patternTransform);\n      }\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fill();\n      }\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.stroke();\n      }\n      ctx.restore();\n    } else {\n      if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.fillText(character, x, y);\n      }\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        ctx.strokeText(character, x, y);\n      }\n    }\n    if (isAddToPathSet) {\n      const paths = this.pendingTextPaths ||= [];\n      paths.push({\n        transform: (0, _display_utils.getCurrentTransform)(ctx),\n        x,\n        y,\n        fontSize,\n        addToPath\n      });\n    }\n  }\n  get isFontSubpixelAAEnabled() {\n    const {\n      context: ctx\n    } = this.cachedCanvases.getCanvas(\"isFontSubpixelAAEnabled\", 10, 10);\n    ctx.scale(1.5, 1);\n    ctx.fillText(\"I\", 0, 10);\n    const data = ctx.getImageData(0, 0, 10, 10).data;\n    let enabled = false;\n    for (let i = 3; i < data.length; i += 4) {\n      if (data[i] > 0 && data[i] < 255) {\n        enabled = true;\n        break;\n      }\n    }\n    return (0, _util.shadow)(this, \"isFontSubpixelAAEnabled\", enabled);\n  }\n  showText(glyphs) {\n    const current = this.current;\n    const font = current.font;\n    if (font.isType3Font) {\n      return this.showType3Text(glyphs);\n    }\n    const fontSize = current.fontSize;\n    if (fontSize === 0) {\n      return undefined;\n    }\n    const ctx = this.ctx;\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const glyphsLength = glyphs.length;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    const simpleFillText = current.textRenderingMode === _util.TextRenderingMode.FILL && !font.disableFontFace && !current.patternFill;\n    ctx.save();\n    ctx.transform(...current.textMatrix);\n    ctx.translate(current.x, current.y + current.textRise);\n    if (fontDirection > 0) {\n      ctx.scale(textHScale, -1);\n    } else {\n      ctx.scale(textHScale, 1);\n    }\n    let patternTransform;\n    if (current.patternFill) {\n      ctx.save();\n      const pattern = current.fillColor.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL);\n      patternTransform = (0, _display_utils.getCurrentTransform)(ctx);\n      ctx.restore();\n      ctx.fillStyle = pattern;\n    }\n    let lineWidth = current.lineWidth;\n    const scale = current.textMatrixScale;\n    if (scale === 0 || lineWidth === 0) {\n      const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n      if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n        lineWidth = this.getSinglePixelWidth();\n      }\n    } else {\n      lineWidth /= scale;\n    }\n    if (fontSizeScale !== 1.0) {\n      ctx.scale(fontSizeScale, fontSizeScale);\n      lineWidth /= fontSizeScale;\n    }\n    ctx.lineWidth = lineWidth;\n    if (font.isInvalidPDFjsFont) {\n      const chars = [];\n      let width = 0;\n      for (const glyph of glyphs) {\n        chars.push(glyph.unicode);\n        width += glyph.width;\n      }\n      ctx.fillText(chars.join(\"\"), 0, 0);\n      current.x += width * widthAdvanceScale * textHScale;\n      ctx.restore();\n      this.compose();\n      return undefined;\n    }\n    let x = 0,\n      i;\n    for (i = 0; i < glyphsLength; ++i) {\n      const glyph = glyphs[i];\n      if (typeof glyph === \"number\") {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n      let restoreNeeded = false;\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      const accent = glyph.accent;\n      let scaledX, scaledY;\n      let width = glyph.width;\n      if (vertical) {\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        const vx = -(glyph.vmetric ? vmetric[1] : width * 0.5) * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n      if (font.remeasure && width > 0) {\n        const measuredWidth = ctx.measureText(character).width * 1000 / fontSize * fontSizeScale;\n        if (width < measuredWidth && this.isFontSubpixelAAEnabled) {\n          const characterScaleX = width / measuredWidth;\n          restoreNeeded = true;\n          ctx.save();\n          ctx.scale(characterScaleX, 1);\n          scaledX /= characterScaleX;\n        } else if (width !== measuredWidth) {\n          scaledX += (width - measuredWidth) / 2000 * fontSize / fontSizeScale;\n        }\n      }\n      if (this.contentVisible && (glyph.isInFont || font.missingFile)) {\n        if (simpleFillText && !accent) {\n          ctx.fillText(character, scaledX, scaledY);\n        } else {\n          this.paintChar(character, scaledX, scaledY, patternTransform);\n          if (accent) {\n            const scaledAccentX = scaledX + fontSize * accent.offset.x / fontSizeScale;\n            const scaledAccentY = scaledY - fontSize * accent.offset.y / fontSizeScale;\n            this.paintChar(accent.fontChar, scaledAccentX, scaledAccentY, patternTransform);\n          }\n        }\n      }\n      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n      x += charWidth;\n      if (restoreNeeded) {\n        ctx.restore();\n      }\n    }\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n    ctx.restore();\n    this.compose();\n    return undefined;\n  }\n  showType3Text(glyphs) {\n    const ctx = this.ctx;\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    const fontDirection = current.fontDirection;\n    const spacingDir = font.vertical ? 1 : -1;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const textHScale = current.textHScale * fontDirection;\n    const fontMatrix = current.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n    const glyphsLength = glyphs.length;\n    const isTextInvisible = current.textRenderingMode === _util.TextRenderingMode.INVISIBLE;\n    let i, glyph, width, spacingLength;\n    if (isTextInvisible || fontSize === 0) {\n      return;\n    }\n    this._cachedScaleForStroking[0] = -1;\n    this._cachedGetSinglePixelWidth = null;\n    ctx.save();\n    ctx.transform(...current.textMatrix);\n    ctx.translate(current.x, current.y);\n    ctx.scale(textHScale, fontDirection);\n    for (i = 0; i < glyphsLength; ++i) {\n      glyph = glyphs[i];\n      if (typeof glyph === \"number\") {\n        spacingLength = spacingDir * glyph * fontSize / 1000;\n        this.ctx.translate(spacingLength, 0);\n        current.x += spacingLength * textHScale;\n        continue;\n      }\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const operatorList = font.charProcOperatorList[glyph.operatorListId];\n      if (!operatorList) {\n        (0, _util.warn)(`Type3 character \"${glyph.operatorListId}\" is not available.`);\n        continue;\n      }\n      if (this.contentVisible) {\n        this.processingType3 = glyph;\n        this.save();\n        ctx.scale(fontSize, fontSize);\n        ctx.transform(...fontMatrix);\n        this.executeOperatorList(operatorList);\n        this.restore();\n      }\n      const transformed = _util.Util.applyTransform([glyph.width, 0], fontMatrix);\n      width = transformed[0] * fontSize + spacing;\n      ctx.translate(width, 0);\n      current.x += width * textHScale;\n    }\n    ctx.restore();\n    this.processingType3 = null;\n  }\n  setCharWidth(xWidth, yWidth) {}\n  setCharWidthAndBounds(xWidth, yWidth, llx, lly, urx, ury) {\n    this.ctx.rect(llx, lly, urx - llx, ury - lly);\n    this.ctx.clip();\n    this.endPath();\n  }\n  getColorN_Pattern(IR) {\n    let pattern;\n    if (IR[0] === \"TilingPattern\") {\n      const color = IR[1];\n      const baseTransform = this.baseTransform || (0, _display_utils.getCurrentTransform)(this.ctx);\n      const canvasGraphicsFactory = {\n        createCanvasGraphics: ctx => {\n          return new CanvasGraphics(ctx, this.commonObjs, this.objs, this.canvasFactory, this.filterFactory, {\n            optionalContentConfig: this.optionalContentConfig,\n            markedContentStack: this.markedContentStack\n          });\n        }\n      };\n      pattern = new _pattern_helper.TilingPattern(IR, color, this.ctx, canvasGraphicsFactory, baseTransform);\n    } else {\n      pattern = this._getPattern(IR[1], IR[2]);\n    }\n    return pattern;\n  }\n  setStrokeColorN() {\n    this.current.strokeColor = this.getColorN_Pattern(arguments);\n  }\n  setFillColorN() {\n    this.current.fillColor = this.getColorN_Pattern(arguments);\n    this.current.patternFill = true;\n  }\n  setStrokeRGBColor(r, g, b) {\n    const color = _util.Util.makeHexColor(r, g, b);\n    this.ctx.strokeStyle = color;\n    this.current.strokeColor = color;\n  }\n  setFillRGBColor(r, g, b) {\n    const color = _util.Util.makeHexColor(r, g, b);\n    this.ctx.fillStyle = color;\n    this.current.fillColor = color;\n    this.current.patternFill = false;\n  }\n  _getPattern(objId) {\n    let matrix = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let pattern;\n    if (this.cachedPatterns.has(objId)) {\n      pattern = this.cachedPatterns.get(objId);\n    } else {\n      pattern = (0, _pattern_helper.getShadingPattern)(this.getObject(objId));\n      this.cachedPatterns.set(objId, pattern);\n    }\n    if (matrix) {\n      pattern.matrix = matrix;\n    }\n    return pattern;\n  }\n  shadingFill(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    this.save();\n    const pattern = this._getPattern(objId);\n    ctx.fillStyle = pattern.getPattern(ctx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.SHADING);\n    const inv = (0, _display_utils.getCurrentTransformInverse)(ctx);\n    if (inv) {\n      const {\n        width,\n        height\n      } = ctx.canvas;\n      const [x0, y0, x1, y1] = _util.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);\n      this.ctx.fillRect(x0, y0, x1 - x0, y1 - y0);\n    } else {\n      this.ctx.fillRect(-1e10, -1e10, 2e10, 2e10);\n    }\n    this.compose(this.current.getClippedPathBoundingBox());\n    this.restore();\n  }\n  beginInlineImage() {\n    (0, _util.unreachable)(\"Should not call beginInlineImage\");\n  }\n  beginImageData() {\n    (0, _util.unreachable)(\"Should not call beginImageData\");\n  }\n  paintFormXObjectBegin(matrix, bbox) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save();\n    this.baseTransformStack.push(this.baseTransform);\n    if (Array.isArray(matrix) && matrix.length === 6) {\n      this.transform(...matrix);\n    }\n    this.baseTransform = (0, _display_utils.getCurrentTransform)(this.ctx);\n    if (bbox) {\n      const width = bbox[2] - bbox[0];\n      const height = bbox[3] - bbox[1];\n      this.ctx.rect(bbox[0], bbox[1], width, height);\n      this.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(this.ctx), bbox);\n      this.clip();\n      this.endPath();\n    }\n  }\n  paintFormXObjectEnd() {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.restore();\n    this.baseTransform = this.baseTransformStack.pop();\n  }\n  beginGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.save();\n    if (this.inSMaskMode) {\n      this.endSMaskMode();\n      this.current.activeSMask = null;\n    }\n    const currentCtx = this.ctx;\n    if (!group.isolated) {\n      (0, _util.info)(\"TODO: Support non-isolated groups.\");\n    }\n    if (group.knockout) {\n      (0, _util.warn)(\"Knockout groups not supported.\");\n    }\n    const currentTransform = (0, _display_utils.getCurrentTransform)(currentCtx);\n    if (group.matrix) {\n      currentCtx.transform(...group.matrix);\n    }\n    if (!group.bbox) {\n      throw new Error(\"Bounding box is required.\");\n    }\n    let bounds = _util.Util.getAxialAlignedBoundingBox(group.bbox, (0, _display_utils.getCurrentTransform)(currentCtx));\n    const canvasBounds = [0, 0, currentCtx.canvas.width, currentCtx.canvas.height];\n    bounds = _util.Util.intersect(bounds, canvasBounds) || [0, 0, 0, 0];\n    const offsetX = Math.floor(bounds[0]);\n    const offsetY = Math.floor(bounds[1]);\n    let drawnWidth = Math.max(Math.ceil(bounds[2]) - offsetX, 1);\n    let drawnHeight = Math.max(Math.ceil(bounds[3]) - offsetY, 1);\n    let scaleX = 1,\n      scaleY = 1;\n    if (drawnWidth > MAX_GROUP_SIZE) {\n      scaleX = drawnWidth / MAX_GROUP_SIZE;\n      drawnWidth = MAX_GROUP_SIZE;\n    }\n    if (drawnHeight > MAX_GROUP_SIZE) {\n      scaleY = drawnHeight / MAX_GROUP_SIZE;\n      drawnHeight = MAX_GROUP_SIZE;\n    }\n    this.current.startNewPathAndClipBox([0, 0, drawnWidth, drawnHeight]);\n    let cacheId = \"groupAt\" + this.groupLevel;\n    if (group.smask) {\n      cacheId += \"_smask_\" + this.smaskCounter++ % 2;\n    }\n    const scratchCanvas = this.cachedCanvases.getCanvas(cacheId, drawnWidth, drawnHeight);\n    const groupCtx = scratchCanvas.context;\n    groupCtx.scale(1 / scaleX, 1 / scaleY);\n    groupCtx.translate(-offsetX, -offsetY);\n    groupCtx.transform(...currentTransform);\n    if (group.smask) {\n      this.smaskStack.push({\n        canvas: scratchCanvas.canvas,\n        context: groupCtx,\n        offsetX,\n        offsetY,\n        scaleX,\n        scaleY,\n        subtype: group.smask.subtype,\n        backdrop: group.smask.backdrop,\n        transferMap: group.smask.transferMap || null,\n        startTransformInverse: null\n      });\n    } else {\n      currentCtx.setTransform(1, 0, 0, 1, 0, 0);\n      currentCtx.translate(offsetX, offsetY);\n      currentCtx.scale(scaleX, scaleY);\n      currentCtx.save();\n    }\n    copyCtxState(currentCtx, groupCtx);\n    this.ctx = groupCtx;\n    this.setGState([[\"BM\", \"source-over\"], [\"ca\", 1], [\"CA\", 1]]);\n    this.groupStack.push(currentCtx);\n    this.groupLevel++;\n  }\n  endGroup(group) {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.groupLevel--;\n    const groupCtx = this.ctx;\n    const ctx = this.groupStack.pop();\n    this.ctx = ctx;\n    this.ctx.imageSmoothingEnabled = false;\n    if (group.smask) {\n      this.tempSMask = this.smaskStack.pop();\n      this.restore();\n    } else {\n      this.ctx.restore();\n      const currentMtx = (0, _display_utils.getCurrentTransform)(this.ctx);\n      this.restore();\n      this.ctx.save();\n      this.ctx.setTransform(...currentMtx);\n      const dirtyBox = _util.Util.getAxialAlignedBoundingBox([0, 0, groupCtx.canvas.width, groupCtx.canvas.height], currentMtx);\n      this.ctx.drawImage(groupCtx.canvas, 0, 0);\n      this.ctx.restore();\n      this.compose(dirtyBox);\n    }\n  }\n  beginAnnotation(id, rect, transform, matrix, hasOwnCanvas) {\n    this.#restoreInitialState();\n    resetCtxToDefault(this.ctx);\n    this.ctx.save();\n    this.save();\n    if (this.baseTransform) {\n      this.ctx.setTransform(...this.baseTransform);\n    }\n    if (Array.isArray(rect) && rect.length === 4) {\n      const width = rect[2] - rect[0];\n      const height = rect[3] - rect[1];\n      if (hasOwnCanvas && this.annotationCanvasMap) {\n        transform = transform.slice();\n        transform[4] -= rect[0];\n        transform[5] -= rect[1];\n        rect = rect.slice();\n        rect[0] = rect[1] = 0;\n        rect[2] = width;\n        rect[3] = height;\n        const [scaleX, scaleY] = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(this.ctx));\n        const {\n          viewportScale\n        } = this;\n        const canvasWidth = Math.ceil(width * this.outputScaleX * viewportScale);\n        const canvasHeight = Math.ceil(height * this.outputScaleY * viewportScale);\n        this.annotationCanvas = this.canvasFactory.create(canvasWidth, canvasHeight);\n        const {\n          canvas,\n          context\n        } = this.annotationCanvas;\n        this.annotationCanvasMap.set(id, canvas);\n        this.annotationCanvas.savedCtx = this.ctx;\n        this.ctx = context;\n        this.ctx.save();\n        this.ctx.setTransform(scaleX, 0, 0, -scaleY, 0, height * scaleY);\n        resetCtxToDefault(this.ctx);\n      } else {\n        resetCtxToDefault(this.ctx);\n        this.ctx.rect(rect[0], rect[1], width, height);\n        this.ctx.clip();\n        this.endPath();\n      }\n    }\n    this.current = new CanvasExtraState(this.ctx.canvas.width, this.ctx.canvas.height);\n    this.transform(...transform);\n    this.transform(...matrix);\n  }\n  endAnnotation() {\n    if (this.annotationCanvas) {\n      this.ctx.restore();\n      this.#drawFilter();\n      this.ctx = this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas.savedCtx;\n      delete this.annotationCanvas;\n    }\n  }\n  paintImageMaskXObject(img) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const count = img.count;\n    img = this.getObject(img.data, img);\n    img.count = count;\n    const ctx = this.ctx;\n    const glyph = this.processingType3;\n    if (glyph) {\n      if (glyph.compiled === undefined) {\n        glyph.compiled = compileType3Glyph(img);\n      }\n      if (glyph.compiled) {\n        glyph.compiled(ctx);\n        return;\n      }\n    }\n    const mask = this._createMaskCanvas(img);\n    const maskCanvas = mask.canvas;\n    ctx.save();\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.drawImage(maskCanvas, mask.offsetX, mask.offsetY);\n    ctx.restore();\n    this.compose();\n  }\n  paintImageMaskXObjectRepeat(img, scaleX) {\n    let skewX = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n    let skewY = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n    let scaleY = arguments.length > 4 ? arguments[4] : undefined;\n    let positions = arguments.length > 5 ? arguments[5] : undefined;\n    if (!this.contentVisible) {\n      return;\n    }\n    img = this.getObject(img.data, img);\n    const ctx = this.ctx;\n    ctx.save();\n    const currentTransform = (0, _display_utils.getCurrentTransform)(ctx);\n    ctx.transform(scaleX, skewX, skewY, scaleY, 0, 0);\n    const mask = this._createMaskCanvas(img);\n    ctx.setTransform(1, 0, 0, 1, mask.offsetX - currentTransform[4], mask.offsetY - currentTransform[5]);\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      const trans = _util.Util.transform(currentTransform, [scaleX, skewX, skewY, scaleY, positions[i], positions[i + 1]]);\n      const [x, y] = _util.Util.applyTransform([0, 0], trans);\n      ctx.drawImage(mask.canvas, x, y);\n    }\n    ctx.restore();\n    this.compose();\n  }\n  paintImageMaskXObjectGroup(images) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    const fillColor = this.current.fillColor;\n    const isPatternFill = this.current.patternFill;\n    for (const image of images) {\n      const {\n        data,\n        width,\n        height,\n        transform\n      } = image;\n      const maskCanvas = this.cachedCanvases.getCanvas(\"maskCanvas\", width, height);\n      const maskCtx = maskCanvas.context;\n      maskCtx.save();\n      const img = this.getObject(data, image);\n      putBinaryImageMask(maskCtx, img);\n      maskCtx.globalCompositeOperation = \"source-in\";\n      maskCtx.fillStyle = isPatternFill ? fillColor.getPattern(maskCtx, this, (0, _display_utils.getCurrentTransformInverse)(ctx), _pattern_helper.PathType.FILL) : fillColor;\n      maskCtx.fillRect(0, 0, width, height);\n      maskCtx.restore();\n      ctx.save();\n      ctx.transform(...transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, maskCanvas.canvas, 0, 0, width, height, 0, -1, 1, 1);\n      ctx.restore();\n    }\n    this.compose();\n  }\n  paintImageXObject(objId) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = this.getObject(objId);\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n    this.paintInlineImageXObject(imgData);\n  }\n  paintImageXObjectRepeat(objId, scaleX, scaleY, positions) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const imgData = this.getObject(objId);\n    if (!imgData) {\n      (0, _util.warn)(\"Dependent image isn't ready yet\");\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const map = [];\n    for (let i = 0, ii = positions.length; i < ii; i += 2) {\n      map.push({\n        transform: [scaleX, 0, 0, scaleY, positions[i], positions[i + 1]],\n        x: 0,\n        y: 0,\n        w: width,\n        h: height\n      });\n    }\n    this.paintInlineImageXObjectGroup(imgData, map);\n  }\n  applyTransferMapsToCanvas(ctx) {\n    if (this.current.transferMaps !== \"none\") {\n      ctx.filter = this.current.transferMaps;\n      ctx.drawImage(ctx.canvas, 0, 0);\n      ctx.filter = \"none\";\n    }\n    return ctx.canvas;\n  }\n  applyTransferMapsToBitmap(imgData) {\n    if (this.current.transferMaps === \"none\") {\n      return imgData.bitmap;\n    }\n    const {\n      bitmap,\n      width,\n      height\n    } = imgData;\n    const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n    const tmpCtx = tmpCanvas.context;\n    tmpCtx.filter = this.current.transferMaps;\n    tmpCtx.drawImage(bitmap, 0, 0);\n    tmpCtx.filter = \"none\";\n    return tmpCanvas.canvas;\n  }\n  paintInlineImageXObject(imgData) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const width = imgData.width;\n    const height = imgData.height;\n    const ctx = this.ctx;\n    this.save();\n    if (!_util.isNodeJS) {\n      const {\n        filter\n      } = ctx;\n      if (filter !== \"none\" && filter !== \"\") {\n        ctx.filter = \"none\";\n      }\n    }\n    ctx.scale(1 / width, -1 / height);\n    let imgToPaint;\n    if (imgData.bitmap) {\n      imgToPaint = this.applyTransferMapsToBitmap(imgData);\n    } else if (typeof HTMLElement === \"function\" && imgData instanceof HTMLElement || !imgData.data) {\n      imgToPaint = imgData;\n    } else {\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", width, height);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n    }\n    const scaled = this._scaleImage(imgToPaint, (0, _display_utils.getCurrentTransformInverse)(ctx));\n    ctx.imageSmoothingEnabled = getImageSmoothingEnabled((0, _display_utils.getCurrentTransform)(ctx), imgData.interpolate);\n    drawImageAtIntegerCoords(ctx, scaled.img, 0, 0, scaled.paintWidth, scaled.paintHeight, 0, -height, width, height);\n    this.compose();\n    this.restore();\n  }\n  paintInlineImageXObjectGroup(imgData, map) {\n    if (!this.contentVisible) {\n      return;\n    }\n    const ctx = this.ctx;\n    let imgToPaint;\n    if (imgData.bitmap) {\n      imgToPaint = imgData.bitmap;\n    } else {\n      const w = imgData.width;\n      const h = imgData.height;\n      const tmpCanvas = this.cachedCanvases.getCanvas(\"inlineImage\", w, h);\n      const tmpCtx = tmpCanvas.context;\n      putBinaryImageData(tmpCtx, imgData);\n      imgToPaint = this.applyTransferMapsToCanvas(tmpCtx);\n    }\n    for (const entry of map) {\n      ctx.save();\n      ctx.transform(...entry.transform);\n      ctx.scale(1, -1);\n      drawImageAtIntegerCoords(ctx, imgToPaint, entry.x, entry.y, entry.w, entry.h, 0, -1, 1, 1);\n      ctx.restore();\n    }\n    this.compose();\n  }\n  paintSolidColorImageMask() {\n    if (!this.contentVisible) {\n      return;\n    }\n    this.ctx.fillRect(0, 0, 1, 1);\n    this.compose();\n  }\n  markPoint(tag) {}\n  markPointProps(tag, properties) {}\n  beginMarkedContent(tag) {\n    this.markedContentStack.push({\n      visible: true\n    });\n  }\n  beginMarkedContentProps(tag, properties) {\n    if (tag === \"OC\") {\n      this.markedContentStack.push({\n        visible: this.optionalContentConfig.isVisible(properties)\n      });\n    } else {\n      this.markedContentStack.push({\n        visible: true\n      });\n    }\n    this.contentVisible = this.isContentVisible();\n  }\n  endMarkedContent() {\n    this.markedContentStack.pop();\n    this.contentVisible = this.isContentVisible();\n  }\n  beginCompat() {}\n  endCompat() {}\n  consumePath(clipBox) {\n    const isEmpty = this.current.isEmptyClip();\n    if (this.pendingClip) {\n      this.current.updateClipFromPath();\n    }\n    if (!this.pendingClip) {\n      this.compose(clipBox);\n    }\n    const ctx = this.ctx;\n    if (this.pendingClip) {\n      if (!isEmpty) {\n        if (this.pendingClip === EO_CLIP) {\n          ctx.clip(\"evenodd\");\n        } else {\n          ctx.clip();\n        }\n      }\n      this.pendingClip = null;\n    }\n    this.current.startNewPathAndClipBox(this.current.clipBox);\n    ctx.beginPath();\n  }\n  getSinglePixelWidth() {\n    if (!this._cachedGetSinglePixelWidth) {\n      const m = (0, _display_utils.getCurrentTransform)(this.ctx);\n      if (m[1] === 0 && m[2] === 0) {\n        this._cachedGetSinglePixelWidth = 1 / Math.min(Math.abs(m[0]), Math.abs(m[3]));\n      } else {\n        const absDet = Math.abs(m[0] * m[3] - m[2] * m[1]);\n        const normX = Math.hypot(m[0], m[2]);\n        const normY = Math.hypot(m[1], m[3]);\n        this._cachedGetSinglePixelWidth = Math.max(normX, normY) / absDet;\n      }\n    }\n    return this._cachedGetSinglePixelWidth;\n  }\n  getScaleForStroking() {\n    if (this._cachedScaleForStroking[0] === -1) {\n      const {\n        lineWidth\n      } = this.current;\n      const {\n        a,\n        b,\n        c,\n        d\n      } = this.ctx.getTransform();\n      let scaleX, scaleY;\n      if (b === 0 && c === 0) {\n        const normX = Math.abs(a);\n        const normY = Math.abs(d);\n        if (normX === normY) {\n          if (lineWidth === 0) {\n            scaleX = scaleY = 1 / normX;\n          } else {\n            const scaledLineWidth = normX * lineWidth;\n            scaleX = scaleY = scaledLineWidth < 1 ? 1 / scaledLineWidth : 1;\n          }\n        } else if (lineWidth === 0) {\n          scaleX = 1 / normX;\n          scaleY = 1 / normY;\n        } else {\n          const scaledXLineWidth = normX * lineWidth;\n          const scaledYLineWidth = normY * lineWidth;\n          scaleX = scaledXLineWidth < 1 ? 1 / scaledXLineWidth : 1;\n          scaleY = scaledYLineWidth < 1 ? 1 / scaledYLineWidth : 1;\n        }\n      } else {\n        const absDet = Math.abs(a * d - b * c);\n        const normX = Math.hypot(a, b);\n        const normY = Math.hypot(c, d);\n        if (lineWidth === 0) {\n          scaleX = normY / absDet;\n          scaleY = normX / absDet;\n        } else {\n          const baseArea = lineWidth * absDet;\n          scaleX = normY > baseArea ? normY / baseArea : 1;\n          scaleY = normX > baseArea ? normX / baseArea : 1;\n        }\n      }\n      this._cachedScaleForStroking[0] = scaleX;\n      this._cachedScaleForStroking[1] = scaleY;\n    }\n    return this._cachedScaleForStroking;\n  }\n  rescaleAndStroke(saveRestore) {\n    const {\n      ctx\n    } = this;\n    const {\n      lineWidth\n    } = this.current;\n    const [scaleX, scaleY] = this.getScaleForStroking();\n    ctx.lineWidth = lineWidth || 1;\n    if (scaleX === 1 && scaleY === 1) {\n      ctx.stroke();\n      return;\n    }\n    const dashes = ctx.getLineDash();\n    if (saveRestore) {\n      ctx.save();\n    }\n    ctx.scale(scaleX, scaleY);\n    if (dashes.length > 0) {\n      const scale = Math.max(scaleX, scaleY);\n      ctx.setLineDash(dashes.map(x => x / scale));\n      ctx.lineDashOffset /= scale;\n    }\n    ctx.stroke();\n    if (saveRestore) {\n      ctx.restore();\n    }\n  }\n  isContentVisible() {\n    for (let i = this.markedContentStack.length - 1; i >= 0; i--) {\n      if (!this.markedContentStack[i].visible) {\n        return false;\n      }\n    }\n    return true;\n  }\n}\nexports.CanvasGraphics = CanvasGraphics;\nfor (const op in _util.OPS) {\n  if (CanvasGraphics.prototype[op] !== undefined) {\n    CanvasGraphics.prototype[_util.OPS[op]] = CanvasGraphics.prototype[op];\n  }\n}\n\n/***/ }),\n/* 174 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TilingPattern = exports.PathType = void 0;\nexports.getShadingPattern = getShadingPattern;\n__w_pdfjs_require__(2);\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(168);\nconst PathType = {\n  FILL: \"Fill\",\n  STROKE: \"Stroke\",\n  SHADING: \"Shading\"\n};\nexports.PathType = PathType;\nfunction applyBoundingBox(ctx, bbox) {\n  if (!bbox) {\n    return;\n  }\n  const width = bbox[2] - bbox[0];\n  const height = bbox[3] - bbox[1];\n  const region = new Path2D();\n  region.rect(bbox[0], bbox[1], width, height);\n  ctx.clip(region);\n}\nclass BaseShadingPattern {\n  constructor() {\n    if (this.constructor === BaseShadingPattern) {\n      (0, _util.unreachable)(\"Cannot initialize BaseShadingPattern.\");\n    }\n  }\n  getPattern() {\n    (0, _util.unreachable)(\"Abstract method `getPattern` called.\");\n  }\n}\nclass RadialAxialShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._type = IR[1];\n    this._bbox = IR[2];\n    this._colorStops = IR[3];\n    this._p0 = IR[4];\n    this._p1 = IR[5];\n    this._r0 = IR[6];\n    this._r1 = IR[7];\n    this.matrix = null;\n  }\n  _createGradient(ctx) {\n    let grad;\n    if (this._type === \"axial\") {\n      grad = ctx.createLinearGradient(this._p0[0], this._p0[1], this._p1[0], this._p1[1]);\n    } else if (this._type === \"radial\") {\n      grad = ctx.createRadialGradient(this._p0[0], this._p0[1], this._r0, this._p1[0], this._p1[1], this._r1);\n    }\n    for (const colorStop of this._colorStops) {\n      grad.addColorStop(colorStop[0], colorStop[1]);\n    }\n    return grad;\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    let pattern;\n    if (pathType === PathType.STROKE || pathType === PathType.FILL) {\n      const ownerBBox = owner.current.getClippedPathBoundingBox(pathType, (0, _display_utils.getCurrentTransform)(ctx)) || [0, 0, 0, 0];\n      const width = Math.ceil(ownerBBox[2] - ownerBBox[0]) || 1;\n      const height = Math.ceil(ownerBBox[3] - ownerBBox[1]) || 1;\n      const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", width, height, true);\n      const tmpCtx = tmpCanvas.context;\n      tmpCtx.clearRect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.beginPath();\n      tmpCtx.rect(0, 0, tmpCtx.canvas.width, tmpCtx.canvas.height);\n      tmpCtx.translate(-ownerBBox[0], -ownerBBox[1]);\n      inverse = _util.Util.transform(inverse, [1, 0, 0, 1, ownerBBox[0], ownerBBox[1]]);\n      tmpCtx.transform(...owner.baseTransform);\n      if (this.matrix) {\n        tmpCtx.transform(...this.matrix);\n      }\n      applyBoundingBox(tmpCtx, this._bbox);\n      tmpCtx.fillStyle = this._createGradient(tmpCtx);\n      tmpCtx.fill();\n      pattern = ctx.createPattern(tmpCanvas.canvas, \"no-repeat\");\n      const domMatrix = new DOMMatrix(inverse);\n      pattern.setTransform(domMatrix);\n    } else {\n      applyBoundingBox(ctx, this._bbox);\n      pattern = this._createGradient(ctx);\n    }\n    return pattern;\n  }\n}\nfunction drawTriangle(data, context, p1, p2, p3, c1, c2, c3) {\n  const coords = context.coords,\n    colors = context.colors;\n  const bytes = data.data,\n    rowSize = data.width * 4;\n  let tmp;\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  if (coords[p2 + 1] > coords[p3 + 1]) {\n    tmp = p2;\n    p2 = p3;\n    p3 = tmp;\n    tmp = c2;\n    c2 = c3;\n    c3 = tmp;\n  }\n  if (coords[p1 + 1] > coords[p2 + 1]) {\n    tmp = p1;\n    p1 = p2;\n    p2 = tmp;\n    tmp = c1;\n    c1 = c2;\n    c2 = tmp;\n  }\n  const x1 = (coords[p1] + context.offsetX) * context.scaleX;\n  const y1 = (coords[p1 + 1] + context.offsetY) * context.scaleY;\n  const x2 = (coords[p2] + context.offsetX) * context.scaleX;\n  const y2 = (coords[p2 + 1] + context.offsetY) * context.scaleY;\n  const x3 = (coords[p3] + context.offsetX) * context.scaleX;\n  const y3 = (coords[p3 + 1] + context.offsetY) * context.scaleY;\n  if (y1 >= y3) {\n    return;\n  }\n  const c1r = colors[c1],\n    c1g = colors[c1 + 1],\n    c1b = colors[c1 + 2];\n  const c2r = colors[c2],\n    c2g = colors[c2 + 1],\n    c2b = colors[c2 + 2];\n  const c3r = colors[c3],\n    c3g = colors[c3 + 1],\n    c3b = colors[c3 + 2];\n  const minY = Math.round(y1),\n    maxY = Math.round(y3);\n  let xa, car, cag, cab;\n  let xb, cbr, cbg, cbb;\n  for (let y = minY; y <= maxY; y++) {\n    if (y < y2) {\n      const k = y < y1 ? 0 : (y1 - y) / (y1 - y2);\n      xa = x1 - (x1 - x2) * k;\n      car = c1r - (c1r - c2r) * k;\n      cag = c1g - (c1g - c2g) * k;\n      cab = c1b - (c1b - c2b) * k;\n    } else {\n      let k;\n      if (y > y3) {\n        k = 1;\n      } else if (y2 === y3) {\n        k = 0;\n      } else {\n        k = (y2 - y) / (y2 - y3);\n      }\n      xa = x2 - (x2 - x3) * k;\n      car = c2r - (c2r - c3r) * k;\n      cag = c2g - (c2g - c3g) * k;\n      cab = c2b - (c2b - c3b) * k;\n    }\n    let k;\n    if (y < y1) {\n      k = 0;\n    } else if (y > y3) {\n      k = 1;\n    } else {\n      k = (y1 - y) / (y1 - y3);\n    }\n    xb = x1 - (x1 - x3) * k;\n    cbr = c1r - (c1r - c3r) * k;\n    cbg = c1g - (c1g - c3g) * k;\n    cbb = c1b - (c1b - c3b) * k;\n    const x1_ = Math.round(Math.min(xa, xb));\n    const x2_ = Math.round(Math.max(xa, xb));\n    let j = rowSize * y + x1_ * 4;\n    for (let x = x1_; x <= x2_; x++) {\n      k = (xa - x) / (xa - xb);\n      if (k < 0) {\n        k = 0;\n      } else if (k > 1) {\n        k = 1;\n      }\n      bytes[j++] = car - (car - cbr) * k | 0;\n      bytes[j++] = cag - (cag - cbg) * k | 0;\n      bytes[j++] = cab - (cab - cbb) * k | 0;\n      bytes[j++] = 255;\n    }\n  }\n}\nfunction drawFigure(data, figure, context) {\n  const ps = figure.coords;\n  const cs = figure.colors;\n  let i, ii;\n  switch (figure.type) {\n    case \"lattice\":\n      const verticesPerRow = figure.verticesPerRow;\n      const rows = Math.floor(ps.length / verticesPerRow) - 1;\n      const cols = verticesPerRow - 1;\n      for (i = 0; i < rows; i++) {\n        let q = i * verticesPerRow;\n        for (let j = 0; j < cols; j++, q++) {\n          drawTriangle(data, context, ps[q], ps[q + 1], ps[q + verticesPerRow], cs[q], cs[q + 1], cs[q + verticesPerRow]);\n          drawTriangle(data, context, ps[q + verticesPerRow + 1], ps[q + 1], ps[q + verticesPerRow], cs[q + verticesPerRow + 1], cs[q + 1], cs[q + verticesPerRow]);\n        }\n      }\n      break;\n    case \"triangles\":\n      for (i = 0, ii = ps.length; i < ii; i += 3) {\n        drawTriangle(data, context, ps[i], ps[i + 1], ps[i + 2], cs[i], cs[i + 1], cs[i + 2]);\n      }\n      break;\n    default:\n      throw new Error(\"illegal figure\");\n  }\n}\nclass MeshShadingPattern extends BaseShadingPattern {\n  constructor(IR) {\n    super();\n    this._coords = IR[2];\n    this._colors = IR[3];\n    this._figures = IR[4];\n    this._bounds = IR[5];\n    this._bbox = IR[7];\n    this._background = IR[8];\n    this.matrix = null;\n  }\n  _createMeshCanvas(combinedScale, backgroundColor, cachedCanvases) {\n    const EXPECTED_SCALE = 1.1;\n    const MAX_PATTERN_SIZE = 3000;\n    const BORDER_SIZE = 2;\n    const offsetX = Math.floor(this._bounds[0]);\n    const offsetY = Math.floor(this._bounds[1]);\n    const boundsWidth = Math.ceil(this._bounds[2]) - offsetX;\n    const boundsHeight = Math.ceil(this._bounds[3]) - offsetY;\n    const width = Math.min(Math.ceil(Math.abs(boundsWidth * combinedScale[0] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const height = Math.min(Math.ceil(Math.abs(boundsHeight * combinedScale[1] * EXPECTED_SCALE)), MAX_PATTERN_SIZE);\n    const scaleX = boundsWidth / width;\n    const scaleY = boundsHeight / height;\n    const context = {\n      coords: this._coords,\n      colors: this._colors,\n      offsetX: -offsetX,\n      offsetY: -offsetY,\n      scaleX: 1 / scaleX,\n      scaleY: 1 / scaleY\n    };\n    const paddedWidth = width + BORDER_SIZE * 2;\n    const paddedHeight = height + BORDER_SIZE * 2;\n    const tmpCanvas = cachedCanvases.getCanvas(\"mesh\", paddedWidth, paddedHeight, false);\n    const tmpCtx = tmpCanvas.context;\n    const data = tmpCtx.createImageData(width, height);\n    if (backgroundColor) {\n      const bytes = data.data;\n      for (let i = 0, ii = bytes.length; i < ii; i += 4) {\n        bytes[i] = backgroundColor[0];\n        bytes[i + 1] = backgroundColor[1];\n        bytes[i + 2] = backgroundColor[2];\n        bytes[i + 3] = 255;\n      }\n    }\n    for (const figure of this._figures) {\n      drawFigure(data, figure, context);\n    }\n    tmpCtx.putImageData(data, BORDER_SIZE, BORDER_SIZE);\n    const canvas = tmpCanvas.canvas;\n    return {\n      canvas,\n      offsetX: offsetX - BORDER_SIZE * scaleX,\n      offsetY: offsetY - BORDER_SIZE * scaleY,\n      scaleX,\n      scaleY\n    };\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    applyBoundingBox(ctx, this._bbox);\n    let scale;\n    if (pathType === PathType.SHADING) {\n      scale = _util.Util.singularValueDecompose2dScale((0, _display_utils.getCurrentTransform)(ctx));\n    } else {\n      scale = _util.Util.singularValueDecompose2dScale(owner.baseTransform);\n      if (this.matrix) {\n        const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n        scale = [scale[0] * matrixScale[0], scale[1] * matrixScale[1]];\n      }\n    }\n    const temporaryPatternCanvas = this._createMeshCanvas(scale, pathType === PathType.SHADING ? null : this._background, owner.cachedCanvases);\n    if (pathType !== PathType.SHADING) {\n      ctx.setTransform(...owner.baseTransform);\n      if (this.matrix) {\n        ctx.transform(...this.matrix);\n      }\n    }\n    ctx.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    ctx.scale(temporaryPatternCanvas.scaleX, temporaryPatternCanvas.scaleY);\n    return ctx.createPattern(temporaryPatternCanvas.canvas, \"no-repeat\");\n  }\n}\nclass DummyShadingPattern extends BaseShadingPattern {\n  getPattern() {\n    return \"hotpink\";\n  }\n}\nfunction getShadingPattern(IR) {\n  switch (IR[0]) {\n    case \"RadialAxial\":\n      return new RadialAxialShadingPattern(IR);\n    case \"Mesh\":\n      return new MeshShadingPattern(IR);\n    case \"Dummy\":\n      return new DummyShadingPattern();\n  }\n  throw new Error(`Unknown IR type: ${IR[0]}`);\n}\nconst PaintType = {\n  COLORED: 1,\n  UNCOLORED: 2\n};\nclass TilingPattern {\n  static MAX_PATTERN_SIZE = 3000;\n  constructor(IR, color, ctx, canvasGraphicsFactory, baseTransform) {\n    this.operatorList = IR[2];\n    this.matrix = IR[3] || [1, 0, 0, 1, 0, 0];\n    this.bbox = IR[4];\n    this.xstep = IR[5];\n    this.ystep = IR[6];\n    this.paintType = IR[7];\n    this.tilingType = IR[8];\n    this.color = color;\n    this.ctx = ctx;\n    this.canvasGraphicsFactory = canvasGraphicsFactory;\n    this.baseTransform = baseTransform;\n  }\n  createPatternCanvas(owner) {\n    const operatorList = this.operatorList;\n    const bbox = this.bbox;\n    const xstep = this.xstep;\n    const ystep = this.ystep;\n    const paintType = this.paintType;\n    const tilingType = this.tilingType;\n    const color = this.color;\n    const canvasGraphicsFactory = this.canvasGraphicsFactory;\n    (0, _util.info)(\"TilingType: \" + tilingType);\n    const x0 = bbox[0],\n      y0 = bbox[1],\n      x1 = bbox[2],\n      y1 = bbox[3];\n    const matrixScale = _util.Util.singularValueDecompose2dScale(this.matrix);\n    const curMatrixScale = _util.Util.singularValueDecompose2dScale(this.baseTransform);\n    const combinedScale = [matrixScale[0] * curMatrixScale[0], matrixScale[1] * curMatrixScale[1]];\n    const dimx = this.getSizeAndScale(xstep, this.ctx.canvas.width, combinedScale[0]);\n    const dimy = this.getSizeAndScale(ystep, this.ctx.canvas.height, combinedScale[1]);\n    const tmpCanvas = owner.cachedCanvases.getCanvas(\"pattern\", dimx.size, dimy.size, true);\n    const tmpCtx = tmpCanvas.context;\n    const graphics = canvasGraphicsFactory.createCanvasGraphics(tmpCtx);\n    graphics.groupLevel = owner.groupLevel;\n    this.setFillAndStrokeStyleToContext(graphics, paintType, color);\n    let adjustedX0 = x0;\n    let adjustedY0 = y0;\n    let adjustedX1 = x1;\n    let adjustedY1 = y1;\n    if (x0 < 0) {\n      adjustedX0 = 0;\n      adjustedX1 += Math.abs(x0);\n    }\n    if (y0 < 0) {\n      adjustedY0 = 0;\n      adjustedY1 += Math.abs(y0);\n    }\n    tmpCtx.translate(-(dimx.scale * adjustedX0), -(dimy.scale * adjustedY0));\n    graphics.transform(dimx.scale, 0, 0, dimy.scale, 0, 0);\n    tmpCtx.save();\n    this.clipBbox(graphics, adjustedX0, adjustedY0, adjustedX1, adjustedY1);\n    graphics.baseTransform = (0, _display_utils.getCurrentTransform)(graphics.ctx);\n    graphics.executeOperatorList(operatorList);\n    graphics.endDrawing();\n    return {\n      canvas: tmpCanvas.canvas,\n      scaleX: dimx.scale,\n      scaleY: dimy.scale,\n      offsetX: adjustedX0,\n      offsetY: adjustedY0\n    };\n  }\n  getSizeAndScale(step, realOutputSize, scale) {\n    step = Math.abs(step);\n    const maxSize = Math.max(TilingPattern.MAX_PATTERN_SIZE, realOutputSize);\n    let size = Math.ceil(step * scale);\n    if (size >= maxSize) {\n      size = maxSize;\n    } else {\n      scale = size / step;\n    }\n    return {\n      scale,\n      size\n    };\n  }\n  clipBbox(graphics, x0, y0, x1, y1) {\n    const bboxWidth = x1 - x0;\n    const bboxHeight = y1 - y0;\n    graphics.ctx.rect(x0, y0, bboxWidth, bboxHeight);\n    graphics.current.updateRectMinMax((0, _display_utils.getCurrentTransform)(graphics.ctx), [x0, y0, x1, y1]);\n    graphics.clip();\n    graphics.endPath();\n  }\n  setFillAndStrokeStyleToContext(graphics, paintType, color) {\n    const context = graphics.ctx,\n      current = graphics.current;\n    switch (paintType) {\n      case PaintType.COLORED:\n        const ctx = this.ctx;\n        context.fillStyle = ctx.fillStyle;\n        context.strokeStyle = ctx.strokeStyle;\n        current.fillColor = ctx.fillStyle;\n        current.strokeColor = ctx.strokeStyle;\n        break;\n      case PaintType.UNCOLORED:\n        const cssColor = _util.Util.makeHexColor(color[0], color[1], color[2]);\n        context.fillStyle = cssColor;\n        context.strokeStyle = cssColor;\n        current.fillColor = cssColor;\n        current.strokeColor = cssColor;\n        break;\n      default:\n        throw new _util.FormatError(`Unsupported paint type: ${paintType}`);\n    }\n  }\n  getPattern(ctx, owner, inverse, pathType) {\n    let matrix = inverse;\n    if (pathType !== PathType.SHADING) {\n      matrix = _util.Util.transform(matrix, owner.baseTransform);\n      if (this.matrix) {\n        matrix = _util.Util.transform(matrix, this.matrix);\n      }\n    }\n    const temporaryPatternCanvas = this.createPatternCanvas(owner);\n    let domMatrix = new DOMMatrix(matrix);\n    domMatrix = domMatrix.translate(temporaryPatternCanvas.offsetX, temporaryPatternCanvas.offsetY);\n    domMatrix = domMatrix.scale(1 / temporaryPatternCanvas.scaleX, 1 / temporaryPatternCanvas.scaleY);\n    const pattern = ctx.createPattern(temporaryPatternCanvas.canvas, \"repeat\");\n    pattern.setTransform(domMatrix);\n    return pattern;\n  }\n}\nexports.TilingPattern = TilingPattern;\n\n/***/ }),\n/* 175 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.convertBlackAndWhiteToRGBA = convertBlackAndWhiteToRGBA;\nexports.convertToRGBA = convertToRGBA;\nexports.grayToRGBA = grayToRGBA;\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\nvar _util = __w_pdfjs_require__(1);\nfunction convertToRGBA(params) {\n  switch (params.kind) {\n    case _util.ImageKind.GRAYSCALE_1BPP:\n      return convertBlackAndWhiteToRGBA(params);\n    case _util.ImageKind.RGB_24BPP:\n      return convertRGBToRGBA(params);\n  }\n  return null;\n}\nfunction convertBlackAndWhiteToRGBA(_ref) {\n  let {\n    src,\n    srcPos = 0,\n    dest,\n    width,\n    height,\n    nonBlackColor = 0xffffffff,\n    inverseDecode = false\n  } = _ref;\n  const black = _util.FeatureTest.isLittleEndian ? 0xff000000 : 0x000000ff;\n  const [zeroMapping, oneMapping] = inverseDecode ? [nonBlackColor, black] : [black, nonBlackColor];\n  const widthInSource = width >> 3;\n  const widthRemainder = width & 7;\n  const srcLength = src.length;\n  dest = new Uint32Array(dest.buffer);\n  let destPos = 0;\n  for (let i = 0; i < height; i++) {\n    for (const max = srcPos + widthInSource; srcPos < max; srcPos++) {\n      const elem = srcPos < srcLength ? src[srcPos] : 255;\n      dest[destPos++] = elem & 0b10000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1000 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b100 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b10 ? oneMapping : zeroMapping;\n      dest[destPos++] = elem & 0b1 ? oneMapping : zeroMapping;\n    }\n    if (widthRemainder === 0) {\n      continue;\n    }\n    const elem = srcPos < srcLength ? src[srcPos++] : 255;\n    for (let j = 0; j < widthRemainder; j++) {\n      dest[destPos++] = elem & 1 << 7 - j ? oneMapping : zeroMapping;\n    }\n  }\n  return {\n    srcPos,\n    destPos\n  };\n}\nfunction convertRGBToRGBA(_ref2) {\n  let {\n    src,\n    srcPos = 0,\n    dest,\n    destPos = 0,\n    width,\n    height\n  } = _ref2;\n  let i = 0;\n  const len32 = src.length >> 2;\n  const src32 = new Uint32Array(src.buffer, srcPos, len32);\n  if (_util.FeatureTest.isLittleEndian) {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff000000;\n      dest[destPos + 1] = s1 >>> 24 | s2 << 8 | 0xff000000;\n      dest[destPos + 2] = s2 >>> 16 | s3 << 16 | 0xff000000;\n      dest[destPos + 3] = s3 >>> 8 | 0xff000000;\n    }\n    for (let j = i * 4, jj = src.length; j < jj; j += 3) {\n      dest[destPos++] = src[j] | src[j + 1] << 8 | src[j + 2] << 16 | 0xff000000;\n    }\n  } else {\n    for (; i < len32 - 2; i += 3, destPos += 4) {\n      const s1 = src32[i];\n      const s2 = src32[i + 1];\n      const s3 = src32[i + 2];\n      dest[destPos] = s1 | 0xff;\n      dest[destPos + 1] = s1 << 24 | s2 >>> 8 | 0xff;\n      dest[destPos + 2] = s2 << 16 | s3 >>> 16 | 0xff;\n      dest[destPos + 3] = s3 << 8 | 0xff;\n    }\n    for (let j = i * 4, jj = src.length; j < jj; j += 3) {\n      dest[destPos++] = src[j] << 24 | src[j + 1] << 16 | src[j + 2] << 8 | 0xff;\n    }\n  }\n  return {\n    srcPos,\n    destPos\n  };\n}\nfunction grayToRGBA(src, dest) {\n  if (_util.FeatureTest.isLittleEndian) {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x10101 | 0xff000000;\n    }\n  } else {\n    for (let i = 0, ii = src.length; i < ii; i++) {\n      dest[i] = src[i] * 0x1010100 | 0x000000ff;\n    }\n  }\n}\n\n/***/ }),\n/* 176 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.GlobalWorkerOptions = void 0;\nconst GlobalWorkerOptions = Object.create(null);\nexports.GlobalWorkerOptions = GlobalWorkerOptions;\nGlobalWorkerOptions.workerPort = null;\nGlobalWorkerOptions.workerSrc = \"\";\n\n/***/ }),\n/* 177 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.MessageHandler = void 0;\n__w_pdfjs_require__(2);\nvar _util = __w_pdfjs_require__(1);\nconst CallbackKind = {\n  UNKNOWN: 0,\n  DATA: 1,\n  ERROR: 2\n};\nconst StreamKind = {\n  UNKNOWN: 0,\n  CANCEL: 1,\n  CANCEL_COMPLETE: 2,\n  CLOSE: 3,\n  ENQUEUE: 4,\n  ERROR: 5,\n  PULL: 6,\n  PULL_COMPLETE: 7,\n  START_COMPLETE: 8\n};\nfunction wrapReason(reason) {\n  if (!(reason instanceof Error || typeof reason === \"object\" && reason !== null)) {\n    (0, _util.unreachable)('wrapReason: Expected \"reason\" to be a (possibly cloned) Error.');\n  }\n  switch (reason.name) {\n    case \"AbortException\":\n      return new _util.AbortException(reason.message);\n    case \"MissingPDFException\":\n      return new _util.MissingPDFException(reason.message);\n    case \"PasswordException\":\n      return new _util.PasswordException(reason.message, reason.code);\n    case \"UnexpectedResponseException\":\n      return new _util.UnexpectedResponseException(reason.message, reason.status);\n    case \"UnknownErrorException\":\n      return new _util.UnknownErrorException(reason.message, reason.details);\n    default:\n      return new _util.UnknownErrorException(reason.message, reason.toString());\n  }\n}\nclass MessageHandler {\n  constructor(sourceName, targetName, comObj) {\n    this.sourceName = sourceName;\n    this.targetName = targetName;\n    this.comObj = comObj;\n    this.callbackId = 1;\n    this.streamId = 1;\n    this.streamSinks = Object.create(null);\n    this.streamControllers = Object.create(null);\n    this.callbackCapabilities = Object.create(null);\n    this.actionHandler = Object.create(null);\n    this._onComObjOnMessage = event => {\n      const data = event.data;\n      if (data.targetName !== this.sourceName) {\n        return;\n      }\n      if (data.stream) {\n        this.#processStreamMessage(data);\n        return;\n      }\n      if (data.callback) {\n        const callbackId = data.callbackId;\n        const capability = this.callbackCapabilities[callbackId];\n        if (!capability) {\n          throw new Error(`Cannot resolve callback ${callbackId}`);\n        }\n        delete this.callbackCapabilities[callbackId];\n        if (data.callback === CallbackKind.DATA) {\n          capability.resolve(data.data);\n        } else if (data.callback === CallbackKind.ERROR) {\n          capability.reject(wrapReason(data.reason));\n        } else {\n          throw new Error(\"Unexpected callback case\");\n        }\n        return;\n      }\n      const action = this.actionHandler[data.action];\n      if (!action) {\n        throw new Error(`Unknown action from worker: ${data.action}`);\n      }\n      if (data.callbackId) {\n        const cbSourceName = this.sourceName;\n        const cbTargetName = data.sourceName;\n        new Promise(function (resolve) {\n          resolve(action(data.data));\n        }).then(function (result) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.DATA,\n            callbackId: data.callbackId,\n            data: result\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName: cbSourceName,\n            targetName: cbTargetName,\n            callback: CallbackKind.ERROR,\n            callbackId: data.callbackId,\n            reason: wrapReason(reason)\n          });\n        });\n        return;\n      }\n      if (data.streamId) {\n        this.#createStreamSink(data);\n        return;\n      }\n      action(data.data);\n    };\n    comObj.addEventListener(\"message\", this._onComObjOnMessage);\n  }\n  on(actionName, handler) {\n    const ah = this.actionHandler;\n    if (ah[actionName]) {\n      throw new Error(`There is already an actionName called \"${actionName}\"`);\n    }\n    ah[actionName] = handler;\n  }\n  send(actionName, data, transfers) {\n    this.comObj.postMessage({\n      sourceName: this.sourceName,\n      targetName: this.targetName,\n      action: actionName,\n      data\n    }, transfers);\n  }\n  sendWithPromise(actionName, data, transfers) {\n    const callbackId = this.callbackId++;\n    const capability = new _util.PromiseCapability();\n    this.callbackCapabilities[callbackId] = capability;\n    try {\n      this.comObj.postMessage({\n        sourceName: this.sourceName,\n        targetName: this.targetName,\n        action: actionName,\n        callbackId,\n        data\n      }, transfers);\n    } catch (ex) {\n      capability.reject(ex);\n    }\n    return capability.promise;\n  }\n  sendWithStream(actionName, data, queueingStrategy, transfers) {\n    const streamId = this.streamId++,\n      sourceName = this.sourceName,\n      targetName = this.targetName,\n      comObj = this.comObj;\n    return new ReadableStream({\n      start: controller => {\n        const startCapability = new _util.PromiseCapability();\n        this.streamControllers[streamId] = {\n          controller,\n          startCall: startCapability,\n          pullCall: null,\n          cancelCall: null,\n          isClosed: false\n        };\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          action: actionName,\n          streamId,\n          data,\n          desiredSize: controller.desiredSize\n        }, transfers);\n        return startCapability.promise;\n      },\n      pull: controller => {\n        const pullCapability = new _util.PromiseCapability();\n        this.streamControllers[streamId].pullCall = pullCapability;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.PULL,\n          streamId,\n          desiredSize: controller.desiredSize\n        });\n        return pullCapability.promise;\n      },\n      cancel: reason => {\n        (0, _util.assert)(reason instanceof Error, \"cancel must have a valid reason\");\n        const cancelCapability = new _util.PromiseCapability();\n        this.streamControllers[streamId].cancelCall = cancelCapability;\n        this.streamControllers[streamId].isClosed = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CANCEL,\n          streamId,\n          reason: wrapReason(reason)\n        });\n        return cancelCapability.promise;\n      }\n    }, queueingStrategy);\n  }\n  #createStreamSink(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const self = this,\n      action = this.actionHandler[data.action];\n    const streamSink = {\n      enqueue(chunk) {\n        let size = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n        let transfers = arguments.length > 2 ? arguments[2] : undefined;\n        if (this.isCancelled) {\n          return;\n        }\n        const lastDesiredSize = this.desiredSize;\n        this.desiredSize -= size;\n        if (lastDesiredSize > 0 && this.desiredSize <= 0) {\n          this.sinkCapability = new _util.PromiseCapability();\n          this.ready = this.sinkCapability.promise;\n        }\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ENQUEUE,\n          streamId,\n          chunk\n        }, transfers);\n      },\n      close() {\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.CLOSE,\n          streamId\n        });\n        delete self.streamSinks[streamId];\n      },\n      error(reason) {\n        (0, _util.assert)(reason instanceof Error, \"error must have a valid reason\");\n        if (this.isCancelled) {\n          return;\n        }\n        this.isCancelled = true;\n        comObj.postMessage({\n          sourceName,\n          targetName,\n          stream: StreamKind.ERROR,\n          streamId,\n          reason: wrapReason(reason)\n        });\n      },\n      sinkCapability: new _util.PromiseCapability(),\n      onPull: null,\n      onCancel: null,\n      isCancelled: false,\n      desiredSize: data.desiredSize,\n      ready: null\n    };\n    streamSink.sinkCapability.resolve();\n    streamSink.ready = streamSink.sinkCapability.promise;\n    this.streamSinks[streamId] = streamSink;\n    new Promise(function (resolve) {\n      resolve(action(data.data, streamSink));\n    }).then(function () {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        success: true\n      });\n    }, function (reason) {\n      comObj.postMessage({\n        sourceName,\n        targetName,\n        stream: StreamKind.START_COMPLETE,\n        streamId,\n        reason: wrapReason(reason)\n      });\n    });\n  }\n  #processStreamMessage(data) {\n    const streamId = data.streamId,\n      sourceName = this.sourceName,\n      targetName = data.sourceName,\n      comObj = this.comObj;\n    const streamController = this.streamControllers[streamId],\n      streamSink = this.streamSinks[streamId];\n    switch (data.stream) {\n      case StreamKind.START_COMPLETE:\n        if (data.success) {\n          streamController.startCall.resolve();\n        } else {\n          streamController.startCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL_COMPLETE:\n        if (data.success) {\n          streamController.pullCall.resolve();\n        } else {\n          streamController.pullCall.reject(wrapReason(data.reason));\n        }\n        break;\n      case StreamKind.PULL:\n        if (!streamSink) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n          break;\n        }\n        if (streamSink.desiredSize <= 0 && data.desiredSize > 0) {\n          streamSink.sinkCapability.resolve();\n        }\n        streamSink.desiredSize = data.desiredSize;\n        new Promise(function (resolve) {\n          resolve(streamSink.onPull?.());\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.PULL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        break;\n      case StreamKind.ENQUEUE:\n        (0, _util.assert)(streamController, \"enqueue should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.controller.enqueue(data.chunk);\n        break;\n      case StreamKind.CLOSE:\n        (0, _util.assert)(streamController, \"close should have stream controller\");\n        if (streamController.isClosed) {\n          break;\n        }\n        streamController.isClosed = true;\n        streamController.controller.close();\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.ERROR:\n        (0, _util.assert)(streamController, \"error should have stream controller\");\n        streamController.controller.error(wrapReason(data.reason));\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL_COMPLETE:\n        if (data.success) {\n          streamController.cancelCall.resolve();\n        } else {\n          streamController.cancelCall.reject(wrapReason(data.reason));\n        }\n        this.#deleteStreamController(streamController, streamId);\n        break;\n      case StreamKind.CANCEL:\n        if (!streamSink) {\n          break;\n        }\n        new Promise(function (resolve) {\n          resolve(streamSink.onCancel?.(wrapReason(data.reason)));\n        }).then(function () {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            success: true\n          });\n        }, function (reason) {\n          comObj.postMessage({\n            sourceName,\n            targetName,\n            stream: StreamKind.CANCEL_COMPLETE,\n            streamId,\n            reason: wrapReason(reason)\n          });\n        });\n        streamSink.sinkCapability.reject(wrapReason(data.reason));\n        streamSink.isCancelled = true;\n        delete this.streamSinks[streamId];\n        break;\n      default:\n        throw new Error(\"Unexpected stream case\");\n    }\n  }\n  async #deleteStreamController(streamController, streamId) {\n    await Promise.allSettled([streamController.startCall?.promise, streamController.pullCall?.promise, streamController.cancelCall?.promise]);\n    delete this.streamControllers[streamId];\n  }\n  destroy() {\n    this.comObj.removeEventListener(\"message\", this._onComObjOnMessage);\n  }\n}\nexports.MessageHandler = MessageHandler;\n\n/***/ }),\n/* 178 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.Metadata = void 0;\nvar _util = __w_pdfjs_require__(1);\nclass Metadata {\n  #metadataMap;\n  #data;\n  constructor(_ref) {\n    let {\n      parsedData,\n      rawData\n    } = _ref;\n    this.#metadataMap = parsedData;\n    this.#data = rawData;\n  }\n  getRaw() {\n    return this.#data;\n  }\n  get(name) {\n    return this.#metadataMap.get(name) ?? null;\n  }\n  getAll() {\n    return (0, _util.objectFromMap)(this.#metadataMap);\n  }\n  has(name) {\n    return this.#metadataMap.has(name);\n  }\n}\nexports.Metadata = Metadata;\n\n/***/ }),\n/* 179 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.OptionalContentConfig = void 0;\nvar _util = __w_pdfjs_require__(1);\nvar _murmurhash = __w_pdfjs_require__(170);\nconst INTERNAL = Symbol(\"INTERNAL\");\nclass OptionalContentGroup {\n  #visible = true;\n  constructor(name, intent) {\n    this.name = name;\n    this.intent = intent;\n  }\n  get visible() {\n    return this.#visible;\n  }\n  _setVisible(internal, visible) {\n    if (internal !== INTERNAL) {\n      (0, _util.unreachable)(\"Internal method `_setVisible` called.\");\n    }\n    this.#visible = visible;\n  }\n}\nclass OptionalContentConfig {\n  #cachedGetHash = null;\n  #groups = new Map();\n  #initialHash = null;\n  #order = null;\n  constructor(data) {\n    this.name = null;\n    this.creator = null;\n    if (data === null) {\n      return;\n    }\n    this.name = data.name;\n    this.creator = data.creator;\n    this.#order = data.order;\n    for (const group of data.groups) {\n      this.#groups.set(group.id, new OptionalContentGroup(group.name, group.intent));\n    }\n    if (data.baseState === \"OFF\") {\n      for (const group of this.#groups.values()) {\n        group._setVisible(INTERNAL, false);\n      }\n    }\n    for (const on of data.on) {\n      this.#groups.get(on)._setVisible(INTERNAL, true);\n    }\n    for (const off of data.off) {\n      this.#groups.get(off)._setVisible(INTERNAL, false);\n    }\n    this.#initialHash = this.getHash();\n  }\n  #evaluateVisibilityExpression(array) {\n    const length = array.length;\n    if (length < 2) {\n      return true;\n    }\n    const operator = array[0];\n    for (let i = 1; i < length; i++) {\n      const element = array[i];\n      let state;\n      if (Array.isArray(element)) {\n        state = this.#evaluateVisibilityExpression(element);\n      } else if (this.#groups.has(element)) {\n        state = this.#groups.get(element).visible;\n      } else {\n        (0, _util.warn)(`Optional content group not found: ${element}`);\n        return true;\n      }\n      switch (operator) {\n        case \"And\":\n          if (!state) {\n            return false;\n          }\n          break;\n        case \"Or\":\n          if (state) {\n            return true;\n          }\n          break;\n        case \"Not\":\n          return !state;\n        default:\n          return true;\n      }\n    }\n    return operator === \"And\";\n  }\n  isVisible(group) {\n    if (this.#groups.size === 0) {\n      return true;\n    }\n    if (!group) {\n      (0, _util.warn)(\"Optional content group not defined.\");\n      return true;\n    }\n    if (group.type === \"OCG\") {\n      if (!this.#groups.has(group.id)) {\n        (0, _util.warn)(`Optional content group not found: ${group.id}`);\n        return true;\n      }\n      return this.#groups.get(group.id).visible;\n    } else if (group.type === \"OCMD\") {\n      if (group.expression) {\n        return this.#evaluateVisibilityExpression(group.expression);\n      }\n      if (!group.policy || group.policy === \"AnyOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOn\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      } else if (group.policy === \"AnyOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (!this.#groups.get(id).visible) {\n            return true;\n          }\n        }\n        return false;\n      } else if (group.policy === \"AllOff\") {\n        for (const id of group.ids) {\n          if (!this.#groups.has(id)) {\n            (0, _util.warn)(`Optional content group not found: ${id}`);\n            return true;\n          }\n          if (this.#groups.get(id).visible) {\n            return false;\n          }\n        }\n        return true;\n      }\n      (0, _util.warn)(`Unknown optional content policy ${group.policy}.`);\n      return true;\n    }\n    (0, _util.warn)(`Unknown group type ${group.type}.`);\n    return true;\n  }\n  setVisibility(id) {\n    let visible = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n    if (!this.#groups.has(id)) {\n      (0, _util.warn)(`Optional content group not found: ${id}`);\n      return;\n    }\n    this.#groups.get(id)._setVisible(INTERNAL, !!visible);\n    this.#cachedGetHash = null;\n  }\n  get hasInitialVisibility() {\n    return this.#initialHash === null || this.getHash() === this.#initialHash;\n  }\n  getOrder() {\n    if (!this.#groups.size) {\n      return null;\n    }\n    if (this.#order) {\n      return this.#order.slice();\n    }\n    return [...this.#groups.keys()];\n  }\n  getGroups() {\n    return this.#groups.size > 0 ? (0, _util.objectFromMap)(this.#groups) : null;\n  }\n  getGroup(id) {\n    return this.#groups.get(id) || null;\n  }\n  getHash() {\n    if (this.#cachedGetHash !== null) {\n      return this.#cachedGetHash;\n    }\n    const hash = new _murmurhash.MurmurHash3_64();\n    for (const [id, group] of this.#groups) {\n      hash.update(`${id}:${group.visible}`);\n    }\n    return this.#cachedGetHash = hash.hexdigest();\n  }\n}\nexports.OptionalContentConfig = OptionalContentConfig;\n\n/***/ }),\n/* 180 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFDataTransportStream = void 0;\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\n__w_pdfjs_require__(89);\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(168);\nclass PDFDataTransportStream {\n  constructor(_ref, pdfDataRangeTransport) {\n    let {\n      length,\n      initialData,\n      progressiveDone = false,\n      contentDispositionFilename = null,\n      disableRange = false,\n      disableStream = false\n    } = _ref;\n    (0, _util.assert)(pdfDataRangeTransport, 'PDFDataTransportStream - missing required \"pdfDataRangeTransport\" argument.');\n    this._queuedChunks = [];\n    this._progressiveDone = progressiveDone;\n    this._contentDispositionFilename = contentDispositionFilename;\n    if (initialData?.length > 0) {\n      const buffer = initialData instanceof Uint8Array && initialData.byteLength === initialData.buffer.byteLength ? initialData.buffer : new Uint8Array(initialData).buffer;\n      this._queuedChunks.push(buffer);\n    }\n    this._pdfDataRangeTransport = pdfDataRangeTransport;\n    this._isStreamingSupported = !disableStream;\n    this._isRangeSupported = !disableRange;\n    this._contentLength = length;\n    this._fullRequestReader = null;\n    this._rangeReaders = [];\n    this._pdfDataRangeTransport.addRangeListener((begin, chunk) => {\n      this._onReceiveData({\n        begin,\n        chunk\n      });\n    });\n    this._pdfDataRangeTransport.addProgressListener((loaded, total) => {\n      this._onProgress({\n        loaded,\n        total\n      });\n    });\n    this._pdfDataRangeTransport.addProgressiveReadListener(chunk => {\n      this._onReceiveData({\n        chunk\n      });\n    });\n    this._pdfDataRangeTransport.addProgressiveDoneListener(() => {\n      this._onProgressiveDone();\n    });\n    this._pdfDataRangeTransport.transportReady();\n  }\n  _onReceiveData(_ref2) {\n    let {\n      begin,\n      chunk\n    } = _ref2;\n    const buffer = chunk instanceof Uint8Array && chunk.byteLength === chunk.buffer.byteLength ? chunk.buffer : new Uint8Array(chunk).buffer;\n    if (begin === undefined) {\n      if (this._fullRequestReader) {\n        this._fullRequestReader._enqueue(buffer);\n      } else {\n        this._queuedChunks.push(buffer);\n      }\n    } else {\n      const found = this._rangeReaders.some(function (rangeReader) {\n        if (rangeReader._begin !== begin) {\n          return false;\n        }\n        rangeReader._enqueue(buffer);\n        return true;\n      });\n      (0, _util.assert)(found, \"_onReceiveData - no `PDFDataTransportStreamRangeReader` instance found.\");\n    }\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  _onProgress(evt) {\n    if (evt.total === undefined) {\n      this._rangeReaders[0]?.onProgress?.({\n        loaded: evt.loaded\n      });\n    } else {\n      this._fullRequestReader?.onProgress?.({\n        loaded: evt.loaded,\n        total: evt.total\n      });\n    }\n  }\n  _onProgressiveDone() {\n    this._fullRequestReader?.progressiveDone();\n    this._progressiveDone = true;\n  }\n  _removeRangeReader(reader) {\n    const i = this._rangeReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeReaders.splice(i, 1);\n    }\n  }\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFDataTransportStream.getFullReader can only be called once.\");\n    const queuedChunks = this._queuedChunks;\n    this._queuedChunks = null;\n    return new PDFDataTransportStreamReader(this, queuedChunks, this._progressiveDone, this._contentDispositionFilename);\n  }\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFDataTransportStreamRangeReader(this, begin, end);\n    this._pdfDataRangeTransport.requestDataRange(begin, end);\n    this._rangeReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n    this._pdfDataRangeTransport.abort();\n  }\n}\nexports.PDFDataTransportStream = PDFDataTransportStream;\nclass PDFDataTransportStreamReader {\n  constructor(stream, queuedChunks) {\n    let progressiveDone = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    let contentDispositionFilename = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : null;\n    this._stream = stream;\n    this._done = progressiveDone || false;\n    this._filename = (0, _display_utils.isPdfFile)(contentDispositionFilename) ? contentDispositionFilename : null;\n    this._queuedChunks = queuedChunks || [];\n    this._loaded = 0;\n    for (const chunk of this._queuedChunks) {\n      this._loaded += chunk.byteLength;\n    }\n    this._requests = [];\n    this._headersReady = Promise.resolve();\n    stream._fullRequestReader = this;\n    this.onProgress = null;\n  }\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunks.push(chunk);\n    }\n    this._loaded += chunk.byteLength;\n  }\n  get headersReady() {\n    return this._headersReady;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get isRangeSupported() {\n    return this._stream._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._stream._isStreamingSupported;\n  }\n  get contentLength() {\n    return this._stream._contentLength;\n  }\n  async read() {\n    if (this._queuedChunks.length > 0) {\n      const chunk = this._queuedChunks.shift();\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = new _util.PromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n  }\n  progressiveDone() {\n    if (this._done) {\n      return;\n    }\n    this._done = true;\n  }\n}\nclass PDFDataTransportStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._begin = begin;\n    this._end = end;\n    this._queuedChunk = null;\n    this._requests = [];\n    this._done = false;\n    this.onProgress = null;\n  }\n  _enqueue(chunk) {\n    if (this._done) {\n      return;\n    }\n    if (this._requests.length === 0) {\n      this._queuedChunk = chunk;\n    } else {\n      const requestsCapability = this._requests.shift();\n      requestsCapability.resolve({\n        value: chunk,\n        done: false\n      });\n      for (const requestCapability of this._requests) {\n        requestCapability.resolve({\n          value: undefined,\n          done: true\n        });\n      }\n      this._requests.length = 0;\n    }\n    this._done = true;\n    this._stream._removeRangeReader(this);\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    if (this._queuedChunk) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = new _util.PromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    this._stream._removeRangeReader(this);\n  }\n}\n\n/***/ }),\n/* 181 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFFetchStream = void 0;\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\n__w_pdfjs_require__(89);\nvar _util = __w_pdfjs_require__(1);\nvar _network_utils = __w_pdfjs_require__(182);\n;\nfunction createFetchOptions(headers, withCredentials, abortController) {\n  return {\n    method: \"GET\",\n    headers,\n    signal: abortController.signal,\n    mode: \"cors\",\n    credentials: withCredentials ? \"include\" : \"same-origin\",\n    redirect: \"follow\"\n  };\n}\nfunction createHeaders(httpHeaders) {\n  const headers = new Headers();\n  for (const property in httpHeaders) {\n    const value = httpHeaders[property];\n    if (value === undefined) {\n      continue;\n    }\n    headers.append(property, value);\n  }\n  return headers;\n}\nfunction getArrayBuffer(val) {\n  if (val instanceof Uint8Array) {\n    return val.buffer;\n  }\n  if (val instanceof ArrayBuffer) {\n    return val;\n  }\n  (0, _util.warn)(`getArrayBuffer - unexpected data format: ${val}`);\n  return new Uint8Array(val).buffer;\n}\nclass PDFFetchStream {\n  constructor(source) {\n    this.source = source;\n    this.isHttp = /^https?:/i.test(source.url);\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFFetchStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFFetchStreamReader(this);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const reader = new PDFFetchStreamRangeReader(this, begin, end);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nexports.PDFFetchStream = PDFFetchStream;\nclass PDFFetchStreamReader {\n  constructor(stream) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    this._filename = null;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._contentLength = source.length;\n    this._headersCapability = new _util.PromiseCapability();\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._abortController = new AbortController();\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._headers = createHeaders(this._stream.httpHeaders);\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n      this._reader = response.body.getReader();\n      this._headersCapability.resolve();\n      const getResponseHeader = name => {\n        return response.headers.get(name);\n      };\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: this._stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n      if (!this._isStreamingSupported && this._isRangeSupported) {\n        this.cancel(new _util.AbortException(\"Streaming is disabled.\"));\n      }\n    }).catch(this._headersCapability.reject);\n    this.onProgress = null;\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._headersCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n    this._loaded += value.byteLength;\n    this.onProgress?.({\n      loaded: this._loaded,\n      total: this._contentLength\n    });\n    return {\n      value: getArrayBuffer(value),\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader?.cancel(reason);\n    this._abortController.abort();\n  }\n}\nclass PDFFetchStreamRangeReader {\n  constructor(stream, begin, end) {\n    this._stream = stream;\n    this._reader = null;\n    this._loaded = 0;\n    const source = stream.source;\n    this._withCredentials = source.withCredentials || false;\n    this._readCapability = new _util.PromiseCapability();\n    this._isStreamingSupported = !source.disableStream;\n    this._abortController = new AbortController();\n    this._headers = createHeaders(this._stream.httpHeaders);\n    this._headers.append(\"Range\", `bytes=${begin}-${end - 1}`);\n    const url = source.url;\n    fetch(url, createFetchOptions(this._headers, this._withCredentials, this._abortController)).then(response => {\n      if (!(0, _network_utils.validateResponseStatus)(response.status)) {\n        throw (0, _network_utils.createResponseStatusError)(response.status, url);\n      }\n      this._readCapability.resolve();\n      this._reader = response.body.getReader();\n    }).catch(this._readCapability.reject);\n    this.onProgress = null;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    const {\n      value,\n      done\n    } = await this._reader.read();\n    if (done) {\n      return {\n        value,\n        done\n      };\n    }\n    this._loaded += value.byteLength;\n    this.onProgress?.({\n      loaded: this._loaded\n    });\n    return {\n      value: getArrayBuffer(value),\n      done: false\n    };\n  }\n  cancel(reason) {\n    this._reader?.cancel(reason);\n    this._abortController.abort();\n  }\n}\n\n/***/ }),\n/* 182 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.createResponseStatusError = createResponseStatusError;\nexports.extractFilenameFromHeader = extractFilenameFromHeader;\nexports.validateRangeRequestCapabilities = validateRangeRequestCapabilities;\nexports.validateResponseStatus = validateResponseStatus;\nvar _util = __w_pdfjs_require__(1);\nvar _content_disposition = __w_pdfjs_require__(183);\nvar _display_utils = __w_pdfjs_require__(168);\nfunction validateRangeRequestCapabilities(_ref) {\n  let {\n    getResponseHeader,\n    isHttp,\n    rangeChunkSize,\n    disableRange\n  } = _ref;\n  const returnValues = {\n    allowRangeRequests: false,\n    suggestedLength: undefined\n  };\n  const length = parseInt(getResponseHeader(\"Content-Length\"), 10);\n  if (!Number.isInteger(length)) {\n    return returnValues;\n  }\n  returnValues.suggestedLength = length;\n  if (length <= 2 * rangeChunkSize) {\n    return returnValues;\n  }\n  if (disableRange || !isHttp) {\n    return returnValues;\n  }\n  if (getResponseHeader(\"Accept-Ranges\") !== \"bytes\") {\n    return returnValues;\n  }\n  const contentEncoding = getResponseHeader(\"Content-Encoding\") || \"identity\";\n  if (contentEncoding !== \"identity\") {\n    return returnValues;\n  }\n  returnValues.allowRangeRequests = true;\n  return returnValues;\n}\nfunction extractFilenameFromHeader(getResponseHeader) {\n  const contentDisposition = getResponseHeader(\"Content-Disposition\");\n  if (contentDisposition) {\n    let filename = (0, _content_disposition.getFilenameFromContentDispositionHeader)(contentDisposition);\n    if (filename.includes(\"%\")) {\n      try {\n        filename = decodeURIComponent(filename);\n      } catch {}\n    }\n    if ((0, _display_utils.isPdfFile)(filename)) {\n      return filename;\n    }\n  }\n  return null;\n}\nfunction createResponseStatusError(status, url) {\n  if (status === 404 || status === 0 && url.startsWith(\"file:\")) {\n    return new _util.MissingPDFException('Missing PDF \"' + url + '\".');\n  }\n  return new _util.UnexpectedResponseException(`Unexpected server response (${status}) while retrieving PDF \"${url}\".`, status);\n}\nfunction validateResponseStatus(status) {\n  return status === 200 || status === 206;\n}\n\n/***/ }),\n/* 183 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.getFilenameFromContentDispositionHeader = getFilenameFromContentDispositionHeader;\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(149);\nvar _util = __w_pdfjs_require__(1);\nfunction getFilenameFromContentDispositionHeader(contentDisposition) {\n  let needsEncodingFixup = true;\n  let tmp = toParamRegExp(\"filename\\\\*\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = unescape(filename);\n    filename = rfc5987decode(filename);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n  tmp = rfc2231getparam(contentDisposition);\n  if (tmp) {\n    const filename = rfc2047decode(tmp);\n    return fixupEncoding(filename);\n  }\n  tmp = toParamRegExp(\"filename\", \"i\").exec(contentDisposition);\n  if (tmp) {\n    tmp = tmp[1];\n    let filename = rfc2616unquote(tmp);\n    filename = rfc2047decode(filename);\n    return fixupEncoding(filename);\n  }\n  function toParamRegExp(attributePattern, flags) {\n    return new RegExp(\"(?:^|;)\\\\s*\" + attributePattern + \"\\\\s*=\\\\s*\" + \"(\" + '[^\";\\\\s][^;\\\\s]*' + \"|\" + '\"(?:[^\"\\\\\\\\]|\\\\\\\\\"?)+\"?' + \")\", flags);\n  }\n  function textdecode(encoding, value) {\n    if (encoding) {\n      if (!/^[\\x00-\\xFF]+$/.test(value)) {\n        return value;\n      }\n      try {\n        const decoder = new TextDecoder(encoding, {\n          fatal: true\n        });\n        const buffer = (0, _util.stringToBytes)(value);\n        value = decoder.decode(buffer);\n        needsEncodingFixup = false;\n      } catch {}\n    }\n    return value;\n  }\n  function fixupEncoding(value) {\n    if (needsEncodingFixup && /[\\x80-\\xff]/.test(value)) {\n      value = textdecode(\"utf-8\", value);\n      if (needsEncodingFixup) {\n        value = textdecode(\"iso-8859-1\", value);\n      }\n    }\n    return value;\n  }\n  function rfc2231getparam(contentDispositionStr) {\n    const matches = [];\n    let match;\n    const iter = toParamRegExp(\"filename\\\\*((?!0\\\\d)\\\\d+)(\\\\*?)\", \"ig\");\n    while ((match = iter.exec(contentDispositionStr)) !== null) {\n      let [, n, quot, part] = match;\n      n = parseInt(n, 10);\n      if (n in matches) {\n        if (n === 0) {\n          break;\n        }\n        continue;\n      }\n      matches[n] = [quot, part];\n    }\n    const parts = [];\n    for (let n = 0; n < matches.length; ++n) {\n      if (!(n in matches)) {\n        break;\n      }\n      let [quot, part] = matches[n];\n      part = rfc2616unquote(part);\n      if (quot) {\n        part = unescape(part);\n        if (n === 0) {\n          part = rfc5987decode(part);\n        }\n      }\n      parts.push(part);\n    }\n    return parts.join(\"\");\n  }\n  function rfc2616unquote(value) {\n    if (value.startsWith('\"')) {\n      const parts = value.slice(1).split('\\\\\"');\n      for (let i = 0; i < parts.length; ++i) {\n        const quotindex = parts[i].indexOf('\"');\n        if (quotindex !== -1) {\n          parts[i] = parts[i].slice(0, quotindex);\n          parts.length = i + 1;\n        }\n        parts[i] = parts[i].replaceAll(/\\\\(.)/g, \"$1\");\n      }\n      value = parts.join('\"');\n    }\n    return value;\n  }\n  function rfc5987decode(extvalue) {\n    const encodingend = extvalue.indexOf(\"'\");\n    if (encodingend === -1) {\n      return extvalue;\n    }\n    const encoding = extvalue.slice(0, encodingend);\n    const langvalue = extvalue.slice(encodingend + 1);\n    const value = langvalue.replace(/^[^']*'/, \"\");\n    return textdecode(encoding, value);\n  }\n  function rfc2047decode(value) {\n    if (!value.startsWith(\"=?\") || /[\\x00-\\x19\\x80-\\xff]/.test(value)) {\n      return value;\n    }\n    return value.replaceAll(/=\\?([\\w-]*)\\?([QqBb])\\?((?:[^?]|\\?(?!=))*)\\?=/g, function (matches, charset, encoding, text) {\n      if (encoding === \"q\" || encoding === \"Q\") {\n        text = text.replaceAll(\"_\", \" \");\n        text = text.replaceAll(/=([0-9a-fA-F]{2})/g, function (match, hex) {\n          return String.fromCharCode(parseInt(hex, 16));\n        });\n        return textdecode(charset, text);\n      }\n      try {\n        text = atob(text);\n      } catch {}\n      return textdecode(charset, text);\n    });\n  }\n  return \"\";\n}\n\n/***/ }),\n/* 184 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNetworkStream = void 0;\n__w_pdfjs_require__(89);\nvar _util = __w_pdfjs_require__(1);\nvar _network_utils = __w_pdfjs_require__(182);\n;\nconst OK_RESPONSE = 200;\nconst PARTIAL_CONTENT_RESPONSE = 206;\nfunction getArrayBuffer(xhr) {\n  const data = xhr.response;\n  if (typeof data !== \"string\") {\n    return data;\n  }\n  return (0, _util.stringToBytes)(data).buffer;\n}\nclass NetworkManager {\n  constructor(url) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.url = url;\n    this.isHttp = /^https?:/i.test(url);\n    this.httpHeaders = this.isHttp && args.httpHeaders || Object.create(null);\n    this.withCredentials = args.withCredentials || false;\n    this.currXhrId = 0;\n    this.pendingRequests = Object.create(null);\n  }\n  requestRange(begin, end, listeners) {\n    const args = {\n      begin,\n      end\n    };\n    for (const prop in listeners) {\n      args[prop] = listeners[prop];\n    }\n    return this.request(args);\n  }\n  requestFull(listeners) {\n    return this.request(listeners);\n  }\n  request(args) {\n    const xhr = new XMLHttpRequest();\n    const xhrId = this.currXhrId++;\n    const pendingRequest = this.pendingRequests[xhrId] = {\n      xhr\n    };\n    xhr.open(\"GET\", this.url);\n    xhr.withCredentials = this.withCredentials;\n    for (const property in this.httpHeaders) {\n      const value = this.httpHeaders[property];\n      if (value === undefined) {\n        continue;\n      }\n      xhr.setRequestHeader(property, value);\n    }\n    if (this.isHttp && \"begin\" in args && \"end\" in args) {\n      xhr.setRequestHeader(\"Range\", `bytes=${args.begin}-${args.end - 1}`);\n      pendingRequest.expectedStatus = PARTIAL_CONTENT_RESPONSE;\n    } else {\n      pendingRequest.expectedStatus = OK_RESPONSE;\n    }\n    xhr.responseType = \"arraybuffer\";\n    if (args.onError) {\n      xhr.onerror = function (evt) {\n        args.onError(xhr.status);\n      };\n    }\n    xhr.onreadystatechange = this.onStateChange.bind(this, xhrId);\n    xhr.onprogress = this.onProgress.bind(this, xhrId);\n    pendingRequest.onHeadersReceived = args.onHeadersReceived;\n    pendingRequest.onDone = args.onDone;\n    pendingRequest.onError = args.onError;\n    pendingRequest.onProgress = args.onProgress;\n    xhr.send(null);\n    return xhrId;\n  }\n  onProgress(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return;\n    }\n    pendingRequest.onProgress?.(evt);\n  }\n  onStateChange(xhrId, evt) {\n    const pendingRequest = this.pendingRequests[xhrId];\n    if (!pendingRequest) {\n      return;\n    }\n    const xhr = pendingRequest.xhr;\n    if (xhr.readyState >= 2 && pendingRequest.onHeadersReceived) {\n      pendingRequest.onHeadersReceived();\n      delete pendingRequest.onHeadersReceived;\n    }\n    if (xhr.readyState !== 4) {\n      return;\n    }\n    if (!(xhrId in this.pendingRequests)) {\n      return;\n    }\n    delete this.pendingRequests[xhrId];\n    if (xhr.status === 0 && this.isHttp) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n    const xhrStatus = xhr.status || OK_RESPONSE;\n    const ok_response_on_range_request = xhrStatus === OK_RESPONSE && pendingRequest.expectedStatus === PARTIAL_CONTENT_RESPONSE;\n    if (!ok_response_on_range_request && xhrStatus !== pendingRequest.expectedStatus) {\n      pendingRequest.onError?.(xhr.status);\n      return;\n    }\n    const chunk = getArrayBuffer(xhr);\n    if (xhrStatus === PARTIAL_CONTENT_RESPONSE) {\n      const rangeHeader = xhr.getResponseHeader(\"Content-Range\");\n      const matches = /bytes (\\d+)-(\\d+)\\/(\\d+)/.exec(rangeHeader);\n      pendingRequest.onDone({\n        begin: parseInt(matches[1], 10),\n        chunk\n      });\n    } else if (chunk) {\n      pendingRequest.onDone({\n        begin: 0,\n        chunk\n      });\n    } else {\n      pendingRequest.onError?.(xhr.status);\n    }\n  }\n  getRequestXhr(xhrId) {\n    return this.pendingRequests[xhrId].xhr;\n  }\n  isPendingRequest(xhrId) {\n    return xhrId in this.pendingRequests;\n  }\n  abortRequest(xhrId) {\n    const xhr = this.pendingRequests[xhrId].xhr;\n    delete this.pendingRequests[xhrId];\n    xhr.abort();\n  }\n}\nclass PDFNetworkStream {\n  constructor(source) {\n    this._source = source;\n    this._manager = new NetworkManager(source.url, {\n      httpHeaders: source.httpHeaders,\n      withCredentials: source.withCredentials\n    });\n    this._rangeChunkSize = source.rangeChunkSize;\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  _onRangeRequestReaderClosed(reader) {\n    const i = this._rangeRequestReaders.indexOf(reader);\n    if (i >= 0) {\n      this._rangeRequestReaders.splice(i, 1);\n    }\n  }\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNetworkStream.getFullReader can only be called once.\");\n    this._fullRequestReader = new PDFNetworkStreamFullRequestReader(this._manager, this._source);\n    return this._fullRequestReader;\n  }\n  getRangeReader(begin, end) {\n    const reader = new PDFNetworkStreamRangeRequestReader(this._manager, begin, end);\n    reader.onClosed = this._onRangeRequestReaderClosed.bind(this);\n    this._rangeRequestReaders.push(reader);\n    return reader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nexports.PDFNetworkStream = PDFNetworkStream;\nclass PDFNetworkStreamFullRequestReader {\n  constructor(manager, source) {\n    this._manager = manager;\n    const args = {\n      onHeadersReceived: this._onHeadersReceived.bind(this),\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = source.url;\n    this._fullRequestId = manager.requestFull(args);\n    this._headersReceivedCapability = new _util.PromiseCapability();\n    this._disableRange = source.disableRange || false;\n    this._contentLength = source.length;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._isStreamingSupported = false;\n    this._isRangeSupported = false;\n    this._cachedChunks = [];\n    this._requests = [];\n    this._done = false;\n    this._storedError = undefined;\n    this._filename = null;\n    this.onProgress = null;\n  }\n  _onHeadersReceived() {\n    const fullRequestXhrId = this._fullRequestId;\n    const fullRequestXhr = this._manager.getRequestXhr(fullRequestXhrId);\n    const getResponseHeader = name => {\n      return fullRequestXhr.getResponseHeader(name);\n    };\n    const {\n      allowRangeRequests,\n      suggestedLength\n    } = (0, _network_utils.validateRangeRequestCapabilities)({\n      getResponseHeader,\n      isHttp: this._manager.isHttp,\n      rangeChunkSize: this._rangeChunkSize,\n      disableRange: this._disableRange\n    });\n    if (allowRangeRequests) {\n      this._isRangeSupported = true;\n    }\n    this._contentLength = suggestedLength || this._contentLength;\n    this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    if (this._isRangeSupported) {\n      this._manager.abortRequest(fullRequestXhrId);\n    }\n    this._headersReceivedCapability.resolve();\n  }\n  _onDone(data) {\n    if (data) {\n      if (this._requests.length > 0) {\n        const requestCapability = this._requests.shift();\n        requestCapability.resolve({\n          value: data.chunk,\n          done: false\n        });\n      } else {\n        this._cachedChunks.push(data.chunk);\n      }\n    }\n    this._done = true;\n    if (this._cachedChunks.length > 0) {\n      return;\n    }\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n  }\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n    this._headersReceivedCapability.reject(this._storedError);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._cachedChunks.length = 0;\n  }\n  _onProgress(evt) {\n    this.onProgress?.({\n      loaded: evt.loaded,\n      total: evt.lengthComputable ? evt.total : this._contentLength\n    });\n  }\n  get filename() {\n    return this._filename;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get headersReady() {\n    return this._headersReceivedCapability.promise;\n  }\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._cachedChunks.length > 0) {\n      const chunk = this._cachedChunks.shift();\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = new _util.PromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    this._headersReceivedCapability.reject(reason);\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._fullRequestId)) {\n      this._manager.abortRequest(this._fullRequestId);\n    }\n    this._fullRequestReader = null;\n  }\n}\nclass PDFNetworkStreamRangeRequestReader {\n  constructor(manager, begin, end) {\n    this._manager = manager;\n    const args = {\n      onDone: this._onDone.bind(this),\n      onError: this._onError.bind(this),\n      onProgress: this._onProgress.bind(this)\n    };\n    this._url = manager.url;\n    this._requestId = manager.requestRange(begin, end, args);\n    this._requests = [];\n    this._queuedChunk = null;\n    this._done = false;\n    this._storedError = undefined;\n    this.onProgress = null;\n    this.onClosed = null;\n  }\n  _close() {\n    this.onClosed?.(this);\n  }\n  _onDone(data) {\n    const chunk = data.chunk;\n    if (this._requests.length > 0) {\n      const requestCapability = this._requests.shift();\n      requestCapability.resolve({\n        value: chunk,\n        done: false\n      });\n    } else {\n      this._queuedChunk = chunk;\n    }\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    this._close();\n  }\n  _onError(status) {\n    this._storedError = (0, _network_utils.createResponseStatusError)(status, this._url);\n    for (const requestCapability of this._requests) {\n      requestCapability.reject(this._storedError);\n    }\n    this._requests.length = 0;\n    this._queuedChunk = null;\n  }\n  _onProgress(evt) {\n    if (!this.isStreamingSupported) {\n      this.onProgress?.({\n        loaded: evt.loaded\n      });\n    }\n  }\n  get isStreamingSupported() {\n    return false;\n  }\n  async read() {\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    if (this._queuedChunk !== null) {\n      const chunk = this._queuedChunk;\n      this._queuedChunk = null;\n      return {\n        value: chunk,\n        done: false\n      };\n    }\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    const requestCapability = new _util.PromiseCapability();\n    this._requests.push(requestCapability);\n    return requestCapability.promise;\n  }\n  cancel(reason) {\n    this._done = true;\n    for (const requestCapability of this._requests) {\n      requestCapability.resolve({\n        value: undefined,\n        done: true\n      });\n    }\n    this._requests.length = 0;\n    if (this._manager.isPendingRequest(this._requestId)) {\n      this._manager.abortRequest(this._requestId);\n    }\n    this._close();\n  }\n}\n\n/***/ }),\n/* 185 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.PDFNodeStream = void 0;\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\nvar _util = __w_pdfjs_require__(1);\nvar _network_utils = __w_pdfjs_require__(182);\n;\nconst fileUriRegex = /^file:\\/\\/\\/[a-zA-Z]:\\//;\nfunction parseUrl(sourceUrl) {\n  const url = __webpack_require__(/*! url */ \"url\");\n  const parsedUrl = url.parse(sourceUrl);\n  if (parsedUrl.protocol === \"file:\" || parsedUrl.host) {\n    return parsedUrl;\n  }\n  if (/^[a-z]:[/\\\\]/i.test(sourceUrl)) {\n    return url.parse(`file:///${sourceUrl}`);\n  }\n  if (!parsedUrl.host) {\n    parsedUrl.protocol = \"file:\";\n  }\n  return parsedUrl;\n}\nclass PDFNodeStream {\n  constructor(source) {\n    this.source = source;\n    this.url = parseUrl(source.url);\n    this.isHttp = this.url.protocol === \"http:\" || this.url.protocol === \"https:\";\n    this.isFsUrl = this.url.protocol === \"file:\";\n    this.httpHeaders = this.isHttp && source.httpHeaders || {};\n    this._fullRequestReader = null;\n    this._rangeRequestReaders = [];\n  }\n  get _progressiveDataLength() {\n    return this._fullRequestReader?._loaded ?? 0;\n  }\n  getFullReader() {\n    (0, _util.assert)(!this._fullRequestReader, \"PDFNodeStream.getFullReader can only be called once.\");\n    this._fullRequestReader = this.isFsUrl ? new PDFNodeStreamFsFullReader(this) : new PDFNodeStreamFullReader(this);\n    return this._fullRequestReader;\n  }\n  getRangeReader(start, end) {\n    if (end <= this._progressiveDataLength) {\n      return null;\n    }\n    const rangeReader = this.isFsUrl ? new PDFNodeStreamFsRangeReader(this, start, end) : new PDFNodeStreamRangeReader(this, start, end);\n    this._rangeRequestReaders.push(rangeReader);\n    return rangeReader;\n  }\n  cancelAllRequests(reason) {\n    this._fullRequestReader?.cancel(reason);\n    for (const reader of this._rangeRequestReaders.slice(0)) {\n      reader.cancel(reason);\n    }\n  }\n}\nexports.PDFNodeStream = PDFNodeStream;\nclass BaseFullReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    const source = stream.source;\n    this._contentLength = source.length;\n    this._loaded = 0;\n    this._filename = null;\n    this._disableRange = source.disableRange || false;\n    this._rangeChunkSize = source.rangeChunkSize;\n    if (!this._rangeChunkSize && !this._disableRange) {\n      this._disableRange = true;\n    }\n    this._isStreamingSupported = !source.disableStream;\n    this._isRangeSupported = !source.disableRange;\n    this._readableStream = null;\n    this._readCapability = new _util.PromiseCapability();\n    this._headersCapability = new _util.PromiseCapability();\n  }\n  get headersReady() {\n    return this._headersCapability.promise;\n  }\n  get filename() {\n    return this._filename;\n  }\n  get contentLength() {\n    return this._contentLength;\n  }\n  get isRangeSupported() {\n    return this._isRangeSupported;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = new _util.PromiseCapability();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    this.onProgress?.({\n      loaded: this._loaded,\n      total: this._contentLength\n    });\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n    if (!this._isStreamingSupported && this._isRangeSupported) {\n      this._error(new _util.AbortException(\"streaming is disabled\"));\n    }\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\nclass BaseRangeReader {\n  constructor(stream) {\n    this._url = stream.url;\n    this._done = false;\n    this._storedError = null;\n    this.onProgress = null;\n    this._loaded = 0;\n    this._readableStream = null;\n    this._readCapability = new _util.PromiseCapability();\n    const source = stream.source;\n    this._isStreamingSupported = !source.disableStream;\n  }\n  get isStreamingSupported() {\n    return this._isStreamingSupported;\n  }\n  async read() {\n    await this._readCapability.promise;\n    if (this._done) {\n      return {\n        value: undefined,\n        done: true\n      };\n    }\n    if (this._storedError) {\n      throw this._storedError;\n    }\n    const chunk = this._readableStream.read();\n    if (chunk === null) {\n      this._readCapability = new _util.PromiseCapability();\n      return this.read();\n    }\n    this._loaded += chunk.length;\n    this.onProgress?.({\n      loaded: this._loaded\n    });\n    const buffer = new Uint8Array(chunk).buffer;\n    return {\n      value: buffer,\n      done: false\n    };\n  }\n  cancel(reason) {\n    if (!this._readableStream) {\n      this._error(reason);\n      return;\n    }\n    this._readableStream.destroy(reason);\n  }\n  _error(reason) {\n    this._storedError = reason;\n    this._readCapability.resolve();\n  }\n  _setReadableStream(readableStream) {\n    this._readableStream = readableStream;\n    readableStream.on(\"readable\", () => {\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"end\", () => {\n      readableStream.destroy();\n      this._done = true;\n      this._readCapability.resolve();\n    });\n    readableStream.on(\"error\", reason => {\n      this._error(reason);\n    });\n    if (this._storedError) {\n      this._readableStream.destroy(this._storedError);\n    }\n  }\n}\nfunction createRequestOptions(parsedUrl, headers) {\n  return {\n    protocol: parsedUrl.protocol,\n    auth: parsedUrl.auth,\n    host: parsedUrl.hostname,\n    port: parsedUrl.port,\n    path: parsedUrl.path,\n    method: \"GET\",\n    headers\n  };\n}\nclass PDFNodeStreamFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        this._headersCapability.reject(error);\n        return;\n      }\n      this._headersCapability.resolve();\n      this._setReadableStream(response);\n      const getResponseHeader = name => {\n        return this._readableStream.headers[name.toLowerCase()];\n      };\n      const {\n        allowRangeRequests,\n        suggestedLength\n      } = (0, _network_utils.validateRangeRequestCapabilities)({\n        getResponseHeader,\n        isHttp: stream.isHttp,\n        rangeChunkSize: this._rangeChunkSize,\n        disableRange: this._disableRange\n      });\n      this._isRangeSupported = allowRangeRequests;\n      this._contentLength = suggestedLength || this._contentLength;\n      this._filename = (0, _network_utils.extractFilenameFromHeader)(getResponseHeader);\n    };\n    this._request = null;\n    if (this._url.protocol === \"http:\") {\n      const http = __webpack_require__(/*! http */ \"http\");\n      this._request = http.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    } else {\n      const https = __webpack_require__(/*! https */ \"https\");\n      this._request = https.request(createRequestOptions(this._url, stream.httpHeaders), handleResponse);\n    }\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n      this._headersCapability.reject(reason);\n    });\n    this._request.end();\n  }\n}\nclass PDFNodeStreamRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    this._httpHeaders = {};\n    for (const property in stream.httpHeaders) {\n      const value = stream.httpHeaders[property];\n      if (value === undefined) {\n        continue;\n      }\n      this._httpHeaders[property] = value;\n    }\n    this._httpHeaders.Range = `bytes=${start}-${end - 1}`;\n    const handleResponse = response => {\n      if (response.statusCode === 404) {\n        const error = new _util.MissingPDFException(`Missing PDF \"${this._url}\".`);\n        this._storedError = error;\n        return;\n      }\n      this._setReadableStream(response);\n    };\n    this._request = null;\n    if (this._url.protocol === \"http:\") {\n      const http = __webpack_require__(/*! http */ \"http\");\n      this._request = http.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    } else {\n      const https = __webpack_require__(/*! https */ \"https\");\n      this._request = https.request(createRequestOptions(this._url, this._httpHeaders), handleResponse);\n    }\n    this._request.on(\"error\", reason => {\n      this._storedError = reason;\n    });\n    this._request.end();\n  }\n}\nclass PDFNodeStreamFsFullReader extends BaseFullReader {\n  constructor(stream) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n    const fs = __webpack_require__(/*! fs */ \"fs\");\n    fs.lstat(path, (error, stat) => {\n      if (error) {\n        if (error.code === \"ENOENT\") {\n          error = new _util.MissingPDFException(`Missing PDF \"${path}\".`);\n        }\n        this._storedError = error;\n        this._headersCapability.reject(error);\n        return;\n      }\n      this._contentLength = stat.size;\n      this._setReadableStream(fs.createReadStream(path));\n      this._headersCapability.resolve();\n    });\n  }\n}\nclass PDFNodeStreamFsRangeReader extends BaseRangeReader {\n  constructor(stream, start, end) {\n    super(stream);\n    let path = decodeURIComponent(this._url.path);\n    if (fileUriRegex.test(this._url.href)) {\n      path = path.replace(/^\\//, \"\");\n    }\n    const fs = __webpack_require__(/*! fs */ \"fs\");\n    this._setReadableStream(fs.createReadStream(path, {\n      start,\n      end: end - 1\n    }));\n  }\n}\n\n/***/ }),\n/* 186 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.SVGGraphics = void 0;\n__w_pdfjs_require__(84);\n__w_pdfjs_require__(86);\n__w_pdfjs_require__(87);\n__w_pdfjs_require__(93);\n__w_pdfjs_require__(101);\n__w_pdfjs_require__(102);\n__w_pdfjs_require__(105);\n__w_pdfjs_require__(107);\n__w_pdfjs_require__(109);\n__w_pdfjs_require__(113);\n__w_pdfjs_require__(116);\n__w_pdfjs_require__(123);\n__w_pdfjs_require__(2);\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(187);\nvar _display_utils = __w_pdfjs_require__(168);\nvar _util = __w_pdfjs_require__(1);\n;\nconst SVG_DEFAULTS = {\n  fontStyle: \"normal\",\n  fontWeight: \"normal\",\n  fillColor: \"#000000\"\n};\nconst XML_NS = \"http://www.w3.org/XML/1998/namespace\";\nconst XLINK_NS = \"http://www.w3.org/1999/xlink\";\nconst LINE_CAP_STYLES = [\"butt\", \"round\", \"square\"];\nconst LINE_JOIN_STYLES = [\"miter\", \"round\", \"bevel\"];\nconst createObjectURL = function (data) {\n  let contentType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"\";\n  let forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n  if (URL.createObjectURL && typeof Blob !== \"undefined\" && !forceDataSchema) {\n    return URL.createObjectURL(new Blob([data], {\n      type: contentType\n    }));\n  }\n  const digits = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\";\n  let buffer = `data:${contentType};base64,`;\n  for (let i = 0, ii = data.length; i < ii; i += 3) {\n    const b1 = data[i] & 0xff;\n    const b2 = data[i + 1] & 0xff;\n    const b3 = data[i + 2] & 0xff;\n    const d1 = b1 >> 2,\n      d2 = (b1 & 3) << 4 | b2 >> 4;\n    const d3 = i + 1 < ii ? (b2 & 0xf) << 2 | b3 >> 6 : 64;\n    const d4 = i + 2 < ii ? b3 & 0x3f : 64;\n    buffer += digits[d1] + digits[d2] + digits[d3] + digits[d4];\n  }\n  return buffer;\n};\nconst convertImgDataToPng = function () {\n  const PNG_HEADER = new Uint8Array([0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a]);\n  const CHUNK_WRAPPER_SIZE = 12;\n  const crcTable = new Int32Array(256);\n  for (let i = 0; i < 256; i++) {\n    let c = i;\n    for (let h = 0; h < 8; h++) {\n      c = c & 1 ? 0xedb88320 ^ c >> 1 & 0x7fffffff : c >> 1 & 0x7fffffff;\n    }\n    crcTable[i] = c;\n  }\n  function crc32(data, start, end) {\n    let crc = -1;\n    for (let i = start; i < end; i++) {\n      const a = (crc ^ data[i]) & 0xff;\n      const b = crcTable[a];\n      crc = crc >>> 8 ^ b;\n    }\n    return crc ^ -1;\n  }\n  function writePngChunk(type, body, data, offset) {\n    let p = offset;\n    const len = body.length;\n    data[p] = len >> 24 & 0xff;\n    data[p + 1] = len >> 16 & 0xff;\n    data[p + 2] = len >> 8 & 0xff;\n    data[p + 3] = len & 0xff;\n    p += 4;\n    data[p] = type.charCodeAt(0) & 0xff;\n    data[p + 1] = type.charCodeAt(1) & 0xff;\n    data[p + 2] = type.charCodeAt(2) & 0xff;\n    data[p + 3] = type.charCodeAt(3) & 0xff;\n    p += 4;\n    data.set(body, p);\n    p += body.length;\n    const crc = crc32(data, offset + 4, p);\n    data[p] = crc >> 24 & 0xff;\n    data[p + 1] = crc >> 16 & 0xff;\n    data[p + 2] = crc >> 8 & 0xff;\n    data[p + 3] = crc & 0xff;\n  }\n  function adler32(data, start, end) {\n    let a = 1;\n    let b = 0;\n    for (let i = start; i < end; ++i) {\n      a = (a + (data[i] & 0xff)) % 65521;\n      b = (b + a) % 65521;\n    }\n    return b << 16 | a;\n  }\n  function deflateSync(literals) {\n    if (!_util.isNodeJS) {\n      return deflateSyncUncompressed(literals);\n    }\n    try {\n      const input = parseInt(process.versions.node) >= 8 ? literals : Buffer.from(literals);\n      const output = (__webpack_require__(/*! zlib */ \"zlib\").deflateSync)(input, {\n        level: 9\n      });\n      return output instanceof Uint8Array ? output : new Uint8Array(output);\n    } catch (e) {\n      (0, _util.warn)(\"Not compressing PNG because zlib.deflateSync is unavailable: \" + e);\n    }\n    return deflateSyncUncompressed(literals);\n  }\n  function deflateSyncUncompressed(literals) {\n    let len = literals.length;\n    const maxBlockLength = 0xffff;\n    const deflateBlocks = Math.ceil(len / maxBlockLength);\n    const idat = new Uint8Array(2 + len + deflateBlocks * 5 + 4);\n    let pi = 0;\n    idat[pi++] = 0x78;\n    idat[pi++] = 0x9c;\n    let pos = 0;\n    while (len > maxBlockLength) {\n      idat[pi++] = 0x00;\n      idat[pi++] = 0xff;\n      idat[pi++] = 0xff;\n      idat[pi++] = 0x00;\n      idat[pi++] = 0x00;\n      idat.set(literals.subarray(pos, pos + maxBlockLength), pi);\n      pi += maxBlockLength;\n      pos += maxBlockLength;\n      len -= maxBlockLength;\n    }\n    idat[pi++] = 0x01;\n    idat[pi++] = len & 0xff;\n    idat[pi++] = len >> 8 & 0xff;\n    idat[pi++] = ~len & 0xffff & 0xff;\n    idat[pi++] = (~len & 0xffff) >> 8 & 0xff;\n    idat.set(literals.subarray(pos), pi);\n    pi += literals.length - pos;\n    const adler = adler32(literals, 0, literals.length);\n    idat[pi++] = adler >> 24 & 0xff;\n    idat[pi++] = adler >> 16 & 0xff;\n    idat[pi++] = adler >> 8 & 0xff;\n    idat[pi++] = adler & 0xff;\n    return idat;\n  }\n  function encode(imgData, kind, forceDataSchema, isMask) {\n    const width = imgData.width;\n    const height = imgData.height;\n    let bitDepth, colorType, lineSize;\n    const bytes = imgData.data;\n    switch (kind) {\n      case _util.ImageKind.GRAYSCALE_1BPP:\n        colorType = 0;\n        bitDepth = 1;\n        lineSize = width + 7 >> 3;\n        break;\n      case _util.ImageKind.RGB_24BPP:\n        colorType = 2;\n        bitDepth = 8;\n        lineSize = width * 3;\n        break;\n      case _util.ImageKind.RGBA_32BPP:\n        colorType = 6;\n        bitDepth = 8;\n        lineSize = width * 4;\n        break;\n      default:\n        throw new Error(\"invalid format\");\n    }\n    const literals = new Uint8Array((1 + lineSize) * height);\n    let offsetLiterals = 0,\n      offsetBytes = 0;\n    for (let y = 0; y < height; ++y) {\n      literals[offsetLiterals++] = 0;\n      literals.set(bytes.subarray(offsetBytes, offsetBytes + lineSize), offsetLiterals);\n      offsetBytes += lineSize;\n      offsetLiterals += lineSize;\n    }\n    if (kind === _util.ImageKind.GRAYSCALE_1BPP && isMask) {\n      offsetLiterals = 0;\n      for (let y = 0; y < height; y++) {\n        offsetLiterals++;\n        for (let i = 0; i < lineSize; i++) {\n          literals[offsetLiterals++] ^= 0xff;\n        }\n      }\n    }\n    const ihdr = new Uint8Array([width >> 24 & 0xff, width >> 16 & 0xff, width >> 8 & 0xff, width & 0xff, height >> 24 & 0xff, height >> 16 & 0xff, height >> 8 & 0xff, height & 0xff, bitDepth, colorType, 0x00, 0x00, 0x00]);\n    const idat = deflateSync(literals);\n    const pngLength = PNG_HEADER.length + CHUNK_WRAPPER_SIZE * 3 + ihdr.length + idat.length;\n    const data = new Uint8Array(pngLength);\n    let offset = 0;\n    data.set(PNG_HEADER, offset);\n    offset += PNG_HEADER.length;\n    writePngChunk(\"IHDR\", ihdr, data, offset);\n    offset += CHUNK_WRAPPER_SIZE + ihdr.length;\n    writePngChunk(\"IDATA\", idat, data, offset);\n    offset += CHUNK_WRAPPER_SIZE + idat.length;\n    writePngChunk(\"IEND\", new Uint8Array(0), data, offset);\n    return createObjectURL(data, \"image/png\", forceDataSchema);\n  }\n  return function convertImgDataToPng(imgData, forceDataSchema, isMask) {\n    const kind = imgData.kind === undefined ? _util.ImageKind.GRAYSCALE_1BPP : imgData.kind;\n    return encode(imgData, kind, forceDataSchema, isMask);\n  };\n}();\nclass SVGExtraState {\n  constructor() {\n    this.fontSizeScale = 1;\n    this.fontWeight = SVG_DEFAULTS.fontWeight;\n    this.fontSize = 0;\n    this.textMatrix = _util.IDENTITY_MATRIX;\n    this.fontMatrix = _util.FONT_IDENTITY_MATRIX;\n    this.leading = 0;\n    this.textRenderingMode = _util.TextRenderingMode.FILL;\n    this.textMatrixScale = 1;\n    this.x = 0;\n    this.y = 0;\n    this.lineX = 0;\n    this.lineY = 0;\n    this.charSpacing = 0;\n    this.wordSpacing = 0;\n    this.textHScale = 1;\n    this.textRise = 0;\n    this.fillColor = SVG_DEFAULTS.fillColor;\n    this.strokeColor = \"#000000\";\n    this.fillAlpha = 1;\n    this.strokeAlpha = 1;\n    this.lineWidth = 1;\n    this.lineJoin = \"\";\n    this.lineCap = \"\";\n    this.miterLimit = 0;\n    this.dashArray = [];\n    this.dashPhase = 0;\n    this.dependencies = [];\n    this.activeClipUrl = null;\n    this.clipGroup = null;\n    this.maskId = \"\";\n  }\n  clone() {\n    return Object.create(this);\n  }\n  setCurrentPoint(x, y) {\n    this.x = x;\n    this.y = y;\n  }\n}\nfunction opListToTree(opList) {\n  let opTree = [];\n  const tmp = [];\n  for (const opListElement of opList) {\n    if (opListElement.fn === \"save\") {\n      opTree.push({\n        fnId: 92,\n        fn: \"group\",\n        items: []\n      });\n      tmp.push(opTree);\n      opTree = opTree.at(-1).items;\n      continue;\n    }\n    if (opListElement.fn === \"restore\") {\n      opTree = tmp.pop();\n    } else {\n      opTree.push(opListElement);\n    }\n  }\n  return opTree;\n}\nfunction pf(value) {\n  if (Number.isInteger(value)) {\n    return value.toString();\n  }\n  const s = value.toFixed(10);\n  let i = s.length - 1;\n  if (s[i] !== \"0\") {\n    return s;\n  }\n  do {\n    i--;\n  } while (s[i] === \"0\");\n  return s.substring(0, s[i] === \".\" ? i : i + 1);\n}\nfunction pm(m) {\n  if (m[4] === 0 && m[5] === 0) {\n    if (m[1] === 0 && m[2] === 0) {\n      if (m[0] === 1 && m[3] === 1) {\n        return \"\";\n      }\n      return `scale(${pf(m[0])} ${pf(m[3])})`;\n    }\n    if (m[0] === m[3] && m[1] === -m[2]) {\n      const a = Math.acos(m[0]) * 180 / Math.PI;\n      return `rotate(${pf(a)})`;\n    }\n  } else if (m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1) {\n    return `translate(${pf(m[4])} ${pf(m[5])})`;\n  }\n  return `matrix(${pf(m[0])} ${pf(m[1])} ${pf(m[2])} ${pf(m[3])} ${pf(m[4])} ` + `${pf(m[5])})`;\n}\nlet clipCount = 0;\nlet maskCount = 0;\nlet shadingCount = 0;\nclass SVGGraphics {\n  constructor(commonObjs, objs) {\n    let forceDataSchema = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n    (0, _display_utils.deprecated)(\"The SVG back-end is no longer maintained and *may* be removed in the future.\");\n    this.svgFactory = new _display_utils.DOMSVGFactory();\n    this.current = new SVGExtraState();\n    this.transformMatrix = _util.IDENTITY_MATRIX;\n    this.transformStack = [];\n    this.extraStack = [];\n    this.commonObjs = commonObjs;\n    this.objs = objs;\n    this.pendingClip = null;\n    this.pendingEOFill = false;\n    this.embedFonts = false;\n    this.embeddedFonts = Object.create(null);\n    this.cssStyle = null;\n    this.forceDataSchema = !!forceDataSchema;\n    this._operatorIdMapping = [];\n    for (const op in _util.OPS) {\n      this._operatorIdMapping[_util.OPS[op]] = op;\n    }\n  }\n  getObject(data) {\n    let fallback = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (typeof data === \"string\") {\n      return data.startsWith(\"g_\") ? this.commonObjs.get(data) : this.objs.get(data);\n    }\n    return fallback;\n  }\n  save() {\n    this.transformStack.push(this.transformMatrix);\n    const old = this.current;\n    this.extraStack.push(old);\n    this.current = old.clone();\n  }\n  restore() {\n    this.transformMatrix = this.transformStack.pop();\n    this.current = this.extraStack.pop();\n    this.pendingClip = null;\n    this.tgrp = null;\n  }\n  group(items) {\n    this.save();\n    this.executeOpTree(items);\n    this.restore();\n  }\n  loadDependencies(operatorList) {\n    const fnArray = operatorList.fnArray;\n    const argsArray = operatorList.argsArray;\n    for (let i = 0, ii = fnArray.length; i < ii; i++) {\n      if (fnArray[i] !== _util.OPS.dependency) {\n        continue;\n      }\n      for (const obj of argsArray[i]) {\n        const objsPool = obj.startsWith(\"g_\") ? this.commonObjs : this.objs;\n        const promise = new Promise(resolve => {\n          objsPool.get(obj, resolve);\n        });\n        this.current.dependencies.push(promise);\n      }\n    }\n    return Promise.all(this.current.dependencies);\n  }\n  transform(a, b, c, d, e, f) {\n    const transformMatrix = [a, b, c, d, e, f];\n    this.transformMatrix = _util.Util.transform(this.transformMatrix, transformMatrix);\n    this.tgrp = null;\n  }\n  getSVG(operatorList, viewport) {\n    this.viewport = viewport;\n    const svgElement = this._initialize(viewport);\n    return this.loadDependencies(operatorList).then(() => {\n      this.transformMatrix = _util.IDENTITY_MATRIX;\n      this.executeOpTree(this.convertOpList(operatorList));\n      return svgElement;\n    });\n  }\n  convertOpList(operatorList) {\n    const operatorIdMapping = this._operatorIdMapping;\n    const argsArray = operatorList.argsArray;\n    const fnArray = operatorList.fnArray;\n    const opList = [];\n    for (let i = 0, ii = fnArray.length; i < ii; i++) {\n      const fnId = fnArray[i];\n      opList.push({\n        fnId,\n        fn: operatorIdMapping[fnId],\n        args: argsArray[i]\n      });\n    }\n    return opListToTree(opList);\n  }\n  executeOpTree(opTree) {\n    for (const opTreeElement of opTree) {\n      const fn = opTreeElement.fn;\n      const fnId = opTreeElement.fnId;\n      const args = opTreeElement.args;\n      switch (fnId | 0) {\n        case _util.OPS.beginText:\n          this.beginText();\n          break;\n        case _util.OPS.dependency:\n          break;\n        case _util.OPS.setLeading:\n          this.setLeading(args);\n          break;\n        case _util.OPS.setLeadingMoveText:\n          this.setLeadingMoveText(args[0], args[1]);\n          break;\n        case _util.OPS.setFont:\n          this.setFont(args);\n          break;\n        case _util.OPS.showText:\n          this.showText(args[0]);\n          break;\n        case _util.OPS.showSpacedText:\n          this.showText(args[0]);\n          break;\n        case _util.OPS.endText:\n          this.endText();\n          break;\n        case _util.OPS.moveText:\n          this.moveText(args[0], args[1]);\n          break;\n        case _util.OPS.setCharSpacing:\n          this.setCharSpacing(args[0]);\n          break;\n        case _util.OPS.setWordSpacing:\n          this.setWordSpacing(args[0]);\n          break;\n        case _util.OPS.setHScale:\n          this.setHScale(args[0]);\n          break;\n        case _util.OPS.setTextMatrix:\n          this.setTextMatrix(args[0], args[1], args[2], args[3], args[4], args[5]);\n          break;\n        case _util.OPS.setTextRise:\n          this.setTextRise(args[0]);\n          break;\n        case _util.OPS.setTextRenderingMode:\n          this.setTextRenderingMode(args[0]);\n          break;\n        case _util.OPS.setLineWidth:\n          this.setLineWidth(args[0]);\n          break;\n        case _util.OPS.setLineJoin:\n          this.setLineJoin(args[0]);\n          break;\n        case _util.OPS.setLineCap:\n          this.setLineCap(args[0]);\n          break;\n        case _util.OPS.setMiterLimit:\n          this.setMiterLimit(args[0]);\n          break;\n        case _util.OPS.setFillRGBColor:\n          this.setFillRGBColor(args[0], args[1], args[2]);\n          break;\n        case _util.OPS.setStrokeRGBColor:\n          this.setStrokeRGBColor(args[0], args[1], args[2]);\n          break;\n        case _util.OPS.setStrokeColorN:\n          this.setStrokeColorN(args);\n          break;\n        case _util.OPS.setFillColorN:\n          this.setFillColorN(args);\n          break;\n        case _util.OPS.shadingFill:\n          this.shadingFill(args[0]);\n          break;\n        case _util.OPS.setDash:\n          this.setDash(args[0], args[1]);\n          break;\n        case _util.OPS.setRenderingIntent:\n          this.setRenderingIntent(args[0]);\n          break;\n        case _util.OPS.setFlatness:\n          this.setFlatness(args[0]);\n          break;\n        case _util.OPS.setGState:\n          this.setGState(args[0]);\n          break;\n        case _util.OPS.fill:\n          this.fill();\n          break;\n        case _util.OPS.eoFill:\n          this.eoFill();\n          break;\n        case _util.OPS.stroke:\n          this.stroke();\n          break;\n        case _util.OPS.fillStroke:\n          this.fillStroke();\n          break;\n        case _util.OPS.eoFillStroke:\n          this.eoFillStroke();\n          break;\n        case _util.OPS.clip:\n          this.clip(\"nonzero\");\n          break;\n        case _util.OPS.eoClip:\n          this.clip(\"evenodd\");\n          break;\n        case _util.OPS.paintSolidColorImageMask:\n          this.paintSolidColorImageMask();\n          break;\n        case _util.OPS.paintImageXObject:\n          this.paintImageXObject(args[0]);\n          break;\n        case _util.OPS.paintInlineImageXObject:\n          this.paintInlineImageXObject(args[0]);\n          break;\n        case _util.OPS.paintImageMaskXObject:\n          this.paintImageMaskXObject(args[0]);\n          break;\n        case _util.OPS.paintFormXObjectBegin:\n          this.paintFormXObjectBegin(args[0], args[1]);\n          break;\n        case _util.OPS.paintFormXObjectEnd:\n          this.paintFormXObjectEnd();\n          break;\n        case _util.OPS.closePath:\n          this.closePath();\n          break;\n        case _util.OPS.closeStroke:\n          this.closeStroke();\n          break;\n        case _util.OPS.closeFillStroke:\n          this.closeFillStroke();\n          break;\n        case _util.OPS.closeEOFillStroke:\n          this.closeEOFillStroke();\n          break;\n        case _util.OPS.nextLine:\n          this.nextLine();\n          break;\n        case _util.OPS.transform:\n          this.transform(args[0], args[1], args[2], args[3], args[4], args[5]);\n          break;\n        case _util.OPS.constructPath:\n          this.constructPath(args[0], args[1]);\n          break;\n        case _util.OPS.endPath:\n          this.endPath();\n          break;\n        case 92:\n          this.group(opTreeElement.items);\n          break;\n        default:\n          (0, _util.warn)(`Unimplemented operator ${fn}`);\n          break;\n      }\n    }\n  }\n  setWordSpacing(wordSpacing) {\n    this.current.wordSpacing = wordSpacing;\n  }\n  setCharSpacing(charSpacing) {\n    this.current.charSpacing = charSpacing;\n  }\n  nextLine() {\n    this.moveText(0, this.current.leading);\n  }\n  setTextMatrix(a, b, c, d, e, f) {\n    const current = this.current;\n    current.textMatrix = current.lineMatrix = [a, b, c, d, e, f];\n    current.textMatrixScale = Math.hypot(a, b);\n    current.x = current.lineX = 0;\n    current.y = current.lineY = 0;\n    current.xcoords = [];\n    current.ycoords = [];\n    current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n    current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n    current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n    current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    current.txtElement = this.svgFactory.createElement(\"svg:text\");\n    current.txtElement.append(current.tspan);\n  }\n  beginText() {\n    const current = this.current;\n    current.x = current.lineX = 0;\n    current.y = current.lineY = 0;\n    current.textMatrix = _util.IDENTITY_MATRIX;\n    current.lineMatrix = _util.IDENTITY_MATRIX;\n    current.textMatrixScale = 1;\n    current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n    current.txtElement = this.svgFactory.createElement(\"svg:text\");\n    current.txtgrp = this.svgFactory.createElement(\"svg:g\");\n    current.xcoords = [];\n    current.ycoords = [];\n  }\n  moveText(x, y) {\n    const current = this.current;\n    current.x = current.lineX += x;\n    current.y = current.lineY += y;\n    current.xcoords = [];\n    current.ycoords = [];\n    current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n    current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n    current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n    current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n  }\n  showText(glyphs) {\n    const current = this.current;\n    const font = current.font;\n    const fontSize = current.fontSize;\n    if (fontSize === 0) {\n      return;\n    }\n    const fontSizeScale = current.fontSizeScale;\n    const charSpacing = current.charSpacing;\n    const wordSpacing = current.wordSpacing;\n    const fontDirection = current.fontDirection;\n    const textHScale = current.textHScale * fontDirection;\n    const vertical = font.vertical;\n    const spacingDir = vertical ? 1 : -1;\n    const defaultVMetrics = font.defaultVMetrics;\n    const widthAdvanceScale = fontSize * current.fontMatrix[0];\n    let x = 0;\n    for (const glyph of glyphs) {\n      if (glyph === null) {\n        x += fontDirection * wordSpacing;\n        continue;\n      } else if (typeof glyph === \"number\") {\n        x += spacingDir * glyph * fontSize / 1000;\n        continue;\n      }\n      const spacing = (glyph.isSpace ? wordSpacing : 0) + charSpacing;\n      const character = glyph.fontChar;\n      let scaledX, scaledY;\n      let width = glyph.width;\n      if (vertical) {\n        let vx;\n        const vmetric = glyph.vmetric || defaultVMetrics;\n        vx = glyph.vmetric ? vmetric[1] : width * 0.5;\n        vx = -vx * widthAdvanceScale;\n        const vy = vmetric[2] * widthAdvanceScale;\n        width = vmetric ? -vmetric[0] : width;\n        scaledX = vx / fontSizeScale;\n        scaledY = (x + vy) / fontSizeScale;\n      } else {\n        scaledX = x / fontSizeScale;\n        scaledY = 0;\n      }\n      if (glyph.isInFont || font.missingFile) {\n        current.xcoords.push(current.x + scaledX);\n        if (vertical) {\n          current.ycoords.push(-current.y + scaledY);\n        }\n        current.tspan.textContent += character;\n      } else {}\n      const charWidth = vertical ? width * widthAdvanceScale - spacing * fontDirection : width * widthAdvanceScale + spacing * fontDirection;\n      x += charWidth;\n    }\n    current.tspan.setAttributeNS(null, \"x\", current.xcoords.map(pf).join(\" \"));\n    if (vertical) {\n      current.tspan.setAttributeNS(null, \"y\", current.ycoords.map(pf).join(\" \"));\n    } else {\n      current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    }\n    if (vertical) {\n      current.y -= x;\n    } else {\n      current.x += x * textHScale;\n    }\n    current.tspan.setAttributeNS(null, \"font-family\", current.fontFamily);\n    current.tspan.setAttributeNS(null, \"font-size\", `${pf(current.fontSize)}px`);\n    if (current.fontStyle !== SVG_DEFAULTS.fontStyle) {\n      current.tspan.setAttributeNS(null, \"font-style\", current.fontStyle);\n    }\n    if (current.fontWeight !== SVG_DEFAULTS.fontWeight) {\n      current.tspan.setAttributeNS(null, \"font-weight\", current.fontWeight);\n    }\n    const fillStrokeMode = current.textRenderingMode & _util.TextRenderingMode.FILL_STROKE_MASK;\n    if (fillStrokeMode === _util.TextRenderingMode.FILL || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n      if (current.fillColor !== SVG_DEFAULTS.fillColor) {\n        current.tspan.setAttributeNS(null, \"fill\", current.fillColor);\n      }\n      if (current.fillAlpha < 1) {\n        current.tspan.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n      }\n    } else if (current.textRenderingMode === _util.TextRenderingMode.ADD_TO_PATH) {\n      current.tspan.setAttributeNS(null, \"fill\", \"transparent\");\n    } else {\n      current.tspan.setAttributeNS(null, \"fill\", \"none\");\n    }\n    if (fillStrokeMode === _util.TextRenderingMode.STROKE || fillStrokeMode === _util.TextRenderingMode.FILL_STROKE) {\n      const lineWidthScale = 1 / (current.textMatrixScale || 1);\n      this._setStrokeAttributes(current.tspan, lineWidthScale);\n    }\n    let textMatrix = current.textMatrix;\n    if (current.textRise !== 0) {\n      textMatrix = textMatrix.slice();\n      textMatrix[5] += current.textRise;\n    }\n    current.txtElement.setAttributeNS(null, \"transform\", `${pm(textMatrix)} scale(${pf(textHScale)}, -1)`);\n    current.txtElement.setAttributeNS(XML_NS, \"xml:space\", \"preserve\");\n    current.txtElement.append(current.tspan);\n    current.txtgrp.append(current.txtElement);\n    this._ensureTransformGroup().append(current.txtElement);\n  }\n  setLeadingMoveText(x, y) {\n    this.setLeading(-y);\n    this.moveText(x, y);\n  }\n  addFontStyle(fontObj) {\n    if (!fontObj.data) {\n      throw new Error(\"addFontStyle: No font data available, \" + 'ensure that the \"fontExtraProperties\" API parameter is set.');\n    }\n    if (!this.cssStyle) {\n      this.cssStyle = this.svgFactory.createElement(\"svg:style\");\n      this.cssStyle.setAttributeNS(null, \"type\", \"text/css\");\n      this.defs.append(this.cssStyle);\n    }\n    const url = createObjectURL(fontObj.data, fontObj.mimetype, this.forceDataSchema);\n    this.cssStyle.textContent += `@font-face { font-family: \"${fontObj.loadedName}\";` + ` src: url(${url}); }\\n`;\n  }\n  setFont(details) {\n    const current = this.current;\n    const fontObj = this.commonObjs.get(details[0]);\n    let size = details[1];\n    current.font = fontObj;\n    if (this.embedFonts && !fontObj.missingFile && !this.embeddedFonts[fontObj.loadedName]) {\n      this.addFontStyle(fontObj);\n      this.embeddedFonts[fontObj.loadedName] = fontObj;\n    }\n    current.fontMatrix = fontObj.fontMatrix || _util.FONT_IDENTITY_MATRIX;\n    let bold = \"normal\";\n    if (fontObj.black) {\n      bold = \"900\";\n    } else if (fontObj.bold) {\n      bold = \"bold\";\n    }\n    const italic = fontObj.italic ? \"italic\" : \"normal\";\n    if (size < 0) {\n      size = -size;\n      current.fontDirection = -1;\n    } else {\n      current.fontDirection = 1;\n    }\n    current.fontSize = size;\n    current.fontFamily = fontObj.loadedName;\n    current.fontWeight = bold;\n    current.fontStyle = italic;\n    current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n    current.tspan.setAttributeNS(null, \"y\", pf(-current.y));\n    current.xcoords = [];\n    current.ycoords = [];\n  }\n  endText() {\n    const current = this.current;\n    if (current.textRenderingMode & _util.TextRenderingMode.ADD_TO_PATH_FLAG && current.txtElement?.hasChildNodes()) {\n      current.element = current.txtElement;\n      this.clip(\"nonzero\");\n      this.endPath();\n    }\n  }\n  setLineWidth(width) {\n    if (width > 0) {\n      this.current.lineWidth = width;\n    }\n  }\n  setLineCap(style) {\n    this.current.lineCap = LINE_CAP_STYLES[style];\n  }\n  setLineJoin(style) {\n    this.current.lineJoin = LINE_JOIN_STYLES[style];\n  }\n  setMiterLimit(limit) {\n    this.current.miterLimit = limit;\n  }\n  setStrokeAlpha(strokeAlpha) {\n    this.current.strokeAlpha = strokeAlpha;\n  }\n  setStrokeRGBColor(r, g, b) {\n    this.current.strokeColor = _util.Util.makeHexColor(r, g, b);\n  }\n  setFillAlpha(fillAlpha) {\n    this.current.fillAlpha = fillAlpha;\n  }\n  setFillRGBColor(r, g, b) {\n    this.current.fillColor = _util.Util.makeHexColor(r, g, b);\n    this.current.tspan = this.svgFactory.createElement(\"svg:tspan\");\n    this.current.xcoords = [];\n    this.current.ycoords = [];\n  }\n  setStrokeColorN(args) {\n    this.current.strokeColor = this._makeColorN_Pattern(args);\n  }\n  setFillColorN(args) {\n    this.current.fillColor = this._makeColorN_Pattern(args);\n  }\n  shadingFill(args) {\n    const {\n      width,\n      height\n    } = this.viewport;\n    const inv = _util.Util.inverseTransform(this.transformMatrix);\n    const [x0, y0, x1, y1] = _util.Util.getAxialAlignedBoundingBox([0, 0, width, height], inv);\n    const rect = this.svgFactory.createElement(\"svg:rect\");\n    rect.setAttributeNS(null, \"x\", x0);\n    rect.setAttributeNS(null, \"y\", y0);\n    rect.setAttributeNS(null, \"width\", x1 - x0);\n    rect.setAttributeNS(null, \"height\", y1 - y0);\n    rect.setAttributeNS(null, \"fill\", this._makeShadingPattern(args));\n    if (this.current.fillAlpha < 1) {\n      rect.setAttributeNS(null, \"fill-opacity\", this.current.fillAlpha);\n    }\n    this._ensureTransformGroup().append(rect);\n  }\n  _makeColorN_Pattern(args) {\n    if (args[0] === \"TilingPattern\") {\n      return this._makeTilingPattern(args);\n    }\n    return this._makeShadingPattern(args);\n  }\n  _makeTilingPattern(args) {\n    const color = args[1];\n    const operatorList = args[2];\n    const matrix = args[3] || _util.IDENTITY_MATRIX;\n    const [x0, y0, x1, y1] = args[4];\n    const xstep = args[5];\n    const ystep = args[6];\n    const paintType = args[7];\n    const tilingId = `shading${shadingCount++}`;\n    const [tx0, ty0, tx1, ty1] = _util.Util.normalizeRect([..._util.Util.applyTransform([x0, y0], matrix), ..._util.Util.applyTransform([x1, y1], matrix)]);\n    const [xscale, yscale] = _util.Util.singularValueDecompose2dScale(matrix);\n    const txstep = xstep * xscale;\n    const tystep = ystep * yscale;\n    const tiling = this.svgFactory.createElement(\"svg:pattern\");\n    tiling.setAttributeNS(null, \"id\", tilingId);\n    tiling.setAttributeNS(null, \"patternUnits\", \"userSpaceOnUse\");\n    tiling.setAttributeNS(null, \"width\", txstep);\n    tiling.setAttributeNS(null, \"height\", tystep);\n    tiling.setAttributeNS(null, \"x\", `${tx0}`);\n    tiling.setAttributeNS(null, \"y\", `${ty0}`);\n    const svg = this.svg;\n    const transformMatrix = this.transformMatrix;\n    const fillColor = this.current.fillColor;\n    const strokeColor = this.current.strokeColor;\n    const bbox = this.svgFactory.create(tx1 - tx0, ty1 - ty0);\n    this.svg = bbox;\n    this.transformMatrix = matrix;\n    if (paintType === 2) {\n      const cssColor = _util.Util.makeHexColor(...color);\n      this.current.fillColor = cssColor;\n      this.current.strokeColor = cssColor;\n    }\n    this.executeOpTree(this.convertOpList(operatorList));\n    this.svg = svg;\n    this.transformMatrix = transformMatrix;\n    this.current.fillColor = fillColor;\n    this.current.strokeColor = strokeColor;\n    tiling.append(bbox.childNodes[0]);\n    this.defs.append(tiling);\n    return `url(#${tilingId})`;\n  }\n  _makeShadingPattern(args) {\n    if (typeof args === \"string\") {\n      args = this.objs.get(args);\n    }\n    switch (args[0]) {\n      case \"RadialAxial\":\n        const shadingId = `shading${shadingCount++}`;\n        const colorStops = args[3];\n        let gradient;\n        switch (args[1]) {\n          case \"axial\":\n            const point0 = args[4];\n            const point1 = args[5];\n            gradient = this.svgFactory.createElement(\"svg:linearGradient\");\n            gradient.setAttributeNS(null, \"id\", shadingId);\n            gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n            gradient.setAttributeNS(null, \"x1\", point0[0]);\n            gradient.setAttributeNS(null, \"y1\", point0[1]);\n            gradient.setAttributeNS(null, \"x2\", point1[0]);\n            gradient.setAttributeNS(null, \"y2\", point1[1]);\n            break;\n          case \"radial\":\n            const focalPoint = args[4];\n            const circlePoint = args[5];\n            const focalRadius = args[6];\n            const circleRadius = args[7];\n            gradient = this.svgFactory.createElement(\"svg:radialGradient\");\n            gradient.setAttributeNS(null, \"id\", shadingId);\n            gradient.setAttributeNS(null, \"gradientUnits\", \"userSpaceOnUse\");\n            gradient.setAttributeNS(null, \"cx\", circlePoint[0]);\n            gradient.setAttributeNS(null, \"cy\", circlePoint[1]);\n            gradient.setAttributeNS(null, \"r\", circleRadius);\n            gradient.setAttributeNS(null, \"fx\", focalPoint[0]);\n            gradient.setAttributeNS(null, \"fy\", focalPoint[1]);\n            gradient.setAttributeNS(null, \"fr\", focalRadius);\n            break;\n          default:\n            throw new Error(`Unknown RadialAxial type: ${args[1]}`);\n        }\n        for (const colorStop of colorStops) {\n          const stop = this.svgFactory.createElement(\"svg:stop\");\n          stop.setAttributeNS(null, \"offset\", colorStop[0]);\n          stop.setAttributeNS(null, \"stop-color\", colorStop[1]);\n          gradient.append(stop);\n        }\n        this.defs.append(gradient);\n        return `url(#${shadingId})`;\n      case \"Mesh\":\n        (0, _util.warn)(\"Unimplemented pattern Mesh\");\n        return null;\n      case \"Dummy\":\n        return \"hotpink\";\n      default:\n        throw new Error(`Unknown IR type: ${args[0]}`);\n    }\n  }\n  setDash(dashArray, dashPhase) {\n    this.current.dashArray = dashArray;\n    this.current.dashPhase = dashPhase;\n  }\n  constructPath(ops, args) {\n    const current = this.current;\n    let x = current.x,\n      y = current.y;\n    let d = [];\n    let j = 0;\n    for (const op of ops) {\n      switch (op | 0) {\n        case _util.OPS.rectangle:\n          x = args[j++];\n          y = args[j++];\n          const width = args[j++];\n          const height = args[j++];\n          const xw = x + width;\n          const yh = y + height;\n          d.push(\"M\", pf(x), pf(y), \"L\", pf(xw), pf(y), \"L\", pf(xw), pf(yh), \"L\", pf(x), pf(yh), \"Z\");\n          break;\n        case _util.OPS.moveTo:\n          x = args[j++];\n          y = args[j++];\n          d.push(\"M\", pf(x), pf(y));\n          break;\n        case _util.OPS.lineTo:\n          x = args[j++];\n          y = args[j++];\n          d.push(\"L\", pf(x), pf(y));\n          break;\n        case _util.OPS.curveTo:\n          x = args[j + 4];\n          y = args[j + 5];\n          d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]), pf(x), pf(y));\n          j += 6;\n          break;\n        case _util.OPS.curveTo2:\n          d.push(\"C\", pf(x), pf(y), pf(args[j]), pf(args[j + 1]), pf(args[j + 2]), pf(args[j + 3]));\n          x = args[j + 2];\n          y = args[j + 3];\n          j += 4;\n          break;\n        case _util.OPS.curveTo3:\n          x = args[j + 2];\n          y = args[j + 3];\n          d.push(\"C\", pf(args[j]), pf(args[j + 1]), pf(x), pf(y), pf(x), pf(y));\n          j += 4;\n          break;\n        case _util.OPS.closePath:\n          d.push(\"Z\");\n          break;\n      }\n    }\n    d = d.join(\" \");\n    if (current.path && ops.length > 0 && ops[0] !== _util.OPS.rectangle && ops[0] !== _util.OPS.moveTo) {\n      d = current.path.getAttributeNS(null, \"d\") + d;\n    } else {\n      current.path = this.svgFactory.createElement(\"svg:path\");\n      this._ensureTransformGroup().append(current.path);\n    }\n    current.path.setAttributeNS(null, \"d\", d);\n    current.path.setAttributeNS(null, \"fill\", \"none\");\n    current.element = current.path;\n    current.setCurrentPoint(x, y);\n  }\n  endPath() {\n    const current = this.current;\n    current.path = null;\n    if (!this.pendingClip) {\n      return;\n    }\n    if (!current.element) {\n      this.pendingClip = null;\n      return;\n    }\n    const clipId = `clippath${clipCount++}`;\n    const clipPath = this.svgFactory.createElement(\"svg:clipPath\");\n    clipPath.setAttributeNS(null, \"id\", clipId);\n    clipPath.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n    const clipElement = current.element.cloneNode(true);\n    if (this.pendingClip === \"evenodd\") {\n      clipElement.setAttributeNS(null, \"clip-rule\", \"evenodd\");\n    } else {\n      clipElement.setAttributeNS(null, \"clip-rule\", \"nonzero\");\n    }\n    this.pendingClip = null;\n    clipPath.append(clipElement);\n    this.defs.append(clipPath);\n    if (current.activeClipUrl) {\n      current.clipGroup = null;\n      for (const prev of this.extraStack) {\n        prev.clipGroup = null;\n      }\n      clipPath.setAttributeNS(null, \"clip-path\", current.activeClipUrl);\n    }\n    current.activeClipUrl = `url(#${clipId})`;\n    this.tgrp = null;\n  }\n  clip(type) {\n    this.pendingClip = type;\n  }\n  closePath() {\n    const current = this.current;\n    if (current.path) {\n      const d = `${current.path.getAttributeNS(null, \"d\")}Z`;\n      current.path.setAttributeNS(null, \"d\", d);\n    }\n  }\n  setLeading(leading) {\n    this.current.leading = -leading;\n  }\n  setTextRise(textRise) {\n    this.current.textRise = textRise;\n  }\n  setTextRenderingMode(textRenderingMode) {\n    this.current.textRenderingMode = textRenderingMode;\n  }\n  setHScale(scale) {\n    this.current.textHScale = scale / 100;\n  }\n  setRenderingIntent(intent) {}\n  setFlatness(flatness) {}\n  setGState(states) {\n    for (const [key, value] of states) {\n      switch (key) {\n        case \"LW\":\n          this.setLineWidth(value);\n          break;\n        case \"LC\":\n          this.setLineCap(value);\n          break;\n        case \"LJ\":\n          this.setLineJoin(value);\n          break;\n        case \"ML\":\n          this.setMiterLimit(value);\n          break;\n        case \"D\":\n          this.setDash(value[0], value[1]);\n          break;\n        case \"RI\":\n          this.setRenderingIntent(value);\n          break;\n        case \"FL\":\n          this.setFlatness(value);\n          break;\n        case \"Font\":\n          this.setFont(value);\n          break;\n        case \"CA\":\n          this.setStrokeAlpha(value);\n          break;\n        case \"ca\":\n          this.setFillAlpha(value);\n          break;\n        default:\n          (0, _util.warn)(`Unimplemented graphic state operator ${key}`);\n          break;\n      }\n    }\n  }\n  fill() {\n    const current = this.current;\n    if (current.element) {\n      current.element.setAttributeNS(null, \"fill\", current.fillColor);\n      current.element.setAttributeNS(null, \"fill-opacity\", current.fillAlpha);\n      this.endPath();\n    }\n  }\n  stroke() {\n    const current = this.current;\n    if (current.element) {\n      this._setStrokeAttributes(current.element);\n      current.element.setAttributeNS(null, \"fill\", \"none\");\n      this.endPath();\n    }\n  }\n  _setStrokeAttributes(element) {\n    let lineWidthScale = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n    const current = this.current;\n    let dashArray = current.dashArray;\n    if (lineWidthScale !== 1 && dashArray.length > 0) {\n      dashArray = dashArray.map(function (value) {\n        return lineWidthScale * value;\n      });\n    }\n    element.setAttributeNS(null, \"stroke\", current.strokeColor);\n    element.setAttributeNS(null, \"stroke-opacity\", current.strokeAlpha);\n    element.setAttributeNS(null, \"stroke-miterlimit\", pf(current.miterLimit));\n    element.setAttributeNS(null, \"stroke-linecap\", current.lineCap);\n    element.setAttributeNS(null, \"stroke-linejoin\", current.lineJoin);\n    element.setAttributeNS(null, \"stroke-width\", pf(lineWidthScale * current.lineWidth) + \"px\");\n    element.setAttributeNS(null, \"stroke-dasharray\", dashArray.map(pf).join(\" \"));\n    element.setAttributeNS(null, \"stroke-dashoffset\", pf(lineWidthScale * current.dashPhase) + \"px\");\n  }\n  eoFill() {\n    this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n    this.fill();\n  }\n  fillStroke() {\n    this.stroke();\n    this.fill();\n  }\n  eoFillStroke() {\n    this.current.element?.setAttributeNS(null, \"fill-rule\", \"evenodd\");\n    this.fillStroke();\n  }\n  closeStroke() {\n    this.closePath();\n    this.stroke();\n  }\n  closeFillStroke() {\n    this.closePath();\n    this.fillStroke();\n  }\n  closeEOFillStroke() {\n    this.closePath();\n    this.eoFillStroke();\n  }\n  paintSolidColorImageMask() {\n    const rect = this.svgFactory.createElement(\"svg:rect\");\n    rect.setAttributeNS(null, \"x\", \"0\");\n    rect.setAttributeNS(null, \"y\", \"0\");\n    rect.setAttributeNS(null, \"width\", \"1px\");\n    rect.setAttributeNS(null, \"height\", \"1px\");\n    rect.setAttributeNS(null, \"fill\", this.current.fillColor);\n    this._ensureTransformGroup().append(rect);\n  }\n  paintImageXObject(objId) {\n    const imgData = this.getObject(objId);\n    if (!imgData) {\n      (0, _util.warn)(`Dependent image with object ID ${objId} is not ready yet`);\n      return;\n    }\n    this.paintInlineImageXObject(imgData);\n  }\n  paintInlineImageXObject(imgData, mask) {\n    const width = imgData.width;\n    const height = imgData.height;\n    const imgSrc = convertImgDataToPng(imgData, this.forceDataSchema, !!mask);\n    const cliprect = this.svgFactory.createElement(\"svg:rect\");\n    cliprect.setAttributeNS(null, \"x\", \"0\");\n    cliprect.setAttributeNS(null, \"y\", \"0\");\n    cliprect.setAttributeNS(null, \"width\", pf(width));\n    cliprect.setAttributeNS(null, \"height\", pf(height));\n    this.current.element = cliprect;\n    this.clip(\"nonzero\");\n    const imgEl = this.svgFactory.createElement(\"svg:image\");\n    imgEl.setAttributeNS(XLINK_NS, \"xlink:href\", imgSrc);\n    imgEl.setAttributeNS(null, \"x\", \"0\");\n    imgEl.setAttributeNS(null, \"y\", pf(-height));\n    imgEl.setAttributeNS(null, \"width\", pf(width) + \"px\");\n    imgEl.setAttributeNS(null, \"height\", pf(height) + \"px\");\n    imgEl.setAttributeNS(null, \"transform\", `scale(${pf(1 / width)} ${pf(-1 / height)})`);\n    if (mask) {\n      mask.append(imgEl);\n    } else {\n      this._ensureTransformGroup().append(imgEl);\n    }\n  }\n  paintImageMaskXObject(img) {\n    const imgData = this.getObject(img.data, img);\n    if (imgData.bitmap) {\n      (0, _util.warn)(\"paintImageMaskXObject: ImageBitmap support is not implemented, \" + \"ensure that the `isOffscreenCanvasSupported` API parameter is disabled.\");\n      return;\n    }\n    const current = this.current;\n    const width = imgData.width;\n    const height = imgData.height;\n    const fillColor = current.fillColor;\n    current.maskId = `mask${maskCount++}`;\n    const mask = this.svgFactory.createElement(\"svg:mask\");\n    mask.setAttributeNS(null, \"id\", current.maskId);\n    const rect = this.svgFactory.createElement(\"svg:rect\");\n    rect.setAttributeNS(null, \"x\", \"0\");\n    rect.setAttributeNS(null, \"y\", \"0\");\n    rect.setAttributeNS(null, \"width\", pf(width));\n    rect.setAttributeNS(null, \"height\", pf(height));\n    rect.setAttributeNS(null, \"fill\", fillColor);\n    rect.setAttributeNS(null, \"mask\", `url(#${current.maskId})`);\n    this.defs.append(mask);\n    this._ensureTransformGroup().append(rect);\n    this.paintInlineImageXObject(imgData, mask);\n  }\n  paintFormXObjectBegin(matrix, bbox) {\n    if (Array.isArray(matrix) && matrix.length === 6) {\n      this.transform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\n    }\n    if (bbox) {\n      const width = bbox[2] - bbox[0];\n      const height = bbox[3] - bbox[1];\n      const cliprect = this.svgFactory.createElement(\"svg:rect\");\n      cliprect.setAttributeNS(null, \"x\", bbox[0]);\n      cliprect.setAttributeNS(null, \"y\", bbox[1]);\n      cliprect.setAttributeNS(null, \"width\", pf(width));\n      cliprect.setAttributeNS(null, \"height\", pf(height));\n      this.current.element = cliprect;\n      this.clip(\"nonzero\");\n      this.endPath();\n    }\n  }\n  paintFormXObjectEnd() {}\n  _initialize(viewport) {\n    const svg = this.svgFactory.create(viewport.width, viewport.height);\n    const definitions = this.svgFactory.createElement(\"svg:defs\");\n    svg.append(definitions);\n    this.defs = definitions;\n    const rootGroup = this.svgFactory.createElement(\"svg:g\");\n    rootGroup.setAttributeNS(null, \"transform\", pm(viewport.transform));\n    svg.append(rootGroup);\n    this.svg = rootGroup;\n    return svg;\n  }\n  _ensureClipGroup() {\n    if (!this.current.clipGroup) {\n      const clipGroup = this.svgFactory.createElement(\"svg:g\");\n      clipGroup.setAttributeNS(null, \"clip-path\", this.current.activeClipUrl);\n      this.svg.append(clipGroup);\n      this.current.clipGroup = clipGroup;\n    }\n    return this.current.clipGroup;\n  }\n  _ensureTransformGroup() {\n    if (!this.tgrp) {\n      this.tgrp = this.svgFactory.createElement(\"svg:g\");\n      this.tgrp.setAttributeNS(null, \"transform\", pm(this.transformMatrix));\n      if (this.current.activeClipUrl) {\n        this._ensureClipGroup().append(this.tgrp);\n      } else {\n        this.svg.append(this.tgrp);\n      }\n    }\n    return this.tgrp;\n  }\n}\nexports.SVGGraphics = SVGGraphics;\n\n/***/ }),\n/* 187 */\n/***/ ((__unused_webpack_module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar $ = __w_pdfjs_require__(3);\nvar $group = __w_pdfjs_require__(188);\nvar addToUnscopables = __w_pdfjs_require__(193);\n$({\n target: 'Array',\n proto: true\n}, {\n group: function group(callbackfn) {\n  var thisArg = arguments.length > 1 ? arguments[1] : undefined;\n  return $group(this, callbackfn, thisArg);\n }\n});\naddToUnscopables('group');\n\n/***/ }),\n/* 188 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar bind = __w_pdfjs_require__(99);\nvar uncurryThis = __w_pdfjs_require__(14);\nvar IndexedObject = __w_pdfjs_require__(13);\nvar toObject = __w_pdfjs_require__(40);\nvar toPropertyKey = __w_pdfjs_require__(18);\nvar lengthOfArrayLike = __w_pdfjs_require__(64);\nvar objectCreate = __w_pdfjs_require__(189);\nvar arrayFromConstructorAndList = __w_pdfjs_require__(108);\nvar $Array = Array;\nvar push = uncurryThis([].push);\nmodule.exports = function ($this, callbackfn, that, specificConstructor) {\n var O = toObject($this);\n var self = IndexedObject(O);\n var boundFunction = bind(callbackfn, that);\n var target = objectCreate(null);\n var length = lengthOfArrayLike(self);\n var index = 0;\n var Constructor, key, value;\n for (; length > index; index++) {\n  value = self[index];\n  key = toPropertyKey(boundFunction(value, index, O));\n  if (key in target)\n   push(target[key], value);\n  else\n   target[key] = [value];\n }\n if (specificConstructor) {\n  Constructor = specificConstructor(O);\n  if (Constructor !== $Array) {\n   for (key in target)\n    target[key] = arrayFromConstructorAndList(Constructor, target[key]);\n  }\n }\n return target;\n};\n\n/***/ }),\n/* 189 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar anObject = __w_pdfjs_require__(47);\nvar definePropertiesModule = __w_pdfjs_require__(190);\nvar enumBugKeys = __w_pdfjs_require__(66);\nvar hiddenKeys = __w_pdfjs_require__(55);\nvar html = __w_pdfjs_require__(192);\nvar documentCreateElement = __w_pdfjs_require__(43);\nvar sharedKey = __w_pdfjs_require__(54);\nvar GT = '>';\nvar LT = '<';\nvar PROTOTYPE = 'prototype';\nvar SCRIPT = 'script';\nvar IE_PROTO = sharedKey('IE_PROTO');\nvar EmptyConstructor = function () {\n};\nvar scriptTag = function (content) {\n return LT + SCRIPT + GT + content + LT + '/' + SCRIPT + GT;\n};\nvar NullProtoObjectViaActiveX = function (activeXDocument) {\n activeXDocument.write(scriptTag(''));\n activeXDocument.close();\n var temp = activeXDocument.parentWindow.Object;\n activeXDocument = null;\n return temp;\n};\nvar NullProtoObjectViaIFrame = function () {\n var iframe = documentCreateElement('iframe');\n var JS = 'java' + SCRIPT + ':';\n var iframeDocument;\n iframe.style.display = 'none';\n html.appendChild(iframe);\n iframe.src = String(JS);\n iframeDocument = iframe.contentWindow.document;\n iframeDocument.open();\n iframeDocument.write(scriptTag('document.F=Object'));\n iframeDocument.close();\n return iframeDocument.F;\n};\nvar activeXDocument;\nvar NullProtoObject = function () {\n try {\n  activeXDocument = new ActiveXObject('htmlfile');\n } catch (error) {\n }\n NullProtoObject = typeof document != 'undefined' ? document.domain && activeXDocument ? NullProtoObjectViaActiveX(activeXDocument) : NullProtoObjectViaIFrame() : NullProtoObjectViaActiveX(activeXDocument);\n var length = enumBugKeys.length;\n while (length--)\n  delete NullProtoObject[PROTOTYPE][enumBugKeys[length]];\n return NullProtoObject();\n};\nhiddenKeys[IE_PROTO] = true;\nmodule.exports = Object.create || function create(O, Properties) {\n var result;\n if (O !== null) {\n  EmptyConstructor[PROTOTYPE] = anObject(O);\n  result = new EmptyConstructor();\n  EmptyConstructor[PROTOTYPE] = null;\n  result[IE_PROTO] = O;\n } else\n  result = NullProtoObject();\n return Properties === undefined ? result : definePropertiesModule.f(result, Properties);\n};\n\n/***/ }),\n/* 190 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\nvar DESCRIPTORS = __w_pdfjs_require__(6);\nvar V8_PROTOTYPE_DEFINE_BUG = __w_pdfjs_require__(46);\nvar definePropertyModule = __w_pdfjs_require__(45);\nvar anObject = __w_pdfjs_require__(47);\nvar toIndexedObject = __w_pdfjs_require__(12);\nvar objectKeys = __w_pdfjs_require__(191);\nexports.f = DESCRIPTORS && !V8_PROTOTYPE_DEFINE_BUG ? Object.defineProperties : function defineProperties(O, Properties) {\n anObject(O);\n var props = toIndexedObject(Properties);\n var keys = objectKeys(Properties);\n var length = keys.length;\n var index = 0;\n var key;\n while (length > index)\n  definePropertyModule.f(O, key = keys[index++], props[key]);\n return O;\n};\n\n/***/ }),\n/* 191 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar internalObjectKeys = __w_pdfjs_require__(59);\nvar enumBugKeys = __w_pdfjs_require__(66);\nmodule.exports = Object.keys || function keys(O) {\n return internalObjectKeys(O, enumBugKeys);\n};\n\n/***/ }),\n/* 192 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar getBuiltIn = __w_pdfjs_require__(24);\nmodule.exports = getBuiltIn('document', 'documentElement');\n\n/***/ }),\n/* 193 */\n/***/ ((module, __unused_webpack_exports, __w_pdfjs_require__) => {\n\n\nvar wellKnownSymbol = __w_pdfjs_require__(34);\nvar create = __w_pdfjs_require__(189);\nvar defineProperty = (__w_pdfjs_require__(45).f);\nvar UNSCOPABLES = wellKnownSymbol('unscopables');\nvar ArrayPrototype = Array.prototype;\nif (ArrayPrototype[UNSCOPABLES] === undefined) {\n defineProperty(ArrayPrototype, UNSCOPABLES, {\n  configurable: true,\n  value: create(null)\n });\n}\nmodule.exports = function (key) {\n ArrayPrototype[UNSCOPABLES][key] = true;\n};\n\n/***/ }),\n/* 194 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaText = void 0;\n__w_pdfjs_require__(89);\nclass XfaText {\n  static textContent(xfa) {\n    const items = [];\n    const output = {\n      items,\n      styles: Object.create(null)\n    };\n    function walk(node) {\n      if (!node) {\n        return;\n      }\n      let str = null;\n      const name = node.name;\n      if (name === \"#text\") {\n        str = node.value;\n      } else if (!XfaText.shouldBuildText(name)) {\n        return;\n      } else if (node?.attributes?.textContent) {\n        str = node.attributes.textContent;\n      } else if (node.value) {\n        str = node.value;\n      }\n      if (str !== null) {\n        items.push({\n          str\n        });\n      }\n      if (!node.children) {\n        return;\n      }\n      for (const child of node.children) {\n        walk(child);\n      }\n    }\n    walk(xfa);\n    return output;\n  }\n  static shouldBuildText(name) {\n    return !(name === \"textarea\" || name === \"input\" || name === \"option\" || name === \"select\");\n  }\n}\nexports.XfaText = XfaText;\n\n/***/ }),\n/* 195 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.TextLayerRenderTask = void 0;\nexports.renderTextLayer = renderTextLayer;\nexports.updateTextLayer = updateTextLayer;\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(2);\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(168);\nconst MAX_TEXT_DIVS_TO_RENDER = 100000;\nconst DEFAULT_FONT_SIZE = 30;\nconst DEFAULT_FONT_ASCENT = 0.8;\nconst ascentCache = new Map();\nfunction getCtx(size, isOffscreenCanvasSupported) {\n  let ctx;\n  if (isOffscreenCanvasSupported && _util.FeatureTest.isOffscreenCanvasSupported) {\n    ctx = new OffscreenCanvas(size, size).getContext(\"2d\", {\n      alpha: false\n    });\n  } else {\n    const canvas = document.createElement(\"canvas\");\n    canvas.width = canvas.height = size;\n    ctx = canvas.getContext(\"2d\", {\n      alpha: false\n    });\n  }\n  return ctx;\n}\nfunction getAscent(fontFamily, isOffscreenCanvasSupported) {\n  const cachedAscent = ascentCache.get(fontFamily);\n  if (cachedAscent) {\n    return cachedAscent;\n  }\n  const ctx = getCtx(DEFAULT_FONT_SIZE, isOffscreenCanvasSupported);\n  ctx.font = `${DEFAULT_FONT_SIZE}px ${fontFamily}`;\n  const metrics = ctx.measureText(\"\");\n  let ascent = metrics.fontBoundingBoxAscent;\n  let descent = Math.abs(metrics.fontBoundingBoxDescent);\n  if (ascent) {\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    ctx.canvas.width = ctx.canvas.height = 0;\n    return ratio;\n  }\n  ctx.strokeStyle = \"red\";\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"g\", 0, 0);\n  let pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  descent = 0;\n  for (let i = pixels.length - 1 - 3; i >= 0; i -= 4) {\n    if (pixels[i] > 0) {\n      descent = Math.ceil(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n  ctx.clearRect(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE);\n  ctx.strokeText(\"A\", 0, DEFAULT_FONT_SIZE);\n  pixels = ctx.getImageData(0, 0, DEFAULT_FONT_SIZE, DEFAULT_FONT_SIZE).data;\n  ascent = 0;\n  for (let i = 0, ii = pixels.length; i < ii; i += 4) {\n    if (pixels[i] > 0) {\n      ascent = DEFAULT_FONT_SIZE - Math.floor(i / 4 / DEFAULT_FONT_SIZE);\n      break;\n    }\n  }\n  ctx.canvas.width = ctx.canvas.height = 0;\n  if (ascent) {\n    const ratio = ascent / (ascent + descent);\n    ascentCache.set(fontFamily, ratio);\n    return ratio;\n  }\n  ascentCache.set(fontFamily, DEFAULT_FONT_ASCENT);\n  return DEFAULT_FONT_ASCENT;\n}\nfunction appendText(task, geom, styles) {\n  const textDiv = document.createElement(\"span\");\n  const textDivProperties = {\n    angle: 0,\n    canvasWidth: 0,\n    hasText: geom.str !== \"\",\n    hasEOL: geom.hasEOL,\n    fontSize: 0\n  };\n  task._textDivs.push(textDiv);\n  const tx = _util.Util.transform(task._transform, geom.transform);\n  let angle = Math.atan2(tx[1], tx[0]);\n  const style = styles[geom.fontName];\n  if (style.vertical) {\n    angle += Math.PI / 2;\n  }\n  const fontHeight = Math.hypot(tx[2], tx[3]);\n  const fontAscent = fontHeight * getAscent(style.fontFamily, task._isOffscreenCanvasSupported);\n  let left, top;\n  if (angle === 0) {\n    left = tx[4];\n    top = tx[5] - fontAscent;\n  } else {\n    left = tx[4] + fontAscent * Math.sin(angle);\n    top = tx[5] - fontAscent * Math.cos(angle);\n  }\n  const scaleFactorStr = \"calc(var(--scale-factor)*\";\n  const divStyle = textDiv.style;\n  if (task._container === task._rootContainer) {\n    divStyle.left = `${(100 * left / task._pageWidth).toFixed(2)}%`;\n    divStyle.top = `${(100 * top / task._pageHeight).toFixed(2)}%`;\n  } else {\n    divStyle.left = `${scaleFactorStr}${left.toFixed(2)}px)`;\n    divStyle.top = `${scaleFactorStr}${top.toFixed(2)}px)`;\n  }\n  divStyle.fontSize = `${scaleFactorStr}${fontHeight.toFixed(2)}px)`;\n  divStyle.fontFamily = style.fontFamily;\n  textDivProperties.fontSize = fontHeight;\n  textDiv.setAttribute(\"role\", \"presentation\");\n  textDiv.textContent = geom.str;\n  textDiv.dir = geom.dir;\n  if (task._fontInspectorEnabled) {\n    textDiv.dataset.fontName = geom.fontName;\n  }\n  if (angle !== 0) {\n    textDivProperties.angle = angle * (180 / Math.PI);\n  }\n  let shouldScaleText = false;\n  if (geom.str.length > 1) {\n    shouldScaleText = true;\n  } else if (geom.str !== \" \" && geom.transform[0] !== geom.transform[3]) {\n    const absScaleX = Math.abs(geom.transform[0]),\n      absScaleY = Math.abs(geom.transform[3]);\n    if (absScaleX !== absScaleY && Math.max(absScaleX, absScaleY) / Math.min(absScaleX, absScaleY) > 1.5) {\n      shouldScaleText = true;\n    }\n  }\n  if (shouldScaleText) {\n    textDivProperties.canvasWidth = style.vertical ? geom.height : geom.width;\n  }\n  task._textDivProperties.set(textDiv, textDivProperties);\n  if (task._isReadableStream) {\n    task._layoutText(textDiv);\n  }\n}\nfunction layout(params) {\n  const {\n    div,\n    scale,\n    properties,\n    ctx,\n    prevFontSize,\n    prevFontFamily\n  } = params;\n  const {\n    style\n  } = div;\n  let transform = \"\";\n  if (properties.canvasWidth !== 0 && properties.hasText) {\n    const {\n      fontFamily\n    } = style;\n    const {\n      canvasWidth,\n      fontSize\n    } = properties;\n    if (prevFontSize !== fontSize || prevFontFamily !== fontFamily) {\n      ctx.font = `${fontSize * scale}px ${fontFamily}`;\n      params.prevFontSize = fontSize;\n      params.prevFontFamily = fontFamily;\n    }\n    const {\n      width\n    } = ctx.measureText(div.textContent);\n    if (width > 0) {\n      transform = `scaleX(${canvasWidth * scale / width})`;\n    }\n  }\n  if (properties.angle !== 0) {\n    transform = `rotate(${properties.angle}deg) ${transform}`;\n  }\n  if (transform.length > 0) {\n    style.transform = transform;\n  }\n}\nfunction render(task) {\n  if (task._canceled) {\n    return;\n  }\n  const textDivs = task._textDivs;\n  const capability = task._capability;\n  const textDivsLength = textDivs.length;\n  if (textDivsLength > MAX_TEXT_DIVS_TO_RENDER) {\n    capability.resolve();\n    return;\n  }\n  if (!task._isReadableStream) {\n    for (const textDiv of textDivs) {\n      task._layoutText(textDiv);\n    }\n  }\n  capability.resolve();\n}\nclass TextLayerRenderTask {\n  constructor(_ref) {\n    let {\n      textContentSource,\n      container,\n      viewport,\n      textDivs,\n      textDivProperties,\n      textContentItemsStr,\n      isOffscreenCanvasSupported\n    } = _ref;\n    this._textContentSource = textContentSource;\n    this._isReadableStream = textContentSource instanceof ReadableStream;\n    this._container = this._rootContainer = container;\n    this._textDivs = textDivs || [];\n    this._textContentItemsStr = textContentItemsStr || [];\n    this._isOffscreenCanvasSupported = isOffscreenCanvasSupported;\n    this._fontInspectorEnabled = !!globalThis.FontInspector?.enabled;\n    this._reader = null;\n    this._textDivProperties = textDivProperties || new WeakMap();\n    this._canceled = false;\n    this._capability = new _util.PromiseCapability();\n    this._layoutTextParams = {\n      prevFontSize: null,\n      prevFontFamily: null,\n      div: null,\n      scale: viewport.scale * (globalThis.devicePixelRatio || 1),\n      properties: null,\n      ctx: getCtx(0, isOffscreenCanvasSupported)\n    };\n    const {\n      pageWidth,\n      pageHeight,\n      pageX,\n      pageY\n    } = viewport.rawDims;\n    this._transform = [1, 0, 0, -1, -pageX, pageY + pageHeight];\n    this._pageWidth = pageWidth;\n    this._pageHeight = pageHeight;\n    (0, _display_utils.setLayerDimensions)(container, viewport);\n    this._capability.promise.finally(() => {\n      this._layoutTextParams = null;\n    }).catch(() => {});\n  }\n  get promise() {\n    return this._capability.promise;\n  }\n  cancel() {\n    this._canceled = true;\n    if (this._reader) {\n      this._reader.cancel(new _util.AbortException(\"TextLayer task cancelled.\")).catch(() => {});\n      this._reader = null;\n    }\n    this._capability.reject(new _util.AbortException(\"TextLayer task cancelled.\"));\n  }\n  _processItems(items, styleCache) {\n    for (const item of items) {\n      if (item.str === undefined) {\n        if (item.type === \"beginMarkedContentProps\" || item.type === \"beginMarkedContent\") {\n          const parent = this._container;\n          this._container = document.createElement(\"span\");\n          this._container.classList.add(\"markedContent\");\n          if (item.id !== null) {\n            this._container.setAttribute(\"id\", `${item.id}`);\n          }\n          parent.append(this._container);\n        } else if (item.type === \"endMarkedContent\") {\n          this._container = this._container.parentNode;\n        }\n        continue;\n      }\n      this._textContentItemsStr.push(item.str);\n      appendText(this, item, styleCache);\n    }\n  }\n  _layoutText(textDiv) {\n    const textDivProperties = this._layoutTextParams.properties = this._textDivProperties.get(textDiv);\n    this._layoutTextParams.div = textDiv;\n    layout(this._layoutTextParams);\n    if (textDivProperties.hasText) {\n      this._container.append(textDiv);\n    }\n    if (textDivProperties.hasEOL) {\n      const br = document.createElement(\"br\");\n      br.setAttribute(\"role\", \"presentation\");\n      this._container.append(br);\n    }\n  }\n  _render() {\n    const capability = new _util.PromiseCapability();\n    let styleCache = Object.create(null);\n    if (this._isReadableStream) {\n      const pump = () => {\n        this._reader.read().then(_ref2 => {\n          let {\n            value,\n            done\n          } = _ref2;\n          if (done) {\n            capability.resolve();\n            return;\n          }\n          Object.assign(styleCache, value.styles);\n          this._processItems(value.items, styleCache);\n          pump();\n        }, capability.reject);\n      };\n      this._reader = this._textContentSource.getReader();\n      pump();\n    } else if (this._textContentSource) {\n      const {\n        items,\n        styles\n      } = this._textContentSource;\n      this._processItems(items, styles);\n      capability.resolve();\n    } else {\n      throw new Error('No \"textContentSource\" parameter specified.');\n    }\n    capability.promise.then(() => {\n      styleCache = null;\n      render(this);\n    }, this._capability.reject);\n  }\n}\nexports.TextLayerRenderTask = TextLayerRenderTask;\nfunction renderTextLayer(params) {\n  if (!params.textContentSource && (params.textContent || params.textContentStream)) {\n    (0, _display_utils.deprecated)(\"The TextLayerRender `textContent`/`textContentStream` parameters \" + \"will be removed in the future, please use `textContentSource` instead.\");\n    params.textContentSource = params.textContent || params.textContentStream;\n  }\n  const {\n    container,\n    viewport\n  } = params;\n  const style = getComputedStyle(container);\n  const visibility = style.getPropertyValue(\"visibility\");\n  const scaleFactor = parseFloat(style.getPropertyValue(\"--scale-factor\"));\n  if (visibility === \"visible\" && (!scaleFactor || Math.abs(scaleFactor - viewport.scale) > 1e-5)) {\n    console.error(\"The `--scale-factor` CSS-variable must be set, \" + \"to the same value as `viewport.scale`, \" + \"either on the `container`-element itself or higher up in the DOM.\");\n  }\n  const task = new TextLayerRenderTask(params);\n  task._render();\n  return task;\n}\nfunction updateTextLayer(_ref3) {\n  let {\n    container,\n    viewport,\n    textDivs,\n    textDivProperties,\n    isOffscreenCanvasSupported,\n    mustRotate = true,\n    mustRescale = true\n  } = _ref3;\n  if (mustRotate) {\n    (0, _display_utils.setLayerDimensions)(container, {\n      rotation: viewport.rotation\n    });\n  }\n  if (mustRescale) {\n    const ctx = getCtx(0, isOffscreenCanvasSupported);\n    const scale = viewport.scale * (globalThis.devicePixelRatio || 1);\n    const params = {\n      prevFontSize: null,\n      prevFontFamily: null,\n      div: null,\n      scale,\n      properties: null,\n      ctx\n    };\n    for (const div of textDivs) {\n      params.properties = textDivProperties.get(div);\n      params.div = div;\n      layout(params);\n    }\n  }\n}\n\n/***/ }),\n/* 196 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.AnnotationEditorLayer = void 0;\n__w_pdfjs_require__(125);\n__w_pdfjs_require__(136);\n__w_pdfjs_require__(138);\n__w_pdfjs_require__(141);\n__w_pdfjs_require__(143);\n__w_pdfjs_require__(145);\n__w_pdfjs_require__(147);\nvar _util = __w_pdfjs_require__(1);\nvar _editor = __w_pdfjs_require__(164);\nvar _freetext = __w_pdfjs_require__(197);\nvar _ink = __w_pdfjs_require__(202);\nvar _display_utils = __w_pdfjs_require__(168);\nvar _stamp = __w_pdfjs_require__(203);\nclass AnnotationEditorLayer {\n  #accessibilityManager;\n  #allowClick = false;\n  #annotationLayer = null;\n  #boundPointerup = this.pointerup.bind(this);\n  #boundPointerdown = this.pointerdown.bind(this);\n  #editors = new Map();\n  #hadPointerDown = false;\n  #isCleaningUp = false;\n  #isDisabling = false;\n  #uiManager;\n  static _initialized = false;\n  constructor(_ref) {\n    let {\n      uiManager,\n      pageIndex,\n      div,\n      accessibilityManager,\n      annotationLayer,\n      viewport,\n      l10n\n    } = _ref;\n    const editorTypes = [_freetext.FreeTextEditor, _ink.InkEditor, _stamp.StampEditor];\n    if (!AnnotationEditorLayer._initialized) {\n      AnnotationEditorLayer._initialized = true;\n      for (const editorType of editorTypes) {\n        editorType.initialize(l10n);\n      }\n    }\n    uiManager.registerEditorTypes(editorTypes);\n    this.#uiManager = uiManager;\n    this.pageIndex = pageIndex;\n    this.div = div;\n    this.#accessibilityManager = accessibilityManager;\n    this.#annotationLayer = annotationLayer;\n    this.viewport = viewport;\n    this.#uiManager.addLayer(this);\n  }\n  get isEmpty() {\n    return this.#editors.size === 0;\n  }\n  updateToolbar(mode) {\n    this.#uiManager.updateToolbar(mode);\n  }\n  updateMode() {\n    let mode = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : this.#uiManager.getMode();\n    this.#cleanup();\n    if (mode === _util.AnnotationEditorType.INK) {\n      this.addInkEditorIfNeeded(false);\n      this.disableClick();\n    } else {\n      this.enableClick();\n    }\n    if (mode !== _util.AnnotationEditorType.NONE) {\n      this.div.classList.toggle(\"freeTextEditing\", mode === _util.AnnotationEditorType.FREETEXT);\n      this.div.classList.toggle(\"inkEditing\", mode === _util.AnnotationEditorType.INK);\n      this.div.classList.toggle(\"stampEditing\", mode === _util.AnnotationEditorType.STAMP);\n      this.div.hidden = false;\n    }\n  }\n  addInkEditorIfNeeded(isCommitting) {\n    if (!isCommitting && this.#uiManager.getMode() !== _util.AnnotationEditorType.INK) {\n      return;\n    }\n    if (!isCommitting) {\n      for (const editor of this.#editors.values()) {\n        if (editor.isEmpty()) {\n          editor.setInBackground();\n          return;\n        }\n      }\n    }\n    const editor = this.#createAndAddNewEditor({\n      offsetX: 0,\n      offsetY: 0\n    }, false);\n    editor.setInBackground();\n  }\n  setEditingState(isEditing) {\n    this.#uiManager.setEditingState(isEditing);\n  }\n  addCommands(params) {\n    this.#uiManager.addCommands(params);\n  }\n  enable() {\n    this.div.style.pointerEvents = \"auto\";\n    const annotationElementIds = new Set();\n    for (const editor of this.#editors.values()) {\n      editor.enableEditing();\n      if (editor.annotationElementId) {\n        annotationElementIds.add(editor.annotationElementId);\n      }\n    }\n    if (!this.#annotationLayer) {\n      return;\n    }\n    const editables = this.#annotationLayer.getEditableAnnotations();\n    for (const editable of editables) {\n      editable.hide();\n      if (this.#uiManager.isDeletedAnnotationElement(editable.data.id)) {\n        continue;\n      }\n      if (annotationElementIds.has(editable.data.id)) {\n        continue;\n      }\n      const editor = this.deserialize(editable);\n      if (!editor) {\n        continue;\n      }\n      this.addOrRebuild(editor);\n      editor.enableEditing();\n    }\n  }\n  disable() {\n    this.#isDisabling = true;\n    this.div.style.pointerEvents = \"none\";\n    const hiddenAnnotationIds = new Set();\n    for (const editor of this.#editors.values()) {\n      editor.disableEditing();\n      if (!editor.annotationElementId || editor.serialize() !== null) {\n        hiddenAnnotationIds.add(editor.annotationElementId);\n        continue;\n      }\n      this.getEditableAnnotation(editor.annotationElementId)?.show();\n      editor.remove();\n    }\n    if (this.#annotationLayer) {\n      const editables = this.#annotationLayer.getEditableAnnotations();\n      for (const editable of editables) {\n        const {\n          id\n        } = editable.data;\n        if (hiddenAnnotationIds.has(id) || this.#uiManager.isDeletedAnnotationElement(id)) {\n          continue;\n        }\n        editable.show();\n      }\n    }\n    this.#cleanup();\n    if (this.isEmpty) {\n      this.div.hidden = true;\n    }\n    this.#isDisabling = false;\n  }\n  getEditableAnnotation(id) {\n    return this.#annotationLayer?.getEditableAnnotation(id) || null;\n  }\n  setActiveEditor(editor) {\n    const currentActive = this.#uiManager.getActive();\n    if (currentActive === editor) {\n      return;\n    }\n    this.#uiManager.setActiveEditor(editor);\n  }\n  enableClick() {\n    this.div.addEventListener(\"pointerdown\", this.#boundPointerdown);\n    this.div.addEventListener(\"pointerup\", this.#boundPointerup);\n  }\n  disableClick() {\n    this.div.removeEventListener(\"pointerdown\", this.#boundPointerdown);\n    this.div.removeEventListener(\"pointerup\", this.#boundPointerup);\n  }\n  attach(editor) {\n    this.#editors.set(editor.id, editor);\n    const {\n      annotationElementId\n    } = editor;\n    if (annotationElementId && this.#uiManager.isDeletedAnnotationElement(annotationElementId)) {\n      this.#uiManager.removeDeletedAnnotationElement(editor);\n    }\n  }\n  detach(editor) {\n    this.#editors.delete(editor.id);\n    this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n    if (!this.#isDisabling && editor.annotationElementId) {\n      this.#uiManager.addDeletedAnnotationElement(editor);\n    }\n  }\n  remove(editor) {\n    this.detach(editor);\n    this.#uiManager.removeEditor(editor);\n    if (editor.div.contains(document.activeElement)) {\n      setTimeout(() => {\n        this.#uiManager.focusMainContainer();\n      }, 0);\n    }\n    editor.div.remove();\n    editor.isAttachedToDOM = false;\n    if (!this.#isCleaningUp) {\n      this.addInkEditorIfNeeded(false);\n    }\n  }\n  changeParent(editor) {\n    if (editor.parent === this) {\n      return;\n    }\n    if (editor.annotationElementId) {\n      this.#uiManager.addDeletedAnnotationElement(editor.annotationElementId);\n      _editor.AnnotationEditor.deleteAnnotationElement(editor);\n      editor.annotationElementId = null;\n    }\n    this.attach(editor);\n    editor.parent?.detach(editor);\n    editor.setParent(this);\n    if (editor.div && editor.isAttachedToDOM) {\n      editor.div.remove();\n      this.div.append(editor.div);\n    }\n  }\n  add(editor) {\n    this.changeParent(editor);\n    this.#uiManager.addEditor(editor);\n    this.attach(editor);\n    if (!editor.isAttachedToDOM) {\n      const div = editor.render();\n      this.div.append(div);\n      editor.isAttachedToDOM = true;\n    }\n    editor.fixAndSetPosition();\n    editor.onceAdded();\n    this.#uiManager.addToAnnotationStorage(editor);\n  }\n  moveEditorInDOM(editor) {\n    if (!editor.isAttachedToDOM) {\n      return;\n    }\n    const {\n      activeElement\n    } = document;\n    if (editor.div.contains(activeElement)) {\n      editor._focusEventsAllowed = false;\n      setTimeout(() => {\n        if (!editor.div.contains(document.activeElement)) {\n          editor.div.addEventListener(\"focusin\", () => {\n            editor._focusEventsAllowed = true;\n          }, {\n            once: true\n          });\n          activeElement.focus();\n        } else {\n          editor._focusEventsAllowed = true;\n        }\n      }, 0);\n    }\n    editor._structTreeParentId = this.#accessibilityManager?.moveElementInDOM(this.div, editor.div, editor.contentDiv, true);\n  }\n  addOrRebuild(editor) {\n    if (editor.needsToBeRebuilt()) {\n      editor.rebuild();\n    } else {\n      this.add(editor);\n    }\n  }\n  addUndoableEditor(editor) {\n    const cmd = () => editor._uiManager.rebuild(editor);\n    const undo = () => {\n      editor.remove();\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: false\n    });\n  }\n  getNextId() {\n    return this.#uiManager.getId();\n  }\n  #createNewEditor(params) {\n    switch (this.#uiManager.getMode()) {\n      case _util.AnnotationEditorType.FREETEXT:\n        return new _freetext.FreeTextEditor(params);\n      case _util.AnnotationEditorType.INK:\n        return new _ink.InkEditor(params);\n      case _util.AnnotationEditorType.STAMP:\n        return new _stamp.StampEditor(params);\n    }\n    return null;\n  }\n  pasteEditor(mode, params) {\n    this.#uiManager.updateToolbar(mode);\n    this.#uiManager.updateMode(mode);\n    const {\n      offsetX,\n      offsetY\n    } = this.#getCenterPoint();\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: offsetX,\n      y: offsetY,\n      uiManager: this.#uiManager,\n      isCentered: true,\n      ...params\n    });\n    if (editor) {\n      this.add(editor);\n    }\n  }\n  deserialize(data) {\n    switch (data.annotationType ?? data.annotationEditorType) {\n      case _util.AnnotationEditorType.FREETEXT:\n        return _freetext.FreeTextEditor.deserialize(data, this, this.#uiManager);\n      case _util.AnnotationEditorType.INK:\n        return _ink.InkEditor.deserialize(data, this, this.#uiManager);\n      case _util.AnnotationEditorType.STAMP:\n        return _stamp.StampEditor.deserialize(data, this, this.#uiManager);\n    }\n    return null;\n  }\n  #createAndAddNewEditor(event, isCentered) {\n    const id = this.getNextId();\n    const editor = this.#createNewEditor({\n      parent: this,\n      id,\n      x: event.offsetX,\n      y: event.offsetY,\n      uiManager: this.#uiManager,\n      isCentered\n    });\n    if (editor) {\n      this.add(editor);\n    }\n    return editor;\n  }\n  #getCenterPoint() {\n    const {\n      x,\n      y,\n      width,\n      height\n    } = this.div.getBoundingClientRect();\n    const tlX = Math.max(0, x);\n    const tlY = Math.max(0, y);\n    const brX = Math.min(window.innerWidth, x + width);\n    const brY = Math.min(window.innerHeight, y + height);\n    const centerX = (tlX + brX) / 2 - x;\n    const centerY = (tlY + brY) / 2 - y;\n    const [offsetX, offsetY] = this.viewport.rotation % 180 === 0 ? [centerX, centerY] : [centerY, centerX];\n    return {\n      offsetX,\n      offsetY\n    };\n  }\n  addNewEditor() {\n    this.#createAndAddNewEditor(this.#getCenterPoint(), true);\n  }\n  setSelected(editor) {\n    this.#uiManager.setSelected(editor);\n  }\n  toggleSelected(editor) {\n    this.#uiManager.toggleSelected(editor);\n  }\n  isSelected(editor) {\n    return this.#uiManager.isSelected(editor);\n  }\n  unselect(editor) {\n    this.#uiManager.unselect(editor);\n  }\n  pointerup(event) {\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    if (event.target !== this.div) {\n      return;\n    }\n    if (!this.#hadPointerDown) {\n      return;\n    }\n    this.#hadPointerDown = false;\n    if (!this.#allowClick) {\n      this.#allowClick = true;\n      return;\n    }\n    if (this.#uiManager.getMode() === _util.AnnotationEditorType.STAMP) {\n      this.#uiManager.unselectAll();\n      return;\n    }\n    this.#createAndAddNewEditor(event, false);\n  }\n  pointerdown(event) {\n    if (this.#hadPointerDown) {\n      this.#hadPointerDown = false;\n      return;\n    }\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    if (event.button !== 0 || event.ctrlKey && isMac) {\n      return;\n    }\n    if (event.target !== this.div) {\n      return;\n    }\n    this.#hadPointerDown = true;\n    const editor = this.#uiManager.getActive();\n    this.#allowClick = !editor || editor.isEmpty();\n  }\n  findNewParent(editor, x, y) {\n    const layer = this.#uiManager.findParent(x, y);\n    if (layer === null || layer === this) {\n      return false;\n    }\n    layer.changeParent(editor);\n    return true;\n  }\n  destroy() {\n    if (this.#uiManager.getActive()?.parent === this) {\n      this.#uiManager.commitOrRemove();\n      this.#uiManager.setActiveEditor(null);\n    }\n    for (const editor of this.#editors.values()) {\n      this.#accessibilityManager?.removePointerInTextLayer(editor.contentDiv);\n      editor.setParent(null);\n      editor.isAttachedToDOM = false;\n      editor.div.remove();\n    }\n    this.div = null;\n    this.#editors.clear();\n    this.#uiManager.removeLayer(this);\n  }\n  #cleanup() {\n    this.#isCleaningUp = true;\n    for (const editor of this.#editors.values()) {\n      if (editor.isEmpty()) {\n        editor.remove();\n      }\n    }\n    this.#isCleaningUp = false;\n  }\n  render(_ref2) {\n    let {\n      viewport\n    } = _ref2;\n    this.viewport = viewport;\n    (0, _display_utils.setLayerDimensions)(this.div, viewport);\n    for (const editor of this.#uiManager.getEditors(this.pageIndex)) {\n      this.add(editor);\n    }\n    this.updateMode();\n  }\n  update(_ref3) {\n    let {\n      viewport\n    } = _ref3;\n    this.#uiManager.commitOrRemove();\n    this.viewport = viewport;\n    (0, _display_utils.setLayerDimensions)(this.div, {\n      rotation: viewport.rotation\n    });\n    this.updateMode();\n  }\n  get pageDimensions() {\n    const {\n      pageWidth,\n      pageHeight\n    } = this.viewport.rawDims;\n    return [pageWidth, pageHeight];\n  }\n}\nexports.AnnotationEditorLayer = AnnotationEditorLayer;\n\n/***/ }),\n/* 197 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.FreeTextEditor = void 0;\n__w_pdfjs_require__(89);\nvar _util = __w_pdfjs_require__(1);\nvar _tools = __w_pdfjs_require__(165);\nvar _editor = __w_pdfjs_require__(164);\nvar _annotation_layer = __w_pdfjs_require__(198);\nclass FreeTextEditor extends _editor.AnnotationEditor {\n  #boundEditorDivBlur = this.editorDivBlur.bind(this);\n  #boundEditorDivFocus = this.editorDivFocus.bind(this);\n  #boundEditorDivInput = this.editorDivInput.bind(this);\n  #boundEditorDivKeydown = this.editorDivKeydown.bind(this);\n  #color;\n  #content = \"\";\n  #editorDivId = `${this.id}-editor`;\n  #fontSize;\n  #initialData = null;\n  static _freeTextDefaultContent = \"\";\n  static _internalPadding = 0;\n  static _defaultColor = null;\n  static _defaultFontSize = 10;\n  static get _keyboardManager() {\n    const proto = FreeTextEditor.prototype;\n    const arrowChecker = self => self.isEmpty();\n    const small = _tools.AnnotationEditorUIManager.TRANSLATE_SMALL;\n    const big = _tools.AnnotationEditorUIManager.TRANSLATE_BIG;\n    return (0, _util.shadow)(this, \"_keyboardManager\", new _tools.KeyboardManager([[[\"ctrl+s\", \"mac+meta+s\", \"ctrl+p\", \"mac+meta+p\"], proto.commitOrRemove, {\n      bubbles: true\n    }], [[\"ctrl+Enter\", \"mac+meta+Enter\", \"Escape\", \"mac+Escape\"], proto.commitOrRemove], [[\"ArrowLeft\", \"mac+ArrowLeft\"], proto._translateEmpty, {\n      args: [-small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowLeft\", \"mac+shift+ArrowLeft\"], proto._translateEmpty, {\n      args: [-big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowRight\", \"mac+ArrowRight\"], proto._translateEmpty, {\n      args: [small, 0],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowRight\", \"mac+shift+ArrowRight\"], proto._translateEmpty, {\n      args: [big, 0],\n      checker: arrowChecker\n    }], [[\"ArrowUp\", \"mac+ArrowUp\"], proto._translateEmpty, {\n      args: [0, -small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowUp\", \"mac+shift+ArrowUp\"], proto._translateEmpty, {\n      args: [0, -big],\n      checker: arrowChecker\n    }], [[\"ArrowDown\", \"mac+ArrowDown\"], proto._translateEmpty, {\n      args: [0, small],\n      checker: arrowChecker\n    }], [[\"ctrl+ArrowDown\", \"mac+shift+ArrowDown\"], proto._translateEmpty, {\n      args: [0, big],\n      checker: arrowChecker\n    }]]));\n  }\n  static _type = \"freetext\";\n  constructor(params) {\n    super({\n      ...params,\n      name: \"freeTextEditor\"\n    });\n    this.#color = params.color || FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n    this.#fontSize = params.fontSize || FreeTextEditor._defaultFontSize;\n  }\n  static initialize(l10n) {\n    _editor.AnnotationEditor.initialize(l10n, {\n      strings: [\"free_text2_default_content\", \"editor_free_text2_aria_label\"]\n    });\n    const style = getComputedStyle(document.documentElement);\n    this._internalPadding = parseFloat(style.getPropertyValue(\"--freetext-padding\"));\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n        FreeTextEditor._defaultFontSize = value;\n        break;\n      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n        FreeTextEditor._defaultColor = value;\n        break;\n    }\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.FREETEXT_SIZE:\n        this.#updateFontSize(value);\n        break;\n      case _util.AnnotationEditorParamsType.FREETEXT_COLOR:\n        this.#updateColor(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, FreeTextEditor._defaultFontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, FreeTextEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor]];\n  }\n  get propertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.FREETEXT_SIZE, this.#fontSize], [_util.AnnotationEditorParamsType.FREETEXT_COLOR, this.#color]];\n  }\n  #updateFontSize(fontSize) {\n    const setFontsize = size => {\n      this.editorDiv.style.fontSize = `calc(${size}px * var(--scale-factor))`;\n      this.translate(0, -(size - this.#fontSize) * this.parentScale);\n      this.#fontSize = size;\n      this.#setEditorDimensions();\n    };\n    const savedFontsize = this.#fontSize;\n    this.addCommands({\n      cmd: () => {\n        setFontsize(fontSize);\n      },\n      undo: () => {\n        setFontsize(savedFontsize);\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.FREETEXT_SIZE,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  #updateColor(color) {\n    const savedColor = this.#color;\n    this.addCommands({\n      cmd: () => {\n        this.#color = this.editorDiv.style.color = color;\n      },\n      undo: () => {\n        this.#color = this.editorDiv.style.color = savedColor;\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.FREETEXT_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  _translateEmpty(x, y) {\n    this._uiManager.translateSelectedEditors(x, y, true);\n  }\n  getInitialTranslation() {\n    const scale = this.parentScale;\n    return [-FreeTextEditor._internalPadding * scale, -(FreeTextEditor._internalPadding + this.#fontSize) * scale];\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  enableEditMode() {\n    if (this.isInEditMode()) {\n      return;\n    }\n    this.parent.setEditingState(false);\n    this.parent.updateToolbar(_util.AnnotationEditorType.FREETEXT);\n    super.enableEditMode();\n    this.overlayDiv.classList.remove(\"enabled\");\n    this.editorDiv.contentEditable = true;\n    this._isDraggable = false;\n    this.div.removeAttribute(\"aria-activedescendant\");\n    this.editorDiv.addEventListener(\"keydown\", this.#boundEditorDivKeydown);\n    this.editorDiv.addEventListener(\"focus\", this.#boundEditorDivFocus);\n    this.editorDiv.addEventListener(\"blur\", this.#boundEditorDivBlur);\n    this.editorDiv.addEventListener(\"input\", this.#boundEditorDivInput);\n  }\n  disableEditMode() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n    this.parent.setEditingState(true);\n    super.disableEditMode();\n    this.overlayDiv.classList.add(\"enabled\");\n    this.editorDiv.contentEditable = false;\n    this.div.setAttribute(\"aria-activedescendant\", this.#editorDivId);\n    this._isDraggable = true;\n    this.editorDiv.removeEventListener(\"keydown\", this.#boundEditorDivKeydown);\n    this.editorDiv.removeEventListener(\"focus\", this.#boundEditorDivFocus);\n    this.editorDiv.removeEventListener(\"blur\", this.#boundEditorDivBlur);\n    this.editorDiv.removeEventListener(\"input\", this.#boundEditorDivInput);\n    this.div.focus({\n      preventScroll: true\n    });\n    this.isEditing = false;\n    this.parent.div.classList.add(\"freeTextEditing\");\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    super.focusin(event);\n    if (event.target !== this.editorDiv) {\n      this.editorDiv.focus();\n    }\n  }\n  onceAdded() {\n    if (this.width) {\n      this.#cheatInitialRect();\n      return;\n    }\n    this.enableEditMode();\n    this.editorDiv.focus();\n    if (this._initialOptions?.isCentered) {\n      this.center();\n    }\n    this._initialOptions = null;\n  }\n  isEmpty() {\n    return !this.editorDiv || this.editorDiv.innerText.trim() === \"\";\n  }\n  remove() {\n    this.isEditing = false;\n    if (this.parent) {\n      this.parent.setEditingState(true);\n      this.parent.div.classList.add(\"freeTextEditing\");\n    }\n    super.remove();\n  }\n  #extractText() {\n    const divs = this.editorDiv.getElementsByTagName(\"div\");\n    if (divs.length === 0) {\n      return this.editorDiv.innerText;\n    }\n    const buffer = [];\n    for (const div of divs) {\n      buffer.push(div.innerText.replace(/\\r\\n?|\\n/, \"\"));\n    }\n    return buffer.join(\"\\n\");\n  }\n  #setEditorDimensions() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    let rect;\n    if (this.isAttachedToDOM) {\n      rect = this.div.getBoundingClientRect();\n    } else {\n      const {\n        currentLayer,\n        div\n      } = this;\n      const savedDisplay = div.style.display;\n      div.style.display = \"hidden\";\n      currentLayer.div.append(this.div);\n      rect = div.getBoundingClientRect();\n      div.remove();\n      div.style.display = savedDisplay;\n    }\n    if (this.rotation % 180 === this.parentRotation % 180) {\n      this.width = rect.width / parentWidth;\n      this.height = rect.height / parentHeight;\n    } else {\n      this.width = rect.height / parentWidth;\n      this.height = rect.width / parentHeight;\n    }\n    this.fixAndSetPosition();\n  }\n  commit() {\n    if (!this.isInEditMode()) {\n      return;\n    }\n    super.commit();\n    this.disableEditMode();\n    const savedText = this.#content;\n    const newText = this.#content = this.#extractText().trimEnd();\n    if (savedText === newText) {\n      return;\n    }\n    const setText = text => {\n      this.#content = text;\n      if (!text) {\n        this.remove();\n        return;\n      }\n      this.#setContent();\n      this._uiManager.rebuild(this);\n      this.#setEditorDimensions();\n    };\n    this.addCommands({\n      cmd: () => {\n        setText(newText);\n      },\n      undo: () => {\n        setText(savedText);\n      },\n      mustExec: false\n    });\n    this.#setEditorDimensions();\n  }\n  shouldGetKeyboardEvents() {\n    return this.isInEditMode();\n  }\n  enterInEditMode() {\n    this.enableEditMode();\n    this.editorDiv.focus();\n  }\n  dblclick(event) {\n    this.enterInEditMode();\n  }\n  keydown(event) {\n    if (event.target === this.div && event.key === \"Enter\") {\n      this.enterInEditMode();\n      event.preventDefault();\n    }\n  }\n  editorDivKeydown(event) {\n    FreeTextEditor._keyboardManager.exec(this, event);\n  }\n  editorDivFocus(event) {\n    this.isEditing = true;\n  }\n  editorDivBlur(event) {\n    this.isEditing = false;\n  }\n  editorDivInput(event) {\n    this.parent.div.classList.toggle(\"freeTextEditing\", this.isEmpty());\n  }\n  disableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"comment\");\n    this.editorDiv.removeAttribute(\"aria-multiline\");\n  }\n  enableEditing() {\n    this.editorDiv.setAttribute(\"role\", \"textbox\");\n    this.editorDiv.setAttribute(\"aria-multiline\", true);\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.editorDiv = document.createElement(\"div\");\n    this.editorDiv.className = \"internal\";\n    this.editorDiv.setAttribute(\"id\", this.#editorDivId);\n    this.enableEditing();\n    _editor.AnnotationEditor._l10nPromise.get(\"editor_free_text2_aria_label\").then(msg => this.editorDiv?.setAttribute(\"aria-label\", msg));\n    _editor.AnnotationEditor._l10nPromise.get(\"free_text2_default_content\").then(msg => this.editorDiv?.setAttribute(\"default-content\", msg));\n    this.editorDiv.contentEditable = true;\n    const {\n      style\n    } = this.editorDiv;\n    style.fontSize = `calc(${this.#fontSize}px * var(--scale-factor))`;\n    style.color = this.#color;\n    this.div.append(this.editorDiv);\n    this.overlayDiv = document.createElement(\"div\");\n    this.overlayDiv.classList.add(\"overlay\", \"enabled\");\n    this.div.append(this.overlayDiv);\n    (0, _tools.bindEvents)(this, this.div, [\"dblclick\", \"keydown\"]);\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      if (this.annotationElementId) {\n        const {\n          position\n        } = this.#initialData;\n        let [tx, ty] = this.getInitialTranslation();\n        [tx, ty] = this.pageTranslationToScreen(tx, ty);\n        const [pageWidth, pageHeight] = this.pageDimensions;\n        const [pageX, pageY] = this.pageTranslation;\n        let posX, posY;\n        switch (this.rotation) {\n          case 0:\n            posX = baseX + (position[0] - pageX) / pageWidth;\n            posY = baseY + this.height - (position[1] - pageY) / pageHeight;\n            break;\n          case 90:\n            posX = baseX + (position[0] - pageX) / pageWidth;\n            posY = baseY - (position[1] - pageY) / pageHeight;\n            [tx, ty] = [ty, -tx];\n            break;\n          case 180:\n            posX = baseX - this.width + (position[0] - pageX) / pageWidth;\n            posY = baseY - (position[1] - pageY) / pageHeight;\n            [tx, ty] = [-tx, -ty];\n            break;\n          case 270:\n            posX = baseX + (position[0] - pageX - this.height * pageHeight) / pageWidth;\n            posY = baseY + (position[1] - pageY - this.width * pageWidth) / pageHeight;\n            [tx, ty] = [-ty, tx];\n            break;\n        }\n        this.setAt(posX * parentWidth, posY * parentHeight, tx, ty);\n      } else {\n        this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n      }\n      this.#setContent();\n      this._isDraggable = true;\n      this.editorDiv.contentEditable = false;\n    } else {\n      this._isDraggable = false;\n      this.editorDiv.contentEditable = true;\n    }\n    return this.div;\n  }\n  #setContent() {\n    this.editorDiv.replaceChildren();\n    if (!this.#content) {\n      return;\n    }\n    for (const line of this.#content.split(\"\\n\")) {\n      const div = document.createElement(\"div\");\n      div.append(line ? document.createTextNode(line) : document.createElement(\"br\"));\n      this.editorDiv.append(div);\n    }\n  }\n  get contentDiv() {\n    return this.editorDiv;\n  }\n  static deserialize(data, parent, uiManager) {\n    let initialData = null;\n    if (data instanceof _annotation_layer.FreeTextAnnotationElement) {\n      const {\n        data: {\n          defaultAppearanceData: {\n            fontSize,\n            fontColor\n          },\n          rect,\n          rotation,\n          id\n        },\n        textContent,\n        textPosition,\n        parent: {\n          page: {\n            pageNumber\n          }\n        }\n      } = data;\n      if (!textContent || textContent.length === 0) {\n        return null;\n      }\n      initialData = data = {\n        annotationType: _util.AnnotationEditorType.FREETEXT,\n        color: Array.from(fontColor),\n        fontSize,\n        value: textContent.join(\"\\n\"),\n        position: textPosition,\n        pageIndex: pageNumber - 1,\n        rect,\n        rotation,\n        id,\n        deleted: false\n      };\n    }\n    const editor = super.deserialize(data, parent, uiManager);\n    editor.#fontSize = data.fontSize;\n    editor.#color = _util.Util.makeHexColor(...data.color);\n    editor.#content = data.value;\n    editor.annotationElementId = data.id || null;\n    editor.#initialData = initialData;\n    return editor;\n  }\n  serialize() {\n    let isForCopying = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.isEmpty()) {\n      return null;\n    }\n    if (this.deleted) {\n      return {\n        pageIndex: this.pageIndex,\n        id: this.annotationElementId,\n        deleted: true\n      };\n    }\n    const padding = FreeTextEditor._internalPadding * this.parentScale;\n    const rect = this.getRect(padding, padding);\n    const color = _editor.AnnotationEditor._colorManager.convert(this.isAttachedToDOM ? getComputedStyle(this.editorDiv).color : this.#color);\n    const serialized = {\n      annotationType: _util.AnnotationEditorType.FREETEXT,\n      color,\n      fontSize: this.#fontSize,\n      value: this.#content,\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.rotation,\n      structTreeParentId: this._structTreeParentId\n    };\n    if (isForCopying) {\n      return serialized;\n    }\n    if (this.annotationElementId && !this.#hasElementChanged(serialized)) {\n      return null;\n    }\n    serialized.id = this.annotationElementId;\n    return serialized;\n  }\n  #hasElementChanged(serialized) {\n    const {\n      value,\n      fontSize,\n      color,\n      rect,\n      pageIndex\n    } = this.#initialData;\n    return serialized.value !== value || serialized.fontSize !== fontSize || serialized.rect.some((x, i) => Math.abs(x - rect[i]) >= 1) || serialized.color.some((c, i) => c !== color[i]) || serialized.pageIndex !== pageIndex;\n  }\n  #cheatInitialRect() {\n    let delayed = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (!this.annotationElementId) {\n      return;\n    }\n    this.#setEditorDimensions();\n    if (!delayed && (this.width === 0 || this.height === 0)) {\n      setTimeout(() => this.#cheatInitialRect(true), 0);\n      return;\n    }\n    const padding = FreeTextEditor._internalPadding * this.parentScale;\n    this.#initialData.rect = this.getRect(padding, padding);\n  }\n}\nexports.FreeTextEditor = FreeTextEditor;\n\n/***/ }),\n/* 198 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.StampAnnotationElement = exports.InkAnnotationElement = exports.FreeTextAnnotationElement = exports.AnnotationLayer = void 0;\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(125);\n__w_pdfjs_require__(136);\n__w_pdfjs_require__(138);\n__w_pdfjs_require__(141);\n__w_pdfjs_require__(143);\n__w_pdfjs_require__(145);\n__w_pdfjs_require__(147);\nvar _util = __w_pdfjs_require__(1);\nvar _display_utils = __w_pdfjs_require__(168);\nvar _annotation_storage = __w_pdfjs_require__(163);\nvar _scripting_utils = __w_pdfjs_require__(199);\nvar _displayL10n_utils = __w_pdfjs_require__(200);\nvar _xfa_layer = __w_pdfjs_require__(201);\nconst DEFAULT_TAB_INDEX = 1000;\nconst DEFAULT_FONT_SIZE = 9;\nconst GetElementsByNameSet = new WeakSet();\nfunction getRectDims(rect) {\n  return {\n    width: rect[2] - rect[0],\n    height: rect[3] - rect[1]\n  };\n}\nclass AnnotationElementFactory {\n  static create(parameters) {\n    const subtype = parameters.data.annotationType;\n    switch (subtype) {\n      case _util.AnnotationType.LINK:\n        return new LinkAnnotationElement(parameters);\n      case _util.AnnotationType.TEXT:\n        return new TextAnnotationElement(parameters);\n      case _util.AnnotationType.WIDGET:\n        const fieldType = parameters.data.fieldType;\n        switch (fieldType) {\n          case \"Tx\":\n            return new TextWidgetAnnotationElement(parameters);\n          case \"Btn\":\n            if (parameters.data.radioButton) {\n              return new RadioButtonWidgetAnnotationElement(parameters);\n            } else if (parameters.data.checkBox) {\n              return new CheckboxWidgetAnnotationElement(parameters);\n            }\n            return new PushButtonWidgetAnnotationElement(parameters);\n          case \"Ch\":\n            return new ChoiceWidgetAnnotationElement(parameters);\n          case \"Sig\":\n            return new SignatureWidgetAnnotationElement(parameters);\n        }\n        return new WidgetAnnotationElement(parameters);\n      case _util.AnnotationType.POPUP:\n        return new PopupAnnotationElement(parameters);\n      case _util.AnnotationType.FREETEXT:\n        return new FreeTextAnnotationElement(parameters);\n      case _util.AnnotationType.LINE:\n        return new LineAnnotationElement(parameters);\n      case _util.AnnotationType.SQUARE:\n        return new SquareAnnotationElement(parameters);\n      case _util.AnnotationType.CIRCLE:\n        return new CircleAnnotationElement(parameters);\n      case _util.AnnotationType.POLYLINE:\n        return new PolylineAnnotationElement(parameters);\n      case _util.AnnotationType.CARET:\n        return new CaretAnnotationElement(parameters);\n      case _util.AnnotationType.INK:\n        return new InkAnnotationElement(parameters);\n      case _util.AnnotationType.POLYGON:\n        return new PolygonAnnotationElement(parameters);\n      case _util.AnnotationType.HIGHLIGHT:\n        return new HighlightAnnotationElement(parameters);\n      case _util.AnnotationType.UNDERLINE:\n        return new UnderlineAnnotationElement(parameters);\n      case _util.AnnotationType.SQUIGGLY:\n        return new SquigglyAnnotationElement(parameters);\n      case _util.AnnotationType.STRIKEOUT:\n        return new StrikeOutAnnotationElement(parameters);\n      case _util.AnnotationType.STAMP:\n        return new StampAnnotationElement(parameters);\n      case _util.AnnotationType.FILEATTACHMENT:\n        return new FileAttachmentAnnotationElement(parameters);\n      default:\n        return new AnnotationElement(parameters);\n    }\n  }\n}\nclass AnnotationElement {\n  #hasBorder = false;\n  constructor(parameters) {\n    let {\n      isRenderable = false,\n      ignoreBorder = false,\n      createQuadrilaterals = false\n    } = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    this.isRenderable = isRenderable;\n    this.data = parameters.data;\n    this.layer = parameters.layer;\n    this.linkService = parameters.linkService;\n    this.downloadManager = parameters.downloadManager;\n    this.imageResourcesPath = parameters.imageResourcesPath;\n    this.renderForms = parameters.renderForms;\n    this.svgFactory = parameters.svgFactory;\n    this.annotationStorage = parameters.annotationStorage;\n    this.enableScripting = parameters.enableScripting;\n    this.hasJSActions = parameters.hasJSActions;\n    this._fieldObjects = parameters.fieldObjects;\n    this.parent = parameters.parent;\n    if (isRenderable) {\n      this.container = this._createContainer(ignoreBorder);\n    }\n    if (createQuadrilaterals) {\n      this._createQuadrilaterals();\n    }\n  }\n  static _hasPopupData(_ref) {\n    let {\n      titleObj,\n      contentsObj,\n      richText\n    } = _ref;\n    return !!(titleObj?.str || contentsObj?.str || richText?.str);\n  }\n  get hasPopupData() {\n    return AnnotationElement._hasPopupData(this.data);\n  }\n  _createContainer(ignoreBorder) {\n    const {\n      data,\n      parent: {\n        page,\n        viewport\n      }\n    } = this;\n    const container = document.createElement(\"section\");\n    container.setAttribute(\"data-annotation-id\", data.id);\n    if (!(this instanceof WidgetAnnotationElement)) {\n      container.tabIndex = DEFAULT_TAB_INDEX;\n    }\n    container.style.zIndex = this.parent.zIndex++;\n    if (this.data.popupRef) {\n      container.setAttribute(\"aria-haspopup\", \"dialog\");\n    }\n    if (data.noRotate) {\n      container.classList.add(\"norotate\");\n    }\n    const {\n      pageWidth,\n      pageHeight,\n      pageX,\n      pageY\n    } = viewport.rawDims;\n    if (!data.rect || this instanceof PopupAnnotationElement) {\n      const {\n        rotation\n      } = data;\n      if (!data.hasOwnCanvas && rotation !== 0) {\n        this.setRotation(rotation, container);\n      }\n      return container;\n    }\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const rect = _util.Util.normalizeRect([data.rect[0], page.view[3] - data.rect[1] + page.view[1], data.rect[2], page.view[3] - data.rect[3] + page.view[1]]);\n    if (!ignoreBorder && data.borderStyle.width > 0) {\n      container.style.borderWidth = `${data.borderStyle.width}px`;\n      const horizontalRadius = data.borderStyle.horizontalCornerRadius;\n      const verticalRadius = data.borderStyle.verticalCornerRadius;\n      if (horizontalRadius > 0 || verticalRadius > 0) {\n        const radius = `calc(${horizontalRadius}px * var(--scale-factor)) / calc(${verticalRadius}px * var(--scale-factor))`;\n        container.style.borderRadius = radius;\n      } else if (this instanceof RadioButtonWidgetAnnotationElement) {\n        const radius = `calc(${width}px * var(--scale-factor)) / calc(${height}px * var(--scale-factor))`;\n        container.style.borderRadius = radius;\n      }\n      switch (data.borderStyle.style) {\n        case _util.AnnotationBorderStyleType.SOLID:\n          container.style.borderStyle = \"solid\";\n          break;\n        case _util.AnnotationBorderStyleType.DASHED:\n          container.style.borderStyle = \"dashed\";\n          break;\n        case _util.AnnotationBorderStyleType.BEVELED:\n          (0, _util.warn)(\"Unimplemented border style: beveled\");\n          break;\n        case _util.AnnotationBorderStyleType.INSET:\n          (0, _util.warn)(\"Unimplemented border style: inset\");\n          break;\n        case _util.AnnotationBorderStyleType.UNDERLINE:\n          container.style.borderBottomStyle = \"solid\";\n          break;\n        default:\n          break;\n      }\n      const borderColor = data.borderColor || null;\n      if (borderColor) {\n        this.#hasBorder = true;\n        container.style.borderColor = _util.Util.makeHexColor(borderColor[0] | 0, borderColor[1] | 0, borderColor[2] | 0);\n      } else {\n        container.style.borderWidth = 0;\n      }\n    }\n    container.style.left = `${100 * (rect[0] - pageX) / pageWidth}%`;\n    container.style.top = `${100 * (rect[1] - pageY) / pageHeight}%`;\n    const {\n      rotation\n    } = data;\n    if (data.hasOwnCanvas || rotation === 0) {\n      container.style.width = `${100 * width / pageWidth}%`;\n      container.style.height = `${100 * height / pageHeight}%`;\n    } else {\n      this.setRotation(rotation, container);\n    }\n    return container;\n  }\n  setRotation(angle) {\n    let container = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.container;\n    if (!this.data.rect) {\n      return;\n    }\n    const {\n      pageWidth,\n      pageHeight\n    } = this.parent.viewport.rawDims;\n    const {\n      width,\n      height\n    } = getRectDims(this.data.rect);\n    let elementWidth, elementHeight;\n    if (angle % 180 === 0) {\n      elementWidth = 100 * width / pageWidth;\n      elementHeight = 100 * height / pageHeight;\n    } else {\n      elementWidth = 100 * height / pageWidth;\n      elementHeight = 100 * width / pageHeight;\n    }\n    container.style.width = `${elementWidth}%`;\n    container.style.height = `${elementHeight}%`;\n    container.setAttribute(\"data-main-rotation\", (360 - angle) % 360);\n  }\n  get _commonActions() {\n    const setColor = (jsName, styleName, event) => {\n      const color = event.detail[jsName];\n      const colorType = color[0];\n      const colorArray = color.slice(1);\n      event.target.style[styleName] = _scripting_utils.ColorConverters[`${colorType}_HTML`](colorArray);\n      this.annotationStorage.setValue(this.data.id, {\n        [styleName]: _scripting_utils.ColorConverters[`${colorType}_rgb`](colorArray)\n      });\n    };\n    return (0, _util.shadow)(this, \"_commonActions\", {\n      display: event => {\n        const {\n          display\n        } = event.detail;\n        const hidden = display % 2 === 1;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          noView: hidden,\n          noPrint: display === 1 || display === 2\n        });\n      },\n      print: event => {\n        this.annotationStorage.setValue(this.data.id, {\n          noPrint: !event.detail.print\n        });\n      },\n      hidden: event => {\n        const {\n          hidden\n        } = event.detail;\n        this.container.style.visibility = hidden ? \"hidden\" : \"visible\";\n        this.annotationStorage.setValue(this.data.id, {\n          noPrint: hidden,\n          noView: hidden\n        });\n      },\n      focus: event => {\n        setTimeout(() => event.target.focus({\n          preventScroll: false\n        }), 0);\n      },\n      userName: event => {\n        event.target.title = event.detail.userName;\n      },\n      readonly: event => {\n        event.target.disabled = event.detail.readonly;\n      },\n      required: event => {\n        this._setRequired(event.target, event.detail.required);\n      },\n      bgColor: event => {\n        setColor(\"bgColor\", \"backgroundColor\", event);\n      },\n      fillColor: event => {\n        setColor(\"fillColor\", \"backgroundColor\", event);\n      },\n      fgColor: event => {\n        setColor(\"fgColor\", \"color\", event);\n      },\n      textColor: event => {\n        setColor(\"textColor\", \"color\", event);\n      },\n      borderColor: event => {\n        setColor(\"borderColor\", \"borderColor\", event);\n      },\n      strokeColor: event => {\n        setColor(\"strokeColor\", \"borderColor\", event);\n      },\n      rotation: event => {\n        const angle = event.detail.rotation;\n        this.setRotation(angle);\n        this.annotationStorage.setValue(this.data.id, {\n          rotation: angle\n        });\n      }\n    });\n  }\n  _dispatchEventFromSandbox(actions, jsEvent) {\n    const commonActions = this._commonActions;\n    for (const name of Object.keys(jsEvent.detail)) {\n      const action = actions[name] || commonActions[name];\n      action?.(jsEvent);\n    }\n  }\n  _setDefaultPropertiesFromJS(element) {\n    if (!this.enableScripting) {\n      return;\n    }\n    const storedData = this.annotationStorage.getRawValue(this.data.id);\n    if (!storedData) {\n      return;\n    }\n    const commonActions = this._commonActions;\n    for (const [actionName, detail] of Object.entries(storedData)) {\n      const action = commonActions[actionName];\n      if (action) {\n        const eventProxy = {\n          detail: {\n            [actionName]: detail\n          },\n          target: element\n        };\n        action(eventProxy);\n        delete storedData[actionName];\n      }\n    }\n  }\n  _createQuadrilaterals() {\n    if (!this.container) {\n      return;\n    }\n    const {\n      quadPoints\n    } = this.data;\n    if (!quadPoints) {\n      return;\n    }\n    const [rectBlX, rectBlY, rectTrX, rectTrY] = this.data.rect;\n    if (quadPoints.length === 1) {\n      const [, {\n        x: trX,\n        y: trY\n      }, {\n        x: blX,\n        y: blY\n      }] = quadPoints[0];\n      if (rectTrX === trX && rectTrY === trY && rectBlX === blX && rectBlY === blY) {\n        return;\n      }\n    }\n    const {\n      style\n    } = this.container;\n    let svgBuffer;\n    if (this.#hasBorder) {\n      const {\n        borderColor,\n        borderWidth\n      } = style;\n      style.borderWidth = 0;\n      svgBuffer = [\"url('data:image/svg+xml;utf8,\", `<svg xmlns=\"http://www.w3.org/2000/svg\"`, ` preserveAspectRatio=\"none\" viewBox=\"0 0 1 1\">`, `<g fill=\"transparent\" stroke=\"${borderColor}\" stroke-width=\"${borderWidth}\">`];\n      this.container.classList.add(\"hasBorder\");\n    }\n    const width = rectTrX - rectBlX;\n    const height = rectTrY - rectBlY;\n    const {\n      svgFactory\n    } = this;\n    const svg = svgFactory.createElement(\"svg\");\n    svg.classList.add(\"quadrilateralsContainer\");\n    svg.setAttribute(\"width\", 0);\n    svg.setAttribute(\"height\", 0);\n    const defs = svgFactory.createElement(\"defs\");\n    svg.append(defs);\n    const clipPath = svgFactory.createElement(\"clipPath\");\n    const id = `clippath_${this.data.id}`;\n    clipPath.setAttribute(\"id\", id);\n    clipPath.setAttribute(\"clipPathUnits\", \"objectBoundingBox\");\n    defs.append(clipPath);\n    for (const [, {\n      x: trX,\n      y: trY\n    }, {\n      x: blX,\n      y: blY\n    }] of quadPoints) {\n      const rect = svgFactory.createElement(\"rect\");\n      const x = (blX - rectBlX) / width;\n      const y = (rectTrY - trY) / height;\n      const rectWidth = (trX - blX) / width;\n      const rectHeight = (trY - blY) / height;\n      rect.setAttribute(\"x\", x);\n      rect.setAttribute(\"y\", y);\n      rect.setAttribute(\"width\", rectWidth);\n      rect.setAttribute(\"height\", rectHeight);\n      clipPath.append(rect);\n      svgBuffer?.push(`<rect vector-effect=\"non-scaling-stroke\" x=\"${x}\" y=\"${y}\" width=\"${rectWidth}\" height=\"${rectHeight}\"/>`);\n    }\n    if (this.#hasBorder) {\n      svgBuffer.push(`</g></svg>')`);\n      style.backgroundImage = svgBuffer.join(\"\");\n    }\n    this.container.append(svg);\n    this.container.style.clipPath = `url(#${id})`;\n  }\n  _createPopup() {\n    const {\n      container,\n      data\n    } = this;\n    container.setAttribute(\"aria-haspopup\", \"dialog\");\n    const popup = new PopupAnnotationElement({\n      data: {\n        color: data.color,\n        titleObj: data.titleObj,\n        modificationDate: data.modificationDate,\n        contentsObj: data.contentsObj,\n        richText: data.richText,\n        parentRect: data.rect,\n        borderStyle: 0,\n        id: `popup_${data.id}`,\n        rotation: data.rotation\n      },\n      parent: this.parent,\n      elements: [this]\n    });\n    this.parent.div.append(popup.render());\n  }\n  render() {\n    (0, _util.unreachable)(\"Abstract method `AnnotationElement.render` called\");\n  }\n  _getElementsByName(name) {\n    let skipId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    const fields = [];\n    if (this._fieldObjects) {\n      const fieldObj = this._fieldObjects[name];\n      if (fieldObj) {\n        for (const {\n          page,\n          id,\n          exportValues\n        } of fieldObj) {\n          if (page === -1) {\n            continue;\n          }\n          if (id === skipId) {\n            continue;\n          }\n          const exportValue = typeof exportValues === \"string\" ? exportValues : null;\n          const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n          if (domElement && !GetElementsByNameSet.has(domElement)) {\n            (0, _util.warn)(`_getElementsByName - element not allowed: ${id}`);\n            continue;\n          }\n          fields.push({\n            id,\n            exportValue,\n            domElement\n          });\n        }\n      }\n      return fields;\n    }\n    for (const domElement of document.getElementsByName(name)) {\n      const {\n        exportValue\n      } = domElement;\n      const id = domElement.getAttribute(\"data-element-id\");\n      if (id === skipId) {\n        continue;\n      }\n      if (!GetElementsByNameSet.has(domElement)) {\n        continue;\n      }\n      fields.push({\n        id,\n        exportValue,\n        domElement\n      });\n    }\n    return fields;\n  }\n  show() {\n    if (this.container) {\n      this.container.hidden = false;\n    }\n    this.popup?.maybeShow();\n  }\n  hide() {\n    if (this.container) {\n      this.container.hidden = true;\n    }\n    this.popup?.forceHide();\n  }\n  getElementsToTriggerPopup() {\n    return this.container;\n  }\n  addHighlightArea() {\n    const triggers = this.getElementsToTriggerPopup();\n    if (Array.isArray(triggers)) {\n      for (const element of triggers) {\n        element.classList.add(\"highlightArea\");\n      }\n    } else {\n      triggers.classList.add(\"highlightArea\");\n    }\n  }\n  _editOnDoubleClick() {\n    const {\n      annotationEditorType: mode,\n      data: {\n        id: editId\n      }\n    } = this;\n    this.container.addEventListener(\"dblclick\", () => {\n      this.linkService.eventBus?.dispatch(\"switchannotationeditormode\", {\n        source: this,\n        mode,\n        editId\n      });\n    });\n  }\n}\nclass LinkAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    let options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: !!options?.ignoreBorder,\n      createQuadrilaterals: true\n    });\n    this.isTooltipOnly = parameters.data.isTooltipOnly;\n  }\n  render() {\n    const {\n      data,\n      linkService\n    } = this;\n    const link = document.createElement(\"a\");\n    link.setAttribute(\"data-element-id\", data.id);\n    let isBound = false;\n    if (data.url) {\n      linkService.addLinkAttributes(link, data.url, data.newWindow);\n      isBound = true;\n    } else if (data.action) {\n      this._bindNamedAction(link, data.action);\n      isBound = true;\n    } else if (data.attachment) {\n      this._bindAttachment(link, data.attachment);\n      isBound = true;\n    } else if (data.setOCGState) {\n      this.#bindSetOCGState(link, data.setOCGState);\n      isBound = true;\n    } else if (data.dest) {\n      this._bindLink(link, data.dest);\n      isBound = true;\n    } else {\n      if (data.actions && (data.actions.Action || data.actions[\"Mouse Up\"] || data.actions[\"Mouse Down\"]) && this.enableScripting && this.hasJSActions) {\n        this._bindJSAction(link, data);\n        isBound = true;\n      }\n      if (data.resetForm) {\n        this._bindResetFormAction(link, data.resetForm);\n        isBound = true;\n      } else if (this.isTooltipOnly && !isBound) {\n        this._bindLink(link, \"\");\n        isBound = true;\n      }\n    }\n    this.container.classList.add(\"linkAnnotation\");\n    if (isBound) {\n      this.container.append(link);\n    }\n    return this.container;\n  }\n  #setInternalLink() {\n    this.container.setAttribute(\"data-internal-link\", \"\");\n  }\n  _bindLink(link, destination) {\n    link.href = this.linkService.getDestinationHash(destination);\n    link.onclick = () => {\n      if (destination) {\n        this.linkService.goToDestination(destination);\n      }\n      return false;\n    };\n    if (destination || destination === \"\") {\n      this.#setInternalLink();\n    }\n  }\n  _bindNamedAction(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeNamedAction(action);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  _bindAttachment(link, attachment) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.downloadManager?.openOrDownloadData(this.container, attachment.content, attachment.filename);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  #bindSetOCGState(link, action) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    link.onclick = () => {\n      this.linkService.executeSetOCGState(action);\n      return false;\n    };\n    this.#setInternalLink();\n  }\n  _bindJSAction(link, data) {\n    link.href = this.linkService.getAnchorUrl(\"\");\n    const map = new Map([[\"Action\", \"onclick\"], [\"Mouse Up\", \"onmouseup\"], [\"Mouse Down\", \"onmousedown\"]]);\n    for (const name of Object.keys(data.actions)) {\n      const jsName = map.get(name);\n      if (!jsName) {\n        continue;\n      }\n      link[jsName] = () => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: data.id,\n            name\n          }\n        });\n        return false;\n      };\n    }\n    if (!link.onclick) {\n      link.onclick = () => false;\n    }\n    this.#setInternalLink();\n  }\n  _bindResetFormAction(link, resetForm) {\n    const otherClickAction = link.onclick;\n    if (!otherClickAction) {\n      link.href = this.linkService.getAnchorUrl(\"\");\n    }\n    this.#setInternalLink();\n    if (!this._fieldObjects) {\n      (0, _util.warn)(`_bindResetFormAction - \"resetForm\" action not supported, ` + \"ensure that the `fieldObjects` parameter is provided.\");\n      if (!otherClickAction) {\n        link.onclick = () => false;\n      }\n      return;\n    }\n    link.onclick = () => {\n      otherClickAction?.();\n      const {\n        fields: resetFormFields,\n        refs: resetFormRefs,\n        include\n      } = resetForm;\n      const allFields = [];\n      if (resetFormFields.length !== 0 || resetFormRefs.length !== 0) {\n        const fieldIds = new Set(resetFormRefs);\n        for (const fieldName of resetFormFields) {\n          const fields = this._fieldObjects[fieldName] || [];\n          for (const {\n            id\n          } of fields) {\n            fieldIds.add(id);\n          }\n        }\n        for (const fields of Object.values(this._fieldObjects)) {\n          for (const field of fields) {\n            if (fieldIds.has(field.id) === include) {\n              allFields.push(field);\n            }\n          }\n        }\n      } else {\n        for (const fields of Object.values(this._fieldObjects)) {\n          allFields.push(...fields);\n        }\n      }\n      const storage = this.annotationStorage;\n      const allIds = [];\n      for (const field of allFields) {\n        const {\n          id\n        } = field;\n        allIds.push(id);\n        switch (field.type) {\n          case \"text\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          case \"checkbox\":\n          case \"radiobutton\":\n            {\n              const value = field.defaultValue === field.exportValues;\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          case \"combobox\":\n          case \"listbox\":\n            {\n              const value = field.defaultValue || \"\";\n              storage.setValue(id, {\n                value\n              });\n              break;\n            }\n          default:\n            continue;\n        }\n        const domElement = document.querySelector(`[data-element-id=\"${id}\"]`);\n        if (!domElement) {\n          continue;\n        } else if (!GetElementsByNameSet.has(domElement)) {\n          (0, _util.warn)(`_bindResetFormAction - element not allowed: ${id}`);\n          continue;\n        }\n        domElement.dispatchEvent(new Event(\"resetform\"));\n      }\n      if (this.enableScripting) {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: \"app\",\n            ids: allIds,\n            name: \"ResetForm\"\n          }\n        });\n      }\n      return false;\n    };\n  }\n}\nclass TextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"textAnnotation\");\n    const image = document.createElement(\"img\");\n    image.src = this.imageResourcesPath + \"annotation-\" + this.data.name.toLowerCase() + \".svg\";\n    image.alt = \"[{{type}} Annotation]\";\n    image.dataset.l10nId = \"text_annotation_type\";\n    image.dataset.l10nArgs = JSON.stringify({\n      type: this.data.name\n    });\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.append(image);\n    return this.container;\n  }\n}\nclass WidgetAnnotationElement extends AnnotationElement {\n  render() {\n    if (this.data.alternativeText) {\n      this.container.title = this.data.alternativeText;\n    }\n    return this.container;\n  }\n  showElementAndHideCanvas(element) {\n    if (this.data.hasOwnCanvas) {\n      if (element.previousSibling?.nodeName === \"CANVAS\") {\n        element.previousSibling.hidden = true;\n      }\n      element.hidden = false;\n    }\n  }\n  _getKeyModifier(event) {\n    const {\n      isWin,\n      isMac\n    } = _util.FeatureTest.platform;\n    return isWin && event.ctrlKey || isMac && event.metaKey;\n  }\n  _setEventListener(element, elementData, baseName, eventName, valueGetter) {\n    if (baseName.includes(\"mouse\")) {\n      element.addEventListener(baseName, event => {\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event),\n            shift: event.shiftKey,\n            modifier: this._getKeyModifier(event)\n          }\n        });\n      });\n    } else {\n      element.addEventListener(baseName, event => {\n        if (baseName === \"blur\") {\n          if (!elementData.focused || !event.relatedTarget) {\n            return;\n          }\n          elementData.focused = false;\n        } else if (baseName === \"focus\") {\n          if (elementData.focused) {\n            return;\n          }\n          elementData.focused = true;\n        }\n        if (!valueGetter) {\n          return;\n        }\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id: this.data.id,\n            name: eventName,\n            value: valueGetter(event)\n          }\n        });\n      });\n    }\n  }\n  _setEventListeners(element, elementData, names, getter) {\n    for (const [baseName, eventName] of names) {\n      if (eventName === \"Action\" || this.data.actions?.[eventName]) {\n        if (eventName === \"Focus\" || eventName === \"Blur\") {\n          elementData ||= {\n            focused: false\n          };\n        }\n        this._setEventListener(element, elementData, baseName, eventName, getter);\n        if (eventName === \"Focus\" && !this.data.actions?.Blur) {\n          this._setEventListener(element, elementData, \"blur\", \"Blur\", null);\n        } else if (eventName === \"Blur\" && !this.data.actions?.Focus) {\n          this._setEventListener(element, elementData, \"focus\", \"Focus\", null);\n        }\n      }\n    }\n  }\n  _setBackgroundColor(element) {\n    const color = this.data.backgroundColor || null;\n    element.style.backgroundColor = color === null ? \"transparent\" : _util.Util.makeHexColor(color[0], color[1], color[2]);\n  }\n  _setTextStyle(element) {\n    const TEXT_ALIGNMENT = [\"left\", \"center\", \"right\"];\n    const {\n      fontColor\n    } = this.data.defaultAppearanceData;\n    const fontSize = this.data.defaultAppearanceData.fontSize || DEFAULT_FONT_SIZE;\n    const style = element.style;\n    let computedFontSize;\n    const BORDER_SIZE = 2;\n    const roundToOneDecimal = x => Math.round(10 * x) / 10;\n    if (this.data.multiLine) {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n      const numberOfLines = Math.round(height / (_util.LINE_FACTOR * fontSize)) || 1;\n      const lineHeight = height / numberOfLines;\n      computedFontSize = Math.min(fontSize, roundToOneDecimal(lineHeight / _util.LINE_FACTOR));\n    } else {\n      const height = Math.abs(this.data.rect[3] - this.data.rect[1] - BORDER_SIZE);\n      computedFontSize = Math.min(fontSize, roundToOneDecimal(height / _util.LINE_FACTOR));\n    }\n    style.fontSize = `calc(${computedFontSize}px * var(--scale-factor))`;\n    style.color = _util.Util.makeHexColor(fontColor[0], fontColor[1], fontColor[2]);\n    if (this.data.textAlignment !== null) {\n      style.textAlign = TEXT_ALIGNMENT[this.data.textAlignment];\n    }\n  }\n  _setRequired(element, isRequired) {\n    if (isRequired) {\n      element.setAttribute(\"required\", true);\n    } else {\n      element.removeAttribute(\"required\");\n    }\n    element.setAttribute(\"aria-required\", isRequired);\n  }\n}\nclass TextWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    const isRenderable = parameters.renderForms || !parameters.data.hasAppearance && !!parameters.data.fieldValue;\n    super(parameters, {\n      isRenderable\n    });\n  }\n  setPropertyOnSiblings(base, key, value, keyInStorage) {\n    const storage = this.annotationStorage;\n    for (const element of this._getElementsByName(base.name, base.id)) {\n      if (element.domElement) {\n        element.domElement[key] = value;\n      }\n      storage.setValue(element.id, {\n        [keyInStorage]: value\n      });\n    }\n  }\n  render() {\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    this.container.classList.add(\"textWidgetAnnotation\");\n    let element = null;\n    if (this.renderForms) {\n      const storedData = storage.getValue(id, {\n        value: this.data.fieldValue\n      });\n      let textContent = storedData.value || \"\";\n      const maxLen = storage.getValue(id, {\n        charLimit: this.data.maxLen\n      }).charLimit;\n      if (maxLen && textContent.length > maxLen) {\n        textContent = textContent.slice(0, maxLen);\n      }\n      let fieldFormattedValues = storedData.formattedValue || this.data.textContent?.join(\"\\n\") || null;\n      if (fieldFormattedValues && this.data.comb) {\n        fieldFormattedValues = fieldFormattedValues.replaceAll(/\\s+/g, \"\");\n      }\n      const elementData = {\n        userValue: textContent,\n        formattedValue: fieldFormattedValues,\n        lastCommittedValue: null,\n        commitKey: 1,\n        focused: false\n      };\n      if (this.data.multiLine) {\n        element = document.createElement(\"textarea\");\n        element.textContent = fieldFormattedValues ?? textContent;\n        if (this.data.doNotScroll) {\n          element.style.overflowY = \"hidden\";\n        }\n      } else {\n        element = document.createElement(\"input\");\n        element.type = \"text\";\n        element.setAttribute(\"value\", fieldFormattedValues ?? textContent);\n        if (this.data.doNotScroll) {\n          element.style.overflowX = \"hidden\";\n        }\n      }\n      if (this.data.hasOwnCanvas) {\n        element.hidden = true;\n      }\n      GetElementsByNameSet.add(element);\n      element.setAttribute(\"data-element-id\", id);\n      element.disabled = this.data.readOnly;\n      element.name = this.data.fieldName;\n      element.tabIndex = DEFAULT_TAB_INDEX;\n      this._setRequired(element, this.data.required);\n      if (maxLen) {\n        element.maxLength = maxLen;\n      }\n      element.addEventListener(\"input\", event => {\n        storage.setValue(id, {\n          value: event.target.value\n        });\n        this.setPropertyOnSiblings(element, \"value\", event.target.value, \"value\");\n        elementData.formattedValue = null;\n      });\n      element.addEventListener(\"resetform\", event => {\n        const defaultValue = this.data.defaultFieldValue ?? \"\";\n        element.value = elementData.userValue = defaultValue;\n        elementData.formattedValue = null;\n      });\n      let blurListener = event => {\n        const {\n          formattedValue\n        } = elementData;\n        if (formattedValue !== null && formattedValue !== undefined) {\n          event.target.value = formattedValue;\n        }\n        event.target.scrollLeft = 0;\n      };\n      if (this.enableScripting && this.hasJSActions) {\n        element.addEventListener(\"focus\", event => {\n          if (elementData.focused) {\n            return;\n          }\n          const {\n            target\n          } = event;\n          if (elementData.userValue) {\n            target.value = elementData.userValue;\n          }\n          elementData.lastCommittedValue = target.value;\n          elementData.commitKey = 1;\n          elementData.focused = true;\n        });\n        element.addEventListener(\"updatefromsandbox\", jsEvent => {\n          this.showElementAndHideCanvas(jsEvent.target);\n          const actions = {\n            value(event) {\n              elementData.userValue = event.detail.value ?? \"\";\n              storage.setValue(id, {\n                value: elementData.userValue.toString()\n              });\n              event.target.value = elementData.userValue;\n            },\n            formattedValue(event) {\n              const {\n                formattedValue\n              } = event.detail;\n              elementData.formattedValue = formattedValue;\n              if (formattedValue !== null && formattedValue !== undefined && event.target !== document.activeElement) {\n                event.target.value = formattedValue;\n              }\n              storage.setValue(id, {\n                formattedValue\n              });\n            },\n            selRange(event) {\n              event.target.setSelectionRange(...event.detail.selRange);\n            },\n            charLimit: event => {\n              const {\n                charLimit\n              } = event.detail;\n              const {\n                target\n              } = event;\n              if (charLimit === 0) {\n                target.removeAttribute(\"maxLength\");\n                return;\n              }\n              target.setAttribute(\"maxLength\", charLimit);\n              let value = elementData.userValue;\n              if (!value || value.length <= charLimit) {\n                return;\n              }\n              value = value.slice(0, charLimit);\n              target.value = elementData.userValue = value;\n              storage.setValue(id, {\n                value\n              });\n              this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n                source: this,\n                detail: {\n                  id,\n                  name: \"Keystroke\",\n                  value,\n                  willCommit: true,\n                  commitKey: 1,\n                  selStart: target.selectionStart,\n                  selEnd: target.selectionEnd\n                }\n              });\n            }\n          };\n          this._dispatchEventFromSandbox(actions, jsEvent);\n        });\n        element.addEventListener(\"keydown\", event => {\n          elementData.commitKey = 1;\n          let commitKey = -1;\n          if (event.key === \"Escape\") {\n            commitKey = 0;\n          } else if (event.key === \"Enter\" && !this.data.multiLine) {\n            commitKey = 2;\n          } else if (event.key === \"Tab\") {\n            elementData.commitKey = 3;\n          }\n          if (commitKey === -1) {\n            return;\n          }\n          const {\n            value\n          } = event.target;\n          if (elementData.lastCommittedValue === value) {\n            return;\n          }\n          elementData.lastCommittedValue = value;\n          elementData.userValue = value;\n          this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n            source: this,\n            detail: {\n              id,\n              name: \"Keystroke\",\n              value,\n              willCommit: true,\n              commitKey,\n              selStart: event.target.selectionStart,\n              selEnd: event.target.selectionEnd\n            }\n          });\n        });\n        const _blurListener = blurListener;\n        blurListener = null;\n        element.addEventListener(\"blur\", event => {\n          if (!elementData.focused || !event.relatedTarget) {\n            return;\n          }\n          elementData.focused = false;\n          const {\n            value\n          } = event.target;\n          elementData.userValue = value;\n          if (elementData.lastCommittedValue !== value) {\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                willCommit: true,\n                commitKey: elementData.commitKey,\n                selStart: event.target.selectionStart,\n                selEnd: event.target.selectionEnd\n              }\n            });\n          }\n          _blurListener(event);\n        });\n        if (this.data.actions?.Keystroke) {\n          element.addEventListener(\"beforeinput\", event => {\n            elementData.lastCommittedValue = null;\n            const {\n              data,\n              target\n            } = event;\n            const {\n              value,\n              selectionStart,\n              selectionEnd\n            } = target;\n            let selStart = selectionStart,\n              selEnd = selectionEnd;\n            switch (event.inputType) {\n              case \"deleteWordBackward\":\n                {\n                  const match = value.substring(0, selectionStart).match(/\\w*[^\\w]*$/);\n                  if (match) {\n                    selStart -= match[0].length;\n                  }\n                  break;\n                }\n              case \"deleteWordForward\":\n                {\n                  const match = value.substring(selectionStart).match(/^[^\\w]*\\w*/);\n                  if (match) {\n                    selEnd += match[0].length;\n                  }\n                  break;\n                }\n              case \"deleteContentBackward\":\n                if (selectionStart === selectionEnd) {\n                  selStart -= 1;\n                }\n                break;\n              case \"deleteContentForward\":\n                if (selectionStart === selectionEnd) {\n                  selEnd += 1;\n                }\n                break;\n            }\n            event.preventDefault();\n            this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n              source: this,\n              detail: {\n                id,\n                name: \"Keystroke\",\n                value,\n                change: data || \"\",\n                willCommit: false,\n                selStart,\n                selEnd\n              }\n            });\n          });\n        }\n        this._setEventListeners(element, elementData, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.value);\n      }\n      if (blurListener) {\n        element.addEventListener(\"blur\", blurListener);\n      }\n      if (this.data.comb) {\n        const fieldWidth = this.data.rect[2] - this.data.rect[0];\n        const combWidth = fieldWidth / maxLen;\n        element.classList.add(\"comb\");\n        element.style.letterSpacing = `calc(${combWidth}px * var(--scale-factor) - 1ch)`;\n      }\n    } else {\n      element = document.createElement(\"div\");\n      element.textContent = this.data.fieldValue;\n      element.style.verticalAlign = \"middle\";\n      element.style.display = \"table-cell\";\n    }\n    this._setTextStyle(element);\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass SignatureWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: !!parameters.data.hasOwnCanvas\n    });\n  }\n}\nclass CheckboxWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.exportValue === data.fieldValue\n    }).value;\n    if (typeof value === \"string\") {\n      value = value !== \"Off\";\n      storage.setValue(id, {\n        value\n      });\n    }\n    this.container.classList.add(\"buttonWidgetAnnotation\", \"checkBox\");\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n    this._setRequired(element, this.data.required);\n    element.type = \"checkbox\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.setAttribute(\"exportValue\", data.exportValue);\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n      for (const checkbox of this._getElementsByName(name, id)) {\n        const curChecked = checked && checkbox.exportValue === data.exportValue;\n        if (checkbox.domElement) {\n          checkbox.domElement.checked = curChecked;\n        }\n        storage.setValue(checkbox.id, {\n          value: curChecked\n        });\n      }\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue || \"Off\";\n      event.target.checked = defaultValue === data.exportValue;\n    });\n    if (this.enableScripting && this.hasJSActions) {\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            event.target.checked = event.detail.value !== \"Off\";\n            storage.setValue(id, {\n              value: event.target.checked\n            });\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      this._setEventListeners(element, null, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass RadioButtonWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    this.container.classList.add(\"buttonWidgetAnnotation\", \"radioButton\");\n    const storage = this.annotationStorage;\n    const data = this.data;\n    const id = data.id;\n    let value = storage.getValue(id, {\n      value: data.fieldValue === data.buttonValue\n    }).value;\n    if (typeof value === \"string\") {\n      value = value !== data.buttonValue;\n      storage.setValue(id, {\n        value\n      });\n    }\n    const element = document.createElement(\"input\");\n    GetElementsByNameSet.add(element);\n    element.setAttribute(\"data-element-id\", id);\n    element.disabled = data.readOnly;\n    this._setRequired(element, this.data.required);\n    element.type = \"radio\";\n    element.name = data.fieldName;\n    if (value) {\n      element.setAttribute(\"checked\", true);\n    }\n    element.tabIndex = DEFAULT_TAB_INDEX;\n    element.addEventListener(\"change\", event => {\n      const {\n        name,\n        checked\n      } = event.target;\n      for (const radio of this._getElementsByName(name, id)) {\n        storage.setValue(radio.id, {\n          value: false\n        });\n      }\n      storage.setValue(id, {\n        value: checked\n      });\n    });\n    element.addEventListener(\"resetform\", event => {\n      const defaultValue = data.defaultFieldValue;\n      event.target.checked = defaultValue !== null && defaultValue !== undefined && defaultValue === data.buttonValue;\n    });\n    if (this.enableScripting && this.hasJSActions) {\n      const pdfButtonValue = data.buttonValue;\n      element.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value: event => {\n            const checked = pdfButtonValue === event.detail.value;\n            for (const radio of this._getElementsByName(event.target.name)) {\n              const curChecked = checked && radio.id === id;\n              if (radio.domElement) {\n                radio.domElement.checked = curChecked;\n              }\n              storage.setValue(radio.id, {\n                value: curChecked\n              });\n            }\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      this._setEventListeners(element, null, [[\"change\", \"Validate\"], [\"change\", \"Action\"], [\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"]], event => event.target.checked);\n    }\n    this._setBackgroundColor(element);\n    this._setDefaultPropertiesFromJS(element);\n    this.container.append(element);\n    return this.container;\n  }\n}\nclass PushButtonWidgetAnnotationElement extends LinkAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      ignoreBorder: parameters.data.hasAppearance\n    });\n  }\n  render() {\n    const container = super.render();\n    container.classList.add(\"buttonWidgetAnnotation\", \"pushButton\");\n    if (this.data.alternativeText) {\n      container.title = this.data.alternativeText;\n    }\n    const linkElement = container.lastChild;\n    if (this.enableScripting && this.hasJSActions && linkElement) {\n      this._setDefaultPropertiesFromJS(linkElement);\n      linkElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        this._dispatchEventFromSandbox({}, jsEvent);\n      });\n    }\n    return container;\n  }\n}\nclass ChoiceWidgetAnnotationElement extends WidgetAnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: parameters.renderForms\n    });\n  }\n  render() {\n    this.container.classList.add(\"choiceWidgetAnnotation\");\n    const storage = this.annotationStorage;\n    const id = this.data.id;\n    const storedData = storage.getValue(id, {\n      value: this.data.fieldValue\n    });\n    const selectElement = document.createElement(\"select\");\n    GetElementsByNameSet.add(selectElement);\n    selectElement.setAttribute(\"data-element-id\", id);\n    selectElement.disabled = this.data.readOnly;\n    this._setRequired(selectElement, this.data.required);\n    selectElement.name = this.data.fieldName;\n    selectElement.tabIndex = DEFAULT_TAB_INDEX;\n    let addAnEmptyEntry = this.data.combo && this.data.options.length > 0;\n    if (!this.data.combo) {\n      selectElement.size = this.data.options.length;\n      if (this.data.multiSelect) {\n        selectElement.multiple = true;\n      }\n    }\n    selectElement.addEventListener(\"resetform\", event => {\n      const defaultValue = this.data.defaultFieldValue;\n      for (const option of selectElement.options) {\n        option.selected = option.value === defaultValue;\n      }\n    });\n    for (const option of this.data.options) {\n      const optionElement = document.createElement(\"option\");\n      optionElement.textContent = option.displayValue;\n      optionElement.value = option.exportValue;\n      if (storedData.value.includes(option.exportValue)) {\n        optionElement.setAttribute(\"selected\", true);\n        addAnEmptyEntry = false;\n      }\n      selectElement.append(optionElement);\n    }\n    let removeEmptyEntry = null;\n    if (addAnEmptyEntry) {\n      const noneOptionElement = document.createElement(\"option\");\n      noneOptionElement.value = \" \";\n      noneOptionElement.setAttribute(\"hidden\", true);\n      noneOptionElement.setAttribute(\"selected\", true);\n      selectElement.prepend(noneOptionElement);\n      removeEmptyEntry = () => {\n        noneOptionElement.remove();\n        selectElement.removeEventListener(\"input\", removeEmptyEntry);\n        removeEmptyEntry = null;\n      };\n      selectElement.addEventListener(\"input\", removeEmptyEntry);\n    }\n    const getValue = isExport => {\n      const name = isExport ? \"value\" : \"textContent\";\n      const {\n        options,\n        multiple\n      } = selectElement;\n      if (!multiple) {\n        return options.selectedIndex === -1 ? null : options[options.selectedIndex][name];\n      }\n      return Array.prototype.filter.call(options, option => option.selected).map(option => option[name]);\n    };\n    let selectedValues = getValue(false);\n    const getItems = event => {\n      const options = event.target.options;\n      return Array.prototype.map.call(options, option => {\n        return {\n          displayValue: option.textContent,\n          exportValue: option.value\n        };\n      });\n    };\n    if (this.enableScripting && this.hasJSActions) {\n      selectElement.addEventListener(\"updatefromsandbox\", jsEvent => {\n        const actions = {\n          value(event) {\n            removeEmptyEntry?.();\n            const value = event.detail.value;\n            const values = new Set(Array.isArray(value) ? value : [value]);\n            for (const option of selectElement.options) {\n              option.selected = values.has(option.value);\n            }\n            storage.setValue(id, {\n              value: getValue(true)\n            });\n            selectedValues = getValue(false);\n          },\n          multipleSelection(event) {\n            selectElement.multiple = true;\n          },\n          remove(event) {\n            const options = selectElement.options;\n            const index = event.detail.remove;\n            options[index].selected = false;\n            selectElement.remove(index);\n            if (options.length > 0) {\n              const i = Array.prototype.findIndex.call(options, option => option.selected);\n              if (i === -1) {\n                options[0].selected = true;\n              }\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          clear(event) {\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            storage.setValue(id, {\n              value: null,\n              items: []\n            });\n            selectedValues = getValue(false);\n          },\n          insert(event) {\n            const {\n              index,\n              displayValue,\n              exportValue\n            } = event.detail.insert;\n            const selectChild = selectElement.children[index];\n            const optionElement = document.createElement(\"option\");\n            optionElement.textContent = displayValue;\n            optionElement.value = exportValue;\n            if (selectChild) {\n              selectChild.before(optionElement);\n            } else {\n              selectElement.append(optionElement);\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          items(event) {\n            const {\n              items\n            } = event.detail;\n            while (selectElement.length !== 0) {\n              selectElement.remove(0);\n            }\n            for (const item of items) {\n              const {\n                displayValue,\n                exportValue\n              } = item;\n              const optionElement = document.createElement(\"option\");\n              optionElement.textContent = displayValue;\n              optionElement.value = exportValue;\n              selectElement.append(optionElement);\n            }\n            if (selectElement.options.length > 0) {\n              selectElement.options[0].selected = true;\n            }\n            storage.setValue(id, {\n              value: getValue(true),\n              items: getItems(event)\n            });\n            selectedValues = getValue(false);\n          },\n          indices(event) {\n            const indices = new Set(event.detail.indices);\n            for (const option of event.target.options) {\n              option.selected = indices.has(option.index);\n            }\n            storage.setValue(id, {\n              value: getValue(true)\n            });\n            selectedValues = getValue(false);\n          },\n          editable(event) {\n            event.target.disabled = !event.detail.editable;\n          }\n        };\n        this._dispatchEventFromSandbox(actions, jsEvent);\n      });\n      selectElement.addEventListener(\"input\", event => {\n        const exportValue = getValue(true);\n        storage.setValue(id, {\n          value: exportValue\n        });\n        event.preventDefault();\n        this.linkService.eventBus?.dispatch(\"dispatcheventinsandbox\", {\n          source: this,\n          detail: {\n            id,\n            name: \"Keystroke\",\n            value: selectedValues,\n            changeEx: exportValue,\n            willCommit: false,\n            commitKey: 1,\n            keyDown: false\n          }\n        });\n      });\n      this._setEventListeners(selectElement, null, [[\"focus\", \"Focus\"], [\"blur\", \"Blur\"], [\"mousedown\", \"Mouse Down\"], [\"mouseenter\", \"Mouse Enter\"], [\"mouseleave\", \"Mouse Exit\"], [\"mouseup\", \"Mouse Up\"], [\"input\", \"Action\"], [\"input\", \"Validate\"]], event => event.target.value);\n    } else {\n      selectElement.addEventListener(\"input\", function (event) {\n        storage.setValue(id, {\n          value: getValue(true)\n        });\n      });\n    }\n    if (this.data.combo) {\n      this._setTextStyle(selectElement);\n    } else {}\n    this._setBackgroundColor(selectElement);\n    this._setDefaultPropertiesFromJS(selectElement);\n    this.container.append(selectElement);\n    return this.container;\n  }\n}\nclass PopupAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    const {\n      data,\n      elements\n    } = parameters;\n    super(parameters, {\n      isRenderable: AnnotationElement._hasPopupData(data)\n    });\n    this.elements = elements;\n  }\n  render() {\n    this.container.classList.add(\"popupAnnotation\");\n    const popup = new PopupElement({\n      container: this.container,\n      color: this.data.color,\n      titleObj: this.data.titleObj,\n      modificationDate: this.data.modificationDate,\n      contentsObj: this.data.contentsObj,\n      richText: this.data.richText,\n      rect: this.data.rect,\n      parentRect: this.data.parentRect || null,\n      parent: this.parent,\n      elements: this.elements,\n      open: this.data.open\n    });\n    const elementIds = [];\n    for (const element of this.elements) {\n      element.popup = popup;\n      elementIds.push(element.data.id);\n      element.addHighlightArea();\n    }\n    this.container.setAttribute(\"aria-controls\", elementIds.map(id => `${_util.AnnotationPrefix}${id}`).join(\",\"));\n    return this.container;\n  }\n}\nclass PopupElement {\n  #dateTimePromise = null;\n  #boundKeyDown = this.#keyDown.bind(this);\n  #boundHide = this.#hide.bind(this);\n  #boundShow = this.#show.bind(this);\n  #boundToggle = this.#toggle.bind(this);\n  #color = null;\n  #container = null;\n  #contentsObj = null;\n  #elements = null;\n  #parent = null;\n  #parentRect = null;\n  #pinned = false;\n  #popup = null;\n  #rect = null;\n  #richText = null;\n  #titleObj = null;\n  #wasVisible = false;\n  constructor(_ref2) {\n    let {\n      container,\n      color,\n      elements,\n      titleObj,\n      modificationDate,\n      contentsObj,\n      richText,\n      parent,\n      rect,\n      parentRect,\n      open\n    } = _ref2;\n    this.#container = container;\n    this.#titleObj = titleObj;\n    this.#contentsObj = contentsObj;\n    this.#richText = richText;\n    this.#parent = parent;\n    this.#color = color;\n    this.#rect = rect;\n    this.#parentRect = parentRect;\n    this.#elements = elements;\n    const dateObject = _display_utils.PDFDateString.toDateObject(modificationDate);\n    if (dateObject) {\n      this.#dateTimePromise = parent.l10n.get(\"annotation_date_string\", {\n        date: dateObject.toLocaleDateString(),\n        time: dateObject.toLocaleTimeString()\n      });\n    }\n    this.trigger = elements.flatMap(e => e.getElementsToTriggerPopup());\n    for (const element of this.trigger) {\n      element.addEventListener(\"click\", this.#boundToggle);\n      element.addEventListener(\"mouseenter\", this.#boundShow);\n      element.addEventListener(\"mouseleave\", this.#boundHide);\n      element.classList.add(\"popupTriggerArea\");\n    }\n    for (const element of elements) {\n      element.container?.addEventListener(\"keydown\", this.#boundKeyDown);\n    }\n    this.#container.hidden = true;\n    if (open) {\n      this.#toggle();\n    }\n  }\n  render() {\n    if (this.#popup) {\n      return;\n    }\n    const {\n      page: {\n        view\n      },\n      viewport: {\n        rawDims: {\n          pageWidth,\n          pageHeight,\n          pageX,\n          pageY\n        }\n      }\n    } = this.#parent;\n    const popup = this.#popup = document.createElement(\"div\");\n    popup.className = \"popup\";\n    if (this.#color) {\n      const baseColor = popup.style.outlineColor = _util.Util.makeHexColor(...this.#color);\n      if (CSS.supports(\"background-color\", \"color-mix(in srgb, red 30%, white)\")) {\n        popup.style.backgroundColor = `color-mix(in srgb, ${baseColor} 30%, white)`;\n      } else {\n        const BACKGROUND_ENLIGHT = 0.7;\n        popup.style.backgroundColor = _util.Util.makeHexColor(...this.#color.map(c => Math.floor(BACKGROUND_ENLIGHT * (255 - c) + c)));\n      }\n    }\n    const header = document.createElement(\"span\");\n    header.className = \"header\";\n    const title = document.createElement(\"h1\");\n    header.append(title);\n    ({\n      dir: title.dir,\n      str: title.textContent\n    } = this.#titleObj);\n    popup.append(header);\n    if (this.#dateTimePromise) {\n      const modificationDate = document.createElement(\"span\");\n      modificationDate.classList.add(\"popupDate\");\n      this.#dateTimePromise.then(localized => {\n        modificationDate.textContent = localized;\n      });\n      header.append(modificationDate);\n    }\n    const contentsObj = this.#contentsObj;\n    const richText = this.#richText;\n    if (richText?.str && (!contentsObj?.str || contentsObj.str === richText.str)) {\n      _xfa_layer.XfaLayer.render({\n        xfaHtml: richText.html,\n        intent: \"richText\",\n        div: popup\n      });\n      popup.lastChild.classList.add(\"richText\", \"popupContent\");\n    } else {\n      const contents = this._formatContents(contentsObj);\n      popup.append(contents);\n    }\n    let useParentRect = !!this.#parentRect;\n    let rect = useParentRect ? this.#parentRect : this.#rect;\n    for (const element of this.#elements) {\n      if (!rect || _util.Util.intersect(element.data.rect, rect) !== null) {\n        rect = element.data.rect;\n        useParentRect = true;\n        break;\n      }\n    }\n    const normalizedRect = _util.Util.normalizeRect([rect[0], view[3] - rect[1] + view[1], rect[2], view[3] - rect[3] + view[1]]);\n    const HORIZONTAL_SPACE_AFTER_ANNOTATION = 5;\n    const parentWidth = useParentRect ? rect[2] - rect[0] + HORIZONTAL_SPACE_AFTER_ANNOTATION : 0;\n    const popupLeft = normalizedRect[0] + parentWidth;\n    const popupTop = normalizedRect[1];\n    const {\n      style\n    } = this.#container;\n    style.left = `${100 * (popupLeft - pageX) / pageWidth}%`;\n    style.top = `${100 * (popupTop - pageY) / pageHeight}%`;\n    this.#container.append(popup);\n  }\n  _formatContents(_ref3) {\n    let {\n      str,\n      dir\n    } = _ref3;\n    const p = document.createElement(\"p\");\n    p.classList.add(\"popupContent\");\n    p.dir = dir;\n    const lines = str.split(/(?:\\r\\n?|\\n)/);\n    for (let i = 0, ii = lines.length; i < ii; ++i) {\n      const line = lines[i];\n      p.append(document.createTextNode(line));\n      if (i < ii - 1) {\n        p.append(document.createElement(\"br\"));\n      }\n    }\n    return p;\n  }\n  #keyDown(event) {\n    if (event.altKey || event.shiftKey || event.ctrlKey || event.metaKey) {\n      return;\n    }\n    if (event.key === \"Enter\" || event.key === \"Escape\" && this.#pinned) {\n      this.#toggle();\n    }\n  }\n  #toggle() {\n    this.#pinned = !this.#pinned;\n    if (this.#pinned) {\n      this.#show();\n      this.#container.addEventListener(\"click\", this.#boundToggle);\n      this.#container.addEventListener(\"keydown\", this.#boundKeyDown);\n    } else {\n      this.#hide();\n      this.#container.removeEventListener(\"click\", this.#boundToggle);\n      this.#container.removeEventListener(\"keydown\", this.#boundKeyDown);\n    }\n  }\n  #show() {\n    if (!this.#popup) {\n      this.render();\n    }\n    if (!this.isVisible) {\n      this.#container.hidden = false;\n      this.#container.style.zIndex = parseInt(this.#container.style.zIndex) + 1000;\n    } else if (this.#pinned) {\n      this.#container.classList.add(\"focused\");\n    }\n  }\n  #hide() {\n    this.#container.classList.remove(\"focused\");\n    if (this.#pinned || !this.isVisible) {\n      return;\n    }\n    this.#container.hidden = true;\n    this.#container.style.zIndex = parseInt(this.#container.style.zIndex) - 1000;\n  }\n  forceHide() {\n    this.#wasVisible = this.isVisible;\n    if (!this.#wasVisible) {\n      return;\n    }\n    this.#container.hidden = true;\n  }\n  maybeShow() {\n    if (!this.#wasVisible) {\n      return;\n    }\n    this.#wasVisible = false;\n    this.#container.hidden = false;\n  }\n  get isVisible() {\n    return this.#container.hidden === false;\n  }\n}\nclass FreeTextAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.textContent = parameters.data.textContent;\n    this.textPosition = parameters.data.textPosition;\n    this.annotationEditorType = _util.AnnotationEditorType.FREETEXT;\n  }\n  render() {\n    this.container.classList.add(\"freeTextAnnotation\");\n    if (this.textContent) {\n      const content = document.createElement(\"div\");\n      content.classList.add(\"annotationTextContent\");\n      content.setAttribute(\"role\", \"comment\");\n      for (const line of this.textContent) {\n        const lineSpan = document.createElement(\"span\");\n        lineSpan.textContent = line;\n        content.append(lineSpan);\n      }\n      this.container.append(content);\n    }\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this._editOnDoubleClick();\n    return this.container;\n  }\n}\nexports.FreeTextAnnotationElement = FreeTextAnnotationElement;\nclass LineAnnotationElement extends AnnotationElement {\n  #line = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"lineAnnotation\");\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const line = this.#line = this.svgFactory.createElement(\"svg:line\");\n    line.setAttribute(\"x1\", data.rect[2] - data.lineCoordinates[0]);\n    line.setAttribute(\"y1\", data.rect[3] - data.lineCoordinates[1]);\n    line.setAttribute(\"x2\", data.rect[2] - data.lineCoordinates[2]);\n    line.setAttribute(\"y2\", data.rect[3] - data.lineCoordinates[3]);\n    line.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    line.setAttribute(\"stroke\", \"transparent\");\n    line.setAttribute(\"fill\", \"transparent\");\n    svg.append(line);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#line;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass SquareAnnotationElement extends AnnotationElement {\n  #square = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"squareAnnotation\");\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const square = this.#square = this.svgFactory.createElement(\"svg:rect\");\n    square.setAttribute(\"x\", borderWidth / 2);\n    square.setAttribute(\"y\", borderWidth / 2);\n    square.setAttribute(\"width\", width - borderWidth);\n    square.setAttribute(\"height\", height - borderWidth);\n    square.setAttribute(\"stroke-width\", borderWidth || 1);\n    square.setAttribute(\"stroke\", \"transparent\");\n    square.setAttribute(\"fill\", \"transparent\");\n    svg.append(square);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#square;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass CircleAnnotationElement extends AnnotationElement {\n  #circle = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"circleAnnotation\");\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    const borderWidth = data.borderStyle.width;\n    const circle = this.#circle = this.svgFactory.createElement(\"svg:ellipse\");\n    circle.setAttribute(\"cx\", width / 2);\n    circle.setAttribute(\"cy\", height / 2);\n    circle.setAttribute(\"rx\", width / 2 - borderWidth / 2);\n    circle.setAttribute(\"ry\", height / 2 - borderWidth / 2);\n    circle.setAttribute(\"stroke-width\", borderWidth || 1);\n    circle.setAttribute(\"stroke\", \"transparent\");\n    circle.setAttribute(\"fill\", \"transparent\");\n    svg.append(circle);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#circle;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass PolylineAnnotationElement extends AnnotationElement {\n  #polyline = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"polylineAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n  }\n  render() {\n    this.container.classList.add(this.containerClassName);\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    let points = [];\n    for (const coordinate of data.vertices) {\n      const x = coordinate.x - data.rect[0];\n      const y = data.rect[3] - coordinate.y;\n      points.push(x + \",\" + y);\n    }\n    points = points.join(\" \");\n    const polyline = this.#polyline = this.svgFactory.createElement(this.svgElementName);\n    polyline.setAttribute(\"points\", points);\n    polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n    polyline.setAttribute(\"stroke\", \"transparent\");\n    polyline.setAttribute(\"fill\", \"transparent\");\n    svg.append(polyline);\n    this.container.append(svg);\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#polyline;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nclass PolygonAnnotationElement extends PolylineAnnotationElement {\n  constructor(parameters) {\n    super(parameters);\n    this.containerClassName = \"polygonAnnotation\";\n    this.svgElementName = \"svg:polygon\";\n  }\n}\nclass CaretAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"caretAnnotation\");\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n}\nclass InkAnnotationElement extends AnnotationElement {\n  #polylines = [];\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n    this.containerClassName = \"inkAnnotation\";\n    this.svgElementName = \"svg:polyline\";\n    this.annotationEditorType = _util.AnnotationEditorType.INK;\n  }\n  render() {\n    this.container.classList.add(this.containerClassName);\n    const data = this.data;\n    const {\n      width,\n      height\n    } = getRectDims(data.rect);\n    const svg = this.svgFactory.create(width, height, true);\n    for (const inkList of data.inkLists) {\n      let points = [];\n      for (const coordinate of inkList) {\n        const x = coordinate.x - data.rect[0];\n        const y = data.rect[3] - coordinate.y;\n        points.push(`${x},${y}`);\n      }\n      points = points.join(\" \");\n      const polyline = this.svgFactory.createElement(this.svgElementName);\n      this.#polylines.push(polyline);\n      polyline.setAttribute(\"points\", points);\n      polyline.setAttribute(\"stroke-width\", data.borderStyle.width || 1);\n      polyline.setAttribute(\"stroke\", \"transparent\");\n      polyline.setAttribute(\"fill\", \"transparent\");\n      if (!data.popupRef && this.hasPopupData) {\n        this._createPopup();\n      }\n      svg.append(polyline);\n    }\n    this.container.append(svg);\n    return this.container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#polylines;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n}\nexports.InkAnnotationElement = InkAnnotationElement;\nclass HighlightAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"highlightAnnotation\");\n    return this.container;\n  }\n}\nclass UnderlineAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"underlineAnnotation\");\n    return this.container;\n  }\n}\nclass SquigglyAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"squigglyAnnotation\");\n    return this.container;\n  }\n}\nclass StrikeOutAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true,\n      createQuadrilaterals: true\n    });\n  }\n  render() {\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    this.container.classList.add(\"strikeoutAnnotation\");\n    return this.container;\n  }\n}\nclass StampAnnotationElement extends AnnotationElement {\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true,\n      ignoreBorder: true\n    });\n  }\n  render() {\n    this.container.classList.add(\"stampAnnotation\");\n    if (!this.data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    }\n    return this.container;\n  }\n}\nexports.StampAnnotationElement = StampAnnotationElement;\nclass FileAttachmentAnnotationElement extends AnnotationElement {\n  #trigger = null;\n  constructor(parameters) {\n    super(parameters, {\n      isRenderable: true\n    });\n    const {\n      filename,\n      content\n    } = this.data.file;\n    this.filename = (0, _display_utils.getFilenameFromUrl)(filename, true);\n    this.content = content;\n    this.linkService.eventBus?.dispatch(\"fileattachmentannotation\", {\n      source: this,\n      filename,\n      content\n    });\n  }\n  render() {\n    this.container.classList.add(\"fileAttachmentAnnotation\");\n    const {\n      container,\n      data\n    } = this;\n    let trigger;\n    if (data.hasAppearance || data.fillAlpha === 0) {\n      trigger = document.createElement(\"div\");\n    } else {\n      trigger = document.createElement(\"img\");\n      trigger.src = `${this.imageResourcesPath}annotation-${/paperclip/i.test(data.name) ? \"paperclip\" : \"pushpin\"}.svg`;\n      if (data.fillAlpha && data.fillAlpha < 1) {\n        trigger.style = `filter: opacity(${Math.round(data.fillAlpha * 100)}%);`;\n      }\n    }\n    trigger.addEventListener(\"dblclick\", this.#download.bind(this));\n    this.#trigger = trigger;\n    const {\n      isMac\n    } = _util.FeatureTest.platform;\n    container.addEventListener(\"keydown\", evt => {\n      if (evt.key === \"Enter\" && (isMac ? evt.metaKey : evt.ctrlKey)) {\n        this.#download();\n      }\n    });\n    if (!data.popupRef && this.hasPopupData) {\n      this._createPopup();\n    } else {\n      trigger.classList.add(\"popupTriggerArea\");\n    }\n    container.append(trigger);\n    return container;\n  }\n  getElementsToTriggerPopup() {\n    return this.#trigger;\n  }\n  addHighlightArea() {\n    this.container.classList.add(\"highlightArea\");\n  }\n  #download() {\n    this.downloadManager?.openOrDownloadData(this.container, this.content, this.filename);\n  }\n}\nclass AnnotationLayer {\n  #accessibilityManager = null;\n  #annotationCanvasMap = null;\n  #editableAnnotations = new Map();\n  constructor(_ref4) {\n    let {\n      div,\n      accessibilityManager,\n      annotationCanvasMap,\n      l10n,\n      page,\n      viewport\n    } = _ref4;\n    this.div = div;\n    this.#accessibilityManager = accessibilityManager;\n    this.#annotationCanvasMap = annotationCanvasMap;\n    this.l10n = l10n;\n    this.page = page;\n    this.viewport = viewport;\n    this.zIndex = 0;\n    this.l10n ||= _displayL10n_utils.NullL10n;\n  }\n  #appendElement(element, id) {\n    const contentElement = element.firstChild || element;\n    contentElement.id = `${_util.AnnotationPrefix}${id}`;\n    this.div.append(element);\n    this.#accessibilityManager?.moveElementInDOM(this.div, element, contentElement, false);\n  }\n  async render(params) {\n    const {\n      annotations\n    } = params;\n    const layer = this.div;\n    (0, _display_utils.setLayerDimensions)(layer, this.viewport);\n    const popupToElements = new Map();\n    const elementParams = {\n      data: null,\n      layer,\n      linkService: params.linkService,\n      downloadManager: params.downloadManager,\n      imageResourcesPath: params.imageResourcesPath || \"\",\n      renderForms: params.renderForms !== false,\n      svgFactory: new _display_utils.DOMSVGFactory(),\n      annotationStorage: params.annotationStorage || new _annotation_storage.AnnotationStorage(),\n      enableScripting: params.enableScripting === true,\n      hasJSActions: params.hasJSActions,\n      fieldObjects: params.fieldObjects,\n      parent: this,\n      elements: null\n    };\n    for (const data of annotations) {\n      if (data.noHTML) {\n        continue;\n      }\n      const isPopupAnnotation = data.annotationType === _util.AnnotationType.POPUP;\n      if (!isPopupAnnotation) {\n        const {\n          width,\n          height\n        } = getRectDims(data.rect);\n        if (width <= 0 || height <= 0) {\n          continue;\n        }\n      } else {\n        const elements = popupToElements.get(data.id);\n        if (!elements) {\n          continue;\n        }\n        elementParams.elements = elements;\n      }\n      elementParams.data = data;\n      const element = AnnotationElementFactory.create(elementParams);\n      if (!element.isRenderable) {\n        continue;\n      }\n      if (!isPopupAnnotation && data.popupRef) {\n        const elements = popupToElements.get(data.popupRef);\n        if (!elements) {\n          popupToElements.set(data.popupRef, [element]);\n        } else {\n          elements.push(element);\n        }\n      }\n      if (element.annotationEditorType > 0) {\n        this.#editableAnnotations.set(element.data.id, element);\n      }\n      const rendered = element.render();\n      if (data.hidden) {\n        rendered.style.visibility = \"hidden\";\n      }\n      this.#appendElement(rendered, data.id);\n    }\n    this.#setAnnotationCanvasMap();\n    await this.l10n.translate(layer);\n  }\n  update(_ref5) {\n    let {\n      viewport\n    } = _ref5;\n    const layer = this.div;\n    this.viewport = viewport;\n    (0, _display_utils.setLayerDimensions)(layer, {\n      rotation: viewport.rotation\n    });\n    this.#setAnnotationCanvasMap();\n    layer.hidden = false;\n  }\n  #setAnnotationCanvasMap() {\n    if (!this.#annotationCanvasMap) {\n      return;\n    }\n    const layer = this.div;\n    for (const [id, canvas] of this.#annotationCanvasMap) {\n      const element = layer.querySelector(`[data-annotation-id=\"${id}\"]`);\n      if (!element) {\n        continue;\n      }\n      const {\n        firstChild\n      } = element;\n      if (!firstChild) {\n        element.append(canvas);\n      } else if (firstChild.nodeName === \"CANVAS\") {\n        firstChild.replaceWith(canvas);\n      } else {\n        firstChild.before(canvas);\n      }\n    }\n    this.#annotationCanvasMap.clear();\n  }\n  getEditableAnnotations() {\n    return Array.from(this.#editableAnnotations.values());\n  }\n  getEditableAnnotation(id) {\n    return this.#editableAnnotations.get(id);\n  }\n}\nexports.AnnotationLayer = AnnotationLayer;\n\n/***/ }),\n/* 199 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.ColorConverters = void 0;\nfunction makeColorComp(n) {\n  return Math.floor(Math.max(0, Math.min(1, n)) * 255).toString(16).padStart(2, \"0\");\n}\nfunction scaleAndClamp(x) {\n  return Math.max(0, Math.min(255, 255 * x));\n}\nclass ColorConverters {\n  static CMYK_G(_ref) {\n    let [c, y, m, k] = _ref;\n    return [\"G\", 1 - Math.min(1, 0.3 * c + 0.59 * m + 0.11 * y + k)];\n  }\n  static G_CMYK(_ref2) {\n    let [g] = _ref2;\n    return [\"CMYK\", 0, 0, 0, 1 - g];\n  }\n  static G_RGB(_ref3) {\n    let [g] = _ref3;\n    return [\"RGB\", g, g, g];\n  }\n  static G_rgb(_ref4) {\n    let [g] = _ref4;\n    g = scaleAndClamp(g);\n    return [g, g, g];\n  }\n  static G_HTML(_ref5) {\n    let [g] = _ref5;\n    const G = makeColorComp(g);\n    return `#${G}${G}${G}`;\n  }\n  static RGB_G(_ref6) {\n    let [r, g, b] = _ref6;\n    return [\"G\", 0.3 * r + 0.59 * g + 0.11 * b];\n  }\n  static RGB_rgb(color) {\n    return color.map(scaleAndClamp);\n  }\n  static RGB_HTML(color) {\n    return `#${color.map(makeColorComp).join(\"\")}`;\n  }\n  static T_HTML() {\n    return \"#00000000\";\n  }\n  static T_rgb() {\n    return [null];\n  }\n  static CMYK_RGB(_ref7) {\n    let [c, y, m, k] = _ref7;\n    return [\"RGB\", 1 - Math.min(1, c + k), 1 - Math.min(1, m + k), 1 - Math.min(1, y + k)];\n  }\n  static CMYK_rgb(_ref8) {\n    let [c, y, m, k] = _ref8;\n    return [scaleAndClamp(1 - Math.min(1, c + k)), scaleAndClamp(1 - Math.min(1, m + k)), scaleAndClamp(1 - Math.min(1, y + k))];\n  }\n  static CMYK_HTML(components) {\n    const rgb = this.CMYK_RGB(components).slice(1);\n    return this.RGB_HTML(rgb);\n  }\n  static RGB_CMYK(_ref9) {\n    let [r, g, b] = _ref9;\n    const c = 1 - r;\n    const m = 1 - g;\n    const y = 1 - b;\n    const k = Math.min(c, m, y);\n    return [\"CMYK\", c, m, y, k];\n  }\n}\nexports.ColorConverters = ColorConverters;\n\n/***/ }),\n/* 200 */\n/***/ ((__unused_webpack_module, exports) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.NullL10n = void 0;\nexports.getL10nFallback = getL10nFallback;\nconst DEFAULT_L10N_STRINGS = {\n  of_pages: \"of {{pagesCount}}\",\n  page_of_pages: \"({{pageNumber}} of {{pagesCount}})\",\n  document_properties_kb: \"{{size_kb}} KB ({{size_b}} bytes)\",\n  document_properties_mb: \"{{size_mb}} MB ({{size_b}} bytes)\",\n  document_properties_date_string: \"{{date}}, {{time}}\",\n  document_properties_page_size_unit_inches: \"in\",\n  document_properties_page_size_unit_millimeters: \"mm\",\n  document_properties_page_size_orientation_portrait: \"portrait\",\n  document_properties_page_size_orientation_landscape: \"landscape\",\n  document_properties_page_size_name_a3: \"A3\",\n  document_properties_page_size_name_a4: \"A4\",\n  document_properties_page_size_name_letter: \"Letter\",\n  document_properties_page_size_name_legal: \"Legal\",\n  document_properties_page_size_dimension_string: \"{{width}} × {{height}} {{unit}} ({{orientation}})\",\n  document_properties_page_size_dimension_name_string: \"{{width}} × {{height}} {{unit}} ({{name}}, {{orientation}})\",\n  document_properties_linearized_yes: \"Yes\",\n  document_properties_linearized_no: \"No\",\n  additional_layers: \"Additional Layers\",\n  page_landmark: \"Page {{page}}\",\n  thumb_page_title: \"Page {{page}}\",\n  thumb_page_canvas: \"Thumbnail of Page {{page}}\",\n  find_reached_top: \"Reached top of document, continued from bottom\",\n  find_reached_bottom: \"Reached end of document, continued from top\",\n  \"find_match_count[one]\": \"{{current}} of {{total}} match\",\n  \"find_match_count[other]\": \"{{current}} of {{total}} matches\",\n  \"find_match_count_limit[one]\": \"More than {{limit}} match\",\n  \"find_match_count_limit[other]\": \"More than {{limit}} matches\",\n  find_not_found: \"Phrase not found\",\n  page_scale_width: \"Page Width\",\n  page_scale_fit: \"Page Fit\",\n  page_scale_auto: \"Automatic Zoom\",\n  page_scale_actual: \"Actual Size\",\n  page_scale_percent: \"{{scale}}%\",\n  loading_error: \"An error occurred while loading the PDF.\",\n  invalid_file_error: \"Invalid or corrupted PDF file.\",\n  missing_file_error: \"Missing PDF file.\",\n  unexpected_response_error: \"Unexpected server response.\",\n  rendering_error: \"An error occurred while rendering the page.\",\n  annotation_date_string: \"{{date}}, {{time}}\",\n  printing_not_supported: \"Warning: Printing is not fully supported by this browser.\",\n  printing_not_ready: \"Warning: The PDF is not fully loaded for printing.\",\n  web_fonts_disabled: \"Web fonts are disabled: unable to use embedded PDF fonts.\",\n  free_text2_default_content: \"Start typing…\",\n  editor_free_text2_aria_label: \"Text Editor\",\n  editor_ink2_aria_label: \"Draw Editor\",\n  editor_ink_canvas_aria_label: \"User-created image\",\n  editor_alt_text_button_label: \"Alt text\",\n  editor_alt_text_edit_button_label: \"Edit alt text\",\n  editor_alt_text_decorative_tooltip: \"Marked as decorative\"\n};\n{\n  DEFAULT_L10N_STRINGS.print_progress_percent = \"{{progress}}%\";\n}\nfunction getL10nFallback(key, args) {\n  switch (key) {\n    case \"find_match_count\":\n      key = `find_match_count[${args.total === 1 ? \"one\" : \"other\"}]`;\n      break;\n    case \"find_match_count_limit\":\n      key = `find_match_count_limit[${args.limit === 1 ? \"one\" : \"other\"}]`;\n      break;\n  }\n  return DEFAULT_L10N_STRINGS[key] || \"\";\n}\nfunction formatL10nValue(text, args) {\n  if (!args) {\n    return text;\n  }\n  return text.replaceAll(/\\{\\{\\s*(\\w+)\\s*\\}\\}/g, (all, name) => {\n    return name in args ? args[name] : \"{{\" + name + \"}}\";\n  });\n}\nconst NullL10n = {\n  async getLanguage() {\n    return \"en-us\";\n  },\n  async getDirection() {\n    return \"ltr\";\n  },\n  async get(key) {\n    let args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    let fallback = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : getL10nFallback(key, args);\n    return formatL10nValue(fallback, args);\n  },\n  async translate(element) {}\n};\nexports.NullL10n = NullL10n;\n\n/***/ }),\n/* 201 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.XfaLayer = void 0;\n__w_pdfjs_require__(89);\nvar _xfa_text = __w_pdfjs_require__(194);\nclass XfaLayer {\n  static setupStorage(html, id, element, storage, intent) {\n    const storedData = storage.getValue(id, {\n      value: null\n    });\n    switch (element.name) {\n      case \"textarea\":\n        if (storedData.value !== null) {\n          html.textContent = storedData.value;\n        }\n        if (intent === \"print\") {\n          break;\n        }\n        html.addEventListener(\"input\", event => {\n          storage.setValue(id, {\n            value: event.target.value\n          });\n        });\n        break;\n      case \"input\":\n        if (element.attributes.type === \"radio\" || element.attributes.type === \"checkbox\") {\n          if (storedData.value === element.attributes.xfaOn) {\n            html.setAttribute(\"checked\", true);\n          } else if (storedData.value === element.attributes.xfaOff) {\n            html.removeAttribute(\"checked\");\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"change\", event => {\n            storage.setValue(id, {\n              value: event.target.checked ? event.target.getAttribute(\"xfaOn\") : event.target.getAttribute(\"xfaOff\")\n            });\n          });\n        } else {\n          if (storedData.value !== null) {\n            html.setAttribute(\"value\", storedData.value);\n          }\n          if (intent === \"print\") {\n            break;\n          }\n          html.addEventListener(\"input\", event => {\n            storage.setValue(id, {\n              value: event.target.value\n            });\n          });\n        }\n        break;\n      case \"select\":\n        if (storedData.value !== null) {\n          html.setAttribute(\"value\", storedData.value);\n          for (const option of element.children) {\n            if (option.attributes.value === storedData.value) {\n              option.attributes.selected = true;\n            } else if (option.attributes.hasOwnProperty(\"selected\")) {\n              delete option.attributes.selected;\n            }\n          }\n        }\n        html.addEventListener(\"input\", event => {\n          const options = event.target.options;\n          const value = options.selectedIndex === -1 ? \"\" : options[options.selectedIndex].value;\n          storage.setValue(id, {\n            value\n          });\n        });\n        break;\n    }\n  }\n  static setAttributes(_ref) {\n    let {\n      html,\n      element,\n      storage = null,\n      intent,\n      linkService\n    } = _ref;\n    const {\n      attributes\n    } = element;\n    const isHTMLAnchorElement = html instanceof HTMLAnchorElement;\n    if (attributes.type === \"radio\") {\n      attributes.name = `${attributes.name}-${intent}`;\n    }\n    for (const [key, value] of Object.entries(attributes)) {\n      if (value === null || value === undefined) {\n        continue;\n      }\n      switch (key) {\n        case \"class\":\n          if (value.length) {\n            html.setAttribute(key, value.join(\" \"));\n          }\n          break;\n        case \"dataId\":\n          break;\n        case \"id\":\n          html.setAttribute(\"data-element-id\", value);\n          break;\n        case \"style\":\n          Object.assign(html.style, value);\n          break;\n        case \"textContent\":\n          html.textContent = value;\n          break;\n        default:\n          if (!isHTMLAnchorElement || key !== \"href\" && key !== \"newWindow\") {\n            html.setAttribute(key, value);\n          }\n      }\n    }\n    if (isHTMLAnchorElement) {\n      linkService.addLinkAttributes(html, attributes.href, attributes.newWindow);\n    }\n    if (storage && attributes.dataId) {\n      this.setupStorage(html, attributes.dataId, element, storage);\n    }\n  }\n  static render(parameters) {\n    const storage = parameters.annotationStorage;\n    const linkService = parameters.linkService;\n    const root = parameters.xfaHtml;\n    const intent = parameters.intent || \"display\";\n    const rootHtml = document.createElement(root.name);\n    if (root.attributes) {\n      this.setAttributes({\n        html: rootHtml,\n        element: root,\n        intent,\n        linkService\n      });\n    }\n    const stack = [[root, -1, rootHtml]];\n    const rootDiv = parameters.div;\n    rootDiv.append(rootHtml);\n    if (parameters.viewport) {\n      const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n      rootDiv.style.transform = transform;\n    }\n    if (intent !== \"richText\") {\n      rootDiv.setAttribute(\"class\", \"xfaLayer xfaFont\");\n    }\n    const textDivs = [];\n    while (stack.length > 0) {\n      const [parent, i, html] = stack.at(-1);\n      if (i + 1 === parent.children.length) {\n        stack.pop();\n        continue;\n      }\n      const child = parent.children[++stack.at(-1)[1]];\n      if (child === null) {\n        continue;\n      }\n      const {\n        name\n      } = child;\n      if (name === \"#text\") {\n        const node = document.createTextNode(child.value);\n        textDivs.push(node);\n        html.append(node);\n        continue;\n      }\n      const childHtml = child?.attributes?.xmlns ? document.createElementNS(child.attributes.xmlns, name) : document.createElement(name);\n      html.append(childHtml);\n      if (child.attributes) {\n        this.setAttributes({\n          html: childHtml,\n          element: child,\n          storage,\n          intent,\n          linkService\n        });\n      }\n      if (child.children && child.children.length > 0) {\n        stack.push([child, -1, childHtml]);\n      } else if (child.value) {\n        const node = document.createTextNode(child.value);\n        if (_xfa_text.XfaText.shouldBuildText(name)) {\n          textDivs.push(node);\n        }\n        childHtml.append(node);\n      }\n    }\n    for (const el of rootDiv.querySelectorAll(\".xfaNonInteractive input, .xfaNonInteractive textarea\")) {\n      el.setAttribute(\"readOnly\", true);\n    }\n    return {\n      textDivs\n    };\n  }\n  static update(parameters) {\n    const transform = `matrix(${parameters.viewport.transform.join(\",\")})`;\n    parameters.div.style.transform = transform;\n    parameters.div.hidden = false;\n  }\n}\nexports.XfaLayer = XfaLayer;\n\n/***/ }),\n/* 202 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.InkEditor = void 0;\n__w_pdfjs_require__(89);\n__w_pdfjs_require__(2);\nvar _util = __w_pdfjs_require__(1);\nvar _editor = __w_pdfjs_require__(164);\nvar _annotation_layer = __w_pdfjs_require__(198);\nvar _display_utils = __w_pdfjs_require__(168);\nvar _tools = __w_pdfjs_require__(165);\nclass InkEditor extends _editor.AnnotationEditor {\n  #baseHeight = 0;\n  #baseWidth = 0;\n  #boundCanvasPointermove = this.canvasPointermove.bind(this);\n  #boundCanvasPointerleave = this.canvasPointerleave.bind(this);\n  #boundCanvasPointerup = this.canvasPointerup.bind(this);\n  #boundCanvasPointerdown = this.canvasPointerdown.bind(this);\n  #currentPath2D = new Path2D();\n  #disableEditing = false;\n  #hasSomethingToDraw = false;\n  #isCanvasInitialized = false;\n  #observer = null;\n  #realWidth = 0;\n  #realHeight = 0;\n  #requestFrameCallback = null;\n  static _defaultColor = null;\n  static _defaultOpacity = 1;\n  static _defaultThickness = 1;\n  static _type = \"ink\";\n  constructor(params) {\n    super({\n      ...params,\n      name: \"inkEditor\"\n    });\n    this.color = params.color || null;\n    this.thickness = params.thickness || null;\n    this.opacity = params.opacity || null;\n    this.paths = [];\n    this.bezierPath2D = [];\n    this.allRawPaths = [];\n    this.currentPath = [];\n    this.scaleFactor = 1;\n    this.translationX = this.translationY = 0;\n    this.x = 0;\n    this.y = 0;\n    this._willKeepAspectRatio = true;\n  }\n  static initialize(l10n) {\n    _editor.AnnotationEditor.initialize(l10n, {\n      strings: [\"editor_ink_canvas_aria_label\", \"editor_ink2_aria_label\"]\n    });\n  }\n  static updateDefaultParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.INK_THICKNESS:\n        InkEditor._defaultThickness = value;\n        break;\n      case _util.AnnotationEditorParamsType.INK_COLOR:\n        InkEditor._defaultColor = value;\n        break;\n      case _util.AnnotationEditorParamsType.INK_OPACITY:\n        InkEditor._defaultOpacity = value / 100;\n        break;\n    }\n  }\n  updateParams(type, value) {\n    switch (type) {\n      case _util.AnnotationEditorParamsType.INK_THICKNESS:\n        this.#updateThickness(value);\n        break;\n      case _util.AnnotationEditorParamsType.INK_COLOR:\n        this.#updateColor(value);\n        break;\n      case _util.AnnotationEditorParamsType.INK_OPACITY:\n        this.#updateOpacity(value);\n        break;\n    }\n  }\n  static get defaultPropertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(InkEditor._defaultOpacity * 100)]];\n  }\n  get propertiesToUpdate() {\n    return [[_util.AnnotationEditorParamsType.INK_THICKNESS, this.thickness || InkEditor._defaultThickness], [_util.AnnotationEditorParamsType.INK_COLOR, this.color || InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor], [_util.AnnotationEditorParamsType.INK_OPACITY, Math.round(100 * (this.opacity ?? InkEditor._defaultOpacity))]];\n  }\n  #updateThickness(thickness) {\n    const savedThickness = this.thickness;\n    this.addCommands({\n      cmd: () => {\n        this.thickness = thickness;\n        this.#fitToContent();\n      },\n      undo: () => {\n        this.thickness = savedThickness;\n        this.#fitToContent();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_THICKNESS,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  #updateColor(color) {\n    const savedColor = this.color;\n    this.addCommands({\n      cmd: () => {\n        this.color = color;\n        this.#redraw();\n      },\n      undo: () => {\n        this.color = savedColor;\n        this.#redraw();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_COLOR,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  #updateOpacity(opacity) {\n    opacity /= 100;\n    const savedOpacity = this.opacity;\n    this.addCommands({\n      cmd: () => {\n        this.opacity = opacity;\n        this.#redraw();\n      },\n      undo: () => {\n        this.opacity = savedOpacity;\n        this.#redraw();\n      },\n      mustExec: true,\n      type: _util.AnnotationEditorParamsType.INK_OPACITY,\n      overwriteIfSameType: true,\n      keepUndo: true\n    });\n  }\n  rebuild() {\n    if (!this.parent) {\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (!this.canvas) {\n      this.#createCanvas();\n      this.#createObserver();\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n      this.#setCanvasDims();\n    }\n    this.#fitToContent();\n  }\n  remove() {\n    if (this.canvas === null) {\n      return;\n    }\n    if (!this.isEmpty()) {\n      this.commit();\n    }\n    this.canvas.width = this.canvas.height = 0;\n    this.canvas.remove();\n    this.canvas = null;\n    this.#observer.disconnect();\n    this.#observer = null;\n    super.remove();\n  }\n  setParent(parent) {\n    if (!this.parent && parent) {\n      this._uiManager.removeShouldRescale(this);\n    } else if (this.parent && parent === null) {\n      this._uiManager.addShouldRescale(this);\n    }\n    super.setParent(parent);\n  }\n  onScaleChanging() {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    const width = this.width * parentWidth;\n    const height = this.height * parentHeight;\n    this.setDimensions(width, height);\n  }\n  enableEditMode() {\n    if (this.#disableEditing || this.canvas === null) {\n      return;\n    }\n    super.enableEditMode();\n    this._isDraggable = false;\n    this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n  }\n  disableEditMode() {\n    if (!this.isInEditMode() || this.canvas === null) {\n      return;\n    }\n    super.disableEditMode();\n    this._isDraggable = !this.isEmpty();\n    this.div.classList.remove(\"editing\");\n    this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n  }\n  onceAdded() {\n    this._isDraggable = !this.isEmpty();\n  }\n  isEmpty() {\n    return this.paths.length === 0 || this.paths.length === 1 && this.paths[0].length === 0;\n  }\n  #getInitialBBox() {\n    const {\n      parentRotation,\n      parentDimensions: [width, height]\n    } = this;\n    switch (parentRotation) {\n      case 90:\n        return [0, height, height, width];\n      case 180:\n        return [width, height, width, height];\n      case 270:\n        return [width, 0, height, width];\n      default:\n        return [0, 0, width, height];\n    }\n  }\n  #setStroke() {\n    const {\n      ctx,\n      color,\n      opacity,\n      thickness,\n      parentScale,\n      scaleFactor\n    } = this;\n    ctx.lineWidth = thickness * parentScale / scaleFactor;\n    ctx.lineCap = \"round\";\n    ctx.lineJoin = \"round\";\n    ctx.miterLimit = 10;\n    ctx.strokeStyle = `${color}${(0, _tools.opacityToHex)(opacity)}`;\n  }\n  #startDrawing(x, y) {\n    this.canvas.addEventListener(\"contextmenu\", _display_utils.noContextMenu);\n    this.canvas.addEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n    this.canvas.addEventListener(\"pointermove\", this.#boundCanvasPointermove);\n    this.canvas.addEventListener(\"pointerup\", this.#boundCanvasPointerup);\n    this.canvas.removeEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n    this.isEditing = true;\n    if (!this.#isCanvasInitialized) {\n      this.#isCanvasInitialized = true;\n      this.#setCanvasDims();\n      this.thickness ||= InkEditor._defaultThickness;\n      this.color ||= InkEditor._defaultColor || _editor.AnnotationEditor._defaultLineColor;\n      this.opacity ??= InkEditor._defaultOpacity;\n    }\n    this.currentPath.push([x, y]);\n    this.#hasSomethingToDraw = false;\n    this.#setStroke();\n    this.#requestFrameCallback = () => {\n      this.#drawPoints();\n      if (this.#requestFrameCallback) {\n        window.requestAnimationFrame(this.#requestFrameCallback);\n      }\n    };\n    window.requestAnimationFrame(this.#requestFrameCallback);\n  }\n  #draw(x, y) {\n    const [lastX, lastY] = this.currentPath.at(-1);\n    if (this.currentPath.length > 1 && x === lastX && y === lastY) {\n      return;\n    }\n    const currentPath = this.currentPath;\n    let path2D = this.#currentPath2D;\n    currentPath.push([x, y]);\n    this.#hasSomethingToDraw = true;\n    if (currentPath.length <= 2) {\n      path2D.moveTo(...currentPath[0]);\n      path2D.lineTo(x, y);\n      return;\n    }\n    if (currentPath.length === 3) {\n      this.#currentPath2D = path2D = new Path2D();\n      path2D.moveTo(...currentPath[0]);\n    }\n    this.#makeBezierCurve(path2D, ...currentPath.at(-3), ...currentPath.at(-2), x, y);\n  }\n  #endPath() {\n    if (this.currentPath.length === 0) {\n      return;\n    }\n    const lastPoint = this.currentPath.at(-1);\n    this.#currentPath2D.lineTo(...lastPoint);\n  }\n  #stopDrawing(x, y) {\n    this.#requestFrameCallback = null;\n    x = Math.min(Math.max(x, 0), this.canvas.width);\n    y = Math.min(Math.max(y, 0), this.canvas.height);\n    this.#draw(x, y);\n    this.#endPath();\n    let bezier;\n    if (this.currentPath.length !== 1) {\n      bezier = this.#generateBezierPoints();\n    } else {\n      const xy = [x, y];\n      bezier = [[xy, xy.slice(), xy.slice(), xy]];\n    }\n    const path2D = this.#currentPath2D;\n    const currentPath = this.currentPath;\n    this.currentPath = [];\n    this.#currentPath2D = new Path2D();\n    const cmd = () => {\n      this.allRawPaths.push(currentPath);\n      this.paths.push(bezier);\n      this.bezierPath2D.push(path2D);\n      this.rebuild();\n    };\n    const undo = () => {\n      this.allRawPaths.pop();\n      this.paths.pop();\n      this.bezierPath2D.pop();\n      if (this.paths.length === 0) {\n        this.remove();\n      } else {\n        if (!this.canvas) {\n          this.#createCanvas();\n          this.#createObserver();\n        }\n        this.#fitToContent();\n      }\n    };\n    this.addCommands({\n      cmd,\n      undo,\n      mustExec: true\n    });\n  }\n  #drawPoints() {\n    if (!this.#hasSomethingToDraw) {\n      return;\n    }\n    this.#hasSomethingToDraw = false;\n    const thickness = Math.ceil(this.thickness * this.parentScale);\n    const lastPoints = this.currentPath.slice(-3);\n    const x = lastPoints.map(xy => xy[0]);\n    const y = lastPoints.map(xy => xy[1]);\n    const xMin = Math.min(...x) - thickness;\n    const xMax = Math.max(...x) + thickness;\n    const yMin = Math.min(...y) - thickness;\n    const yMax = Math.max(...y) + thickness;\n    const {\n      ctx\n    } = this;\n    ctx.save();\n    ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);\n    for (const path of this.bezierPath2D) {\n      ctx.stroke(path);\n    }\n    ctx.stroke(this.#currentPath2D);\n    ctx.restore();\n  }\n  #makeBezierCurve(path2D, x0, y0, x1, y1, x2, y2) {\n    const prevX = (x0 + x1) / 2;\n    const prevY = (y0 + y1) / 2;\n    const x3 = (x1 + x2) / 2;\n    const y3 = (y1 + y2) / 2;\n    path2D.bezierCurveTo(prevX + 2 * (x1 - prevX) / 3, prevY + 2 * (y1 - prevY) / 3, x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3, x3, y3);\n  }\n  #generateBezierPoints() {\n    const path = this.currentPath;\n    if (path.length <= 2) {\n      return [[path[0], path[0], path.at(-1), path.at(-1)]];\n    }\n    const bezierPoints = [];\n    let i;\n    let [x0, y0] = path[0];\n    for (i = 1; i < path.length - 2; i++) {\n      const [x1, y1] = path[i];\n      const [x2, y2] = path[i + 1];\n      const x3 = (x1 + x2) / 2;\n      const y3 = (y1 + y2) / 2;\n      const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];\n      const control2 = [x3 + 2 * (x1 - x3) / 3, y3 + 2 * (y1 - y3) / 3];\n      bezierPoints.push([[x0, y0], control1, control2, [x3, y3]]);\n      [x0, y0] = [x3, y3];\n    }\n    const [x1, y1] = path[i];\n    const [x2, y2] = path[i + 1];\n    const control1 = [x0 + 2 * (x1 - x0) / 3, y0 + 2 * (y1 - y0) / 3];\n    const control2 = [x2 + 2 * (x1 - x2) / 3, y2 + 2 * (y1 - y2) / 3];\n    bezierPoints.push([[x0, y0], control1, control2, [x2, y2]]);\n    return bezierPoints;\n  }\n  #redraw() {\n    if (this.isEmpty()) {\n      this.#updateTransform();\n      return;\n    }\n    this.#setStroke();\n    const {\n      canvas,\n      ctx\n    } = this;\n    ctx.setTransform(1, 0, 0, 1, 0, 0);\n    ctx.clearRect(0, 0, canvas.width, canvas.height);\n    this.#updateTransform();\n    for (const path of this.bezierPath2D) {\n      ctx.stroke(path);\n    }\n  }\n  commit() {\n    if (this.#disableEditing) {\n      return;\n    }\n    super.commit();\n    this.isEditing = false;\n    this.disableEditMode();\n    this.setInForeground();\n    this.#disableEditing = true;\n    this.div.classList.add(\"disabled\");\n    this.#fitToContent(true);\n    this.makeResizable();\n    this.parent.addInkEditorIfNeeded(true);\n    this.moveInDOM();\n    this.div.focus({\n      preventScroll: true\n    });\n  }\n  focusin(event) {\n    if (!this._focusEventsAllowed) {\n      return;\n    }\n    super.focusin(event);\n    this.enableEditMode();\n  }\n  canvasPointerdown(event) {\n    if (event.button !== 0 || !this.isInEditMode() || this.#disableEditing) {\n      return;\n    }\n    this.setInForeground();\n    event.preventDefault();\n    if (event.type !== \"mouse\") {\n      this.div.focus();\n    }\n    this.#startDrawing(event.offsetX, event.offsetY);\n  }\n  canvasPointermove(event) {\n    event.preventDefault();\n    this.#draw(event.offsetX, event.offsetY);\n  }\n  canvasPointerup(event) {\n    event.preventDefault();\n    this.#endDrawing(event);\n  }\n  canvasPointerleave(event) {\n    this.#endDrawing(event);\n  }\n  #endDrawing(event) {\n    this.canvas.removeEventListener(\"pointerleave\", this.#boundCanvasPointerleave);\n    this.canvas.removeEventListener(\"pointermove\", this.#boundCanvasPointermove);\n    this.canvas.removeEventListener(\"pointerup\", this.#boundCanvasPointerup);\n    this.canvas.addEventListener(\"pointerdown\", this.#boundCanvasPointerdown);\n    setTimeout(() => {\n      this.canvas.removeEventListener(\"contextmenu\", _display_utils.noContextMenu);\n    }, 10);\n    this.#stopDrawing(event.offsetX, event.offsetY);\n    this.addToAnnotationStorage();\n    this.setInBackground();\n  }\n  #createCanvas() {\n    this.canvas = document.createElement(\"canvas\");\n    this.canvas.width = this.canvas.height = 0;\n    this.canvas.className = \"inkEditorCanvas\";\n    _editor.AnnotationEditor._l10nPromise.get(\"editor_ink_canvas_aria_label\").then(msg => this.canvas?.setAttribute(\"aria-label\", msg));\n    this.div.append(this.canvas);\n    this.ctx = this.canvas.getContext(\"2d\");\n  }\n  #createObserver() {\n    this.#observer = new ResizeObserver(entries => {\n      const rect = entries[0].contentRect;\n      if (rect.width && rect.height) {\n        this.setDimensions(rect.width, rect.height);\n      }\n    });\n    this.#observer.observe(this.div);\n  }\n  get isResizable() {\n    return !this.isEmpty() && this.#disableEditing;\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    _editor.AnnotationEditor._l10nPromise.get(\"editor_ink2_aria_label\").then(msg => this.div?.setAttribute(\"aria-label\", msg));\n    const [x, y, w, h] = this.#getInitialBBox();\n    this.setAt(x, y, 0, 0);\n    this.setDims(w, h);\n    this.#createCanvas();\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      this.setAspectRatio(this.width * parentWidth, this.height * parentHeight);\n      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n      this.#isCanvasInitialized = true;\n      this.#setCanvasDims();\n      this.setDims(this.width * parentWidth, this.height * parentHeight);\n      this.#redraw();\n      this.div.classList.add(\"disabled\");\n    } else {\n      this.div.classList.add(\"editing\");\n      this.enableEditMode();\n    }\n    this.#createObserver();\n    return this.div;\n  }\n  #setCanvasDims() {\n    if (!this.#isCanvasInitialized) {\n      return;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.canvas.width = Math.ceil(this.width * parentWidth);\n    this.canvas.height = Math.ceil(this.height * parentHeight);\n    this.#updateTransform();\n  }\n  setDimensions(width, height) {\n    const roundedWidth = Math.round(width);\n    const roundedHeight = Math.round(height);\n    if (this.#realWidth === roundedWidth && this.#realHeight === roundedHeight) {\n      return;\n    }\n    this.#realWidth = roundedWidth;\n    this.#realHeight = roundedHeight;\n    this.canvas.style.visibility = \"hidden\";\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    this.fixAndSetPosition();\n    if (this.#disableEditing) {\n      this.#setScaleFactor(width, height);\n    }\n    this.#setCanvasDims();\n    this.#redraw();\n    this.canvas.style.visibility = \"visible\";\n    this.fixDims();\n  }\n  #setScaleFactor(width, height) {\n    const padding = this.#getPadding();\n    const scaleFactorW = (width - padding) / this.#baseWidth;\n    const scaleFactorH = (height - padding) / this.#baseHeight;\n    this.scaleFactor = Math.min(scaleFactorW, scaleFactorH);\n  }\n  #updateTransform() {\n    const padding = this.#getPadding() / 2;\n    this.ctx.setTransform(this.scaleFactor, 0, 0, this.scaleFactor, this.translationX * this.scaleFactor + padding, this.translationY * this.scaleFactor + padding);\n  }\n  static #buildPath2D(bezier) {\n    const path2D = new Path2D();\n    for (let i = 0, ii = bezier.length; i < ii; i++) {\n      const [first, control1, control2, second] = bezier[i];\n      if (i === 0) {\n        path2D.moveTo(...first);\n      }\n      path2D.bezierCurveTo(control1[0], control1[1], control2[0], control2[1], second[0], second[1]);\n    }\n    return path2D;\n  }\n  static #toPDFCoordinates(points, rect, rotation) {\n    const [blX, blY, trX, trY] = rect;\n    switch (rotation) {\n      case 0:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] += blX;\n          points[i + 1] = trY - points[i + 1];\n        }\n        break;\n      case 90:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = points[i + 1] + blX;\n          points[i + 1] = x + blY;\n        }\n        break;\n      case 180:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] = trX - points[i];\n          points[i + 1] += blY;\n        }\n        break;\n      case 270:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = trX - points[i + 1];\n          points[i + 1] = trY - x;\n        }\n        break;\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n    return points;\n  }\n  static #fromPDFCoordinates(points, rect, rotation) {\n    const [blX, blY, trX, trY] = rect;\n    switch (rotation) {\n      case 0:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] -= blX;\n          points[i + 1] = trY - points[i + 1];\n        }\n        break;\n      case 90:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = points[i + 1] - blY;\n          points[i + 1] = x - blX;\n        }\n        break;\n      case 180:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          points[i] = trX - points[i];\n          points[i + 1] -= blY;\n        }\n        break;\n      case 270:\n        for (let i = 0, ii = points.length; i < ii; i += 2) {\n          const x = points[i];\n          points[i] = trY - points[i + 1];\n          points[i + 1] = trX - x;\n        }\n        break;\n      default:\n        throw new Error(\"Invalid rotation\");\n    }\n    return points;\n  }\n  #serializePaths(s, tx, ty, rect) {\n    const paths = [];\n    const padding = this.thickness / 2;\n    const shiftX = s * tx + padding;\n    const shiftY = s * ty + padding;\n    for (const bezier of this.paths) {\n      const buffer = [];\n      const points = [];\n      for (let j = 0, jj = bezier.length; j < jj; j++) {\n        const [first, control1, control2, second] = bezier[j];\n        const p10 = s * first[0] + shiftX;\n        const p11 = s * first[1] + shiftY;\n        const p20 = s * control1[0] + shiftX;\n        const p21 = s * control1[1] + shiftY;\n        const p30 = s * control2[0] + shiftX;\n        const p31 = s * control2[1] + shiftY;\n        const p40 = s * second[0] + shiftX;\n        const p41 = s * second[1] + shiftY;\n        if (j === 0) {\n          buffer.push(p10, p11);\n          points.push(p10, p11);\n        }\n        buffer.push(p20, p21, p30, p31, p40, p41);\n        points.push(p20, p21);\n        if (j === jj - 1) {\n          points.push(p40, p41);\n        }\n      }\n      paths.push({\n        bezier: InkEditor.#toPDFCoordinates(buffer, rect, this.rotation),\n        points: InkEditor.#toPDFCoordinates(points, rect, this.rotation)\n      });\n    }\n    return paths;\n  }\n  #getBbox() {\n    let xMin = Infinity;\n    let xMax = -Infinity;\n    let yMin = Infinity;\n    let yMax = -Infinity;\n    for (const path of this.paths) {\n      for (const [first, control1, control2, second] of path) {\n        const bbox = _util.Util.bezierBoundingBox(...first, ...control1, ...control2, ...second);\n        xMin = Math.min(xMin, bbox[0]);\n        yMin = Math.min(yMin, bbox[1]);\n        xMax = Math.max(xMax, bbox[2]);\n        yMax = Math.max(yMax, bbox[3]);\n      }\n    }\n    return [xMin, yMin, xMax, yMax];\n  }\n  #getPadding() {\n    return this.#disableEditing ? Math.ceil(this.thickness * this.parentScale) : 0;\n  }\n  #fitToContent() {\n    let firstTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    if (this.isEmpty()) {\n      return;\n    }\n    if (!this.#disableEditing) {\n      this.#redraw();\n      return;\n    }\n    const bbox = this.#getBbox();\n    const padding = this.#getPadding();\n    this.#baseWidth = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n    this.#baseHeight = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n    const width = Math.ceil(padding + this.#baseWidth * this.scaleFactor);\n    const height = Math.ceil(padding + this.#baseHeight * this.scaleFactor);\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    this.setAspectRatio(width, height);\n    const prevTranslationX = this.translationX;\n    const prevTranslationY = this.translationY;\n    this.translationX = -bbox[0];\n    this.translationY = -bbox[1];\n    this.#setCanvasDims();\n    this.#redraw();\n    this.#realWidth = width;\n    this.#realHeight = height;\n    this.setDims(width, height);\n    const unscaledPadding = firstTime ? padding / this.scaleFactor / 2 : 0;\n    this.translate(prevTranslationX - this.translationX - unscaledPadding, prevTranslationY - this.translationY - unscaledPadding);\n  }\n  static deserialize(data, parent, uiManager) {\n    if (data instanceof _annotation_layer.InkAnnotationElement) {\n      return null;\n    }\n    const editor = super.deserialize(data, parent, uiManager);\n    editor.thickness = data.thickness;\n    editor.color = _util.Util.makeHexColor(...data.color);\n    editor.opacity = data.opacity;\n    const [pageWidth, pageHeight] = editor.pageDimensions;\n    const width = editor.width * pageWidth;\n    const height = editor.height * pageHeight;\n    const scaleFactor = editor.parentScale;\n    const padding = data.thickness / 2;\n    editor.#disableEditing = true;\n    editor.#realWidth = Math.round(width);\n    editor.#realHeight = Math.round(height);\n    const {\n      paths,\n      rect,\n      rotation\n    } = data;\n    for (let {\n      bezier\n    } of paths) {\n      bezier = InkEditor.#fromPDFCoordinates(bezier, rect, rotation);\n      const path = [];\n      editor.paths.push(path);\n      let p0 = scaleFactor * (bezier[0] - padding);\n      let p1 = scaleFactor * (bezier[1] - padding);\n      for (let i = 2, ii = bezier.length; i < ii; i += 6) {\n        const p10 = scaleFactor * (bezier[i] - padding);\n        const p11 = scaleFactor * (bezier[i + 1] - padding);\n        const p20 = scaleFactor * (bezier[i + 2] - padding);\n        const p21 = scaleFactor * (bezier[i + 3] - padding);\n        const p30 = scaleFactor * (bezier[i + 4] - padding);\n        const p31 = scaleFactor * (bezier[i + 5] - padding);\n        path.push([[p0, p1], [p10, p11], [p20, p21], [p30, p31]]);\n        p0 = p30;\n        p1 = p31;\n      }\n      const path2D = this.#buildPath2D(path);\n      editor.bezierPath2D.push(path2D);\n    }\n    const bbox = editor.#getBbox();\n    editor.#baseWidth = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[2] - bbox[0]);\n    editor.#baseHeight = Math.max(_editor.AnnotationEditor.MIN_SIZE, bbox[3] - bbox[1]);\n    editor.#setScaleFactor(width, height);\n    return editor;\n  }\n  serialize() {\n    if (this.isEmpty()) {\n      return null;\n    }\n    const rect = this.getRect(0, 0);\n    const color = _editor.AnnotationEditor._colorManager.convert(this.ctx.strokeStyle);\n    return {\n      annotationType: _util.AnnotationEditorType.INK,\n      color,\n      thickness: this.thickness,\n      opacity: this.opacity,\n      paths: this.#serializePaths(this.scaleFactor / this.parentScale, this.translationX, this.translationY, rect),\n      pageIndex: this.pageIndex,\n      rect,\n      rotation: this.rotation,\n      structTreeParentId: this._structTreeParentId\n    };\n  }\n}\nexports.InkEditor = InkEditor;\n\n/***/ }),\n/* 203 */\n/***/ ((__unused_webpack_module, exports, __w_pdfjs_require__) => {\n\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nexports.StampEditor = void 0;\n__w_pdfjs_require__(149);\n__w_pdfjs_require__(152);\nvar _util = __w_pdfjs_require__(1);\nvar _editor = __w_pdfjs_require__(164);\nvar _display_utils = __w_pdfjs_require__(168);\nvar _annotation_layer = __w_pdfjs_require__(198);\nclass StampEditor extends _editor.AnnotationEditor {\n  #bitmap = null;\n  #bitmapId = null;\n  #bitmapPromise = null;\n  #bitmapUrl = null;\n  #bitmapFile = null;\n  #canvas = null;\n  #observer = null;\n  #resizeTimeoutId = null;\n  #isSvg = false;\n  #hasBeenAddedInUndoStack = false;\n  static _type = \"stamp\";\n  constructor(params) {\n    super({\n      ...params,\n      name: \"stampEditor\"\n    });\n    this.#bitmapUrl = params.bitmapUrl;\n    this.#bitmapFile = params.bitmapFile;\n  }\n  static initialize(l10n) {\n    _editor.AnnotationEditor.initialize(l10n);\n  }\n  static get supportedTypes() {\n    const types = [\"apng\", \"avif\", \"bmp\", \"gif\", \"jpeg\", \"png\", \"svg+xml\", \"webp\", \"x-icon\"];\n    return (0, _util.shadow)(this, \"supportedTypes\", types.map(type => `image/${type}`));\n  }\n  static get supportedTypesStr() {\n    return (0, _util.shadow)(this, \"supportedTypesStr\", this.supportedTypes.join(\",\"));\n  }\n  static isHandlingMimeForPasting(mime) {\n    return this.supportedTypes.includes(mime);\n  }\n  static paste(item, parent) {\n    parent.pasteEditor(_util.AnnotationEditorType.STAMP, {\n      bitmapFile: item.getAsFile()\n    });\n  }\n  #getBitmapFetched(data) {\n    let fromId = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n    if (!data) {\n      this.remove();\n      return;\n    }\n    this.#bitmap = data.bitmap;\n    if (!fromId) {\n      this.#bitmapId = data.id;\n      this.#isSvg = data.isSvg;\n    }\n    this.#createCanvas();\n  }\n  #getBitmapDone() {\n    this.#bitmapPromise = null;\n    this._uiManager.enableWaiting(false);\n    if (this.#canvas) {\n      this.div.focus();\n    }\n  }\n  #getBitmap() {\n    if (this.#bitmapId) {\n      this._uiManager.enableWaiting(true);\n      this._uiManager.imageManager.getFromId(this.#bitmapId).then(data => this.#getBitmapFetched(data, true)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    if (this.#bitmapUrl) {\n      const url = this.#bitmapUrl;\n      this.#bitmapUrl = null;\n      this._uiManager.enableWaiting(true);\n      this.#bitmapPromise = this._uiManager.imageManager.getFromUrl(url).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    if (this.#bitmapFile) {\n      const file = this.#bitmapFile;\n      this.#bitmapFile = null;\n      this._uiManager.enableWaiting(true);\n      this.#bitmapPromise = this._uiManager.imageManager.getFromFile(file).then(data => this.#getBitmapFetched(data)).finally(() => this.#getBitmapDone());\n      return;\n    }\n    const input = document.createElement(\"input\");\n    input.type = \"file\";\n    input.accept = StampEditor.supportedTypesStr;\n    this.#bitmapPromise = new Promise(resolve => {\n      input.addEventListener(\"change\", async () => {\n        if (!input.files || input.files.length === 0) {\n          this.remove();\n        } else {\n          this._uiManager.enableWaiting(true);\n          const data = await this._uiManager.imageManager.getFromFile(input.files[0]);\n          this.#getBitmapFetched(data);\n        }\n        resolve();\n      });\n      input.addEventListener(\"cancel\", () => {\n        this.remove();\n        resolve();\n      });\n    }).finally(() => this.#getBitmapDone());\n    input.click();\n  }\n  remove() {\n    if (this.#bitmapId) {\n      this.#bitmap = null;\n      this._uiManager.imageManager.deleteId(this.#bitmapId);\n      this.#canvas?.remove();\n      this.#canvas = null;\n      this.#observer?.disconnect();\n      this.#observer = null;\n    }\n    super.remove();\n  }\n  rebuild() {\n    if (!this.parent) {\n      if (this.#bitmapId) {\n        this.#getBitmap();\n      }\n      return;\n    }\n    super.rebuild();\n    if (this.div === null) {\n      return;\n    }\n    if (this.#bitmapId) {\n      this.#getBitmap();\n    }\n    if (!this.isAttachedToDOM) {\n      this.parent.add(this);\n    }\n  }\n  onceAdded() {\n    this._isDraggable = true;\n    this.div.focus();\n  }\n  isEmpty() {\n    return !(this.#bitmapPromise || this.#bitmap || this.#bitmapUrl || this.#bitmapFile);\n  }\n  get isResizable() {\n    return true;\n  }\n  render() {\n    if (this.div) {\n      return this.div;\n    }\n    let baseX, baseY;\n    if (this.width) {\n      baseX = this.x;\n      baseY = this.y;\n    }\n    super.render();\n    this.div.hidden = true;\n    if (this.#bitmap) {\n      this.#createCanvas();\n    } else {\n      this.#getBitmap();\n    }\n    if (this.width) {\n      const [parentWidth, parentHeight] = this.parentDimensions;\n      this.setAt(baseX * parentWidth, baseY * parentHeight, this.width * parentWidth, this.height * parentHeight);\n    }\n    return this.div;\n  }\n  #createCanvas() {\n    const {\n      div\n    } = this;\n    let {\n      width,\n      height\n    } = this.#bitmap;\n    const [pageWidth, pageHeight] = this.pageDimensions;\n    const MAX_RATIO = 0.75;\n    if (this.width) {\n      width = this.width * pageWidth;\n      height = this.height * pageHeight;\n    } else if (width > MAX_RATIO * pageWidth || height > MAX_RATIO * pageHeight) {\n      const factor = Math.min(MAX_RATIO * pageWidth / width, MAX_RATIO * pageHeight / height);\n      width *= factor;\n      height *= factor;\n    }\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.setDims(width * parentWidth / pageWidth, height * parentHeight / pageHeight);\n    this._uiManager.enableWaiting(false);\n    const canvas = this.#canvas = document.createElement(\"canvas\");\n    div.append(canvas);\n    div.hidden = false;\n    this.#drawBitmap(width, height);\n    this.#createObserver();\n    if (!this.#hasBeenAddedInUndoStack) {\n      this.parent.addUndoableEditor(this);\n      this.#hasBeenAddedInUndoStack = true;\n    }\n    this._uiManager._eventBus.dispatch(\"reporttelemetry\", {\n      source: this,\n      details: {\n        type: \"editing\",\n        subtype: this.editorType,\n        data: {\n          action: \"inserted_image\"\n        }\n      }\n    });\n    this.addAltTextButton();\n  }\n  #setDimensions(width, height) {\n    const [parentWidth, parentHeight] = this.parentDimensions;\n    this.width = width / parentWidth;\n    this.height = height / parentHeight;\n    this.setDims(width, height);\n    if (this._initialOptions?.isCentered) {\n      this.center();\n    } else {\n      this.fixAndSetPosition();\n    }\n    this._initialOptions = null;\n    if (this.#resizeTimeoutId !== null) {\n      clearTimeout(this.#resizeTimeoutId);\n    }\n    const TIME_TO_WAIT = 200;\n    this.#resizeTimeoutId = setTimeout(() => {\n      this.#resizeTimeoutId = null;\n      this.#drawBitmap(width, height);\n    }, TIME_TO_WAIT);\n  }\n  #scaleBitmap(width, height) {\n    const {\n      width: bitmapWidth,\n      height: bitmapHeight\n    } = this.#bitmap;\n    let newWidth = bitmapWidth;\n    let newHeight = bitmapHeight;\n    let bitmap = this.#bitmap;\n    while (newWidth > 2 * width || newHeight > 2 * height) {\n      const prevWidth = newWidth;\n      const prevHeight = newHeight;\n      if (newWidth > 2 * width) {\n        newWidth = newWidth >= 16384 ? Math.floor(newWidth / 2) - 1 : Math.ceil(newWidth / 2);\n      }\n      if (newHeight > 2 * height) {\n        newHeight = newHeight >= 16384 ? Math.floor(newHeight / 2) - 1 : Math.ceil(newHeight / 2);\n      }\n      const offscreen = new OffscreenCanvas(newWidth, newHeight);\n      const ctx = offscreen.getContext(\"2d\");\n      ctx.drawImage(bitmap, 0, 0, prevWidth, prevHeight, 0, 0, newWidth, newHeight);\n      bitmap = offscreen.transferToImageBitmap();\n    }\n    return bitmap;\n  }\n  #drawBitmap(width, height) {\n    width = Math.ceil(width);\n    height = Math.ceil(height);\n    const canvas = this.#canvas;\n    if (!canvas || canvas.width === width && canvas.height === height) {\n      return;\n    }\n    canvas.width = width;\n    canvas.height = height;\n    const bitmap = this.#isSvg ? this.#bitmap : this.#scaleBitmap(width, height);\n    const ctx = canvas.getContext(\"2d\");\n    ctx.filter = this._uiManager.hcmFilter;\n    ctx.drawImage(bitmap, 0, 0, bitmap.width, bitmap.height, 0, 0, width, height);\n  }\n  #serializeBitmap(toUrl) {\n    if (toUrl) {\n      if (this.#isSvg) {\n        const url = this._uiManager.imageManager.getSvgUrl(this.#bitmapId);\n        if (url) {\n          return url;\n        }\n      }\n      const canvas = document.createElement(\"canvas\");\n      ({\n        width: canvas.width,\n        height: canvas.height\n      } = this.#bitmap);\n      const ctx = canvas.getContext(\"2d\");\n      ctx.drawImage(this.#bitmap, 0, 0);\n      return canvas.toDataURL();\n    }\n    if (this.#isSvg) {\n      const [pageWidth, pageHeight] = this.pageDimensions;\n      const width = Math.round(this.width * pageWidth * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n      const height = Math.round(this.height * pageHeight * _display_utils.PixelsPerInch.PDF_TO_CSS_UNITS);\n      const offscreen = new OffscreenCanvas(width, height);\n      const ctx = offscreen.getContext(\"2d\");\n      ctx.drawImage(this.#bitmap, 0, 0, this.#bitmap.width, this.#bitmap.height, 0, 0, width, height);\n      return offscreen.transferToImageBitmap();\n    }\n    return structuredClone(this.#bitmap);\n  }\n  #createObserver() {\n    this.#observer = new ResizeObserver(entries => {\n      const rect = entries[0].contentRect;\n      if (rect.width && rect.height) {\n        this.#setDimensions(rect.width, rect.height);\n      }\n    });\n    this.#observer.observe(this.div);\n  }\n  static deserialize(data, parent, uiManager) {\n    if (data instanceof _annotation_layer.StampAnnotationElement) {\n      return null;\n    }\n    const editor = super.deserialize(data, parent, uiManager);\n    const {\n      rect,\n      bitmapUrl,\n      bitmapId,\n      isSvg,\n      accessibilityData\n    } = data;\n    if (bitmapId && uiManager.imageManager.isValidId(bitmapId)) {\n      editor.#bitmapId = bitmapId;\n    } else {\n      editor.#bitmapUrl = bitmapUrl;\n    }\n    editor.#isSvg = isSvg;\n    const [parentWidth, parentHeight] = editor.pageDimensions;\n    editor.width = (rect[2] - rect[0]) / parentWidth;\n    editor.height = (rect[3] - rect[1]) / parentHeight;\n    if (accessibilityData) {\n      editor.altTextData = accessibilityData;\n    }\n    return editor;\n  }\n  serialize() {\n    let isForCopying = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : false;\n    let context = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;\n    if (this.isEmpty()) {\n      return null;\n    }\n    const serialized = {\n      annotationType: _util.AnnotationEditorType.STAMP,\n      bitmapId: this.#bitmapId,\n      pageIndex: this.pageIndex,\n      rect: this.getRect(0, 0),\n      rotation: this.rotation,\n      isSvg: this.#isSvg,\n      structTreeParentId: this._structTreeParentId\n    };\n    if (isForCopying) {\n      serialized.bitmapUrl = this.#serializeBitmap(true);\n      serialized.accessibilityData = this.altTextData;\n      return serialized;\n    }\n    const {\n      decorative,\n      altText\n    } = this.altTextData;\n    if (!decorative && altText) {\n      serialized.accessibilityData = {\n        type: \"Figure\",\n        alt: altText\n      };\n    }\n    if (context === null) {\n      return serialized;\n    }\n    context.stamps ||= new Map();\n    const area = this.#isSvg ? (serialized.rect[2] - serialized.rect[0]) * (serialized.rect[3] - serialized.rect[1]) : null;\n    if (!context.stamps.has(this.#bitmapId)) {\n      context.stamps.set(this.#bitmapId, {\n        area,\n        serialized\n      });\n      serialized.bitmap = this.#serializeBitmap(false);\n    } else if (this.#isSvg) {\n      const prevData = context.stamps.get(this.#bitmapId);\n      if (area > prevData.area) {\n        prevData.area = area;\n        prevData.serialized.bitmap.close();\n        prevData.serialized.bitmap = this.#serializeBitmap(false);\n      }\n    }\n    return serialized;\n  }\n}\nexports.StampEditor = StampEditor;\n\n/***/ })\n/******/ \t]);\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __w_pdfjs_require__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __w_pdfjs_require__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\nvar __nested_webpack_exports__ = {};\n// This entry need to be wrapped in an IIFE because it need to be isolated against other modules in the chunk.\n(() => {\nvar exports = __nested_webpack_exports__;\n\n\nObject.defineProperty(exports, \"__esModule\", ({\n  value: true\n}));\nObject.defineProperty(exports, \"AbortException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AbortException;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _annotation_editor_layer.AnnotationEditorLayer;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorParamsType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationEditorParamsType;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationEditorType;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationEditorUIManager\", ({\n  enumerable: true,\n  get: function () {\n    return _tools.AnnotationEditorUIManager;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _annotation_layer.AnnotationLayer;\n  }\n}));\nObject.defineProperty(exports, \"AnnotationMode\", ({\n  enumerable: true,\n  get: function () {\n    return _util.AnnotationMode;\n  }\n}));\nObject.defineProperty(exports, \"CMapCompressionType\", ({\n  enumerable: true,\n  get: function () {\n    return _util.CMapCompressionType;\n  }\n}));\nObject.defineProperty(exports, \"DOMSVGFactory\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.DOMSVGFactory;\n  }\n}));\nObject.defineProperty(exports, \"FeatureTest\", ({\n  enumerable: true,\n  get: function () {\n    return _util.FeatureTest;\n  }\n}));\nObject.defineProperty(exports, \"GlobalWorkerOptions\", ({\n  enumerable: true,\n  get: function () {\n    return _worker_options.GlobalWorkerOptions;\n  }\n}));\nObject.defineProperty(exports, \"ImageKind\", ({\n  enumerable: true,\n  get: function () {\n    return _util.ImageKind;\n  }\n}));\nObject.defineProperty(exports, \"InvalidPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.InvalidPDFException;\n  }\n}));\nObject.defineProperty(exports, \"MissingPDFException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.MissingPDFException;\n  }\n}));\nObject.defineProperty(exports, \"OPS\", ({\n  enumerable: true,\n  get: function () {\n    return _util.OPS;\n  }\n}));\nObject.defineProperty(exports, \"PDFDataRangeTransport\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFDataRangeTransport;\n  }\n}));\nObject.defineProperty(exports, \"PDFDateString\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PDFDateString;\n  }\n}));\nObject.defineProperty(exports, \"PDFWorker\", ({\n  enumerable: true,\n  get: function () {\n    return _api.PDFWorker;\n  }\n}));\nObject.defineProperty(exports, \"PasswordResponses\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PasswordResponses;\n  }\n}));\nObject.defineProperty(exports, \"PermissionFlag\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PermissionFlag;\n  }\n}));\nObject.defineProperty(exports, \"PixelsPerInch\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.PixelsPerInch;\n  }\n}));\nObject.defineProperty(exports, \"PromiseCapability\", ({\n  enumerable: true,\n  get: function () {\n    return _util.PromiseCapability;\n  }\n}));\nObject.defineProperty(exports, \"RenderingCancelledException\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.RenderingCancelledException;\n  }\n}));\nObject.defineProperty(exports, \"SVGGraphics\", ({\n  enumerable: true,\n  get: function () {\n    return _api.SVGGraphics;\n  }\n}));\nObject.defineProperty(exports, \"UnexpectedResponseException\", ({\n  enumerable: true,\n  get: function () {\n    return _util.UnexpectedResponseException;\n  }\n}));\nObject.defineProperty(exports, \"Util\", ({\n  enumerable: true,\n  get: function () {\n    return _util.Util;\n  }\n}));\nObject.defineProperty(exports, \"VerbosityLevel\", ({\n  enumerable: true,\n  get: function () {\n    return _util.VerbosityLevel;\n  }\n}));\nObject.defineProperty(exports, \"XfaLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _xfa_layer.XfaLayer;\n  }\n}));\nObject.defineProperty(exports, \"build\", ({\n  enumerable: true,\n  get: function () {\n    return _api.build;\n  }\n}));\nObject.defineProperty(exports, \"createValidAbsoluteUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _util.createValidAbsoluteUrl;\n  }\n}));\nObject.defineProperty(exports, \"getDocument\", ({\n  enumerable: true,\n  get: function () {\n    return _api.getDocument;\n  }\n}));\nObject.defineProperty(exports, \"getFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getPdfFilenameFromUrl\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getPdfFilenameFromUrl;\n  }\n}));\nObject.defineProperty(exports, \"getXfaPageViewport\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.getXfaPageViewport;\n  }\n}));\nObject.defineProperty(exports, \"isDataScheme\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.isDataScheme;\n  }\n}));\nObject.defineProperty(exports, \"isPdfFile\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.isPdfFile;\n  }\n}));\nObject.defineProperty(exports, \"loadScript\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.loadScript;\n  }\n}));\nObject.defineProperty(exports, \"noContextMenu\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.noContextMenu;\n  }\n}));\nObject.defineProperty(exports, \"normalizeUnicode\", ({\n  enumerable: true,\n  get: function () {\n    return _util.normalizeUnicode;\n  }\n}));\nObject.defineProperty(exports, \"renderTextLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _text_layer.renderTextLayer;\n  }\n}));\nObject.defineProperty(exports, \"setLayerDimensions\", ({\n  enumerable: true,\n  get: function () {\n    return _display_utils.setLayerDimensions;\n  }\n}));\nObject.defineProperty(exports, \"shadow\", ({\n  enumerable: true,\n  get: function () {\n    return _util.shadow;\n  }\n}));\nObject.defineProperty(exports, \"updateTextLayer\", ({\n  enumerable: true,\n  get: function () {\n    return _text_layer.updateTextLayer;\n  }\n}));\nObject.defineProperty(exports, \"version\", ({\n  enumerable: true,\n  get: function () {\n    return _api.version;\n  }\n}));\nvar _util = __w_pdfjs_require__(1);\nvar _api = __w_pdfjs_require__(124);\nvar _display_utils = __w_pdfjs_require__(168);\nvar _text_layer = __w_pdfjs_require__(195);\nvar _annotation_editor_layer = __w_pdfjs_require__(196);\nvar _tools = __w_pdfjs_require__(165);\nvar _annotation_layer = __w_pdfjs_require__(198);\nvar _worker_options = __w_pdfjs_require__(176);\nvar _xfa_layer = __w_pdfjs_require__(201);\nconst pdfjsVersion = '3.11.174';\nconst pdfjsBuild = 'ce8716743';\n})();\n\n/******/ \treturn __nested_webpack_exports__;\n/******/ })()\n;\n});\n//# sourceMappingURL=pdf.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvLnBucG0vcGRmanMtZGlzdEAzLjExLjE3NC9ub2RlX21vZHVsZXMvcGRmanMtZGlzdC9sZWdhY3kvYnVpbGQvcGRmLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLElBQUksSUFBeUQ7QUFDN0Q7QUFDQSxNQUFNLEVBS3FEO0FBQzNELENBQUM7QUFDRCx5QkFBeUI7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLElBQUk7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsSUFBSTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsSUFBSTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxjQUFjLEVBQUUsY0FBYyxFQUFFLGNBQWM7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFFBQVE7QUFDUixvQ0FBb0MsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxRQUFRO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxRQUFRO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBCQUEwQixVQUFVO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILDREQUE0RDtBQUM1RCxHQUFHO0FBQ0gsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0EsZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQSw4QkFBOEI7QUFDOUI7QUFDQSw0RUFBNEUsTUFBTTtBQUNsRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLEVBQUU7O0FBRUYsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0EsK0JBQStCOztBQUUvQixPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0Esb0VBQW9FO0FBQ3BFLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RDtBQUM3RDs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQSxtQ0FBbUM7QUFDbkM7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0YsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxjQUFjLFVBQVU7QUFDMUIsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msc0JBQXNCO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLGlCQUFpQjtBQUMxRCxJQUFJO0FBQ0o7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGlCQUFpQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSxnQkFBZ0I7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsWUFBWTtBQUNwRSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLGNBQWM7QUFDcEQ7QUFDQSxzQ0FBc0MsY0FBYztBQUNwRDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixxQkFBcUI7QUFDNUMsQ0FBQztBQUNEO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixjQUFjO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsaUJBQWlCO0FBQ3pELEdBQUc7QUFDSDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRCxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsU0FBUztBQUNqQjtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsR0FBRztBQUNIO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUSxTQUFTO0FBQ2pCO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx5QkFBeUI7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsMENBQTBDO0FBQ25IO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCLGdCQUFnQjtBQUNqQztBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQSxDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFOztBQUVGLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLGdDQUFnQztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxRQUFRO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw0RkFBNEY7QUFDNUY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsVUFBYztBQUN0QztBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsSUFBSSxHQUFHO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtREFBbUQ7QUFDbkQ7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsNkJBQTZCO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTCxnRkFBZ0YsZUFBZTtBQUMvRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixVQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxPQUFPO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0VBQXdFLGVBQWU7QUFDdkY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGdCQUFnQixHQUFHLG1DQUFtQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMERBQTBELGNBQWM7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsS0FBSztBQUNqRTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxLQUFLO0FBQzFEO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxpQkFBaUI7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE1BQU07QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVHQUF1RyxvQkFBb0I7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJLHdCQUF3Qjs7QUFFN0IsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSw0QkFBNEI7O0FBRWpDLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNILEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJLGdDQUFnQzs7QUFFckMsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUksd0JBQXdCOztBQUU3QixPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQyxJQUFJLDRCQUE0Qjs7QUFFakMsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSwwQ0FBMEM7O0FBRS9DLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLElBQUksY0FBYzs7QUFFbkIsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUMsSUFBSSx1RUFBdUU7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsOEZBQThGLFVBQVU7QUFDeEc7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0QsZUFBZTtBQUMvRCxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBLDJDQUEyQyxxQ0FBcUM7QUFDaEY7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLFlBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0RBQWtELFlBQVk7QUFDOUQ7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUhBQXFILDhCQUE4QjtBQUNuSixJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFlBQVk7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsWUFBWTtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG1CQUFtQjtBQUNuRSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELG1CQUFtQjtBQUNuRSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRixDQUFDOztBQUVELE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELGdCQUFnQjtBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsSUFBSSxHQUFHLDJCQUEyQjtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixRQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscUJBQXFCO0FBQ2xELDRCQUE0QixxQkFBcUI7QUFDakQ7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0IscUJBQXFCO0FBQ3pDLG1CQUFtQixxQkFBcUI7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhCQUE4Qix1Q0FBdUM7QUFDckU7QUFDQSxpQ0FBaUMseUNBQXlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsbURBQW1EO0FBQzFFO0FBQ0E7QUFDQSx3QkFBd0IscURBQXFEO0FBQzdFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUNBQW1DLDhDQUE4QztBQUNqRixvQ0FBb0MsOENBQThDO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QixFQUFFLFdBQVc7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0Msd0lBQXdJO0FBQzVLO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixhQUFhLEdBQUcsV0FBVztBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsSUFBSTtBQUM3RTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTix3QkFBd0IsYUFBYSxHQUFHLEtBQUssR0FBRyxLQUFLLEdBQUcsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0MsYUFBYTtBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTiw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ04saUNBQWlDLFdBQVc7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOLGlDQUFpQyxXQUFXO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFdBQVc7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0Usc0JBQXNCO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGVBQWUsU0FBUztBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1CQUFtQjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQSxTQUFTLG1CQUFtQjtBQUM1QjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLGtCQUFrQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxFQUFFO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixTQUFTO0FBQy9CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxPQUFPLEVBQUUsT0FBTyxFQUFFLE9BQU87QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVksZ0JBQWdCLFdBQVc7QUFDM0Qsd0JBQXdCLEdBQUc7QUFDM0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUSxHQUFHLFFBQVE7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFVBQVU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNCQUFzQixRQUFRO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsR0FBRztBQUM5QjtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsUUFBUSxHQUFHLFFBQVEsR0FBRyxXQUFXLEdBQUcsV0FBVztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFFBQVE7QUFDOUI7QUFDQTtBQUNBLDJCQUEyQixRQUFRO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCLFNBQVM7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsWUFBWTtBQUNoQztBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsR0FBRztBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRCxLQUFLO0FBQzNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3REFBd0QsS0FBSztBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixxQkFBcUIsc0JBQXNCLEVBQUUsWUFBWTtBQUN6RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELFdBQVc7QUFDNUQ7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxFQUFFLFdBQVcsRUFBRSxZQUFZLEVBQUUsWUFBWSxFQUFFLFlBQVksRUFBRSxZQUFZLEVBQUUsMkJBQTJCLEVBQUUsbUJBQW1CLEVBQUU7QUFDN0s7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCxNQUFNO0FBQ3REO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVDQUF1QyxVQUFVO0FBQ2pELG1DQUFtQyxXQUFXO0FBQzlDLHlDQUF5QyxFQUFFLGtCQUFrQixFQUFFO0FBQy9ELHNDQUFzQyxFQUFFLGtCQUFrQixFQUFFO0FBQzVEO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsbUNBQW1DLFdBQVcsSUFBSTtBQUMxRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsYUFBYSxFQUFFLFNBQVM7QUFDM0M7QUFDQSxzREFBc0QsSUFBSTtBQUMxRCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQyxNQUFNO0FBQ3pDLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQSx1Q0FBdUMsT0FBTyxFQUFFLE9BQU87QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSLG9EQUFvRCxrQkFBa0I7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGtEQUFrRCxzQkFBc0IsTUFBTSxHQUFHO0FBQ2pGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLFdBQVcsRUFBRSxzQkFBc0I7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdELFFBQVE7QUFDeEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLFNBQVMsV0FBVyxFQUFFO0FBQzlELDhCQUE4QixlQUFlLGVBQWUsRUFBRSxNQUFNLEtBQUs7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFO0FBQ2xFLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2QkFBNkI7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixlQUFlLFNBQVMsV0FBVyxFQUFFO0FBQ2pFO0FBQ0E7QUFDQSwwQkFBMEIsZUFBZSxnQkFBZ0IsRUFBRSxNQUFNLEtBQUs7QUFDdEUsTUFBTTtBQUNOLGdDQUFnQyw2QkFBNkI7QUFDN0Q7QUFDQSxzQ0FBc0MsNkJBQTZCLElBQUk7QUFDdkU7QUFDQSwwQkFBMEIsZUFBZSw0QkFBNEIsRUFBRSxFQUFFLElBQUksTUFBTSxLQUFLO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsaUVBQWlFLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIsc0RBQTJCO0FBQ3hELE1BQU07QUFDTixrRkFBa0YsR0FBRztBQUNyRjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsRUFBRSxtQkFBTyxDQUFDLHFCQUFRO0FBQzFCO0FBQ0E7QUFDQSxRQUFRLEVBQUUsbUJBQU8sQ0FBQywySEFBaUI7QUFDbkM7QUFDQTtBQUNBLE1BQU07QUFDTiwrRUFBK0UsR0FBRztBQUNsRjtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsY0FBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxxQkFBUTtBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFlBQVk7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsV0FBVztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjLFdBQVc7QUFDekI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxzQkFBc0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtCQUFrQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsVUFBVTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0JBQWdCLGdCQUFnQjtBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZ0JBQWdCLGlCQUFpQjtBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLElBQUk7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0osdUNBQXVDLGFBQWE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsaUJBQWlCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixZQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsY0FBYztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxZQUFZO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxLQUFLLEtBQUsscUJBQXFCO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLFFBQVEsRUFBRSxNQUFNLEVBQUUsZ0JBQWdCLEtBQUssU0FBUztBQUN2RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0JBQWtCO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLHFCQUFxQjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsUUFBUTtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkNBQTJDLFFBQVE7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixXQUFXO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLFVBQVU7QUFDaEM7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixVQUFVO0FBQzVCO0FBQ0Esd0JBQXdCLFVBQVU7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFFBQVE7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQ0FBc0MsTUFBTTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStELFVBQVU7QUFDekU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5Qiw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLG9CQUFvQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZUFBZTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBLElBQUk7QUFDSixXQUFXLGVBQWU7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlDQUF5QyxRQUFRO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLFFBQVE7QUFDN0M7QUFDQTtBQUNBLElBQUk7QUFDSixxQ0FBcUMsUUFBUTtBQUM3QztBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxXQUFXO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxZQUFZO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsV0FBVztBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixZQUFZO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsUUFBUTtBQUNSLDZEQUE2RCxRQUFRO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELFNBQVM7QUFDdEU7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxpRUFBaUUsR0FBRztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsaUVBQWlFLEdBQUc7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLGlFQUFpRSxHQUFHO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5REFBeUQsYUFBYTtBQUN0RTtBQUNBO0FBQ0EsMENBQTBDLFdBQVc7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJEQUEyRCxHQUFHO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUIsR0FBRyxHQUFHLGNBQWM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThELElBQUk7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsTUFBTSxHQUFHLFFBQVE7QUFDNUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsT0FBTywwQkFBMEIsSUFBSTtBQUNuSDtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkIscURBQXFELE9BQU87QUFDekY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixvQkFBb0I7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0JBQXNCLGtCQUFrQjtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QyxFQUFFO0FBQ2hEO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QyxXQUFXLEdBQUcsYUFBYTtBQUN4RTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxtQkFBTyxDQUFDLGdCQUFLO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsVUFBVTtBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9FQUFvRSxVQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsbUJBQU8sQ0FBQyxrQkFBTTtBQUNqQztBQUNBLE1BQU07QUFDTixvQkFBb0IsbUJBQU8sQ0FBQyxvQkFBTztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsTUFBTSxHQUFHLFFBQVE7QUFDeEQ7QUFDQTtBQUNBLG9FQUFvRSxVQUFVO0FBQzlFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLG1CQUFPLENBQUMsa0JBQU07QUFDakM7QUFDQSxNQUFNO0FBQ04sb0JBQW9CLG1CQUFPLENBQUMsb0JBQU87QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG1CQUFPLENBQUMsY0FBSTtBQUMzQjtBQUNBO0FBQ0E7QUFDQSxnRUFBZ0UsS0FBSztBQUNyRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQyxjQUFJO0FBQzNCO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsdUJBQXVCLGFBQWE7QUFDcEMsb0NBQW9DLFFBQVE7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCLFNBQVM7QUFDM0I7QUFDQSxvQkFBb0IsT0FBTztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsU0FBUztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLHFEQUEyQjtBQUNoRDtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFlBQVk7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsWUFBWTtBQUNsQztBQUNBLHdCQUF3QixjQUFjO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0IsVUFBVSxFQUFFLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCLE1BQU07QUFDN0I7QUFDQSxJQUFJO0FBQ0osd0JBQXdCLFVBQVUsRUFBRSxTQUFTO0FBQzdDO0FBQ0EsbUJBQW1CLFVBQVUsRUFBRSxVQUFVLEVBQUUsVUFBVSxFQUFFLFVBQVUsRUFBRSxVQUFVLE9BQU8sU0FBUztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDLFFBQVE7QUFDakQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUMsUUFBUTtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9EQUFvRCxHQUFHO0FBQ3ZEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQscUJBQXFCO0FBQzVFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdURBQXVELHFCQUFxQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsdURBQXVELHFCQUFxQjtBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0REFBNEQsZ0JBQWdCLFFBQVEsZUFBZTtBQUNuRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyxnQkFBZ0IsbUJBQW1CLEVBQUUsaUJBQWlCLElBQUksSUFBSTtBQUM3RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0MsSUFBSTtBQUM1Qyx3Q0FBd0MsSUFBSTtBQUM1QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixTQUFTO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DLGVBQWU7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELFFBQVE7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QixVQUFVO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCLFlBQVk7QUFDMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQyxPQUFPO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsdUNBQXVDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxJQUFJO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RCxPQUFPO0FBQy9EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxlQUFlLEVBQUUsZ0JBQWdCO0FBQ3RGO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsWUFBWTtBQUN4QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLGVBQWU7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVEsZ0JBQWdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTCxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGtCQUFrQixLQUFLLFdBQVc7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNDQUFzQyxRQUFRO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsMENBQTBDO0FBQ2pFLHNCQUFzQiwwQ0FBMEM7QUFDaEUsSUFBSTtBQUNKLHVCQUF1QixlQUFlLEVBQUUsZ0JBQWdCO0FBQ3hELHNCQUFzQixlQUFlLEVBQUUsZUFBZTtBQUN0RDtBQUNBLHlCQUF5QixlQUFlLEVBQUUsc0JBQXNCO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQSxvQkFBb0IsaUJBQWlCLEtBQUssV0FBVztBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsNEJBQTRCLDRCQUE0QjtBQUN4RDtBQUNBO0FBQ0E7QUFDQSwwQkFBMEIsaUJBQWlCLE9BQU8sVUFBVTtBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssZ0JBQWdCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0ZBQStGO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCxRQUFRO0FBQzFEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLFdBQVc7QUFDWDtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLFFBQVE7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEMsS0FBSztBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOLDZCQUE2QixlQUFlO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsdUNBQXVDLHVCQUF1QjtBQUM5RDtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsaUJBQWlCLG1DQUFtQyxlQUFlO0FBQ2xHO0FBQ0EsUUFBUTtBQUNSLCtCQUErQixNQUFNLG1DQUFtQyxPQUFPO0FBQy9FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBLDhCQUE4QixvQ0FBb0M7QUFDbEUsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0EsaUNBQWlDLHdCQUF3QjtBQUN6RCxrQ0FBa0MsMEJBQTBCO0FBQzVELE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixhQUFhO0FBQzVDLGdDQUFnQyxjQUFjO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFLFVBQVU7QUFDcEY7QUFDQSx5REFBeUQsVUFBVTtBQUNuRSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0EsNENBQTRDLHNJQUFzSSxZQUFZLGtCQUFrQixZQUFZO0FBQzVOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixhQUFhO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFLEVBQUUsT0FBTyxFQUFFLFdBQVcsVUFBVSxZQUFZLFdBQVc7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLEdBQUc7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQixRQUFRO0FBQzdCO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLEdBQUc7QUFDNUU7QUFDQSx5RUFBeUUsR0FBRztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVFQUF1RSxHQUFHO0FBQzFFO0FBQ0E7QUFDQSxVQUFVO0FBQ1YseUVBQXlFLEdBQUc7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLE9BQU87QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1AsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QixpQkFBaUI7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmLGFBQWE7QUFDYjtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQjtBQUNoQjtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDLFVBQVU7QUFDeEQ7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUNBQXlDO0FBQ3pDLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxjQUFjO0FBQ2Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5RUFBeUUsdUJBQXVCLEVBQUUsR0FBRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNERBQTRELFdBQVc7QUFDdkUsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTixvQkFBb0Isc0NBQXNDO0FBQzFELG1CQUFtQixzQ0FBc0M7QUFDekQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDLFFBQVE7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsRUFBRSxHQUFHLEVBQUU7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBLHVCQUF1Qix3QkFBd0IsYUFBYSx1REFBdUQ7QUFDbkg7QUFDQSwyQ0FBMkMsaUNBQWlDLEdBQUc7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQkFBMkIsdUJBQXVCLEVBQUUsR0FBRztBQUN2RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtFQUFrRSxHQUFHO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLEVBQUUsRUFBRSxFQUFFLEVBQUUsRUFBRTtBQUN6QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLGtDQUFrQztBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxrQkFBa0IsWUFBWTtBQUM5QixxQkFBcUIsYUFBYSxLQUFLLFlBQVk7QUFDbkQsNkJBQTZCLFVBQVUsTUFBTSxTQUFTO0FBQ3RELDZCQUE2QixVQUFVLE1BQU0sU0FBUztBQUN0RCxzQ0FBc0MsTUFBTSxJQUFJLE1BQU07QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFEQUFxRCxRQUFRLElBQUksV0FBVyxPQUFPLEdBQUcsYUFBYTtBQUNuRywwREFBMEQsUUFBUSxJQUFJLFdBQVcsT0FBTyxHQUFHLE1BQU0sSUFBSSxhQUFhO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNO0FBQy9CLDRCQUE0QixNQUFNO0FBQ2xDLDBDQUEwQyxNQUFNO0FBQ2hEO0FBQ0E7QUFDQSw4QkFBOEIsVUFBVSxLQUFLLFFBQVE7QUFDckQsZ0NBQWdDLFVBQVUsS0FBSyxRQUFRO0FBQ3ZELDhDQUE4QyxRQUFRO0FBQ3RELGdEQUFnRCxRQUFRO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsT0FBTztBQUNoQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkJBQTZCLE1BQU0sSUFBSSxNQUFNO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCxVQUFVO0FBQzdEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG1DQUFtQztBQUNuRTtBQUNBO0FBQ0Esc0NBQXNDLG1DQUFtQztBQUN6RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLEVBQUUsYUFBYSxFQUFFO0FBQzdDLDBDQUEwQyxjQUFjO0FBQ3hELEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTs7OztBQUlBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWCxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWCxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsMkJBQTJCLGdCQUFnQixHQUFHLE9BQU87QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLHdDQUF3QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsT0FBTztBQUNQO0FBQ0E7Ozs7QUFJQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QixNQUFNLEVBQUUsa0NBQWtDO0FBQ25FO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLHFCQUFxQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxRQUFRO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxRQUFRO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEMsUUFBUTtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNENBQTRDLFFBQVE7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLFFBQVE7QUFDbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLE9BQU87QUFDUDtBQUNBOzs7O0FBSUE7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0YsS0FBSztBQUNyRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSwwQkFBbUI7QUFDdkI7QUFDQTtBQUNBLGNBQWMsMEJBQW1COzs7QUFHakM7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQsaUJBQWlCLDBCQUFtQjtBQUNwQyxVQUFVO0FBQ1Y7QUFDQSxDQUFDO0FBQ0QiLCJzb3VyY2VzIjpbIkQ6XFxkdWNrVGFibGVcXGRlbW9cXHBkZi1yb3RhdGUtdG9vbFxcbm9kZV9tb2R1bGVzXFwucG5wbVxccGRmanMtZGlzdEAzLjExLjE3NFxcbm9kZV9tb2R1bGVzXFxwZGZqcy1kaXN0XFxsZWdhY3lcXGJ1aWxkXFxwZGYuanMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljc3RhcnQgVGhlIGZvbGxvd2luZyBpcyB0aGUgZW50aXJlIGxpY2Vuc2Ugbm90aWNlIGZvciB0aGVcbiAqIEphdmFTY3JpcHQgY29kZSBpbiB0aGlzIHBhZ2VcbiAqXG4gKiBDb3B5cmlnaHQgMjAyMyBNb3ppbGxhIEZvdW5kYXRpb25cbiAqXG4gKiBMaWNlbnNlZCB1bmRlciB0aGUgQXBhY2hlIExpY2Vuc2UsIFZlcnNpb24gMi4wICh0aGUgXCJMaWNlbnNlXCIpO1xuICogeW91IG1heSBub3QgdXNlIHRoaXMgZmlsZSBleGNlcHQgaW4gY29tcGxpYW5jZSB3aXRoIHRoZSBMaWNlbnNlLlxuICogWW91IG1heSBvYnRhaW4gYSBjb3B5IG9mIHRoZSBMaWNlbnNlIGF0XG4gKlxuICogICAgIGh0dHA6Ly93d3cuYXBhY2hlLm9yZy9saWNlbnNlcy9MSUNFTlNFLTIuMFxuICpcbiAqIFVubGVzcyByZXF1aXJlZCBieSBhcHBsaWNhYmxlIGxhdyBvciBhZ3JlZWQgdG8gaW4gd3JpdGluZywgc29mdHdhcmVcbiAqIGRpc3RyaWJ1dGVkIHVuZGVyIHRoZSBMaWNlbnNlIGlzIGRpc3RyaWJ1dGVkIG9uIGFuIFwiQVMgSVNcIiBCQVNJUyxcbiAqIFdJVEhPVVQgV0FSUkFOVElFUyBPUiBDT05ESVRJT05TIE9GIEFOWSBLSU5ELCBlaXRoZXIgZXhwcmVzcyBvciBpbXBsaWVkLlxuICogU2VlIHRoZSBMaWNlbnNlIGZvciB0aGUgc3BlY2lmaWMgbGFuZ3VhZ2UgZ292ZXJuaW5nIHBlcm1pc3Npb25zIGFuZFxuICogbGltaXRhdGlvbnMgdW5kZXIgdGhlIExpY2Vuc2UuXG4gKlxuICogQGxpY2VuZCBUaGUgYWJvdmUgaXMgdGhlIGVudGlyZSBsaWNlbnNlIG5vdGljZSBmb3IgdGhlXG4gKiBKYXZhU2NyaXB0IGNvZGUgaW4gdGhpcyBwYWdlXG4gKi9cblxuKGZ1bmN0aW9uIHdlYnBhY2tVbml2ZXJzYWxNb2R1bGVEZWZpbml0aW9uKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnICYmIHR5cGVvZiBtb2R1bGUgPT09ICdvYmplY3QnKVxuXHRcdG1vZHVsZS5leHBvcnRzID0gcm9vdC5wZGZqc0xpYiA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFwicGRmanMtZGlzdC9idWlsZC9wZGZcIiwgW10sICgpID0+IHsgcmV0dXJuIChyb290LnBkZmpzTGliID0gZmFjdG9yeSgpKTsgfSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJwZGZqcy1kaXN0L2J1aWxkL3BkZlwiXSA9IHJvb3QucGRmanNMaWIgPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wicGRmanMtZGlzdC9idWlsZC9wZGZcIl0gPSByb290LnBkZmpzTGliID0gZmFjdG9yeSgpO1xufSkoZ2xvYmFsVGhpcywgKCkgPT4ge1xucmV0dXJuIC8qKioqKiovICgoKSA9PiB7IC8vIHdlYnBhY2tCb290c3RyYXBcbi8qKioqKiovIFx0XCJ1c2Ugc3RyaWN0XCI7XG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlc19fID0gKFtcbi8qIDAgKi8sXG4vKiAxICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlZlcmJvc2l0eUxldmVsID0gZXhwb3J0cy5VdGlsID0gZXhwb3J0cy5Vbmtub3duRXJyb3JFeGNlcHRpb24gPSBleHBvcnRzLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbiA9IGV4cG9ydHMuVGV4dFJlbmRlcmluZ01vZGUgPSBleHBvcnRzLlJlbmRlcmluZ0ludGVudEZsYWcgPSBleHBvcnRzLlByb21pc2VDYXBhYmlsaXR5ID0gZXhwb3J0cy5QZXJtaXNzaW9uRmxhZyA9IGV4cG9ydHMuUGFzc3dvcmRSZXNwb25zZXMgPSBleHBvcnRzLlBhc3N3b3JkRXhjZXB0aW9uID0gZXhwb3J0cy5QYWdlQWN0aW9uRXZlbnRUeXBlID0gZXhwb3J0cy5PUFMgPSBleHBvcnRzLk1pc3NpbmdQREZFeGNlcHRpb24gPSBleHBvcnRzLk1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFID0gZXhwb3J0cy5MSU5FX0ZBQ1RPUiA9IGV4cG9ydHMuTElORV9ERVNDRU5UX0ZBQ1RPUiA9IGV4cG9ydHMuSW52YWxpZFBERkV4Y2VwdGlvbiA9IGV4cG9ydHMuSW1hZ2VLaW5kID0gZXhwb3J0cy5JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkZvcm1hdEVycm9yID0gZXhwb3J0cy5GZWF0dXJlVGVzdCA9IGV4cG9ydHMuRk9OVF9JREVOVElUWV9NQVRSSVggPSBleHBvcnRzLkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0gZXhwb3J0cy5DTWFwQ29tcHJlc3Npb25UeXBlID0gZXhwb3J0cy5CYXNlRXhjZXB0aW9uID0gZXhwb3J0cy5CQVNFTElORV9GQUNUT1IgPSBleHBvcnRzLkFubm90YXRpb25UeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uUmVwbHlUeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uUHJlZml4ID0gZXhwb3J0cy5Bbm5vdGF0aW9uTW9kZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkZsYWcgPSBleHBvcnRzLkFubm90YXRpb25GaWVsZEZsYWcgPSBleHBvcnRzLkFubm90YXRpb25FZGl0b3JUeXBlID0gZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUHJlZml4ID0gZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IGV4cG9ydHMuQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IGV4cG9ydHMuQWJvcnRFeGNlcHRpb24gPSB2b2lkIDA7XG5leHBvcnRzLmFzc2VydCA9IGFzc2VydDtcbmV4cG9ydHMuYnl0ZXNUb1N0cmluZyA9IGJ5dGVzVG9TdHJpbmc7XG5leHBvcnRzLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmwgPSBjcmVhdGVWYWxpZEFic29sdXRlVXJsO1xuZXhwb3J0cy5nZXRNb2RpZmljYXRpb25EYXRlID0gZ2V0TW9kaWZpY2F0aW9uRGF0ZTtcbmV4cG9ydHMuZ2V0VXVpZCA9IGdldFV1aWQ7XG5leHBvcnRzLmdldFZlcmJvc2l0eUxldmVsID0gZ2V0VmVyYm9zaXR5TGV2ZWw7XG5leHBvcnRzLmluZm8gPSBpbmZvO1xuZXhwb3J0cy5pc0FycmF5QnVmZmVyID0gaXNBcnJheUJ1ZmZlcjtcbmV4cG9ydHMuaXNBcnJheUVxdWFsID0gaXNBcnJheUVxdWFsO1xuZXhwb3J0cy5pc05vZGVKUyA9IHZvaWQgMDtcbmV4cG9ydHMubm9ybWFsaXplVW5pY29kZSA9IG5vcm1hbGl6ZVVuaWNvZGU7XG5leHBvcnRzLm9iamVjdEZyb21NYXAgPSBvYmplY3RGcm9tTWFwO1xuZXhwb3J0cy5vYmplY3RTaXplID0gb2JqZWN0U2l6ZTtcbmV4cG9ydHMuc2V0VmVyYm9zaXR5TGV2ZWwgPSBzZXRWZXJib3NpdHlMZXZlbDtcbmV4cG9ydHMuc2hhZG93ID0gc2hhZG93O1xuZXhwb3J0cy5zdHJpbmczMiA9IHN0cmluZzMyO1xuZXhwb3J0cy5zdHJpbmdUb0J5dGVzID0gc3RyaW5nVG9CeXRlcztcbmV4cG9ydHMuc3RyaW5nVG9QREZTdHJpbmcgPSBzdHJpbmdUb1BERlN0cmluZztcbmV4cG9ydHMuc3RyaW5nVG9VVEY4U3RyaW5nID0gc3RyaW5nVG9VVEY4U3RyaW5nO1xuZXhwb3J0cy51bnJlYWNoYWJsZSA9IHVucmVhY2hhYmxlO1xuZXhwb3J0cy51dGY4U3RyaW5nVG9TdHJpbmcgPSB1dGY4U3RyaW5nVG9TdHJpbmc7XG5leHBvcnRzLndhcm4gPSB3YXJuO1xuX193X3BkZmpzX3JlcXVpcmVfXygyKTtcbl9fd19wZGZqc19yZXF1aXJlX18oODQpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4Nik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDg3KTtcbl9fd19wZGZqc19yZXF1aXJlX18oODkpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg5Myk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwOSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExNik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyMyk7XG5jb25zdCBpc05vZGVKUyA9IHR5cGVvZiBwcm9jZXNzID09PSBcIm9iamVjdFwiICYmIHByb2Nlc3MgKyBcIlwiID09PSBcIltvYmplY3QgcHJvY2Vzc11cIiAmJiAhcHJvY2Vzcy52ZXJzaW9ucy5udyAmJiAhKHByb2Nlc3MudmVyc2lvbnMuZWxlY3Ryb24gJiYgcHJvY2Vzcy50eXBlICYmIHByb2Nlc3MudHlwZSAhPT0gXCJicm93c2VyXCIpO1xuZXhwb3J0cy5pc05vZGVKUyA9IGlzTm9kZUpTO1xuY29uc3QgSURFTlRJVFlfTUFUUklYID0gWzEsIDAsIDAsIDEsIDAsIDBdO1xuZXhwb3J0cy5JREVOVElUWV9NQVRSSVggPSBJREVOVElUWV9NQVRSSVg7XG5jb25zdCBGT05UX0lERU5USVRZX01BVFJJWCA9IFswLjAwMSwgMCwgMCwgMC4wMDEsIDAsIDBdO1xuZXhwb3J0cy5GT05UX0lERU5USVRZX01BVFJJWCA9IEZPTlRfSURFTlRJVFlfTUFUUklYO1xuY29uc3QgTUFYX0lNQUdFX1NJWkVfVE9fQ0FDSEUgPSAxMGU2O1xuZXhwb3J0cy5NQVhfSU1BR0VfU0laRV9UT19DQUNIRSA9IE1BWF9JTUFHRV9TSVpFX1RPX0NBQ0hFO1xuY29uc3QgTElORV9GQUNUT1IgPSAxLjM1O1xuZXhwb3J0cy5MSU5FX0ZBQ1RPUiA9IExJTkVfRkFDVE9SO1xuY29uc3QgTElORV9ERVNDRU5UX0ZBQ1RPUiA9IDAuMzU7XG5leHBvcnRzLkxJTkVfREVTQ0VOVF9GQUNUT1IgPSBMSU5FX0RFU0NFTlRfRkFDVE9SO1xuY29uc3QgQkFTRUxJTkVfRkFDVE9SID0gTElORV9ERVNDRU5UX0ZBQ1RPUiAvIExJTkVfRkFDVE9SO1xuZXhwb3J0cy5CQVNFTElORV9GQUNUT1IgPSBCQVNFTElORV9GQUNUT1I7XG5jb25zdCBSZW5kZXJpbmdJbnRlbnRGbGFnID0ge1xuICBBTlk6IDB4MDEsXG4gIERJU1BMQVk6IDB4MDIsXG4gIFBSSU5UOiAweDA0LFxuICBTQVZFOiAweDA4LFxuICBBTk5PVEFUSU9OU19GT1JNUzogMHgxMCxcbiAgQU5OT1RBVElPTlNfU1RPUkFHRTogMHgyMCxcbiAgQU5OT1RBVElPTlNfRElTQUJMRTogMHg0MCxcbiAgT1BMSVNUOiAweDEwMFxufTtcbmV4cG9ydHMuUmVuZGVyaW5nSW50ZW50RmxhZyA9IFJlbmRlcmluZ0ludGVudEZsYWc7XG5jb25zdCBBbm5vdGF0aW9uTW9kZSA9IHtcbiAgRElTQUJMRTogMCxcbiAgRU5BQkxFOiAxLFxuICBFTkFCTEVfRk9STVM6IDIsXG4gIEVOQUJMRV9TVE9SQUdFOiAzXG59O1xuZXhwb3J0cy5Bbm5vdGF0aW9uTW9kZSA9IEFubm90YXRpb25Nb2RlO1xuY29uc3QgQW5ub3RhdGlvbkVkaXRvclByZWZpeCA9IFwicGRmanNfaW50ZXJuYWxfZWRpdG9yX1wiO1xuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yUHJlZml4ID0gQW5ub3RhdGlvbkVkaXRvclByZWZpeDtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JUeXBlID0ge1xuICBESVNBQkxFOiAtMSxcbiAgTk9ORTogMCxcbiAgRlJFRVRFWFQ6IDMsXG4gIFNUQU1QOiAxMyxcbiAgSU5LOiAxNVxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclR5cGUgPSBBbm5vdGF0aW9uRWRpdG9yVHlwZTtcbmNvbnN0IEFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlID0ge1xuICBSRVNJWkU6IDEsXG4gIENSRUFURTogMixcbiAgRlJFRVRFWFRfU0laRTogMTEsXG4gIEZSRUVURVhUX0NPTE9SOiAxMixcbiAgRlJFRVRFWFRfT1BBQ0lUWTogMTMsXG4gIElOS19DT0xPUjogMjEsXG4gIElOS19USElDS05FU1M6IDIyLFxuICBJTktfT1BBQ0lUWTogMjNcbn07XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlID0gQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGU7XG5jb25zdCBQZXJtaXNzaW9uRmxhZyA9IHtcbiAgUFJJTlQ6IDB4MDQsXG4gIE1PRElGWV9DT05URU5UUzogMHgwOCxcbiAgQ09QWTogMHgxMCxcbiAgTU9ESUZZX0FOTk9UQVRJT05TOiAweDIwLFxuICBGSUxMX0lOVEVSQUNUSVZFX0ZPUk1TOiAweDEwMCxcbiAgQ09QWV9GT1JfQUNDRVNTSUJJTElUWTogMHgyMDAsXG4gIEFTU0VNQkxFOiAweDQwMCxcbiAgUFJJTlRfSElHSF9RVUFMSVRZOiAweDgwMFxufTtcbmV4cG9ydHMuUGVybWlzc2lvbkZsYWcgPSBQZXJtaXNzaW9uRmxhZztcbmNvbnN0IFRleHRSZW5kZXJpbmdNb2RlID0ge1xuICBGSUxMOiAwLFxuICBTVFJPS0U6IDEsXG4gIEZJTExfU1RST0tFOiAyLFxuICBJTlZJU0lCTEU6IDMsXG4gIEZJTExfQUREX1RPX1BBVEg6IDQsXG4gIFNUUk9LRV9BRERfVE9fUEFUSDogNSxcbiAgRklMTF9TVFJPS0VfQUREX1RPX1BBVEg6IDYsXG4gIEFERF9UT19QQVRIOiA3LFxuICBGSUxMX1NUUk9LRV9NQVNLOiAzLFxuICBBRERfVE9fUEFUSF9GTEFHOiA0XG59O1xuZXhwb3J0cy5UZXh0UmVuZGVyaW5nTW9kZSA9IFRleHRSZW5kZXJpbmdNb2RlO1xuY29uc3QgSW1hZ2VLaW5kID0ge1xuICBHUkFZU0NBTEVfMUJQUDogMSxcbiAgUkdCXzI0QlBQOiAyLFxuICBSR0JBXzMyQlBQOiAzXG59O1xuZXhwb3J0cy5JbWFnZUtpbmQgPSBJbWFnZUtpbmQ7XG5jb25zdCBBbm5vdGF0aW9uVHlwZSA9IHtcbiAgVEVYVDogMSxcbiAgTElOSzogMixcbiAgRlJFRVRFWFQ6IDMsXG4gIExJTkU6IDQsXG4gIFNRVUFSRTogNSxcbiAgQ0lSQ0xFOiA2LFxuICBQT0xZR09OOiA3LFxuICBQT0xZTElORTogOCxcbiAgSElHSExJR0hUOiA5LFxuICBVTkRFUkxJTkU6IDEwLFxuICBTUVVJR0dMWTogMTEsXG4gIFNUUklLRU9VVDogMTIsXG4gIFNUQU1QOiAxMyxcbiAgQ0FSRVQ6IDE0LFxuICBJTks6IDE1LFxuICBQT1BVUDogMTYsXG4gIEZJTEVBVFRBQ0hNRU5UOiAxNyxcbiAgU09VTkQ6IDE4LFxuICBNT1ZJRTogMTksXG4gIFdJREdFVDogMjAsXG4gIFNDUkVFTjogMjEsXG4gIFBSSU5URVJNQVJLOiAyMixcbiAgVFJBUE5FVDogMjMsXG4gIFdBVEVSTUFSSzogMjQsXG4gIFRIUkVFRDogMjUsXG4gIFJFREFDVDogMjZcbn07XG5leHBvcnRzLkFubm90YXRpb25UeXBlID0gQW5ub3RhdGlvblR5cGU7XG5jb25zdCBBbm5vdGF0aW9uUmVwbHlUeXBlID0ge1xuICBHUk9VUDogXCJHcm91cFwiLFxuICBSRVBMWTogXCJSXCJcbn07XG5leHBvcnRzLkFubm90YXRpb25SZXBseVR5cGUgPSBBbm5vdGF0aW9uUmVwbHlUeXBlO1xuY29uc3QgQW5ub3RhdGlvbkZsYWcgPSB7XG4gIElOVklTSUJMRTogMHgwMSxcbiAgSElEREVOOiAweDAyLFxuICBQUklOVDogMHgwNCxcbiAgTk9aT09NOiAweDA4LFxuICBOT1JPVEFURTogMHgxMCxcbiAgTk9WSUVXOiAweDIwLFxuICBSRUFET05MWTogMHg0MCxcbiAgTE9DS0VEOiAweDgwLFxuICBUT0dHTEVOT1ZJRVc6IDB4MTAwLFxuICBMT0NLRURDT05URU5UUzogMHgyMDBcbn07XG5leHBvcnRzLkFubm90YXRpb25GbGFnID0gQW5ub3RhdGlvbkZsYWc7XG5jb25zdCBBbm5vdGF0aW9uRmllbGRGbGFnID0ge1xuICBSRUFET05MWTogMHgwMDAwMDAxLFxuICBSRVFVSVJFRDogMHgwMDAwMDAyLFxuICBOT0VYUE9SVDogMHgwMDAwMDA0LFxuICBNVUxUSUxJTkU6IDB4MDAwMTAwMCxcbiAgUEFTU1dPUkQ6IDB4MDAwMjAwMCxcbiAgTk9UT0dHTEVUT09GRjogMHgwMDA0MDAwLFxuICBSQURJTzogMHgwMDA4MDAwLFxuICBQVVNIQlVUVE9OOiAweDAwMTAwMDAsXG4gIENPTUJPOiAweDAwMjAwMDAsXG4gIEVESVQ6IDB4MDA0MDAwMCxcbiAgU09SVDogMHgwMDgwMDAwLFxuICBGSUxFU0VMRUNUOiAweDAxMDAwMDAsXG4gIE1VTFRJU0VMRUNUOiAweDAyMDAwMDAsXG4gIERPTk9UU1BFTExDSEVDSzogMHgwNDAwMDAwLFxuICBET05PVFNDUk9MTDogMHgwODAwMDAwLFxuICBDT01COiAweDEwMDAwMDAsXG4gIFJJQ0hURVhUOiAweDIwMDAwMDAsXG4gIFJBRElPU0lOVU5JU09OOiAweDIwMDAwMDAsXG4gIENPTU1JVE9OU0VMQ0hBTkdFOiAweDQwMDAwMDBcbn07XG5leHBvcnRzLkFubm90YXRpb25GaWVsZEZsYWcgPSBBbm5vdGF0aW9uRmllbGRGbGFnO1xuY29uc3QgQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IHtcbiAgU09MSUQ6IDEsXG4gIERBU0hFRDogMixcbiAgQkVWRUxFRDogMyxcbiAgSU5TRVQ6IDQsXG4gIFVOREVSTElORTogNVxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkJvcmRlclN0eWxlVHlwZSA9IEFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGU7XG5jb25zdCBBbm5vdGF0aW9uQWN0aW9uRXZlbnRUeXBlID0ge1xuICBFOiBcIk1vdXNlIEVudGVyXCIsXG4gIFg6IFwiTW91c2UgRXhpdFwiLFxuICBEOiBcIk1vdXNlIERvd25cIixcbiAgVTogXCJNb3VzZSBVcFwiLFxuICBGbzogXCJGb2N1c1wiLFxuICBCbDogXCJCbHVyXCIsXG4gIFBPOiBcIlBhZ2VPcGVuXCIsXG4gIFBDOiBcIlBhZ2VDbG9zZVwiLFxuICBQVjogXCJQYWdlVmlzaWJsZVwiLFxuICBQSTogXCJQYWdlSW52aXNpYmxlXCIsXG4gIEs6IFwiS2V5c3Ryb2tlXCIsXG4gIEY6IFwiRm9ybWF0XCIsXG4gIFY6IFwiVmFsaWRhdGVcIixcbiAgQzogXCJDYWxjdWxhdGVcIlxufTtcbmV4cG9ydHMuQW5ub3RhdGlvbkFjdGlvbkV2ZW50VHlwZSA9IEFubm90YXRpb25BY3Rpb25FdmVudFR5cGU7XG5jb25zdCBEb2N1bWVudEFjdGlvbkV2ZW50VHlwZSA9IHtcbiAgV0M6IFwiV2lsbENsb3NlXCIsXG4gIFdTOiBcIldpbGxTYXZlXCIsXG4gIERTOiBcIkRpZFNhdmVcIixcbiAgV1A6IFwiV2lsbFByaW50XCIsXG4gIERQOiBcIkRpZFByaW50XCJcbn07XG5leHBvcnRzLkRvY3VtZW50QWN0aW9uRXZlbnRUeXBlID0gRG9jdW1lbnRBY3Rpb25FdmVudFR5cGU7XG5jb25zdCBQYWdlQWN0aW9uRXZlbnRUeXBlID0ge1xuICBPOiBcIlBhZ2VPcGVuXCIsXG4gIEM6IFwiUGFnZUNsb3NlXCJcbn07XG5leHBvcnRzLlBhZ2VBY3Rpb25FdmVudFR5cGUgPSBQYWdlQWN0aW9uRXZlbnRUeXBlO1xuY29uc3QgVmVyYm9zaXR5TGV2ZWwgPSB7XG4gIEVSUk9SUzogMCxcbiAgV0FSTklOR1M6IDEsXG4gIElORk9TOiA1XG59O1xuZXhwb3J0cy5WZXJib3NpdHlMZXZlbCA9IFZlcmJvc2l0eUxldmVsO1xuY29uc3QgQ01hcENvbXByZXNzaW9uVHlwZSA9IHtcbiAgTk9ORTogMCxcbiAgQklOQVJZOiAxXG59O1xuZXhwb3J0cy5DTWFwQ29tcHJlc3Npb25UeXBlID0gQ01hcENvbXByZXNzaW9uVHlwZTtcbmNvbnN0IE9QUyA9IHtcbiAgZGVwZW5kZW5jeTogMSxcbiAgc2V0TGluZVdpZHRoOiAyLFxuICBzZXRMaW5lQ2FwOiAzLFxuICBzZXRMaW5lSm9pbjogNCxcbiAgc2V0TWl0ZXJMaW1pdDogNSxcbiAgc2V0RGFzaDogNixcbiAgc2V0UmVuZGVyaW5nSW50ZW50OiA3LFxuICBzZXRGbGF0bmVzczogOCxcbiAgc2V0R1N0YXRlOiA5LFxuICBzYXZlOiAxMCxcbiAgcmVzdG9yZTogMTEsXG4gIHRyYW5zZm9ybTogMTIsXG4gIG1vdmVUbzogMTMsXG4gIGxpbmVUbzogMTQsXG4gIGN1cnZlVG86IDE1LFxuICBjdXJ2ZVRvMjogMTYsXG4gIGN1cnZlVG8zOiAxNyxcbiAgY2xvc2VQYXRoOiAxOCxcbiAgcmVjdGFuZ2xlOiAxOSxcbiAgc3Ryb2tlOiAyMCxcbiAgY2xvc2VTdHJva2U6IDIxLFxuICBmaWxsOiAyMixcbiAgZW9GaWxsOiAyMyxcbiAgZmlsbFN0cm9rZTogMjQsXG4gIGVvRmlsbFN0cm9rZTogMjUsXG4gIGNsb3NlRmlsbFN0cm9rZTogMjYsXG4gIGNsb3NlRU9GaWxsU3Ryb2tlOiAyNyxcbiAgZW5kUGF0aDogMjgsXG4gIGNsaXA6IDI5LFxuICBlb0NsaXA6IDMwLFxuICBiZWdpblRleHQ6IDMxLFxuICBlbmRUZXh0OiAzMixcbiAgc2V0Q2hhclNwYWNpbmc6IDMzLFxuICBzZXRXb3JkU3BhY2luZzogMzQsXG4gIHNldEhTY2FsZTogMzUsXG4gIHNldExlYWRpbmc6IDM2LFxuICBzZXRGb250OiAzNyxcbiAgc2V0VGV4dFJlbmRlcmluZ01vZGU6IDM4LFxuICBzZXRUZXh0UmlzZTogMzksXG4gIG1vdmVUZXh0OiA0MCxcbiAgc2V0TGVhZGluZ01vdmVUZXh0OiA0MSxcbiAgc2V0VGV4dE1hdHJpeDogNDIsXG4gIG5leHRMaW5lOiA0MyxcbiAgc2hvd1RleHQ6IDQ0LFxuICBzaG93U3BhY2VkVGV4dDogNDUsXG4gIG5leHRMaW5lU2hvd1RleHQ6IDQ2LFxuICBuZXh0TGluZVNldFNwYWNpbmdTaG93VGV4dDogNDcsXG4gIHNldENoYXJXaWR0aDogNDgsXG4gIHNldENoYXJXaWR0aEFuZEJvdW5kczogNDksXG4gIHNldFN0cm9rZUNvbG9yU3BhY2U6IDUwLFxuICBzZXRGaWxsQ29sb3JTcGFjZTogNTEsXG4gIHNldFN0cm9rZUNvbG9yOiA1MixcbiAgc2V0U3Ryb2tlQ29sb3JOOiA1MyxcbiAgc2V0RmlsbENvbG9yOiA1NCxcbiAgc2V0RmlsbENvbG9yTjogNTUsXG4gIHNldFN0cm9rZUdyYXk6IDU2LFxuICBzZXRGaWxsR3JheTogNTcsXG4gIHNldFN0cm9rZVJHQkNvbG9yOiA1OCxcbiAgc2V0RmlsbFJHQkNvbG9yOiA1OSxcbiAgc2V0U3Ryb2tlQ01ZS0NvbG9yOiA2MCxcbiAgc2V0RmlsbENNWUtDb2xvcjogNjEsXG4gIHNoYWRpbmdGaWxsOiA2MixcbiAgYmVnaW5JbmxpbmVJbWFnZTogNjMsXG4gIGJlZ2luSW1hZ2VEYXRhOiA2NCxcbiAgZW5kSW5saW5lSW1hZ2U6IDY1LFxuICBwYWludFhPYmplY3Q6IDY2LFxuICBtYXJrUG9pbnQ6IDY3LFxuICBtYXJrUG9pbnRQcm9wczogNjgsXG4gIGJlZ2luTWFya2VkQ29udGVudDogNjksXG4gIGJlZ2luTWFya2VkQ29udGVudFByb3BzOiA3MCxcbiAgZW5kTWFya2VkQ29udGVudDogNzEsXG4gIGJlZ2luQ29tcGF0OiA3MixcbiAgZW5kQ29tcGF0OiA3MyxcbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luOiA3NCxcbiAgcGFpbnRGb3JtWE9iamVjdEVuZDogNzUsXG4gIGJlZ2luR3JvdXA6IDc2LFxuICBlbmRHcm91cDogNzcsXG4gIGJlZ2luQW5ub3RhdGlvbjogODAsXG4gIGVuZEFubm90YXRpb246IDgxLFxuICBwYWludEltYWdlTWFza1hPYmplY3Q6IDgzLFxuICBwYWludEltYWdlTWFza1hPYmplY3RHcm91cDogODQsXG4gIHBhaW50SW1hZ2VYT2JqZWN0OiA4NSxcbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6IDg2LFxuICBwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwOiA4NyxcbiAgcGFpbnRJbWFnZVhPYmplY3RSZXBlYXQ6IDg4LFxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQ6IDg5LFxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2s6IDkwLFxuICBjb25zdHJ1Y3RQYXRoOiA5MVxufTtcbmV4cG9ydHMuT1BTID0gT1BTO1xuY29uc3QgUGFzc3dvcmRSZXNwb25zZXMgPSB7XG4gIE5FRURfUEFTU1dPUkQ6IDEsXG4gIElOQ09SUkVDVF9QQVNTV09SRDogMlxufTtcbmV4cG9ydHMuUGFzc3dvcmRSZXNwb25zZXMgPSBQYXNzd29yZFJlc3BvbnNlcztcbmxldCB2ZXJib3NpdHkgPSBWZXJib3NpdHlMZXZlbC5XQVJOSU5HUztcbmZ1bmN0aW9uIHNldFZlcmJvc2l0eUxldmVsKGxldmVsKSB7XG4gIGlmIChOdW1iZXIuaXNJbnRlZ2VyKGxldmVsKSkge1xuICAgIHZlcmJvc2l0eSA9IGxldmVsO1xuICB9XG59XG5mdW5jdGlvbiBnZXRWZXJib3NpdHlMZXZlbCgpIHtcbiAgcmV0dXJuIHZlcmJvc2l0eTtcbn1cbmZ1bmN0aW9uIGluZm8obXNnKSB7XG4gIGlmICh2ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWwuSU5GT1MpIHtcbiAgICBjb25zb2xlLmxvZyhgSW5mbzogJHttc2d9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHdhcm4obXNnKSB7XG4gIGlmICh2ZXJib3NpdHkgPj0gVmVyYm9zaXR5TGV2ZWwuV0FSTklOR1MpIHtcbiAgICBjb25zb2xlLmxvZyhgV2FybmluZzogJHttc2d9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHVucmVhY2hhYmxlKG1zZykge1xuICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbn1cbmZ1bmN0aW9uIGFzc2VydChjb25kLCBtc2cpIHtcbiAgaWYgKCFjb25kKSB7XG4gICAgdW5yZWFjaGFibGUobXNnKTtcbiAgfVxufVxuZnVuY3Rpb24gX2lzVmFsaWRQcm90b2NvbCh1cmwpIHtcbiAgc3dpdGNoICh1cmw/LnByb3RvY29sKSB7XG4gICAgY2FzZSBcImh0dHA6XCI6XG4gICAgY2FzZSBcImh0dHBzOlwiOlxuICAgIGNhc2UgXCJmdHA6XCI6XG4gICAgY2FzZSBcIm1haWx0bzpcIjpcbiAgICBjYXNlIFwidGVsOlwiOlxuICAgICAgcmV0dXJuIHRydWU7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlVmFsaWRBYnNvbHV0ZVVybCh1cmwpIHtcbiAgbGV0IGJhc2VVcmwgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gIGxldCBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuICBpZiAoIXVybCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIHRyeSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgdHlwZW9mIHVybCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgaWYgKG9wdGlvbnMuYWRkRGVmYXVsdFByb3RvY29sICYmIHVybC5zdGFydHNXaXRoKFwid3d3LlwiKSkge1xuICAgICAgICBjb25zdCBkb3RzID0gdXJsLm1hdGNoKC9cXC4vZyk7XG4gICAgICAgIGlmIChkb3RzPy5sZW5ndGggPj0gMikge1xuICAgICAgICAgIHVybCA9IGBodHRwOi8vJHt1cmx9YDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKG9wdGlvbnMudHJ5Q29udmVydEVuY29kaW5nKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdXJsID0gc3RyaW5nVG9VVEY4U3RyaW5nKHVybCk7XG4gICAgICAgIH0gY2F0Y2gge31cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgYWJzb2x1dGVVcmwgPSBiYXNlVXJsID8gbmV3IFVSTCh1cmwsIGJhc2VVcmwpIDogbmV3IFVSTCh1cmwpO1xuICAgIGlmIChfaXNWYWxpZFByb3RvY29sKGFic29sdXRlVXJsKSkge1xuICAgICAgcmV0dXJuIGFic29sdXRlVXJsO1xuICAgIH1cbiAgfSBjYXRjaCB7fVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIHNoYWRvdyhvYmosIHByb3AsIHZhbHVlKSB7XG4gIGxldCBub25TZXJpYWxpemFibGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBwcm9wLCB7XG4gICAgdmFsdWUsXG4gICAgZW51bWVyYWJsZTogIW5vblNlcmlhbGl6YWJsZSxcbiAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgd3JpdGFibGU6IGZhbHNlXG4gIH0pO1xuICByZXR1cm4gdmFsdWU7XG59XG5jb25zdCBCYXNlRXhjZXB0aW9uID0gZnVuY3Rpb24gQmFzZUV4Y2VwdGlvbkNsb3N1cmUoKSB7XG4gIGZ1bmN0aW9uIEJhc2VFeGNlcHRpb24obWVzc2FnZSwgbmFtZSkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlRXhjZXB0aW9uKSB7XG4gICAgICB1bnJlYWNoYWJsZShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VFeGNlcHRpb24uXCIpO1xuICAgIH1cbiAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gIH1cbiAgQmFzZUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBuZXcgRXJyb3IoKTtcbiAgQmFzZUV4Y2VwdGlvbi5jb25zdHJ1Y3RvciA9IEJhc2VFeGNlcHRpb247XG4gIHJldHVybiBCYXNlRXhjZXB0aW9uO1xufSgpO1xuZXhwb3J0cy5CYXNlRXhjZXB0aW9uID0gQmFzZUV4Y2VwdGlvbjtcbmNsYXNzIFBhc3N3b3JkRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgY29kZSkge1xuICAgIHN1cGVyKG1zZywgXCJQYXNzd29yZEV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmNvZGUgPSBjb2RlO1xuICB9XG59XG5leHBvcnRzLlBhc3N3b3JkRXhjZXB0aW9uID0gUGFzc3dvcmRFeGNlcHRpb247XG5jbGFzcyBVbmtub3duRXJyb3JFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnLCBkZXRhaWxzKSB7XG4gICAgc3VwZXIobXNnLCBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLmRldGFpbHMgPSBkZXRhaWxzO1xuICB9XG59XG5leHBvcnRzLlVua25vd25FcnJvckV4Y2VwdGlvbiA9IFVua25vd25FcnJvckV4Y2VwdGlvbjtcbmNsYXNzIEludmFsaWRQREZFeGNlcHRpb24gZXh0ZW5kcyBCYXNlRXhjZXB0aW9uIHtcbiAgY29uc3RydWN0b3IobXNnKSB7XG4gICAgc3VwZXIobXNnLCBcIkludmFsaWRQREZFeGNlcHRpb25cIik7XG4gIH1cbn1cbmV4cG9ydHMuSW52YWxpZFBERkV4Y2VwdGlvbiA9IEludmFsaWRQREZFeGNlcHRpb247XG5jbGFzcyBNaXNzaW5nUERGRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCIpO1xuICB9XG59XG5leHBvcnRzLk1pc3NpbmdQREZFeGNlcHRpb24gPSBNaXNzaW5nUERGRXhjZXB0aW9uO1xuY2xhc3MgVW5leHBlY3RlZFJlc3BvbnNlRXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZywgc3RhdHVzKSB7XG4gICAgc3VwZXIobXNnLCBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgfVxufVxuZXhwb3J0cy5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24gPSBVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb247XG5jbGFzcyBGb3JtYXRFcnJvciBleHRlbmRzIEJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBzdXBlcihtc2csIFwiRm9ybWF0RXJyb3JcIik7XG4gIH1cbn1cbmV4cG9ydHMuRm9ybWF0RXJyb3IgPSBGb3JtYXRFcnJvcjtcbmNsYXNzIEFib3J0RXhjZXB0aW9uIGV4dGVuZHMgQmFzZUV4Y2VwdGlvbiB7XG4gIGNvbnN0cnVjdG9yKG1zZykge1xuICAgIHN1cGVyKG1zZywgXCJBYm9ydEV4Y2VwdGlvblwiKTtcbiAgfVxufVxuZXhwb3J0cy5BYm9ydEV4Y2VwdGlvbiA9IEFib3J0RXhjZXB0aW9uO1xuZnVuY3Rpb24gYnl0ZXNUb1N0cmluZyhieXRlcykge1xuICBpZiAodHlwZW9mIGJ5dGVzICE9PSBcIm9iamVjdFwiIHx8IGJ5dGVzPy5sZW5ndGggPT09IHVuZGVmaW5lZCkge1xuICAgIHVucmVhY2hhYmxlKFwiSW52YWxpZCBhcmd1bWVudCBmb3IgYnl0ZXNUb1N0cmluZ1wiKTtcbiAgfVxuICBjb25zdCBsZW5ndGggPSBieXRlcy5sZW5ndGg7XG4gIGNvbnN0IE1BWF9BUkdVTUVOVF9DT1VOVCA9IDgxOTI7XG4gIGlmIChsZW5ndGggPCBNQVhfQVJHVU1FTlRfQ09VTlQpIHtcbiAgICByZXR1cm4gU3RyaW5nLmZyb21DaGFyQ29kZS5hcHBseShudWxsLCBieXRlcyk7XG4gIH1cbiAgY29uc3Qgc3RyQnVmID0gW107XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpICs9IE1BWF9BUkdVTUVOVF9DT1VOVCkge1xuICAgIGNvbnN0IGNodW5rRW5kID0gTWF0aC5taW4oaSArIE1BWF9BUkdVTUVOVF9DT1VOVCwgbGVuZ3RoKTtcbiAgICBjb25zdCBjaHVuayA9IGJ5dGVzLnN1YmFycmF5KGksIGNodW5rRW5kKTtcbiAgICBzdHJCdWYucHVzaChTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KG51bGwsIGNodW5rKSk7XG4gIH1cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9CeXRlcyhzdHIpIHtcbiAgaWYgKHR5cGVvZiBzdHIgIT09IFwic3RyaW5nXCIpIHtcbiAgICB1bnJlYWNoYWJsZShcIkludmFsaWQgYXJndW1lbnQgZm9yIHN0cmluZ1RvQnl0ZXNcIik7XG4gIH1cbiAgY29uc3QgbGVuZ3RoID0gc3RyLmxlbmd0aDtcbiAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW5ndGgpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgKytpKSB7XG4gICAgYnl0ZXNbaV0gPSBzdHIuY2hhckNvZGVBdChpKSAmIDB4ZmY7XG4gIH1cbiAgcmV0dXJuIGJ5dGVzO1xufVxuZnVuY3Rpb24gc3RyaW5nMzIodmFsdWUpIHtcbiAgcmV0dXJuIFN0cmluZy5mcm9tQ2hhckNvZGUodmFsdWUgPj4gMjQgJiAweGZmLCB2YWx1ZSA+PiAxNiAmIDB4ZmYsIHZhbHVlID4+IDggJiAweGZmLCB2YWx1ZSAmIDB4ZmYpO1xufVxuZnVuY3Rpb24gb2JqZWN0U2l6ZShvYmopIHtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKG9iaikubGVuZ3RoO1xufVxuZnVuY3Rpb24gb2JqZWN0RnJvbU1hcChtYXApIHtcbiAgY29uc3Qgb2JqID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbWFwKSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuICByZXR1cm4gb2JqO1xufVxuZnVuY3Rpb24gaXNMaXR0bGVFbmRpYW4oKSB7XG4gIGNvbnN0IGJ1ZmZlcjggPSBuZXcgVWludDhBcnJheSg0KTtcbiAgYnVmZmVyOFswXSA9IDE7XG4gIGNvbnN0IHZpZXczMiA9IG5ldyBVaW50MzJBcnJheShidWZmZXI4LmJ1ZmZlciwgMCwgMSk7XG4gIHJldHVybiB2aWV3MzJbMF0gPT09IDE7XG59XG5mdW5jdGlvbiBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gIHRyeSB7XG4gICAgbmV3IEZ1bmN0aW9uKFwiXCIpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbmNsYXNzIEZlYXR1cmVUZXN0IHtcbiAgc3RhdGljIGdldCBpc0xpdHRsZUVuZGlhbigpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNMaXR0bGVFbmRpYW5cIiwgaXNMaXR0bGVFbmRpYW4oKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc0V2YWxTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzRXZhbFN1cHBvcnRlZFwiLCBpc0V2YWxTdXBwb3J0ZWQoKSk7XG4gIH1cbiAgc3RhdGljIGdldCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCgpIHtcbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwiaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWRcIiwgdHlwZW9mIE9mZnNjcmVlbkNhbnZhcyAhPT0gXCJ1bmRlZmluZWRcIik7XG4gIH1cbiAgc3RhdGljIGdldCBwbGF0Zm9ybSgpIHtcbiAgICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcInBsYXRmb3JtXCIsIHtcbiAgICAgICAgaXNXaW46IGZhbHNlLFxuICAgICAgICBpc01hYzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gc2hhZG93KHRoaXMsIFwicGxhdGZvcm1cIiwge1xuICAgICAgaXNXaW46IG5hdmlnYXRvci5wbGF0Zm9ybS5pbmNsdWRlcyhcIldpblwiKSxcbiAgICAgIGlzTWFjOiBuYXZpZ2F0b3IucGxhdGZvcm0uaW5jbHVkZXMoXCJNYWNcIilcbiAgICB9KTtcbiAgfVxuICBzdGF0aWMgZ2V0IGlzQ1NTUm91bmRTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHNoYWRvdyh0aGlzLCBcImlzQ1NTUm91bmRTdXBwb3J0ZWRcIiwgZ2xvYmFsVGhpcy5DU1M/LnN1cHBvcnRzPy4oXCJ3aWR0aDogcm91bmQoMS41cHgsIDFweClcIikpO1xuICB9XG59XG5leHBvcnRzLkZlYXR1cmVUZXN0ID0gRmVhdHVyZVRlc3Q7XG5jb25zdCBoZXhOdW1iZXJzID0gWy4uLkFycmF5KDI1Nikua2V5cygpXS5tYXAobiA9PiBuLnRvU3RyaW5nKDE2KS5wYWRTdGFydCgyLCBcIjBcIikpO1xuY2xhc3MgVXRpbCB7XG4gIHN0YXRpYyBtYWtlSGV4Q29sb3IociwgZywgYikge1xuICAgIHJldHVybiBgIyR7aGV4TnVtYmVyc1tyXX0ke2hleE51bWJlcnNbZ119JHtoZXhOdW1iZXJzW2JdfWA7XG4gIH1cbiAgc3RhdGljIHNjYWxlTWluTWF4KHRyYW5zZm9ybSwgbWluTWF4KSB7XG4gICAgbGV0IHRlbXA7XG4gICAgaWYgKHRyYW5zZm9ybVswXSkge1xuICAgICAgaWYgKHRyYW5zZm9ybVswXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgICAgbWluTWF4WzBdID0gbWluTWF4WzFdO1xuICAgICAgICBtaW5NYXhbMV0gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzBdICo9IHRyYW5zZm9ybVswXTtcbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bMF07XG4gICAgICBpZiAodHJhbnNmb3JtWzNdIDwgMCkge1xuICAgICAgICB0ZW1wID0gbWluTWF4WzJdO1xuICAgICAgICBtaW5NYXhbMl0gPSBtaW5NYXhbM107XG4gICAgICAgIG1pbk1heFszXSA9IHRlbXA7XG4gICAgICB9XG4gICAgICBtaW5NYXhbMl0gKj0gdHJhbnNmb3JtWzNdO1xuICAgICAgbWluTWF4WzNdICo9IHRyYW5zZm9ybVszXTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgIG1pbk1heFswXSA9IG1pbk1heFsyXTtcbiAgICAgIG1pbk1heFsyXSA9IHRlbXA7XG4gICAgICB0ZW1wID0gbWluTWF4WzFdO1xuICAgICAgbWluTWF4WzFdID0gbWluTWF4WzNdO1xuICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIGlmICh0cmFuc2Zvcm1bMV0gPCAwKSB7XG4gICAgICAgIHRlbXAgPSBtaW5NYXhbMl07XG4gICAgICAgIG1pbk1heFsyXSA9IG1pbk1heFszXTtcbiAgICAgICAgbWluTWF4WzNdID0gdGVtcDtcbiAgICAgIH1cbiAgICAgIG1pbk1heFsyXSAqPSB0cmFuc2Zvcm1bMV07XG4gICAgICBtaW5NYXhbM10gKj0gdHJhbnNmb3JtWzFdO1xuICAgICAgaWYgKHRyYW5zZm9ybVsyXSA8IDApIHtcbiAgICAgICAgdGVtcCA9IG1pbk1heFswXTtcbiAgICAgICAgbWluTWF4WzBdID0gbWluTWF4WzFdO1xuICAgICAgICBtaW5NYXhbMV0gPSB0ZW1wO1xuICAgICAgfVxuICAgICAgbWluTWF4WzBdICo9IHRyYW5zZm9ybVsyXTtcbiAgICAgIG1pbk1heFsxXSAqPSB0cmFuc2Zvcm1bMl07XG4gICAgfVxuICAgIG1pbk1heFswXSArPSB0cmFuc2Zvcm1bNF07XG4gICAgbWluTWF4WzFdICs9IHRyYW5zZm9ybVs0XTtcbiAgICBtaW5NYXhbMl0gKz0gdHJhbnNmb3JtWzVdO1xuICAgIG1pbk1heFszXSArPSB0cmFuc2Zvcm1bNV07XG4gIH1cbiAgc3RhdGljIHRyYW5zZm9ybShtMSwgbTIpIHtcbiAgICByZXR1cm4gW20xWzBdICogbTJbMF0gKyBtMVsyXSAqIG0yWzFdLCBtMVsxXSAqIG0yWzBdICsgbTFbM10gKiBtMlsxXSwgbTFbMF0gKiBtMlsyXSArIG0xWzJdICogbTJbM10sIG0xWzFdICogbTJbMl0gKyBtMVszXSAqIG0yWzNdLCBtMVswXSAqIG0yWzRdICsgbTFbMl0gKiBtMls1XSArIG0xWzRdLCBtMVsxXSAqIG0yWzRdICsgbTFbM10gKiBtMls1XSArIG0xWzVdXTtcbiAgfVxuICBzdGF0aWMgYXBwbHlUcmFuc2Zvcm0ocCwgbSkge1xuICAgIGNvbnN0IHh0ID0gcFswXSAqIG1bMF0gKyBwWzFdICogbVsyXSArIG1bNF07XG4gICAgY29uc3QgeXQgPSBwWzBdICogbVsxXSArIHBbMV0gKiBtWzNdICsgbVs1XTtcbiAgICByZXR1cm4gW3h0LCB5dF07XG4gIH1cbiAgc3RhdGljIGFwcGx5SW52ZXJzZVRyYW5zZm9ybShwLCBtKSB7XG4gICAgY29uc3QgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgY29uc3QgeHQgPSAocFswXSAqIG1bM10gLSBwWzFdICogbVsyXSArIG1bMl0gKiBtWzVdIC0gbVs0XSAqIG1bM10pIC8gZDtcbiAgICBjb25zdCB5dCA9ICgtcFswXSAqIG1bMV0gKyBwWzFdICogbVswXSArIG1bNF0gKiBtWzFdIC0gbVs1XSAqIG1bMF0pIC8gZDtcbiAgICByZXR1cm4gW3h0LCB5dF07XG4gIH1cbiAgc3RhdGljIGdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KHIsIG0pIHtcbiAgICBjb25zdCBwMSA9IHRoaXMuYXBwbHlUcmFuc2Zvcm0ociwgbSk7XG4gICAgY29uc3QgcDIgPSB0aGlzLmFwcGx5VHJhbnNmb3JtKHIuc2xpY2UoMiwgNCksIG0pO1xuICAgIGNvbnN0IHAzID0gdGhpcy5hcHBseVRyYW5zZm9ybShbclswXSwgclszXV0sIG0pO1xuICAgIGNvbnN0IHA0ID0gdGhpcy5hcHBseVRyYW5zZm9ybShbclsyXSwgclsxXV0sIG0pO1xuICAgIHJldHVybiBbTWF0aC5taW4ocDFbMF0sIHAyWzBdLCBwM1swXSwgcDRbMF0pLCBNYXRoLm1pbihwMVsxXSwgcDJbMV0sIHAzWzFdLCBwNFsxXSksIE1hdGgubWF4KHAxWzBdLCBwMlswXSwgcDNbMF0sIHA0WzBdKSwgTWF0aC5tYXgocDFbMV0sIHAyWzFdLCBwM1sxXSwgcDRbMV0pXTtcbiAgfVxuICBzdGF0aWMgaW52ZXJzZVRyYW5zZm9ybShtKSB7XG4gICAgY29uc3QgZCA9IG1bMF0gKiBtWzNdIC0gbVsxXSAqIG1bMl07XG4gICAgcmV0dXJuIFttWzNdIC8gZCwgLW1bMV0gLyBkLCAtbVsyXSAvIGQsIG1bMF0gLyBkLCAobVsyXSAqIG1bNV0gLSBtWzRdICogbVszXSkgLyBkLCAobVs0XSAqIG1bMV0gLSBtWzVdICogbVswXSkgLyBkXTtcbiAgfVxuICBzdGF0aWMgc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobSkge1xuICAgIGNvbnN0IHRyYW5zcG9zZSA9IFttWzBdLCBtWzJdLCBtWzFdLCBtWzNdXTtcbiAgICBjb25zdCBhID0gbVswXSAqIHRyYW5zcG9zZVswXSArIG1bMV0gKiB0cmFuc3Bvc2VbMl07XG4gICAgY29uc3QgYiA9IG1bMF0gKiB0cmFuc3Bvc2VbMV0gKyBtWzFdICogdHJhbnNwb3NlWzNdO1xuICAgIGNvbnN0IGMgPSBtWzJdICogdHJhbnNwb3NlWzBdICsgbVszXSAqIHRyYW5zcG9zZVsyXTtcbiAgICBjb25zdCBkID0gbVsyXSAqIHRyYW5zcG9zZVsxXSArIG1bM10gKiB0cmFuc3Bvc2VbM107XG4gICAgY29uc3QgZmlyc3QgPSAoYSArIGQpIC8gMjtcbiAgICBjb25zdCBzZWNvbmQgPSBNYXRoLnNxcnQoKGEgKyBkKSAqKiAyIC0gNCAqIChhICogZCAtIGMgKiBiKSkgLyAyO1xuICAgIGNvbnN0IHN4ID0gZmlyc3QgKyBzZWNvbmQgfHwgMTtcbiAgICBjb25zdCBzeSA9IGZpcnN0IC0gc2Vjb25kIHx8IDE7XG4gICAgcmV0dXJuIFtNYXRoLnNxcnQoc3gpLCBNYXRoLnNxcnQoc3kpXTtcbiAgfVxuICBzdGF0aWMgbm9ybWFsaXplUmVjdChyZWN0KSB7XG4gICAgY29uc3QgciA9IHJlY3Quc2xpY2UoMCk7XG4gICAgaWYgKHJlY3RbMF0gPiByZWN0WzJdKSB7XG4gICAgICByWzBdID0gcmVjdFsyXTtcbiAgICAgIHJbMl0gPSByZWN0WzBdO1xuICAgIH1cbiAgICBpZiAocmVjdFsxXSA+IHJlY3RbM10pIHtcbiAgICAgIHJbMV0gPSByZWN0WzNdO1xuICAgICAgclszXSA9IHJlY3RbMV07XG4gICAgfVxuICAgIHJldHVybiByO1xuICB9XG4gIHN0YXRpYyBpbnRlcnNlY3QocmVjdDEsIHJlY3QyKSB7XG4gICAgY29uc3QgeExvdyA9IE1hdGgubWF4KE1hdGgubWluKHJlY3QxWzBdLCByZWN0MVsyXSksIE1hdGgubWluKHJlY3QyWzBdLCByZWN0MlsyXSkpO1xuICAgIGNvbnN0IHhIaWdoID0gTWF0aC5taW4oTWF0aC5tYXgocmVjdDFbMF0sIHJlY3QxWzJdKSwgTWF0aC5tYXgocmVjdDJbMF0sIHJlY3QyWzJdKSk7XG4gICAgaWYgKHhMb3cgPiB4SGlnaCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHlMb3cgPSBNYXRoLm1heChNYXRoLm1pbihyZWN0MVsxXSwgcmVjdDFbM10pLCBNYXRoLm1pbihyZWN0MlsxXSwgcmVjdDJbM10pKTtcbiAgICBjb25zdCB5SGlnaCA9IE1hdGgubWluKE1hdGgubWF4KHJlY3QxWzFdLCByZWN0MVszXSksIE1hdGgubWF4KHJlY3QyWzFdLCByZWN0MlszXSkpO1xuICAgIGlmICh5TG93ID4geUhpZ2gpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gW3hMb3csIHlMb3csIHhIaWdoLCB5SGlnaF07XG4gIH1cbiAgc3RhdGljIGJlemllckJvdW5kaW5nQm94KHgwLCB5MCwgeDEsIHkxLCB4MiwgeTIsIHgzLCB5Mykge1xuICAgIGNvbnN0IHR2YWx1ZXMgPSBbXSxcbiAgICAgIGJvdW5kcyA9IFtbXSwgW11dO1xuICAgIGxldCBhLCBiLCBjLCB0LCB0MSwgdDIsIGIyYWMsIHNxcnRiMmFjO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgMjsgKytpKSB7XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBiID0gNiAqIHgwIC0gMTIgKiB4MSArIDYgKiB4MjtcbiAgICAgICAgYSA9IC0zICogeDAgKyA5ICogeDEgLSA5ICogeDIgKyAzICogeDM7XG4gICAgICAgIGMgPSAzICogeDEgLSAzICogeDA7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBiID0gNiAqIHkwIC0gMTIgKiB5MSArIDYgKiB5MjtcbiAgICAgICAgYSA9IC0zICogeTAgKyA5ICogeTEgLSA5ICogeTIgKyAzICogeTM7XG4gICAgICAgIGMgPSAzICogeTEgLSAzICogeTA7XG4gICAgICB9XG4gICAgICBpZiAoTWF0aC5hYnMoYSkgPCAxZS0xMikge1xuICAgICAgICBpZiAoTWF0aC5hYnMoYikgPCAxZS0xMikge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHQgPSAtYyAvIGI7XG4gICAgICAgIGlmICgwIDwgdCAmJiB0IDwgMSkge1xuICAgICAgICAgIHR2YWx1ZXMucHVzaCh0KTtcbiAgICAgICAgfVxuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGIyYWMgPSBiICogYiAtIDQgKiBjICogYTtcbiAgICAgIHNxcnRiMmFjID0gTWF0aC5zcXJ0KGIyYWMpO1xuICAgICAgaWYgKGIyYWMgPCAwKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdDEgPSAoLWIgKyBzcXJ0YjJhYykgLyAoMiAqIGEpO1xuICAgICAgaWYgKDAgPCB0MSAmJiB0MSA8IDEpIHtcbiAgICAgICAgdHZhbHVlcy5wdXNoKHQxKTtcbiAgICAgIH1cbiAgICAgIHQyID0gKC1iIC0gc3FydGIyYWMpIC8gKDIgKiBhKTtcbiAgICAgIGlmICgwIDwgdDIgJiYgdDIgPCAxKSB7XG4gICAgICAgIHR2YWx1ZXMucHVzaCh0Mik7XG4gICAgICB9XG4gICAgfVxuICAgIGxldCBqID0gdHZhbHVlcy5sZW5ndGgsXG4gICAgICBtdDtcbiAgICBjb25zdCBqbGVuID0gajtcbiAgICB3aGlsZSAoai0tKSB7XG4gICAgICB0ID0gdHZhbHVlc1tqXTtcbiAgICAgIG10ID0gMSAtIHQ7XG4gICAgICBib3VuZHNbMF1bal0gPSBtdCAqIG10ICogbXQgKiB4MCArIDMgKiBtdCAqIG10ICogdCAqIHgxICsgMyAqIG10ICogdCAqIHQgKiB4MiArIHQgKiB0ICogdCAqIHgzO1xuICAgICAgYm91bmRzWzFdW2pdID0gbXQgKiBtdCAqIG10ICogeTAgKyAzICogbXQgKiBtdCAqIHQgKiB5MSArIDMgKiBtdCAqIHQgKiB0ICogeTIgKyB0ICogdCAqIHQgKiB5MztcbiAgICB9XG4gICAgYm91bmRzWzBdW2psZW5dID0geDA7XG4gICAgYm91bmRzWzFdW2psZW5dID0geTA7XG4gICAgYm91bmRzWzBdW2psZW4gKyAxXSA9IHgzO1xuICAgIGJvdW5kc1sxXVtqbGVuICsgMV0gPSB5MztcbiAgICBib3VuZHNbMF0ubGVuZ3RoID0gYm91bmRzWzFdLmxlbmd0aCA9IGpsZW4gKyAyO1xuICAgIHJldHVybiBbTWF0aC5taW4oLi4uYm91bmRzWzBdKSwgTWF0aC5taW4oLi4uYm91bmRzWzFdKSwgTWF0aC5tYXgoLi4uYm91bmRzWzBdKSwgTWF0aC5tYXgoLi4uYm91bmRzWzFdKV07XG4gIH1cbn1cbmV4cG9ydHMuVXRpbCA9IFV0aWw7XG5jb25zdCBQREZTdHJpbmdUcmFuc2xhdGVUYWJsZSA9IFswLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAwLCAweDJkOCwgMHgyYzcsIDB4MmM2LCAweDJkOSwgMHgyZGQsIDB4MmRiLCAweDJkYSwgMHgyZGMsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDAsIDB4MjAyMiwgMHgyMDIwLCAweDIwMjEsIDB4MjAyNiwgMHgyMDE0LCAweDIwMTMsIDB4MTkyLCAweDIwNDQsIDB4MjAzOSwgMHgyMDNhLCAweDIyMTIsIDB4MjAzMCwgMHgyMDFlLCAweDIwMWMsIDB4MjAxZCwgMHgyMDE4LCAweDIwMTksIDB4MjAxYSwgMHgyMTIyLCAweGZiMDEsIDB4ZmIwMiwgMHgxNDEsIDB4MTUyLCAweDE2MCwgMHgxNzgsIDB4MTdkLCAweDEzMSwgMHgxNDIsIDB4MTUzLCAweDE2MSwgMHgxN2UsIDAsIDB4MjBhY107XG5mdW5jdGlvbiBzdHJpbmdUb1BERlN0cmluZyhzdHIpIHtcbiAgaWYgKHN0clswXSA+PSBcIlxceEVGXCIpIHtcbiAgICBsZXQgZW5jb2Rpbmc7XG4gICAgaWYgKHN0clswXSA9PT0gXCJcXHhGRVwiICYmIHN0clsxXSA9PT0gXCJcXHhGRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2YmVcIjtcbiAgICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhGRlwiICYmIHN0clsxXSA9PT0gXCJcXHhGRVwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLTE2bGVcIjtcbiAgICB9IGVsc2UgaWYgKHN0clswXSA9PT0gXCJcXHhFRlwiICYmIHN0clsxXSA9PT0gXCJcXHhCQlwiICYmIHN0clsyXSA9PT0gXCJcXHhCRlwiKSB7XG4gICAgICBlbmNvZGluZyA9IFwidXRmLThcIjtcbiAgICB9XG4gICAgaWYgKGVuY29kaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKGVuY29kaW5nLCB7XG4gICAgICAgICAgZmF0YWw6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGJ1ZmZlciA9IHN0cmluZ1RvQnl0ZXMoc3RyKTtcbiAgICAgICAgcmV0dXJuIGRlY29kZXIuZGVjb2RlKGJ1ZmZlcik7XG4gICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICB3YXJuKGBzdHJpbmdUb1BERlN0cmluZzogXCIke2V4fVwiLmApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjb25zdCBzdHJCdWYgPSBbXTtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gc3RyLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBjb25zdCBjb2RlID0gUERGU3RyaW5nVHJhbnNsYXRlVGFibGVbc3RyLmNoYXJDb2RlQXQoaSldO1xuICAgIHN0ckJ1Zi5wdXNoKGNvZGUgPyBTdHJpbmcuZnJvbUNoYXJDb2RlKGNvZGUpIDogc3RyLmNoYXJBdChpKSk7XG4gIH1cbiAgcmV0dXJuIHN0ckJ1Zi5qb2luKFwiXCIpO1xufVxuZnVuY3Rpb24gc3RyaW5nVG9VVEY4U3RyaW5nKHN0cikge1xuICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGVzY2FwZShzdHIpKTtcbn1cbmZ1bmN0aW9uIHV0ZjhTdHJpbmdUb1N0cmluZyhzdHIpIHtcbiAgcmV0dXJuIHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChzdHIpKTtcbn1cbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodikge1xuICByZXR1cm4gdHlwZW9mIHYgPT09IFwib2JqZWN0XCIgJiYgdj8uYnl0ZUxlbmd0aCAhPT0gdW5kZWZpbmVkO1xufVxuZnVuY3Rpb24gaXNBcnJheUVxdWFsKGFycjEsIGFycjIpIHtcbiAgaWYgKGFycjEubGVuZ3RoICE9PSBhcnIyLmxlbmd0aCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBmb3IgKGxldCBpID0gMCwgaWkgPSBhcnIxLmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICBpZiAoYXJyMVtpXSAhPT0gYXJyMltpXSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIGdldE1vZGlmaWNhdGlvbkRhdGUoKSB7XG4gIGxldCBkYXRlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBuZXcgRGF0ZSgpO1xuICBjb25zdCBidWZmZXIgPSBbZGF0ZS5nZXRVVENGdWxsWWVhcigpLnRvU3RyaW5nKCksIChkYXRlLmdldFVUQ01vbnRoKCkgKyAxKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENEYXRlKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDSG91cnMoKS50b1N0cmluZygpLnBhZFN0YXJ0KDIsIFwiMFwiKSwgZGF0ZS5nZXRVVENNaW51dGVzKCkudG9TdHJpbmcoKS5wYWRTdGFydCgyLCBcIjBcIiksIGRhdGUuZ2V0VVRDU2Vjb25kcygpLnRvU3RyaW5nKCkucGFkU3RhcnQoMiwgXCIwXCIpXTtcbiAgcmV0dXJuIGJ1ZmZlci5qb2luKFwiXCIpO1xufVxuY2xhc3MgUHJvbWlzZUNhcGFiaWxpdHkge1xuICAjc2V0dGxlZCA9IGZhbHNlO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICB0aGlzLnJlc29sdmUgPSBkYXRhID0+IHtcbiAgICAgICAgdGhpcy4jc2V0dGxlZCA9IHRydWU7XG4gICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICB9O1xuICAgICAgdGhpcy5yZWplY3QgPSByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLiNzZXR0bGVkID0gdHJ1ZTtcbiAgICAgICAgcmVqZWN0KHJlYXNvbik7XG4gICAgICB9O1xuICAgIH0pO1xuICB9XG4gIGdldCBzZXR0bGVkKCkge1xuICAgIHJldHVybiB0aGlzLiNzZXR0bGVkO1xuICB9XG59XG5leHBvcnRzLlByb21pc2VDYXBhYmlsaXR5ID0gUHJvbWlzZUNhcGFiaWxpdHk7XG5sZXQgTm9ybWFsaXplUmVnZXggPSBudWxsO1xubGV0IE5vcm1hbGl6YXRpb25NYXAgPSBudWxsO1xuZnVuY3Rpb24gbm9ybWFsaXplVW5pY29kZShzdHIpIHtcbiAgaWYgKCFOb3JtYWxpemVSZWdleCkge1xuICAgIE5vcm1hbGl6ZVJlZ2V4ID0gLyhbXFx1MDBhMFxcdTAwYjVcXHUwMzdlXFx1MGViM1xcdTIwMDAtXFx1MjAwYVxcdTIwMmZcXHUyMTI2XFx1ZmIwMC1cXHVmYjA0XFx1ZmIwNlxcdWZiMjAtXFx1ZmIzNlxcdWZiMzgtXFx1ZmIzY1xcdWZiM2VcXHVmYjQwLVxcdWZiNDFcXHVmYjQzLVxcdWZiNDRcXHVmYjQ2LVxcdWZiYTFcXHVmYmE0LVxcdWZiYTlcXHVmYmFlLVxcdWZiYjFcXHVmYmQzLVxcdWZiZGNcXHVmYmRlLVxcdWZiZTdcXHVmYmVhLVxcdWZiZjhcXHVmYmZjLVxcdWZiZmRcXHVmYzAwLVxcdWZjNWRcXHVmYzY0LVxcdWZjZjFcXHVmY2Y1LVxcdWZkM2RcXHVmZDg4XFx1ZmRmNFxcdWZkZmEtXFx1ZmRmYlxcdWZlNzFcXHVmZTc3XFx1ZmU3OVxcdWZlN2JcXHVmZTdkXSspfChcXHVmYjA1KykvZ3U7XG4gICAgTm9ybWFsaXphdGlvbk1hcCA9IG5ldyBNYXAoW1tcIu+shVwiLCBcIsW/dFwiXV0pO1xuICB9XG4gIHJldHVybiBzdHIucmVwbGFjZUFsbChOb3JtYWxpemVSZWdleCwgKF8sIHAxLCBwMikgPT4ge1xuICAgIHJldHVybiBwMSA/IHAxLm5vcm1hbGl6ZShcIk5GS0NcIikgOiBOb3JtYWxpemF0aW9uTWFwLmdldChwMik7XG4gIH0pO1xufVxuZnVuY3Rpb24gZ2V0VXVpZCgpIHtcbiAgaWYgKHR5cGVvZiBjcnlwdG8gIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZW9mIGNyeXB0bz8ucmFuZG9tVVVJRCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgcmV0dXJuIGNyeXB0by5yYW5kb21VVUlEKCk7XG4gIH1cbiAgY29uc3QgYnVmID0gbmV3IFVpbnQ4QXJyYXkoMzIpO1xuICBpZiAodHlwZW9mIGNyeXB0byAhPT0gXCJ1bmRlZmluZWRcIiAmJiB0eXBlb2YgY3J5cHRvPy5nZXRSYW5kb21WYWx1ZXMgPT09IFwiZnVuY3Rpb25cIikge1xuICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXMoYnVmKTtcbiAgfSBlbHNlIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IDMyOyBpKyspIHtcbiAgICAgIGJ1ZltpXSA9IE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDI1NSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBieXRlc1RvU3RyaW5nKGJ1Zik7XG59XG5jb25zdCBBbm5vdGF0aW9uUHJlZml4ID0gXCJwZGZqc19pbnRlcm5hbF9pZF9cIjtcbmV4cG9ydHMuQW5ub3RhdGlvblByZWZpeCA9IEFubm90YXRpb25QcmVmaXg7XG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG52YXIgYXBwbHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY5KTtcbnZhciB3cmFwRXJyb3JDb25zdHJ1Y3RvcldpdGhDYXVzZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNzApO1xudmFyIFdFQl9BU1NFTUJMWSA9ICdXZWJBc3NlbWJseSc7XG52YXIgV2ViQXNzZW1ibHkgPSBnbG9iYWxbV0VCX0FTU0VNQkxZXTtcbnZhciBGT1JDRUQgPSBFcnJvcignZScsIHsgY2F1c2U6IDcgfSkuY2F1c2UgIT09IDc7XG52YXIgZXhwb3J0R2xvYmFsRXJyb3JDYXVzZVdyYXBwZXIgPSBmdW5jdGlvbiAoRVJST1JfTkFNRSwgd3JhcHBlcikge1xuIHZhciBPID0ge307XG4gT1tFUlJPUl9OQU1FXSA9IHdyYXBFcnJvckNvbnN0cnVjdG9yV2l0aENhdXNlKEVSUk9SX05BTUUsIHdyYXBwZXIsIEZPUkNFRCk7XG4gJCh7XG4gIGdsb2JhbDogdHJ1ZSxcbiAgY29uc3RydWN0b3I6IHRydWUsXG4gIGFyaXR5OiAxLFxuICBmb3JjZWQ6IEZPUkNFRFxuIH0sIE8pO1xufTtcbnZhciBleHBvcnRXZWJBc3NlbWJseUVycm9yQ2F1c2VXcmFwcGVyID0gZnVuY3Rpb24gKEVSUk9SX05BTUUsIHdyYXBwZXIpIHtcbiBpZiAoV2ViQXNzZW1ibHkgJiYgV2ViQXNzZW1ibHlbRVJST1JfTkFNRV0pIHtcbiAgdmFyIE8gPSB7fTtcbiAgT1tFUlJPUl9OQU1FXSA9IHdyYXBFcnJvckNvbnN0cnVjdG9yV2l0aENhdXNlKFdFQl9BU1NFTUJMWSArICcuJyArIEVSUk9SX05BTUUsIHdyYXBwZXIsIEZPUkNFRCk7XG4gICQoe1xuICAgdGFyZ2V0OiBXRUJfQVNTRU1CTFksXG4gICBzdGF0OiB0cnVlLFxuICAgY29uc3RydWN0b3I6IHRydWUsXG4gICBhcml0eTogMSxcbiAgIGZvcmNlZDogRk9SQ0VEXG4gIH0sIE8pO1xuIH1cbn07XG5leHBvcnRHbG9iYWxFcnJvckNhdXNlV3JhcHBlcignRXJyb3InLCBmdW5jdGlvbiAoaW5pdCkge1xuIHJldHVybiBmdW5jdGlvbiBFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBhcHBseShpbml0LCB0aGlzLCBhcmd1bWVudHMpO1xuIH07XG59KTtcbmV4cG9ydEdsb2JhbEVycm9yQ2F1c2VXcmFwcGVyKCdFdmFsRXJyb3InLCBmdW5jdGlvbiAoaW5pdCkge1xuIHJldHVybiBmdW5jdGlvbiBFdmFsRXJyb3IobWVzc2FnZSkge1xuICByZXR1cm4gYXBwbHkoaW5pdCwgdGhpcywgYXJndW1lbnRzKTtcbiB9O1xufSk7XG5leHBvcnRHbG9iYWxFcnJvckNhdXNlV3JhcHBlcignUmFuZ2VFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gcmV0dXJuIGZ1bmN0aW9uIFJhbmdlRXJyb3IobWVzc2FnZSkge1xuICByZXR1cm4gYXBwbHkoaW5pdCwgdGhpcywgYXJndW1lbnRzKTtcbiB9O1xufSk7XG5leHBvcnRHbG9iYWxFcnJvckNhdXNlV3JhcHBlcignUmVmZXJlbmNlRXJyb3InLCBmdW5jdGlvbiAoaW5pdCkge1xuIHJldHVybiBmdW5jdGlvbiBSZWZlcmVuY2VFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBhcHBseShpbml0LCB0aGlzLCBhcmd1bWVudHMpO1xuIH07XG59KTtcbmV4cG9ydEdsb2JhbEVycm9yQ2F1c2VXcmFwcGVyKCdTeW50YXhFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gcmV0dXJuIGZ1bmN0aW9uIFN5bnRheEVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7XG4gfTtcbn0pO1xuZXhwb3J0R2xvYmFsRXJyb3JDYXVzZVdyYXBwZXIoJ1R5cGVFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gcmV0dXJuIGZ1bmN0aW9uIFR5cGVFcnJvcihtZXNzYWdlKSB7XG4gIHJldHVybiBhcHBseShpbml0LCB0aGlzLCBhcmd1bWVudHMpO1xuIH07XG59KTtcbmV4cG9ydEdsb2JhbEVycm9yQ2F1c2VXcmFwcGVyKCdVUklFcnJvcicsIGZ1bmN0aW9uIChpbml0KSB7XG4gcmV0dXJuIGZ1bmN0aW9uIFVSSUVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7XG4gfTtcbn0pO1xuZXhwb3J0V2ViQXNzZW1ibHlFcnJvckNhdXNlV3JhcHBlcignQ29tcGlsZUVycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiByZXR1cm4gZnVuY3Rpb24gQ29tcGlsZUVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7XG4gfTtcbn0pO1xuZXhwb3J0V2ViQXNzZW1ibHlFcnJvckNhdXNlV3JhcHBlcignTGlua0Vycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiByZXR1cm4gZnVuY3Rpb24gTGlua0Vycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7XG4gfTtcbn0pO1xuZXhwb3J0V2ViQXNzZW1ibHlFcnJvckNhdXNlV3JhcHBlcignUnVudGltZUVycm9yJywgZnVuY3Rpb24gKGluaXQpIHtcbiByZXR1cm4gZnVuY3Rpb24gUnVudGltZUVycm9yKG1lc3NhZ2UpIHtcbiAgcmV0dXJuIGFwcGx5KGluaXQsIHRoaXMsIGFyZ3VtZW50cyk7XG4gfTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDMgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSAoX193X3BkZmpzX3JlcXVpcmVfXyg1KS5mKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ0KTtcbnZhciBkZWZpbmVCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXyg0OCk7XG52YXIgZGVmaW5lR2xvYmFsUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM4KTtcbnZhciBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Nik7XG52YXIgaXNGb3JjZWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY4KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9wdGlvbnMsIHNvdXJjZSkge1xuIHZhciBUQVJHRVQgPSBvcHRpb25zLnRhcmdldDtcbiB2YXIgR0xPQkFMID0gb3B0aW9ucy5nbG9iYWw7XG4gdmFyIFNUQVRJQyA9IG9wdGlvbnMuc3RhdDtcbiB2YXIgRk9SQ0VELCB0YXJnZXQsIGtleSwgdGFyZ2V0UHJvcGVydHksIHNvdXJjZVByb3BlcnR5LCBkZXNjcmlwdG9yO1xuIGlmIChHTE9CQUwpIHtcbiAgdGFyZ2V0ID0gZ2xvYmFsO1xuIH0gZWxzZSBpZiAoU1RBVElDKSB7XG4gIHRhcmdldCA9IGdsb2JhbFtUQVJHRVRdIHx8IGRlZmluZUdsb2JhbFByb3BlcnR5KFRBUkdFVCwge30pO1xuIH0gZWxzZSB7XG4gIHRhcmdldCA9IChnbG9iYWxbVEFSR0VUXSB8fCB7fSkucHJvdG90eXBlO1xuIH1cbiBpZiAodGFyZ2V0KVxuICBmb3IgKGtleSBpbiBzb3VyY2UpIHtcbiAgIHNvdXJjZVByb3BlcnR5ID0gc291cmNlW2tleV07XG4gICBpZiAob3B0aW9ucy5kb250Q2FsbEdldFNldCkge1xuICAgIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IodGFyZ2V0LCBrZXkpO1xuICAgIHRhcmdldFByb3BlcnR5ID0gZGVzY3JpcHRvciAmJiBkZXNjcmlwdG9yLnZhbHVlO1xuICAgfSBlbHNlXG4gICAgdGFyZ2V0UHJvcGVydHkgPSB0YXJnZXRba2V5XTtcbiAgIEZPUkNFRCA9IGlzRm9yY2VkKEdMT0JBTCA/IGtleSA6IFRBUkdFVCArIChTVEFUSUMgPyAnLicgOiAnIycpICsga2V5LCBvcHRpb25zLmZvcmNlZCk7XG4gICBpZiAoIUZPUkNFRCAmJiB0YXJnZXRQcm9wZXJ0eSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHR5cGVvZiBzb3VyY2VQcm9wZXJ0eSA9PSB0eXBlb2YgdGFyZ2V0UHJvcGVydHkpXG4gICAgIGNvbnRpbnVlO1xuICAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoc291cmNlUHJvcGVydHksIHRhcmdldFByb3BlcnR5KTtcbiAgIH1cbiAgIGlmIChvcHRpb25zLnNoYW0gfHwgdGFyZ2V0UHJvcGVydHkgJiYgdGFyZ2V0UHJvcGVydHkuc2hhbSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShzb3VyY2VQcm9wZXJ0eSwgJ3NoYW0nLCB0cnVlKTtcbiAgIH1cbiAgIGRlZmluZUJ1aWx0SW4odGFyZ2V0LCBrZXksIHNvdXJjZVByb3BlcnR5LCBvcHRpb25zKTtcbiAgfVxufTtcblxuLyoqKi8gfSksXG4vKiA0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlKSB7XG5cblxudmFyIGNoZWNrID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIGl0ICYmIGl0Lk1hdGggPT09IE1hdGggJiYgaXQ7XG59O1xubW9kdWxlLmV4cG9ydHMgPSBjaGVjayh0eXBlb2YgZ2xvYmFsVGhpcyA9PSAnb2JqZWN0JyAmJiBnbG9iYWxUaGlzKSB8fCBjaGVjayh0eXBlb2Ygd2luZG93ID09ICdvYmplY3QnICYmIHdpbmRvdykgfHwgY2hlY2sodHlwZW9mIHNlbGYgPT0gJ29iamVjdCcgJiYgc2VsZikgfHwgY2hlY2sodHlwZW9mIGdsb2JhbCA9PSAnb2JqZWN0JyAmJiBnbG9iYWwpIHx8IChmdW5jdGlvbiAoKSB7XG4gcmV0dXJuIHRoaXM7XG59KCkpIHx8IHRoaXMgfHwgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcblxuLyoqKi8gfSksXG4vKiA1ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBjYWxsID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcbnZhciBwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTApO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIpO1xudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4KTtcbnZhciBoYXNPd24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM5KTtcbnZhciBJRThfRE9NX0RFRklORSA9IF9fd19wZGZqc19yZXF1aXJlX18oNDIpO1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIDogZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApIHtcbiBPID0gdG9JbmRleGVkT2JqZWN0KE8pO1xuIFAgPSB0b1Byb3BlcnR5S2V5KFApO1xuIGlmIChJRThfRE9NX0RFRklORSlcbiAgdHJ5IHtcbiAgIHJldHVybiAkZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE8sIFApO1xuICB9IGNhdGNoIChlcnJvcikge1xuICB9XG4gaWYgKGhhc093bihPLCBQKSlcbiAgcmV0dXJuIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvcighY2FsbChwcm9wZXJ0eUlzRW51bWVyYWJsZU1vZHVsZS5mLCBPLCBQKSwgT1tQXSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDYgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcpO1xubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoe30sIDEsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gNztcbiAgfVxuIH0pWzFdICE9PSA3O1xufSk7XG5cbi8qKiovIH0pLFxuLyogNyAqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChleGVjKSB7XG4gdHJ5IHtcbiAgcmV0dXJuICEhZXhlYygpO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gIHJldHVybiB0cnVlO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogOCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBOQVRJVkVfQklORCA9IF9fd19wZGZqc19yZXF1aXJlX18oOSk7XG52YXIgY2FsbCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5jYWxsO1xubW9kdWxlLmV4cG9ydHMgPSBOQVRJVkVfQklORCA/IGNhbGwuYmluZChjYWxsKSA6IGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gY2FsbC5hcHBseShjYWxsLCBhcmd1bWVudHMpO1xufTtcblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiB2YXIgdGVzdCA9IGZ1bmN0aW9uICgpIHtcbiB9LmJpbmQoKTtcbiByZXR1cm4gdHlwZW9mIHRlc3QgIT0gJ2Z1bmN0aW9uJyB8fCB0ZXN0Lmhhc093blByb3BlcnR5KCdwcm90b3R5cGUnKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzKSA9PiB7XG5cblxudmFyICRwcm9wZXJ0eUlzRW51bWVyYWJsZSA9IHt9LnByb3BlcnR5SXNFbnVtZXJhYmxlO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgTkFTSE9STl9CVUcgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgISRwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHsgMTogMiB9LCAxKTtcbmV4cG9ydHMuZiA9IE5BU0hPUk5fQlVHID8gZnVuY3Rpb24gcHJvcGVydHlJc0VudW1lcmFibGUoVikge1xuIHZhciBkZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRoaXMsIFYpO1xuIHJldHVybiAhIWRlc2NyaXB0b3IgJiYgZGVzY3JpcHRvci5lbnVtZXJhYmxlO1xufSA6ICRwcm9wZXJ0eUlzRW51bWVyYWJsZTtcblxuLyoqKi8gfSksXG4vKiAxMSAqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChiaXRtYXAsIHZhbHVlKSB7XG4gcmV0dXJuIHtcbiAgZW51bWVyYWJsZTogIShiaXRtYXAgJiAxKSxcbiAgY29uZmlndXJhYmxlOiAhKGJpdG1hcCAmIDIpLFxuICB3cml0YWJsZTogIShiaXRtYXAgJiA0KSxcbiAgdmFsdWU6IHZhbHVlXG4gfTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTIgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xudmFyIHJlcXVpcmVPYmplY3RDb2VyY2libGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIEluZGV4ZWRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShpdCkpO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciBjbGFzc29mID0gX193X3BkZmpzX3JlcXVpcmVfXygxNSk7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbnZhciBzcGxpdCA9IHVuY3VycnlUaGlzKCcnLnNwbGl0KTtcbm1vZHVsZS5leHBvcnRzID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuIHJldHVybiAhJE9iamVjdCgneicpLnByb3BlcnR5SXNFbnVtZXJhYmxlKDApO1xufSkgPyBmdW5jdGlvbiAoaXQpIHtcbiByZXR1cm4gY2xhc3NvZihpdCkgPT09ICdTdHJpbmcnID8gc3BsaXQoaXQsICcnKSA6ICRPYmplY3QoaXQpO1xufSA6ICRPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMTQgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgTkFUSVZFX0JJTkQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDkpO1xudmFyIEZ1bmN0aW9uUHJvdG90eXBlID0gRnVuY3Rpb24ucHJvdG90eXBlO1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xudmFyIHVuY3VycnlUaGlzV2l0aEJpbmQgPSBOQVRJVkVfQklORCAmJiBGdW5jdGlvblByb3RvdHlwZS5iaW5kLmJpbmQoY2FsbCwgY2FsbCk7XG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9CSU5EID8gdW5jdXJyeVRoaXNXaXRoQmluZCA6IGZ1bmN0aW9uIChmbikge1xuIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBjYWxsLmFwcGx5KGZuLCBhcmd1bWVudHMpO1xuIH07XG59O1xuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgdG9TdHJpbmcgPSB1bmN1cnJ5VGhpcyh7fS50b1N0cmluZyk7XG52YXIgc3RyaW5nU2xpY2UgPSB1bmN1cnJ5VGhpcygnJy5zbGljZSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuIHJldHVybiBzdHJpbmdTbGljZSh0b1N0cmluZyhpdCksIDgsIC0xKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3KTtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiBpZiAoaXNOdWxsT3JVbmRlZmluZWQoaXQpKVxuICB0aHJvdyAkVHlwZUVycm9yKFwiQ2FuJ3QgY2FsbCBtZXRob2Qgb24gXCIgKyBpdCk7XG4gcmV0dXJuIGl0O1xufTtcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuIHJldHVybiBpdCA9PT0gbnVsbCB8fCBpdCA9PT0gdW5kZWZpbmVkO1xufTtcblxuLyoqKi8gfSksXG4vKiAxOCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b1ByaW1pdGl2ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTkpO1xudmFyIGlzU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXygyMyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuIHZhciBrZXkgPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ3N0cmluZycpO1xuIHJldHVybiBpc1N5bWJvbChrZXkpID8ga2V5IDoga2V5ICsgJyc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNhbGwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG52YXIgaXNTeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIzKTtcbnZhciBnZXRNZXRob2QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMwKTtcbnZhciBvcmRpbmFyeVRvUHJpbWl0aXZlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMyk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXygzNCk7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBUT19QUklNSVRJVkUgPSB3ZWxsS25vd25TeW1ib2woJ3RvUHJpbWl0aXZlJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpbnB1dCwgcHJlZikge1xuIGlmICghaXNPYmplY3QoaW5wdXQpIHx8IGlzU3ltYm9sKGlucHV0KSlcbiAgcmV0dXJuIGlucHV0O1xuIHZhciBleG90aWNUb1ByaW0gPSBnZXRNZXRob2QoaW5wdXQsIFRPX1BSSU1JVElWRSk7XG4gdmFyIHJlc3VsdDtcbiBpZiAoZXhvdGljVG9QcmltKSB7XG4gIGlmIChwcmVmID09PSB1bmRlZmluZWQpXG4gICBwcmVmID0gJ2RlZmF1bHQnO1xuICByZXN1bHQgPSBjYWxsKGV4b3RpY1RvUHJpbSwgaW5wdXQsIHByZWYpO1xuICBpZiAoIWlzT2JqZWN0KHJlc3VsdCkgfHwgaXNTeW1ib2wocmVzdWx0KSlcbiAgIHJldHVybiByZXN1bHQ7XG4gIHRocm93ICRUeXBlRXJyb3IoXCJDYW4ndCBjb252ZXJ0IG9iamVjdCB0byBwcmltaXRpdmUgdmFsdWVcIik7XG4gfVxuIGlmIChwcmVmID09PSB1bmRlZmluZWQpXG4gIHByZWYgPSAnbnVtYmVyJztcbiByZXR1cm4gb3JkaW5hcnlUb1ByaW1pdGl2ZShpbnB1dCwgcHJlZik7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzQ2FsbGFibGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciAkZG9jdW1lbnRBbGwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciBkb2N1bWVudEFsbCA9ICRkb2N1bWVudEFsbC5hbGw7XG5tb2R1bGUuZXhwb3J0cyA9ICRkb2N1bWVudEFsbC5JU19IVE1MRERBID8gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIHR5cGVvZiBpdCA9PSAnb2JqZWN0JyA/IGl0ICE9PSBudWxsIDogaXNDYWxsYWJsZShpdCkgfHwgaXQgPT09IGRvY3VtZW50QWxsO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuIHJldHVybiB0eXBlb2YgaXQgPT0gJ29iamVjdCcgPyBpdCAhPT0gbnVsbCA6IGlzQ2FsbGFibGUoaXQpO1xufTtcblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkZG9jdW1lbnRBbGwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIyKTtcbnZhciBkb2N1bWVudEFsbCA9ICRkb2N1bWVudEFsbC5hbGw7XG5tb2R1bGUuZXhwb3J0cyA9ICRkb2N1bWVudEFsbC5JU19IVE1MRERBID8gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gcmV0dXJuIHR5cGVvZiBhcmd1bWVudCA9PSAnZnVuY3Rpb24nIHx8IGFyZ3VtZW50ID09PSBkb2N1bWVudEFsbDtcbn0gOiBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiByZXR1cm4gdHlwZW9mIGFyZ3VtZW50ID09ICdmdW5jdGlvbic7XG59O1xuXG4vKioqLyB9KSxcbi8qIDIyICovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciBkb2N1bWVudEFsbCA9IHR5cGVvZiBkb2N1bWVudCA9PSAnb2JqZWN0JyAmJiBkb2N1bWVudC5hbGw7XG52YXIgSVNfSFRNTEREQSA9IHR5cGVvZiBkb2N1bWVudEFsbCA9PSAndW5kZWZpbmVkJyAmJiBkb2N1bWVudEFsbCAhPT0gdW5kZWZpbmVkO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gYWxsOiBkb2N1bWVudEFsbCxcbiBJU19IVE1MRERBOiBJU19IVE1MRERBXG59O1xuXG4vKioqLyB9KSxcbi8qIDIzICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdldEJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI0KTtcbnZhciBpc0NhbGxhYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG52YXIgaXNQcm90b3R5cGVPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xudmFyIFVTRV9TWU1CT0xfQVNfVUlEID0gX193X3BkZmpzX3JlcXVpcmVfXygyNik7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gVVNFX1NZTUJPTF9BU19VSUQgPyBmdW5jdGlvbiAoaXQpIHtcbiByZXR1cm4gdHlwZW9mIGl0ID09ICdzeW1ib2wnO1xufSA6IGZ1bmN0aW9uIChpdCkge1xuIHZhciAkU3ltYm9sID0gZ2V0QnVpbHRJbignU3ltYm9sJyk7XG4gcmV0dXJuIGlzQ2FsbGFibGUoJFN5bWJvbCkgJiYgaXNQcm90b3R5cGVPZigkU3ltYm9sLnByb3RvdHlwZSwgJE9iamVjdChpdCkpO1xufTtcblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBhRnVuY3Rpb24gPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiByZXR1cm4gaXNDYWxsYWJsZShhcmd1bWVudCkgPyBhcmd1bWVudCA6IHVuZGVmaW5lZDtcbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChuYW1lc3BhY2UsIG1ldGhvZCkge1xuIHJldHVybiBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGFGdW5jdGlvbihnbG9iYWxbbmFtZXNwYWNlXSkgOiBnbG9iYWxbbmFtZXNwYWNlXSAmJiBnbG9iYWxbbmFtZXNwYWNlXVttZXRob2RdO1xufTtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xubW9kdWxlLmV4cG9ydHMgPSB1bmN1cnJ5VGhpcyh7fS5pc1Byb3RvdHlwZU9mKTtcblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBOQVRJVkVfU1lNQk9MID0gX193X3BkZmpzX3JlcXVpcmVfXygyNyk7XG5tb2R1bGUuZXhwb3J0cyA9IE5BVElWRV9TWU1CT0wgJiYgIVN5bWJvbC5zaGFtICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT0gJ3N5bWJvbCc7XG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgVjhfVkVSU0lPTiA9IF9fd19wZGZqc19yZXF1aXJlX18oMjgpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyICRTdHJpbmcgPSBnbG9iYWwuU3RyaW5nO1xubW9kdWxlLmV4cG9ydHMgPSAhIU9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiB2YXIgc3ltYm9sID0gU3ltYm9sKCdzeW1ib2wgZGV0ZWN0aW9uJyk7XG4gcmV0dXJuICEkU3RyaW5nKHN5bWJvbCkgfHwgIShPYmplY3Qoc3ltYm9sKSBpbnN0YW5jZW9mIFN5bWJvbCkgfHwgIVN5bWJvbC5zaGFtICYmIFY4X1ZFUlNJT04gJiYgVjhfVkVSU0lPTiA8IDQxO1xufSk7XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciB1c2VyQWdlbnQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI5KTtcbnZhciBwcm9jZXNzID0gZ2xvYmFsLnByb2Nlc3M7XG52YXIgRGVubyA9IGdsb2JhbC5EZW5vO1xudmFyIHZlcnNpb25zID0gcHJvY2VzcyAmJiBwcm9jZXNzLnZlcnNpb25zIHx8IERlbm8gJiYgRGVuby52ZXJzaW9uO1xudmFyIHY4ID0gdmVyc2lvbnMgJiYgdmVyc2lvbnMudjg7XG52YXIgbWF0Y2gsIHZlcnNpb247XG5pZiAodjgpIHtcbiBtYXRjaCA9IHY4LnNwbGl0KCcuJyk7XG4gdmVyc2lvbiA9IG1hdGNoWzBdID4gMCAmJiBtYXRjaFswXSA8IDQgPyAxIDogKyhtYXRjaFswXSArIG1hdGNoWzFdKTtcbn1cbmlmICghdmVyc2lvbiAmJiB1c2VyQWdlbnQpIHtcbiBtYXRjaCA9IHVzZXJBZ2VudC5tYXRjaCgvRWRnZVxcLyhcXGQrKS8pO1xuIGlmICghbWF0Y2ggfHwgbWF0Y2hbMV0gPj0gNzQpIHtcbiAgbWF0Y2ggPSB1c2VyQWdlbnQubWF0Y2goL0Nocm9tZVxcLyhcXGQrKS8pO1xuICBpZiAobWF0Y2gpXG4gICB2ZXJzaW9uID0gK21hdGNoWzFdO1xuIH1cbn1cbm1vZHVsZS5leHBvcnRzID0gdmVyc2lvbjtcblxuLyoqKi8gfSksXG4vKiAyOSAqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT0gJ3VuZGVmaW5lZCcgJiYgU3RyaW5nKG5hdmlnYXRvci51c2VyQWdlbnQpIHx8ICcnO1xuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFDYWxsYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzEpO1xudmFyIGlzTnVsbE9yVW5kZWZpbmVkID0gX193X3BkZmpzX3JlcXVpcmVfXygxNyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChWLCBQKSB7XG4gdmFyIGZ1bmMgPSBWW1BdO1xuIHJldHVybiBpc051bGxPclVuZGVmaW5lZChmdW5jKSA/IHVuZGVmaW5lZCA6IGFDYWxsYWJsZShmdW5jKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMzEgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXNDYWxsYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xudmFyIHRyeVRvU3RyaW5nID0gX193X3BkZmpzX3JlcXVpcmVfXygzMik7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gaWYgKGlzQ2FsbGFibGUoYXJndW1lbnQpKVxuICByZXR1cm4gYXJndW1lbnQ7XG4gdGhyb3cgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhhcmd1bWVudCkgKyAnIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDMyICovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciAkU3RyaW5nID0gU3RyaW5nO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiB0cnkge1xuICByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgcmV0dXJuICdPYmplY3QnO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMzMgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2FsbCA9IF9fd19wZGZqc19yZXF1aXJlX18oOCk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGlucHV0LCBwcmVmKSB7XG4gdmFyIGZuLCB2YWw7XG4gaWYgKHByZWYgPT09ICdzdHJpbmcnICYmIGlzQ2FsbGFibGUoZm4gPSBpbnB1dC50b1N0cmluZykgJiYgIWlzT2JqZWN0KHZhbCA9IGNhbGwoZm4sIGlucHV0KSkpXG4gIHJldHVybiB2YWw7XG4gaWYgKGlzQ2FsbGFibGUoZm4gPSBpbnB1dC52YWx1ZU9mKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSlcbiAgcmV0dXJuIHZhbDtcbiBpZiAocHJlZiAhPT0gJ3N0cmluZycgJiYgaXNDYWxsYWJsZShmbiA9IGlucHV0LnRvU3RyaW5nKSAmJiAhaXNPYmplY3QodmFsID0gY2FsbChmbiwgaW5wdXQpKSlcbiAgcmV0dXJuIHZhbDtcbiB0aHJvdyAkVHlwZUVycm9yKFwiQ2FuJ3QgY29udmVydCBvYmplY3QgdG8gcHJpbWl0aXZlIHZhbHVlXCIpO1xufTtcblxuLyoqKi8gfSksXG4vKiAzNCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIHNoYXJlZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzUpO1xudmFyIGhhc093biA9IF9fd19wZGZqc19yZXF1aXJlX18oMzkpO1xudmFyIHVpZCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDEpO1xudmFyIE5BVElWRV9TWU1CT0wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI3KTtcbnZhciBVU0VfU1lNQk9MX0FTX1VJRCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjYpO1xudmFyIFN5bWJvbCA9IGdsb2JhbC5TeW1ib2w7XG52YXIgV2VsbEtub3duU3ltYm9sc1N0b3JlID0gc2hhcmVkKCd3a3MnKTtcbnZhciBjcmVhdGVXZWxsS25vd25TeW1ib2wgPSBVU0VfU1lNQk9MX0FTX1VJRCA/IFN5bWJvbFsnZm9yJ10gfHwgU3ltYm9sIDogU3ltYm9sICYmIFN5bWJvbC53aXRob3V0U2V0dGVyIHx8IHVpZDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG5hbWUpIHtcbiBpZiAoIWhhc093bihXZWxsS25vd25TeW1ib2xzU3RvcmUsIG5hbWUpKSB7XG4gIFdlbGxLbm93blN5bWJvbHNTdG9yZVtuYW1lXSA9IE5BVElWRV9TWU1CT0wgJiYgaGFzT3duKFN5bWJvbCwgbmFtZSkgPyBTeW1ib2xbbmFtZV0gOiBjcmVhdGVXZWxsS25vd25TeW1ib2woJ1N5bWJvbC4nICsgbmFtZSk7XG4gfVxuIHJldHVybiBXZWxsS25vd25TeW1ib2xzU3RvcmVbbmFtZV07XG59O1xuXG4vKioqLyB9KSxcbi8qIDM1ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIElTX1BVUkUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM2KTtcbnZhciBzdG9yZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzcpO1xuKG1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiByZXR1cm4gc3RvcmVba2V5XSB8fCAoc3RvcmVba2V5XSA9IHZhbHVlICE9PSB1bmRlZmluZWQgPyB2YWx1ZSA6IHt9KTtcbn0pKCd2ZXJzaW9ucycsIFtdKS5wdXNoKHtcbiB2ZXJzaW9uOiAnMy4zMi4yJyxcbiBtb2RlOiBJU19QVVJFID8gJ3B1cmUnIDogJ2dsb2JhbCcsXG4gY29weXJpZ2h0OiAnwqkgMjAxNC0yMDIzIERlbmlzIFB1c2hrYXJldiAoemxvaXJvY2sucnUpJyxcbiBsaWNlbnNlOiAnaHR0cHM6Ly9naXRodWIuY29tL3psb2lyb2NrL2NvcmUtanMvYmxvYi92My4zMi4yL0xJQ0VOU0UnLFxuIHNvdXJjZTogJ2h0dHBzOi8vZ2l0aHViLmNvbS96bG9pcm9jay9jb3JlLWpzJ1xufSk7XG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmYWxzZTtcblxuLyoqKi8gfSksXG4vKiAzNyAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygzOCk7XG52YXIgU0hBUkVEID0gJ19fY29yZS1qc19zaGFyZWRfXyc7XG52YXIgc3RvcmUgPSBnbG9iYWxbU0hBUkVEXSB8fCBkZWZpbmVHbG9iYWxQcm9wZXJ0eShTSEFSRUQsIHt9KTtcbm1vZHVsZS5leHBvcnRzID0gc3RvcmU7XG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiB0cnkge1xuICBkZWZpbmVQcm9wZXJ0eShnbG9iYWwsIGtleSwge1xuICAgdmFsdWU6IHZhbHVlLFxuICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgd3JpdGFibGU6IHRydWVcbiAgfSk7XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgZ2xvYmFsW2tleV0gPSB2YWx1ZTtcbiB9XG4gcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqKi8gfSksXG4vKiAzOSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIHRvT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0MCk7XG52YXIgaGFzT3duUHJvcGVydHkgPSB1bmN1cnJ5VGhpcyh7fS5oYXNPd25Qcm9wZXJ0eSk7XG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5oYXNPd24gfHwgZnVuY3Rpb24gaGFzT3duKGl0LCBrZXkpIHtcbiByZXR1cm4gaGFzT3duUHJvcGVydHkodG9PYmplY3QoaXQpLCBrZXkpO1xufTtcblxuLyoqKi8gfSksXG4vKiA0MCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciByZXF1aXJlT2JqZWN0Q29lcmNpYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxNik7XG52YXIgJE9iamVjdCA9IE9iamVjdDtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gcmV0dXJuICRPYmplY3QocmVxdWlyZU9iamVjdENvZXJjaWJsZShhcmd1bWVudCkpO1xufTtcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIGlkID0gMDtcbnZhciBwb3N0Zml4ID0gTWF0aC5yYW5kb20oKTtcbnZhciB0b1N0cmluZyA9IHVuY3VycnlUaGlzKDEuMC50b1N0cmluZyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiByZXR1cm4gJ1N5bWJvbCgnICsgKGtleSA9PT0gdW5kZWZpbmVkID8gJycgOiBrZXkpICsgJylfJyArIHRvU3RyaW5nKCsraWQgKyBwb3N0Zml4LCAzNik7XG59O1xuXG4vKioqLyB9KSxcbi8qIDQyICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG52YXIgY3JlYXRlRWxlbWVudCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDMpO1xubW9kdWxlLmV4cG9ydHMgPSAhREVTQ1JJUFRPUlMgJiYgIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiByZXR1cm4gT2JqZWN0LmRlZmluZVByb3BlcnR5KGNyZWF0ZUVsZW1lbnQoJ2RpdicpLCAnYScsIHtcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gNztcbiAgfVxuIH0pLmEgIT09IDc7XG59KTtcblxuLyoqKi8gfSksXG4vKiA0MyAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG52YXIgZG9jdW1lbnQgPSBnbG9iYWwuZG9jdW1lbnQ7XG52YXIgRVhJU1RTID0gaXNPYmplY3QoZG9jdW1lbnQpICYmIGlzT2JqZWN0KGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiByZXR1cm4gRVhJU1RTID8gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChpdCkgOiB7fTtcbn07XG5cbi8qKiovIH0pLFxuLyogNDQgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXyg0NSk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG5tb2R1bGUuZXhwb3J0cyA9IERFU0NSSVBUT1JTID8gZnVuY3Rpb24gKG9iamVjdCwga2V5LCB2YWx1ZSkge1xuIHJldHVybiBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKG9iamVjdCwga2V5LCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoMSwgdmFsdWUpKTtcbn0gOiBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gb2JqZWN0W2tleV0gPSB2YWx1ZTtcbiByZXR1cm4gb2JqZWN0O1xufTtcblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgSUU4X0RPTV9ERUZJTkUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQyKTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IF9fd19wZGZqc19yZXF1aXJlX18oNDYpO1xudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Nyk7XG52YXIgdG9Qcm9wZXJ0eUtleSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTgpO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgJGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5O1xudmFyICRnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIEVOVU1FUkFCTEUgPSAnZW51bWVyYWJsZSc7XG52YXIgQ09ORklHVVJBQkxFID0gJ2NvbmZpZ3VyYWJsZSc7XG52YXIgV1JJVEFCTEUgPSAnd3JpdGFibGUnO1xuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgPyBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA/IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiBhbk9iamVjdChPKTtcbiBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiBpZiAodHlwZW9mIE8gPT09ICdmdW5jdGlvbicgJiYgUCA9PT0gJ3Byb3RvdHlwZScgJiYgJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzICYmIFdSSVRBQkxFIGluIEF0dHJpYnV0ZXMgJiYgIUF0dHJpYnV0ZXNbV1JJVEFCTEVdKSB7XG4gIHZhciBjdXJyZW50ID0gJGdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCBQKTtcbiAgaWYgKGN1cnJlbnQgJiYgY3VycmVudFtXUklUQUJMRV0pIHtcbiAgIE9bUF0gPSBBdHRyaWJ1dGVzLnZhbHVlO1xuICAgQXR0cmlidXRlcyA9IHtcbiAgICBjb25maWd1cmFibGU6IENPTkZJR1VSQUJMRSBpbiBBdHRyaWJ1dGVzID8gQXR0cmlidXRlc1tDT05GSUdVUkFCTEVdIDogY3VycmVudFtDT05GSUdVUkFCTEVdLFxuICAgIGVudW1lcmFibGU6IEVOVU1FUkFCTEUgaW4gQXR0cmlidXRlcyA/IEF0dHJpYnV0ZXNbRU5VTUVSQUJMRV0gOiBjdXJyZW50W0VOVU1FUkFCTEVdLFxuICAgIHdyaXRhYmxlOiBmYWxzZVxuICAgfTtcbiAgfVxuIH1cbiByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xufSA6ICRkZWZpbmVQcm9wZXJ0eSA6IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpIHtcbiBhbk9iamVjdChPKTtcbiBQID0gdG9Qcm9wZXJ0eUtleShQKTtcbiBhbk9iamVjdChBdHRyaWJ1dGVzKTtcbiBpZiAoSUU4X0RPTV9ERUZJTkUpXG4gIHRyeSB7XG4gICByZXR1cm4gJGRlZmluZVByb3BlcnR5KE8sIFAsIEF0dHJpYnV0ZXMpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICB9XG4gaWYgKCdnZXQnIGluIEF0dHJpYnV0ZXMgfHwgJ3NldCcgaW4gQXR0cmlidXRlcylcbiAgdGhyb3cgJFR5cGVFcnJvcignQWNjZXNzb3JzIG5vdCBzdXBwb3J0ZWQnKTtcbiBpZiAoJ3ZhbHVlJyBpbiBBdHRyaWJ1dGVzKVxuICBPW1BdID0gQXR0cmlidXRlcy52YWx1ZTtcbiByZXR1cm4gTztcbn07XG5cbi8qKiovIH0pLFxuLyogNDYgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbm1vZHVsZS5leHBvcnRzID0gREVTQ1JJUFRPUlMgJiYgZmFpbHMoZnVuY3Rpb24gKCkge1xuIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZnVuY3Rpb24gKCkge1xuIH0sICdwcm90b3R5cGUnLCB7XG4gIHZhbHVlOiA0MixcbiAgd3JpdGFibGU6IGZhbHNlXG4gfSkucHJvdG90eXBlICE9PSA0Mjtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDQ3ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiBpZiAoaXNPYmplY3QoYXJndW1lbnQpKVxuICByZXR1cm4gYXJndW1lbnQ7XG4gdGhyb3cgJFR5cGVFcnJvcigkU3RyaW5nKGFyZ3VtZW50KSArICcgaXMgbm90IGFuIG9iamVjdCcpO1xufTtcblxuLyoqKi8gfSksXG4vKiA0OCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpc0NhbGxhYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ1KTtcbnZhciBtYWtlQnVpbHRJbiA9IF9fd19wZGZqc19yZXF1aXJlX18oNDkpO1xudmFyIGRlZmluZUdsb2JhbFByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygzOCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChPLCBrZXksIHZhbHVlLCBvcHRpb25zKSB7XG4gaWYgKCFvcHRpb25zKVxuICBvcHRpb25zID0ge307XG4gdmFyIHNpbXBsZSA9IG9wdGlvbnMuZW51bWVyYWJsZTtcbiB2YXIgbmFtZSA9IG9wdGlvbnMubmFtZSAhPT0gdW5kZWZpbmVkID8gb3B0aW9ucy5uYW1lIDoga2V5O1xuIGlmIChpc0NhbGxhYmxlKHZhbHVlKSlcbiAgbWFrZUJ1aWx0SW4odmFsdWUsIG5hbWUsIG9wdGlvbnMpO1xuIGlmIChvcHRpb25zLmdsb2JhbCkge1xuICBpZiAoc2ltcGxlKVxuICAgT1trZXldID0gdmFsdWU7XG4gIGVsc2VcbiAgIGRlZmluZUdsb2JhbFByb3BlcnR5KGtleSwgdmFsdWUpO1xuIH0gZWxzZSB7XG4gIHRyeSB7XG4gICBpZiAoIW9wdGlvbnMudW5zYWZlKVxuICAgIGRlbGV0ZSBPW2tleV07XG4gICBlbHNlIGlmIChPW2tleV0pXG4gICAgc2ltcGxlID0gdHJ1ZTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgfVxuICBpZiAoc2ltcGxlKVxuICAgT1trZXldID0gdmFsdWU7XG4gIGVsc2VcbiAgIGRlZmluZVByb3BlcnR5TW9kdWxlLmYoTywga2V5LCB7XG4gICAgdmFsdWU6IHZhbHVlLFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgIGNvbmZpZ3VyYWJsZTogIW9wdGlvbnMubm9uQ29uZmlndXJhYmxlLFxuICAgIHdyaXRhYmxlOiAhb3B0aW9ucy5ub25Xcml0YWJsZVxuICAgfSk7XG4gfVxuIHJldHVybiBPO1xufTtcblxuLyoqKi8gfSksXG4vKiA0OSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciBpc0NhbGxhYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG52YXIgaGFzT3duID0gX193X3BkZmpzX3JlcXVpcmVfXygzOSk7XG52YXIgREVTQ1JJUFRPUlMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYpO1xudmFyIENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FID0gKF9fd19wZGZqc19yZXF1aXJlX18oNTApLkNPTkZJR1VSQUJMRSk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNTEpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUyKTtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciBkZWZpbmVQcm9wZXJ0eSA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBzdHJpbmdTbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcbnZhciByZXBsYWNlID0gdW5jdXJyeVRoaXMoJycucmVwbGFjZSk7XG52YXIgam9pbiA9IHVuY3VycnlUaGlzKFtdLmpvaW4pO1xudmFyIENPTkZJR1VSQUJMRV9MRU5HVEggPSBERVNDUklQVE9SUyAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuIHJldHVybiBkZWZpbmVQcm9wZXJ0eShmdW5jdGlvbiAoKSB7XG4gfSwgJ2xlbmd0aCcsIHsgdmFsdWU6IDggfSkubGVuZ3RoICE9PSA4O1xufSk7XG52YXIgVEVNUExBVEUgPSBTdHJpbmcoU3RyaW5nKS5zcGxpdCgnU3RyaW5nJyk7XG52YXIgbWFrZUJ1aWx0SW4gPSBtb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh2YWx1ZSwgbmFtZSwgb3B0aW9ucykge1xuIGlmIChzdHJpbmdTbGljZSgkU3RyaW5nKG5hbWUpLCAwLCA3KSA9PT0gJ1N5bWJvbCgnKSB7XG4gIG5hbWUgPSAnWycgKyByZXBsYWNlKCRTdHJpbmcobmFtZSksIC9eU3ltYm9sXFwoKFteKV0qKVxcKS8sICckMScpICsgJ10nO1xuIH1cbiBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmdldHRlcilcbiAgbmFtZSA9ICdnZXQgJyArIG5hbWU7XG4gaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5zZXR0ZXIpXG4gIG5hbWUgPSAnc2V0ICcgKyBuYW1lO1xuIGlmICghaGFzT3duKHZhbHVlLCAnbmFtZScpIHx8IENPTkZJR1VSQUJMRV9GVU5DVElPTl9OQU1FICYmIHZhbHVlLm5hbWUgIT09IG5hbWUpIHtcbiAgaWYgKERFU0NSSVBUT1JTKVxuICAgZGVmaW5lUHJvcGVydHkodmFsdWUsICduYW1lJywge1xuICAgIHZhbHVlOiBuYW1lLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgfSk7XG4gIGVsc2VcbiAgIHZhbHVlLm5hbWUgPSBuYW1lO1xuIH1cbiBpZiAoQ09ORklHVVJBQkxFX0xFTkdUSCAmJiBvcHRpb25zICYmIGhhc093bihvcHRpb25zLCAnYXJpdHknKSAmJiB2YWx1ZS5sZW5ndGggIT09IG9wdGlvbnMuYXJpdHkpIHtcbiAgZGVmaW5lUHJvcGVydHkodmFsdWUsICdsZW5ndGgnLCB7IHZhbHVlOiBvcHRpb25zLmFyaXR5IH0pO1xuIH1cbiB0cnkge1xuICBpZiAob3B0aW9ucyAmJiBoYXNPd24ob3B0aW9ucywgJ2NvbnN0cnVjdG9yJykgJiYgb3B0aW9ucy5jb25zdHJ1Y3Rvcikge1xuICAgaWYgKERFU0NSSVBUT1JTKVxuICAgIGRlZmluZVByb3BlcnR5KHZhbHVlLCAncHJvdG90eXBlJywgeyB3cml0YWJsZTogZmFsc2UgfSk7XG4gIH0gZWxzZSBpZiAodmFsdWUucHJvdG90eXBlKVxuICAgdmFsdWUucHJvdG90eXBlID0gdW5kZWZpbmVkO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gfVxuIHZhciBzdGF0ZSA9IGVuZm9yY2VJbnRlcm5hbFN0YXRlKHZhbHVlKTtcbiBpZiAoIWhhc093bihzdGF0ZSwgJ3NvdXJjZScpKSB7XG4gIHN0YXRlLnNvdXJjZSA9IGpvaW4oVEVNUExBVEUsIHR5cGVvZiBuYW1lID09ICdzdHJpbmcnID8gbmFtZSA6ICcnKTtcbiB9XG4gcmV0dXJuIHZhbHVlO1xufTtcbkZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZyA9IG1ha2VCdWlsdEluKGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuIHJldHVybiBpc0NhbGxhYmxlKHRoaXMpICYmIGdldEludGVybmFsU3RhdGUodGhpcykuc291cmNlIHx8IGluc3BlY3RTb3VyY2UodGhpcyk7XG59LCAndG9TdHJpbmcnKTtcblxuLyoqKi8gfSksXG4vKiA1MCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgaGFzT3duID0gX193X3BkZmpzX3JlcXVpcmVfXygzOSk7XG52YXIgRnVuY3Rpb25Qcm90b3R5cGUgPSBGdW5jdGlvbi5wcm90b3R5cGU7XG52YXIgZ2V0RGVzY3JpcHRvciA9IERFU0NSSVBUT1JTICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3I7XG52YXIgRVhJU1RTID0gaGFzT3duKEZ1bmN0aW9uUHJvdG90eXBlLCAnbmFtZScpO1xudmFyIFBST1BFUiA9IEVYSVNUUyAmJiBmdW5jdGlvbiBzb21ldGhpbmcoKSB7XG59Lm5hbWUgPT09ICdzb21ldGhpbmcnO1xudmFyIENPTkZJR1VSQUJMRSA9IEVYSVNUUyAmJiAoIURFU0NSSVBUT1JTIHx8IERFU0NSSVBUT1JTICYmIGdldERlc2NyaXB0b3IoRnVuY3Rpb25Qcm90b3R5cGUsICduYW1lJykuY29uZmlndXJhYmxlKTtcbm1vZHVsZS5leHBvcnRzID0ge1xuIEVYSVNUUzogRVhJU1RTLFxuIFBST1BFUjogUFJPUEVSLFxuIENPTkZJR1VSQUJMRTogQ09ORklHVVJBQkxFXG59O1xuXG4vKioqLyB9KSxcbi8qIDUxICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xudmFyIHN0b3JlID0gX193X3BkZmpzX3JlcXVpcmVfXygzNyk7XG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IHVuY3VycnlUaGlzKEZ1bmN0aW9uLnRvU3RyaW5nKTtcbmlmICghaXNDYWxsYWJsZShzdG9yZS5pbnNwZWN0U291cmNlKSkge1xuIHN0b3JlLmluc3BlY3RTb3VyY2UgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uVG9TdHJpbmcoaXQpO1xuIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHN0b3JlLmluc3BlY3RTb3VyY2U7XG5cbi8qKiovIH0pLFxuLyogNTIgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgTkFUSVZFX1dFQUtfTUFQID0gX193X3BkZmpzX3JlcXVpcmVfXyg1Myk7XG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oNDQpO1xudmFyIGhhc093biA9IF9fd19wZGZqc19yZXF1aXJlX18oMzkpO1xudmFyIHNoYXJlZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzcpO1xudmFyIHNoYXJlZEtleSA9IF9fd19wZGZqc19yZXF1aXJlX18oNTQpO1xudmFyIGhpZGRlbktleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU1KTtcbnZhciBPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCA9ICdPYmplY3QgYWxyZWFkeSBpbml0aWFsaXplZCc7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBXZWFrTWFwID0gZ2xvYmFsLldlYWtNYXA7XG52YXIgc2V0LCBnZXQsIGhhcztcbnZhciBlbmZvcmNlID0gZnVuY3Rpb24gKGl0KSB7XG4gcmV0dXJuIGhhcyhpdCkgPyBnZXQoaXQpIDogc2V0KGl0LCB7fSk7XG59O1xudmFyIGdldHRlckZvciA9IGZ1bmN0aW9uIChUWVBFKSB7XG4gcmV0dXJuIGZ1bmN0aW9uIChpdCkge1xuICB2YXIgc3RhdGU7XG4gIGlmICghaXNPYmplY3QoaXQpIHx8IChzdGF0ZSA9IGdldChpdCkpLnR5cGUgIT09IFRZUEUpIHtcbiAgIHRocm93IFR5cGVFcnJvcignSW5jb21wYXRpYmxlIHJlY2VpdmVyLCAnICsgVFlQRSArICcgcmVxdWlyZWQnKTtcbiAgfVxuICByZXR1cm4gc3RhdGU7XG4gfTtcbn07XG5pZiAoTkFUSVZFX1dFQUtfTUFQIHx8IHNoYXJlZC5zdGF0ZSkge1xuIHZhciBzdG9yZSA9IHNoYXJlZC5zdGF0ZSB8fCAoc2hhcmVkLnN0YXRlID0gbmV3IFdlYWtNYXAoKSk7XG4gc3RvcmUuZ2V0ID0gc3RvcmUuZ2V0O1xuIHN0b3JlLmhhcyA9IHN0b3JlLmhhcztcbiBzdG9yZS5zZXQgPSBzdG9yZS5zZXQ7XG4gc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICBpZiAoc3RvcmUuaGFzKGl0KSlcbiAgIHRocm93IFR5cGVFcnJvcihPQkpFQ1RfQUxSRUFEWV9JTklUSUFMSVpFRCk7XG4gIG1ldGFkYXRhLmZhY2FkZSA9IGl0O1xuICBzdG9yZS5zZXQoaXQsIG1ldGFkYXRhKTtcbiAgcmV0dXJuIG1ldGFkYXRhO1xuIH07XG4gZ2V0ID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdG9yZS5nZXQoaXQpIHx8IHt9O1xuIH07XG4gaGFzID0gZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBzdG9yZS5oYXMoaXQpO1xuIH07XG59IGVsc2Uge1xuIHZhciBTVEFURSA9IHNoYXJlZEtleSgnc3RhdGUnKTtcbiBoaWRkZW5LZXlzW1NUQVRFXSA9IHRydWU7XG4gc2V0ID0gZnVuY3Rpb24gKGl0LCBtZXRhZGF0YSkge1xuICBpZiAoaGFzT3duKGl0LCBTVEFURSkpXG4gICB0aHJvdyBUeXBlRXJyb3IoT0JKRUNUX0FMUkVBRFlfSU5JVElBTElaRUQpO1xuICBtZXRhZGF0YS5mYWNhZGUgPSBpdDtcbiAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KGl0LCBTVEFURSwgbWV0YWRhdGEpO1xuICByZXR1cm4gbWV0YWRhdGE7XG4gfTtcbiBnZXQgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpID8gaXRbU1RBVEVdIDoge307XG4gfTtcbiBoYXMgPSBmdW5jdGlvbiAoaXQpIHtcbiAgcmV0dXJuIGhhc093bihpdCwgU1RBVEUpO1xuIH07XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiBzZXQ6IHNldCxcbiBnZXQ6IGdldCxcbiBoYXM6IGhhcyxcbiBlbmZvcmNlOiBlbmZvcmNlLFxuIGdldHRlckZvcjogZ2V0dGVyRm9yXG59O1xuXG4vKioqLyB9KSxcbi8qIDUzICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGdsb2JhbCA9IF9fd19wZGZqc19yZXF1aXJlX18oNCk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xudmFyIFdlYWtNYXAgPSBnbG9iYWwuV2Vha01hcDtcbm1vZHVsZS5leHBvcnRzID0gaXNDYWxsYWJsZShXZWFrTWFwKSAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoU3RyaW5nKFdlYWtNYXApKTtcblxuLyoqKi8gfSksXG4vKiA1NCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBzaGFyZWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM1KTtcbnZhciB1aWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQxKTtcbnZhciBrZXlzID0gc2hhcmVkKCdrZXlzJyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiByZXR1cm4ga2V5c1trZXldIHx8IChrZXlzW2tleV0gPSB1aWQoa2V5KSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiovIH0pLFxuLyogNTYgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaGFzT3duID0gX193X3BkZmpzX3JlcXVpcmVfXygzOSk7XG52YXIgb3duS2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNTcpO1xudmFyIGdldE93blByb3BlcnR5RGVzY3JpcHRvck1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNSk7XG52YXIgZGVmaW5lUHJvcGVydHlNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ1KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKHRhcmdldCwgc291cmNlLCBleGNlcHRpb25zKSB7XG4gdmFyIGtleXMgPSBvd25LZXlzKHNvdXJjZSk7XG4gdmFyIGRlZmluZVByb3BlcnR5ID0gZGVmaW5lUHJvcGVydHlNb2R1bGUuZjtcbiB2YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yTW9kdWxlLmY7XG4gZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gIHZhciBrZXkgPSBrZXlzW2ldO1xuICBpZiAoIWhhc093bih0YXJnZXQsIGtleSkgJiYgIShleGNlcHRpb25zICYmIGhhc093bihleGNlcHRpb25zLCBrZXkpKSkge1xuICAgZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIGdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICB9XG4gfVxufTtcblxuLyoqKi8gfSksXG4vKiA1NyAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXyg1OCk7XG52YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Nyk7XG52YXIgYW5PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ3KTtcbnZhciBjb25jYXQgPSB1bmN1cnJ5VGhpcyhbXS5jb25jYXQpO1xubW9kdWxlLmV4cG9ydHMgPSBnZXRCdWlsdEluKCdSZWZsZWN0JywgJ293bktleXMnKSB8fCBmdW5jdGlvbiBvd25LZXlzKGl0KSB7XG4gdmFyIGtleXMgPSBnZXRPd25Qcm9wZXJ0eU5hbWVzTW9kdWxlLmYoYW5PYmplY3QoaXQpKTtcbiB2YXIgZ2V0T3duUHJvcGVydHlTeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzTW9kdWxlLmY7XG4gcmV0dXJuIGdldE93blByb3BlcnR5U3ltYm9scyA/IGNvbmNhdChrZXlzLCBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMoaXQpKSA6IGtleXM7XG59O1xuXG4vKioqLyB9KSxcbi8qIDU4ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGludGVybmFsT2JqZWN0S2V5cyA9IF9fd19wZGZqc19yZXF1aXJlX18oNTkpO1xudmFyIGVudW1CdWdLZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Nik7XG52YXIgaGlkZGVuS2V5cyA9IGVudW1CdWdLZXlzLmNvbmNhdCgnbGVuZ3RoJywgJ3Byb3RvdHlwZScpO1xuZXhwb3J0cy5mID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMgfHwgZnVuY3Rpb24gZ2V0T3duUHJvcGVydHlOYW1lcyhPKSB7XG4gcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBoaWRkZW5LZXlzKTtcbn07XG5cbi8qKiovIH0pLFxuLyogNTkgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBoYXNPd24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM5KTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyKTtcbnZhciBpbmRleE9mID0gKF9fd19wZGZqc19yZXF1aXJlX18oNjApLmluZGV4T2YpO1xudmFyIGhpZGRlbktleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU1KTtcbnZhciBwdXNoID0gdW5jdXJyeVRoaXMoW10ucHVzaCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG5hbWVzKSB7XG4gdmFyIE8gPSB0b0luZGV4ZWRPYmplY3Qob2JqZWN0KTtcbiB2YXIgaSA9IDA7XG4gdmFyIHJlc3VsdCA9IFtdO1xuIHZhciBrZXk7XG4gZm9yIChrZXkgaW4gTylcbiAgIWhhc093bihoaWRkZW5LZXlzLCBrZXkpICYmIGhhc093bihPLCBrZXkpICYmIHB1c2gocmVzdWx0LCBrZXkpO1xuIHdoaWxlIChuYW1lcy5sZW5ndGggPiBpKVxuICBpZiAoaGFzT3duKE8sIGtleSA9IG5hbWVzW2krK10pKSB7XG4gICB+aW5kZXhPZihyZXN1bHQsIGtleSkgfHwgcHVzaChyZXN1bHQsIGtleSk7XG4gIH1cbiByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqKi8gfSksXG4vKiA2MCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyKTtcbnZhciB0b0Fic29sdXRlSW5kZXggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYxKTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNjQpO1xudmFyIGNyZWF0ZU1ldGhvZCA9IGZ1bmN0aW9uIChJU19JTkNMVURFUykge1xuIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGVsLCBmcm9tSW5kZXgpIHtcbiAgdmFyIE8gPSB0b0luZGV4ZWRPYmplY3QoJHRoaXMpO1xuICB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gIHZhciBpbmRleCA9IHRvQWJzb2x1dGVJbmRleChmcm9tSW5kZXgsIGxlbmd0aCk7XG4gIHZhciB2YWx1ZTtcbiAgaWYgKElTX0lOQ0xVREVTICYmIGVsICE9PSBlbClcbiAgIHdoaWxlIChsZW5ndGggPiBpbmRleCkge1xuICAgIHZhbHVlID0gT1tpbmRleCsrXTtcbiAgICBpZiAodmFsdWUgIT09IHZhbHVlKVxuICAgICByZXR1cm4gdHJ1ZTtcbiAgIH1cbiAgZWxzZVxuICAgZm9yICg7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgaWYgKChJU19JTkNMVURFUyB8fCBpbmRleCBpbiBPKSAmJiBPW2luZGV4XSA9PT0gZWwpXG4gICAgIHJldHVybiBJU19JTkNMVURFUyB8fCBpbmRleCB8fCAwO1xuICAgfVxuICByZXR1cm4gIUlTX0lOQ0xVREVTICYmIC0xO1xuIH07XG59O1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gaW5jbHVkZXM6IGNyZWF0ZU1ldGhvZCh0cnVlKSxcbiBpbmRleE9mOiBjcmVhdGVNZXRob2QoZmFsc2UpXG59O1xuXG4vKioqLyB9KSxcbi8qIDYxICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYyKTtcbnZhciBtYXggPSBNYXRoLm1heDtcbnZhciBtaW4gPSBNYXRoLm1pbjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGluZGV4LCBsZW5ndGgpIHtcbiB2YXIgaW50ZWdlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaW5kZXgpO1xuIHJldHVybiBpbnRlZ2VyIDwgMCA/IG1heChpbnRlZ2VyICsgbGVuZ3RoLCAwKSA6IG1pbihpbnRlZ2VyLCBsZW5ndGgpO1xufTtcblxuLyoqKi8gfSksXG4vKiA2MiAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0cnVuYyA9IF9fd19wZGZqc19yZXF1aXJlX18oNjMpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiB2YXIgbnVtYmVyID0gK2FyZ3VtZW50O1xuIHJldHVybiBudW1iZXIgIT09IG51bWJlciB8fCBudW1iZXIgPT09IDAgPyAwIDogdHJ1bmMobnVtYmVyKTtcbn07XG5cbi8qKiovIH0pLFxuLyogNjMgKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxudmFyIGNlaWwgPSBNYXRoLmNlaWw7XG52YXIgZmxvb3IgPSBNYXRoLmZsb29yO1xubW9kdWxlLmV4cG9ydHMgPSBNYXRoLnRydW5jIHx8IGZ1bmN0aW9uIHRydW5jKHgpIHtcbiB2YXIgbiA9ICt4O1xuIHJldHVybiAobiA+IDAgPyBmbG9vciA6IGNlaWwpKG4pO1xufTtcblxuLyoqKi8gfSksXG4vKiA2NCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b0xlbmd0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oNjUpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqKSB7XG4gcmV0dXJuIHRvTGVuZ3RoKG9iai5sZW5ndGgpO1xufTtcblxuLyoqKi8gfSksXG4vKiA2NSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Mik7XG52YXIgbWluID0gTWF0aC5taW47XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuIHJldHVybiBhcmd1bWVudCA+IDAgPyBtaW4odG9JbnRlZ2VyT3JJbmZpbml0eShhcmd1bWVudCksIDB4MUZGRkZGRkZGRkZGRkYpIDogMDtcbn07XG5cbi8qKiovIH0pLFxuLyogNjYgKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxubW9kdWxlLmV4cG9ydHMgPSBbXG4gJ2NvbnN0cnVjdG9yJyxcbiAnaGFzT3duUHJvcGVydHknLFxuICdpc1Byb3RvdHlwZU9mJyxcbiAncHJvcGVydHlJc0VudW1lcmFibGUnLFxuICd0b0xvY2FsZVN0cmluZycsXG4gJ3RvU3RyaW5nJyxcbiAndmFsdWVPZidcbl07XG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5leHBvcnRzLmYgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciBpc0NhbGxhYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG52YXIgcmVwbGFjZW1lbnQgPSAvI3xcXC5wcm90b3R5cGVcXC4vO1xudmFyIGlzRm9yY2VkID0gZnVuY3Rpb24gKGZlYXR1cmUsIGRldGVjdGlvbikge1xuIHZhciB2YWx1ZSA9IGRhdGFbbm9ybWFsaXplKGZlYXR1cmUpXTtcbiByZXR1cm4gdmFsdWUgPT09IFBPTFlGSUxMID8gdHJ1ZSA6IHZhbHVlID09PSBOQVRJVkUgPyBmYWxzZSA6IGlzQ2FsbGFibGUoZGV0ZWN0aW9uKSA/IGZhaWxzKGRldGVjdGlvbikgOiAhIWRldGVjdGlvbjtcbn07XG52YXIgbm9ybWFsaXplID0gaXNGb3JjZWQubm9ybWFsaXplID0gZnVuY3Rpb24gKHN0cmluZykge1xuIHJldHVybiBTdHJpbmcoc3RyaW5nKS5yZXBsYWNlKHJlcGxhY2VtZW50LCAnLicpLnRvTG93ZXJDYXNlKCk7XG59O1xudmFyIGRhdGEgPSBpc0ZvcmNlZC5kYXRhID0ge307XG52YXIgTkFUSVZFID0gaXNGb3JjZWQuTkFUSVZFID0gJ04nO1xudmFyIFBPTFlGSUxMID0gaXNGb3JjZWQuUE9MWUZJTEwgPSAnUCc7XG5tb2R1bGUuZXhwb3J0cyA9IGlzRm9yY2VkO1xuXG4vKioqLyB9KSxcbi8qIDY5ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIE5BVElWRV9CSU5EID0gX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcbnZhciBGdW5jdGlvblByb3RvdHlwZSA9IEZ1bmN0aW9uLnByb3RvdHlwZTtcbnZhciBhcHBseSA9IEZ1bmN0aW9uUHJvdG90eXBlLmFwcGx5O1xudmFyIGNhbGwgPSBGdW5jdGlvblByb3RvdHlwZS5jYWxsO1xubW9kdWxlLmV4cG9ydHMgPSB0eXBlb2YgUmVmbGVjdCA9PSAnb2JqZWN0JyAmJiBSZWZsZWN0LmFwcGx5IHx8IChOQVRJVkVfQklORCA/IGNhbGwuYmluZChhcHBseSkgOiBmdW5jdGlvbiAoKSB7XG4gcmV0dXJuIGNhbGwuYXBwbHkoYXBwbHksIGFyZ3VtZW50cyk7XG59KTtcblxuLyoqKi8gfSksXG4vKiA3MCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG52YXIgaGFzT3duID0gX193X3BkZmpzX3JlcXVpcmVfXygzOSk7XG52YXIgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0NCk7XG52YXIgaXNQcm90b3R5cGVPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193X3BkZmpzX3JlcXVpcmVfXyg3MSk7XG52YXIgY29weUNvbnN0cnVjdG9yUHJvcGVydGllcyA9IF9fd19wZGZqc19yZXF1aXJlX18oNTYpO1xudmFyIHByb3h5QWNjZXNzb3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc0KTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd19wZGZqc19yZXF1aXJlX18oNzUpO1xudmFyIG5vcm1hbGl6ZVN0cmluZ0FyZ3VtZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXyg3Nik7XG52YXIgaW5zdGFsbEVycm9yQ2F1c2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgwKTtcbnZhciBpbnN0YWxsRXJyb3JTdGFjayA9IF9fd19wZGZqc19yZXF1aXJlX18oODEpO1xudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBJU19QVVJFID0gX193X3BkZmpzX3JlcXVpcmVfXygzNik7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChGVUxMX05BTUUsIHdyYXBwZXIsIEZPUkNFRCwgSVNfQUdHUkVHQVRFX0VSUk9SKSB7XG4gdmFyIFNUQUNLX1RSQUNFX0xJTUlUID0gJ3N0YWNrVHJhY2VMaW1pdCc7XG4gdmFyIE9QVElPTlNfUE9TSVRJT04gPSBJU19BR0dSRUdBVEVfRVJST1IgPyAyIDogMTtcbiB2YXIgcGF0aCA9IEZVTExfTkFNRS5zcGxpdCgnLicpO1xuIHZhciBFUlJPUl9OQU1FID0gcGF0aFtwYXRoLmxlbmd0aCAtIDFdO1xuIHZhciBPcmlnaW5hbEVycm9yID0gZ2V0QnVpbHRJbi5hcHBseShudWxsLCBwYXRoKTtcbiBpZiAoIU9yaWdpbmFsRXJyb3IpXG4gIHJldHVybjtcbiB2YXIgT3JpZ2luYWxFcnJvclByb3RvdHlwZSA9IE9yaWdpbmFsRXJyb3IucHJvdG90eXBlO1xuIGlmICghSVNfUFVSRSAmJiBoYXNPd24oT3JpZ2luYWxFcnJvclByb3RvdHlwZSwgJ2NhdXNlJykpXG4gIGRlbGV0ZSBPcmlnaW5hbEVycm9yUHJvdG90eXBlLmNhdXNlO1xuIGlmICghRk9SQ0VEKVxuICByZXR1cm4gT3JpZ2luYWxFcnJvcjtcbiB2YXIgQmFzZUVycm9yID0gZ2V0QnVpbHRJbignRXJyb3InKTtcbiB2YXIgV3JhcHBlZEVycm9yID0gd3JhcHBlcihmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgbWVzc2FnZSA9IG5vcm1hbGl6ZVN0cmluZ0FyZ3VtZW50KElTX0FHR1JFR0FURV9FUlJPUiA/IGIgOiBhLCB1bmRlZmluZWQpO1xuICB2YXIgcmVzdWx0ID0gSVNfQUdHUkVHQVRFX0VSUk9SID8gbmV3IE9yaWdpbmFsRXJyb3IoYSkgOiBuZXcgT3JpZ2luYWxFcnJvcigpO1xuICBpZiAobWVzc2FnZSAhPT0gdW5kZWZpbmVkKVxuICAgY3JlYXRlTm9uRW51bWVyYWJsZVByb3BlcnR5KHJlc3VsdCwgJ21lc3NhZ2UnLCBtZXNzYWdlKTtcbiAgaW5zdGFsbEVycm9yU3RhY2socmVzdWx0LCBXcmFwcGVkRXJyb3IsIHJlc3VsdC5zdGFjaywgMik7XG4gIGlmICh0aGlzICYmIGlzUHJvdG90eXBlT2YoT3JpZ2luYWxFcnJvclByb3RvdHlwZSwgdGhpcykpXG4gICBpbmhlcml0SWZSZXF1aXJlZChyZXN1bHQsIHRoaXMsIFdyYXBwZWRFcnJvcik7XG4gIGlmIChhcmd1bWVudHMubGVuZ3RoID4gT1BUSU9OU19QT1NJVElPTilcbiAgIGluc3RhbGxFcnJvckNhdXNlKHJlc3VsdCwgYXJndW1lbnRzW09QVElPTlNfUE9TSVRJT05dKTtcbiAgcmV0dXJuIHJlc3VsdDtcbiB9KTtcbiBXcmFwcGVkRXJyb3IucHJvdG90eXBlID0gT3JpZ2luYWxFcnJvclByb3RvdHlwZTtcbiBpZiAoRVJST1JfTkFNRSAhPT0gJ0Vycm9yJykge1xuICBpZiAoc2V0UHJvdG90eXBlT2YpXG4gICBzZXRQcm90b3R5cGVPZihXcmFwcGVkRXJyb3IsIEJhc2VFcnJvcik7XG4gIGVsc2VcbiAgIGNvcHlDb25zdHJ1Y3RvclByb3BlcnRpZXMoV3JhcHBlZEVycm9yLCBCYXNlRXJyb3IsIHsgbmFtZTogdHJ1ZSB9KTtcbiB9IGVsc2UgaWYgKERFU0NSSVBUT1JTICYmIFNUQUNLX1RSQUNFX0xJTUlUIGluIE9yaWdpbmFsRXJyb3IpIHtcbiAgcHJveHlBY2Nlc3NvcihXcmFwcGVkRXJyb3IsIE9yaWdpbmFsRXJyb3IsIFNUQUNLX1RSQUNFX0xJTUlUKTtcbiAgcHJveHlBY2Nlc3NvcihXcmFwcGVkRXJyb3IsIE9yaWdpbmFsRXJyb3IsICdwcmVwYXJlU3RhY2tUcmFjZScpO1xuIH1cbiBjb3B5Q29uc3RydWN0b3JQcm9wZXJ0aWVzKFdyYXBwZWRFcnJvciwgT3JpZ2luYWxFcnJvcik7XG4gaWYgKCFJU19QVVJFKVxuICB0cnkge1xuICAgaWYgKE9yaWdpbmFsRXJyb3JQcm90b3R5cGUubmFtZSAhPT0gRVJST1JfTkFNRSkge1xuICAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPcmlnaW5hbEVycm9yUHJvdG90eXBlLCAnbmFtZScsIEVSUk9SX05BTUUpO1xuICAgfVxuICAgT3JpZ2luYWxFcnJvclByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IFdyYXBwZWRFcnJvcjtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgfVxuIHJldHVybiBXcmFwcGVkRXJyb3I7XG59O1xuXG4vKioqLyB9KSxcbi8qIDcxICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzQWNjZXNzb3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcyKTtcbnZhciBhbk9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDcpO1xudmFyIGFQb3NzaWJsZVByb3RvdHlwZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNzMpO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgfHwgKCdfX3Byb3RvX18nIGluIHt9ID8gKGZ1bmN0aW9uICgpIHtcbiB2YXIgQ09SUkVDVF9TRVRURVIgPSBmYWxzZTtcbiB2YXIgdGVzdCA9IHt9O1xuIHZhciBzZXR0ZXI7XG4gdHJ5IHtcbiAgc2V0dGVyID0gdW5jdXJyeVRoaXNBY2Nlc3NvcihPYmplY3QucHJvdG90eXBlLCAnX19wcm90b19fJywgJ3NldCcpO1xuICBzZXR0ZXIodGVzdCwgW10pO1xuICBDT1JSRUNUX1NFVFRFUiA9IHRlc3QgaW5zdGFuY2VvZiBBcnJheTtcbiB9IGNhdGNoIChlcnJvcikge1xuIH1cbiByZXR1cm4gZnVuY3Rpb24gc2V0UHJvdG90eXBlT2YoTywgcHJvdG8pIHtcbiAgYW5PYmplY3QoTyk7XG4gIGFQb3NzaWJsZVByb3RvdHlwZShwcm90byk7XG4gIGlmIChDT1JSRUNUX1NFVFRFUilcbiAgIHNldHRlcihPLCBwcm90byk7XG4gIGVsc2VcbiAgIE8uX19wcm90b19fID0gcHJvdG87XG4gIHJldHVybiBPO1xuIH07XG59KCkpIDogdW5kZWZpbmVkKTtcblxuLyoqKi8gfSksXG4vKiA3MiAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIGFDYWxsYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzEpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIG1ldGhvZCkge1xuIHRyeSB7XG4gIHJldHVybiB1bmN1cnJ5VGhpcyhhQ2FsbGFibGUoT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIGtleSlbbWV0aG9kXSkpO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gfVxufTtcblxuLyoqKi8gfSksXG4vKiA3MyAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBpc0NhbGxhYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG52YXIgJFN0cmluZyA9IFN0cmluZztcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQpIHtcbiBpZiAodHlwZW9mIGFyZ3VtZW50ID09ICdvYmplY3QnIHx8IGlzQ2FsbGFibGUoYXJndW1lbnQpKVxuICByZXR1cm4gYXJndW1lbnQ7XG4gdGhyb3cgJFR5cGVFcnJvcihcIkNhbid0IHNldCBcIiArICRTdHJpbmcoYXJndW1lbnQpICsgJyBhcyBhIHByb3RvdHlwZScpO1xufTtcblxuLyoqKi8gfSksXG4vKiA3NCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IChfX3dfcGRmanNfcmVxdWlyZV9fKDQ1KS5mKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFRhcmdldCwgU291cmNlLCBrZXkpIHtcbiBrZXkgaW4gVGFyZ2V0IHx8IGRlZmluZVByb3BlcnR5KFRhcmdldCwga2V5LCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gU291cmNlW2tleV07XG4gIH0sXG4gIHNldDogZnVuY3Rpb24gKGl0KSB7XG4gICBTb3VyY2Vba2V5XSA9IGl0O1xuICB9XG4gfSk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDc1ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzQ2FsbGFibGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xudmFyIHNldFByb3RvdHlwZU9mID0gX193X3BkZmpzX3JlcXVpcmVfXyg3MSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgkdGhpcywgZHVtbXksIFdyYXBwZXIpIHtcbiB2YXIgTmV3VGFyZ2V0LCBOZXdUYXJnZXRQcm90b3R5cGU7XG4gaWYgKHNldFByb3RvdHlwZU9mICYmIGlzQ2FsbGFibGUoTmV3VGFyZ2V0ID0gZHVtbXkuY29uc3RydWN0b3IpICYmIE5ld1RhcmdldCAhPT0gV3JhcHBlciAmJiBpc09iamVjdChOZXdUYXJnZXRQcm90b3R5cGUgPSBOZXdUYXJnZXQucHJvdG90eXBlKSAmJiBOZXdUYXJnZXRQcm90b3R5cGUgIT09IFdyYXBwZXIucHJvdG90eXBlKVxuICBzZXRQcm90b3R5cGVPZigkdGhpcywgTmV3VGFyZ2V0UHJvdG90eXBlKTtcbiByZXR1cm4gJHRoaXM7XG59O1xuXG4vKioqLyB9KSxcbi8qIDc2ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHRvU3RyaW5nID0gX193X3BkZmpzX3JlcXVpcmVfXyg3Nyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCwgJGRlZmF1bHQpIHtcbiByZXR1cm4gYXJndW1lbnQgPT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50cy5sZW5ndGggPCAyID8gJycgOiAkZGVmYXVsdCA6IHRvU3RyaW5nKGFyZ3VtZW50KTtcbn07XG5cbi8qKiovIH0pLFxuLyogNzcgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2xhc3NvZiA9IF9fd19wZGZqc19yZXF1aXJlX18oNzgpO1xudmFyICRTdHJpbmcgPSBTdHJpbmc7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChhcmd1bWVudCkge1xuIGlmIChjbGFzc29mKGFyZ3VtZW50KSA9PT0gJ1N5bWJvbCcpXG4gIHRocm93IFR5cGVFcnJvcignQ2Fubm90IGNvbnZlcnQgYSBTeW1ib2wgdmFsdWUgdG8gYSBzdHJpbmcnKTtcbiByZXR1cm4gJFN0cmluZyhhcmd1bWVudCk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDc4ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIFRPX1NUUklOR19UQUdfU1VQUE9SVCA9IF9fd19wZGZqc19yZXF1aXJlX18oNzkpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBjbGFzc29mUmF3ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNSk7XG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXygzNCk7XG52YXIgVE9fU1RSSU5HX1RBRyA9IHdlbGxLbm93blN5bWJvbCgndG9TdHJpbmdUYWcnKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyIENPUlJFQ1RfQVJHVU1FTlRTID0gY2xhc3NvZlJhdygoZnVuY3Rpb24gKCkge1xuIHJldHVybiBhcmd1bWVudHM7XG59KCkpKSA9PT0gJ0FyZ3VtZW50cyc7XG52YXIgdHJ5R2V0ID0gZnVuY3Rpb24gKGl0LCBrZXkpIHtcbiB0cnkge1xuICByZXR1cm4gaXRba2V5XTtcbiB9IGNhdGNoIChlcnJvcikge1xuIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IFRPX1NUUklOR19UQUdfU1VQUE9SVCA/IGNsYXNzb2ZSYXcgOiBmdW5jdGlvbiAoaXQpIHtcbiB2YXIgTywgdGFnLCByZXN1bHQ7XG4gcmV0dXJuIGl0ID09PSB1bmRlZmluZWQgPyAnVW5kZWZpbmVkJyA6IGl0ID09PSBudWxsID8gJ051bGwnIDogdHlwZW9mICh0YWcgPSB0cnlHZXQoTyA9ICRPYmplY3QoaXQpLCBUT19TVFJJTkdfVEFHKSkgPT0gJ3N0cmluZycgPyB0YWcgOiBDT1JSRUNUX0FSR1VNRU5UUyA/IGNsYXNzb2ZSYXcoTykgOiAocmVzdWx0ID0gY2xhc3NvZlJhdyhPKSkgPT09ICdPYmplY3QnICYmIGlzQ2FsbGFibGUoTy5jYWxsZWUpID8gJ0FyZ3VtZW50cycgOiByZXN1bHQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDc5ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzQpO1xudmFyIFRPX1NUUklOR19UQUcgPSB3ZWxsS25vd25TeW1ib2woJ3RvU3RyaW5nVGFnJyk7XG52YXIgdGVzdCA9IHt9O1xudGVzdFtUT19TVFJJTkdfVEFHXSA9ICd6Jztcbm1vZHVsZS5leHBvcnRzID0gU3RyaW5nKHRlc3QpID09PSAnW29iamVjdCB6XSc7XG5cbi8qKiovIH0pLFxuLyogODAgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaXNPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwKTtcbnZhciBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ0KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8sIG9wdGlvbnMpIHtcbiBpZiAoaXNPYmplY3Qob3B0aW9ucykgJiYgJ2NhdXNlJyBpbiBvcHRpb25zKSB7XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShPLCAnY2F1c2UnLCBvcHRpb25zLmNhdXNlKTtcbiB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDgxICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oNDQpO1xudmFyIGNsZWFyRXJyb3JTdGFjayA9IF9fd19wZGZqc19yZXF1aXJlX18oODIpO1xudmFyIEVSUk9SX1NUQUNLX0lOU1RBTExBQkxFID0gX193X3BkZmpzX3JlcXVpcmVfXyg4Myk7XG52YXIgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGVycm9yLCBDLCBzdGFjaywgZHJvcEVudHJpZXMpIHtcbiBpZiAoRVJST1JfU1RBQ0tfSU5TVEFMTEFCTEUpIHtcbiAgaWYgKGNhcHR1cmVTdGFja1RyYWNlKVxuICAgY2FwdHVyZVN0YWNrVHJhY2UoZXJyb3IsIEMpO1xuICBlbHNlXG4gICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoZXJyb3IsICdzdGFjaycsIGNsZWFyRXJyb3JTdGFjayhzdGFjaywgZHJvcEVudHJpZXMpKTtcbiB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDgyICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgJEVycm9yID0gRXJyb3I7XG52YXIgcmVwbGFjZSA9IHVuY3VycnlUaGlzKCcnLnJlcGxhY2UpO1xudmFyIFRFU1QgPSBmdW5jdGlvbiAoYXJnKSB7XG4gcmV0dXJuIFN0cmluZygkRXJyb3IoYXJnKS5zdGFjayk7XG59KCd6eGNhc2QnKTtcbnZhciBWOF9PUl9DSEFLUkFfU1RBQ0tfRU5UUlkgPSAvXFxuXFxzKmF0IFteOl0qOlteXFxuXSovO1xudmFyIElTX1Y4X09SX0NIQUtSQV9TVEFDSyA9IFY4X09SX0NIQUtSQV9TVEFDS19FTlRSWS50ZXN0KFRFU1QpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RhY2ssIGRyb3BFbnRyaWVzKSB7XG4gaWYgKElTX1Y4X09SX0NIQUtSQV9TVEFDSyAmJiB0eXBlb2Ygc3RhY2sgPT0gJ3N0cmluZycgJiYgISRFcnJvci5wcmVwYXJlU3RhY2tUcmFjZSkge1xuICB3aGlsZSAoZHJvcEVudHJpZXMtLSlcbiAgIHN0YWNrID0gcmVwbGFjZShzdGFjaywgVjhfT1JfQ0hBS1JBX1NUQUNLX0VOVFJZLCAnJyk7XG4gfVxuIHJldHVybiBzdGFjaztcbn07XG5cbi8qKiovIH0pLFxuLyogODMgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xubW9kdWxlLmV4cG9ydHMgPSAhZmFpbHMoZnVuY3Rpb24gKCkge1xuIHZhciBlcnJvciA9IEVycm9yKCdhJyk7XG4gaWYgKCEoJ3N0YWNrJyBpbiBlcnJvcikpXG4gIHJldHVybiB0cnVlO1xuIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlcnJvciwgJ3N0YWNrJywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIDcpKTtcbiByZXR1cm4gZXJyb3Iuc3RhY2sgIT09IDc7XG59KTtcblxuLyoqKi8gfSksXG4vKiA4NCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ4KTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIHRvU3RyaW5nID0gX193X3BkZmpzX3JlcXVpcmVfXyg3Nyk7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg1KTtcbnZhciAkVVJMU2VhcmNoUGFyYW1zID0gVVJMU2VhcmNoUGFyYW1zO1xudmFyIFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZSA9ICRVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xudmFyIGFwcGVuZCA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5hcHBlbmQpO1xudmFyICRkZWxldGUgPSB1bmN1cnJ5VGhpcyhVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGVbJ2RlbGV0ZSddKTtcbnZhciBmb3JFYWNoID0gdW5jdXJyeVRoaXMoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLmZvckVhY2gpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbnZhciBwYXJhbXMgPSBuZXcgJFVSTFNlYXJjaFBhcmFtcygnYT0xJmE9MiZiPTMnKTtcbnBhcmFtc1snZGVsZXRlJ10oJ2EnLCAxKTtcbnBhcmFtc1snZGVsZXRlJ10oJ2InLCB1bmRlZmluZWQpO1xuaWYgKHBhcmFtcyArICcnICE9PSAnYT0yJykge1xuIGRlZmluZUJ1aWx0SW4oVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLCAnZGVsZXRlJywgZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIGxlbmd0aCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHZhciAkdmFsdWUgPSBsZW5ndGggPCAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdO1xuICBpZiAobGVuZ3RoICYmICR2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICAgcmV0dXJuICRkZWxldGUodGhpcywgbmFtZSk7XG4gIHZhciBlbnRyaWVzID0gW107XG4gIGZvckVhY2godGhpcywgZnVuY3Rpb24gKHYsIGspIHtcbiAgIHB1c2goZW50cmllcywge1xuICAgIGtleTogayxcbiAgICB2YWx1ZTogdlxuICAgfSk7XG4gIH0pO1xuICB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChsZW5ndGgsIDEpO1xuICB2YXIga2V5ID0gdG9TdHJpbmcobmFtZSk7XG4gIHZhciB2YWx1ZSA9IHRvU3RyaW5nKCR2YWx1ZSk7XG4gIHZhciBpbmRleCA9IDA7XG4gIHZhciBkaW5kZXggPSAwO1xuICB2YXIgZm91bmQgPSBmYWxzZTtcbiAgdmFyIGVudHJpZXNMZW5ndGggPSBlbnRyaWVzLmxlbmd0aDtcbiAgdmFyIGVudHJ5O1xuICB3aGlsZSAoaW5kZXggPCBlbnRyaWVzTGVuZ3RoKSB7XG4gICBlbnRyeSA9IGVudHJpZXNbaW5kZXgrK107XG4gICBpZiAoZm91bmQgfHwgZW50cnkua2V5ID09PSBrZXkpIHtcbiAgICBmb3VuZCA9IHRydWU7XG4gICAgJGRlbGV0ZSh0aGlzLCBlbnRyeS5rZXkpO1xuICAgfSBlbHNlXG4gICAgZGluZGV4Kys7XG4gIH1cbiAgd2hpbGUgKGRpbmRleCA8IGVudHJpZXNMZW5ndGgpIHtcbiAgIGVudHJ5ID0gZW50cmllc1tkaW5kZXgrK107XG4gICBpZiAoIShlbnRyeS5rZXkgPT09IGtleSAmJiBlbnRyeS52YWx1ZSA9PT0gdmFsdWUpKVxuICAgIGFwcGVuZCh0aGlzLCBlbnRyeS5rZXksIGVudHJ5LnZhbHVlKTtcbiAgfVxuIH0sIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdW5zYWZlOiB0cnVlXG4gfSk7XG59XG5cbi8qKiovIH0pLFxuLyogODUgKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblxudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXNzZWQsIHJlcXVpcmVkKSB7XG4gaWYgKHBhc3NlZCA8IHJlcXVpcmVkKVxuICB0aHJvdyAkVHlwZUVycm9yKCdOb3QgZW5vdWdoIGFyZ3VtZW50cycpO1xuIHJldHVybiBwYXNzZWQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDg2ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZGVmaW5lQnVpbHRJbiA9IF9fd19wZGZqc19yZXF1aXJlX18oNDgpO1xudmFyIHVuY3VycnlUaGlzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgdG9TdHJpbmcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc3KTtcbnZhciB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oODUpO1xudmFyICRVUkxTZWFyY2hQYXJhbXMgPSBVUkxTZWFyY2hQYXJhbXM7XG52YXIgVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlID0gJFVSTFNlYXJjaFBhcmFtcy5wcm90b3R5cGU7XG52YXIgZ2V0QWxsID0gdW5jdXJyeVRoaXMoVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlLmdldEFsbCk7XG52YXIgJGhhcyA9IHVuY3VycnlUaGlzKFVSTFNlYXJjaFBhcmFtc1Byb3RvdHlwZS5oYXMpO1xudmFyIHBhcmFtcyA9IG5ldyAkVVJMU2VhcmNoUGFyYW1zKCdhPTEnKTtcbmlmIChwYXJhbXMuaGFzKCdhJywgMikgfHwgIXBhcmFtcy5oYXMoJ2EnLCB1bmRlZmluZWQpKSB7XG4gZGVmaW5lQnVpbHRJbihVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsICdoYXMnLCBmdW5jdGlvbiBoYXMobmFtZSkge1xuICB2YXIgbGVuZ3RoID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgdmFyICR2YWx1ZSA9IGxlbmd0aCA8IDIgPyB1bmRlZmluZWQgOiBhcmd1bWVudHNbMV07XG4gIGlmIChsZW5ndGggJiYgJHZhbHVlID09PSB1bmRlZmluZWQpXG4gICByZXR1cm4gJGhhcyh0aGlzLCBuYW1lKTtcbiAgdmFyIHZhbHVlcyA9IGdldEFsbCh0aGlzLCBuYW1lKTtcbiAgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGgobGVuZ3RoLCAxKTtcbiAgdmFyIHZhbHVlID0gdG9TdHJpbmcoJHZhbHVlKTtcbiAgdmFyIGluZGV4ID0gMDtcbiAgd2hpbGUgKGluZGV4IDwgdmFsdWVzLmxlbmd0aCkge1xuICAgaWYgKHZhbHVlc1tpbmRleCsrXSA9PT0gdmFsdWUpXG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xuIH0sIHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgdW5zYWZlOiB0cnVlXG4gfSk7XG59XG5cbi8qKiovIH0pLFxuLyogODcgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg4KTtcbnZhciBVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUgPSBVUkxTZWFyY2hQYXJhbXMucHJvdG90eXBlO1xudmFyIGZvckVhY2ggPSB1bmN1cnJ5VGhpcyhVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUuZm9yRWFjaCk7XG5pZiAoREVTQ1JJUFRPUlMgJiYgISgnc2l6ZScgaW4gVVJMU2VhcmNoUGFyYW1zUHJvdG90eXBlKSkge1xuIGRlZmluZUJ1aWx0SW5BY2Nlc3NvcihVUkxTZWFyY2hQYXJhbXNQcm90b3R5cGUsICdzaXplJywge1xuICBnZXQ6IGZ1bmN0aW9uIHNpemUoKSB7XG4gICB2YXIgY291bnQgPSAwO1xuICAgZm9yRWFjaCh0aGlzLCBmdW5jdGlvbiAoKSB7XG4gICAgY291bnQrKztcbiAgIH0pO1xuICAgcmV0dXJuIGNvdW50O1xuICB9LFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGVudW1lcmFibGU6IHRydWVcbiB9KTtcbn1cblxuLyoqKi8gfSksXG4vKiA4OCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBtYWtlQnVpbHRJbiA9IF9fd19wZGZqc19yZXF1aXJlX18oNDkpO1xudmFyIGRlZmluZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0NSk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICh0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpIHtcbiBpZiAoZGVzY3JpcHRvci5nZXQpXG4gIG1ha2VCdWlsdEluKGRlc2NyaXB0b3IuZ2V0LCBuYW1lLCB7IGdldHRlcjogdHJ1ZSB9KTtcbiBpZiAoZGVzY3JpcHRvci5zZXQpXG4gIG1ha2VCdWlsdEluKGRlc2NyaXB0b3Iuc2V0LCBuYW1lLCB7IHNldHRlcjogdHJ1ZSB9KTtcbiByZXR1cm4gZGVmaW5lUHJvcGVydHkuZih0YXJnZXQsIG5hbWUsIGRlc2NyaXB0b3IpO1xufTtcblxuLyoqKi8gfSksXG4vKiA4OSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xudmFyIHRvT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0MCk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY0KTtcbnZhciBzZXRBcnJheUxlbmd0aCA9IF9fd19wZGZqc19yZXF1aXJlX18oOTApO1xudmFyIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlciA9IF9fd19wZGZqc19yZXF1aXJlX18oOTIpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciBJTkNPUlJFQ1RfVE9fTEVOR1RIID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuIHJldHVybiBbXS5wdXNoLmNhbGwoeyBsZW5ndGg6IDB4MTAwMDAwMDAwIH0sIDEpICE9PSA0Mjk0OTY3Mjk3O1xufSk7XG52YXIgcHJvcGVyRXJyb3JPbk5vbldyaXRhYmxlTGVuZ3RoID0gZnVuY3Rpb24gKCkge1xuIHRyeSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShbXSwgJ2xlbmd0aCcsIHsgd3JpdGFibGU6IGZhbHNlIH0pLnB1c2goKTtcbiB9IGNhdGNoIChlcnJvcikge1xuICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3I7XG4gfVxufTtcbnZhciBGT1JDRUQgPSBJTkNPUlJFQ1RfVE9fTEVOR1RIIHx8ICFwcm9wZXJFcnJvck9uTm9uV3JpdGFibGVMZW5ndGgoKTtcbiQoe1xuIHRhcmdldDogJ0FycmF5JyxcbiBwcm90bzogdHJ1ZSxcbiBhcml0eTogMSxcbiBmb3JjZWQ6IEZPUkNFRFxufSwge1xuIHB1c2g6IGZ1bmN0aW9uIHB1c2goaXRlbSkge1xuICB2YXIgTyA9IHRvT2JqZWN0KHRoaXMpO1xuICB2YXIgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2UoTyk7XG4gIHZhciBhcmdDb3VudCA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIGRvZXNOb3RFeGNlZWRTYWZlSW50ZWdlcihsZW4gKyBhcmdDb3VudCk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJnQ291bnQ7IGkrKykge1xuICAgT1tsZW5dID0gYXJndW1lbnRzW2ldO1xuICAgbGVuKys7XG4gIH1cbiAgc2V0QXJyYXlMZW5ndGgoTywgbGVuKTtcbiAgcmV0dXJuIGxlbjtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiA5MCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgaXNBcnJheSA9IF9fd19wZGZqc19yZXF1aXJlX18oOTEpO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG52YXIgZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcbnZhciBTSUxFTlRfT05fTk9OX1dSSVRBQkxFX0xFTkdUSF9TRVQgPSBERVNDUklQVE9SUyAmJiAhKGZ1bmN0aW9uICgpIHtcbiBpZiAodGhpcyAhPT0gdW5kZWZpbmVkKVxuICByZXR1cm4gdHJ1ZTtcbiB0cnkge1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoW10sICdsZW5ndGgnLCB7IHdyaXRhYmxlOiBmYWxzZSB9KS5sZW5ndGggPSAxO1xuIH0gY2F0Y2ggKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIFR5cGVFcnJvcjtcbiB9XG59KCkpO1xubW9kdWxlLmV4cG9ydHMgPSBTSUxFTlRfT05fTk9OX1dSSVRBQkxFX0xFTkdUSF9TRVQgPyBmdW5jdGlvbiAoTywgbGVuZ3RoKSB7XG4gaWYgKGlzQXJyYXkoTykgJiYgIWdldE93blByb3BlcnR5RGVzY3JpcHRvcihPLCAnbGVuZ3RoJykud3JpdGFibGUpIHtcbiAgdGhyb3cgJFR5cGVFcnJvcignQ2Fubm90IHNldCByZWFkIG9ubHkgLmxlbmd0aCcpO1xuIH1cbiByZXR1cm4gTy5sZW5ndGggPSBsZW5ndGg7XG59IDogZnVuY3Rpb24gKE8sIGxlbmd0aCkge1xuIHJldHVybiBPLmxlbmd0aCA9IGxlbmd0aDtcbn07XG5cbi8qKiovIH0pLFxuLyogOTEgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2xhc3NvZiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUpO1xubW9kdWxlLmV4cG9ydHMgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIGlzQXJyYXkoYXJndW1lbnQpIHtcbiByZXR1cm4gY2xhc3NvZihhcmd1bWVudCkgPT09ICdBcnJheSc7XG59O1xuXG4vKioqLyB9KSxcbi8qIDkyICovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIE1BWF9TQUZFX0lOVEVHRVIgPSAweDFGRkZGRkZGRkZGRkZGO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiBpZiAoaXQgPiBNQVhfU0FGRV9JTlRFR0VSKVxuICB0aHJvdyAkVHlwZUVycm9yKCdNYXhpbXVtIGFsbG93ZWQgaW5kZXggZXhjZWVkZWQnKTtcbiByZXR1cm4gaXQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDkzICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd19wZGZqc19yZXF1aXJlX18oOTQpO1xudmFyICRmaW5kTGFzdCA9IChfX3dfcGRmanNfcmVxdWlyZV9fKDk4KS5maW5kTGFzdCk7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCdmaW5kTGFzdCcsIGZ1bmN0aW9uIGZpbmRMYXN0KHByZWRpY2F0ZSkge1xuIHJldHVybiAkZmluZExhc3QoYVR5cGVkQXJyYXkodGhpcyksIHByZWRpY2F0ZSwgYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQpO1xufSk7XG5cbi8qKiovIH0pLFxuLyogOTQgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgTkFUSVZFX0FSUkFZX0JVRkZFUiA9IF9fd19wZGZqc19yZXF1aXJlX18oOTUpO1xudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIGlzQ2FsbGFibGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIxKTtcbnZhciBpc09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjApO1xudmFyIGhhc093biA9IF9fd19wZGZqc19yZXF1aXJlX18oMzkpO1xudmFyIGNsYXNzb2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc4KTtcbnZhciB0cnlUb1N0cmluZyA9IF9fd19wZGZqc19yZXF1aXJlX18oMzIpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oNDQpO1xudmFyIGRlZmluZUJ1aWx0SW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ4KTtcbnZhciBkZWZpbmVCdWlsdEluQWNjZXNzb3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg4KTtcbnZhciBpc1Byb3RvdHlwZU9mID0gX193X3BkZmpzX3JlcXVpcmVfXygyNSk7XG52YXIgZ2V0UHJvdG90eXBlT2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk2KTtcbnZhciBzZXRQcm90b3R5cGVPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oNzEpO1xudmFyIHdlbGxLbm93blN5bWJvbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzQpO1xudmFyIHVpZCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDEpO1xudmFyIEludGVybmFsU3RhdGVNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDUyKTtcbnZhciBlbmZvcmNlSW50ZXJuYWxTdGF0ZSA9IEludGVybmFsU3RhdGVNb2R1bGUuZW5mb3JjZTtcbnZhciBnZXRJbnRlcm5hbFN0YXRlID0gSW50ZXJuYWxTdGF0ZU1vZHVsZS5nZXQ7XG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkgJiYgSW50OEFycmF5LnByb3RvdHlwZTtcbnZhciBVaW50OENsYW1wZWRBcnJheSA9IGdsb2JhbC5VaW50OENsYW1wZWRBcnJheTtcbnZhciBVaW50OENsYW1wZWRBcnJheVByb3RvdHlwZSA9IFVpbnQ4Q2xhbXBlZEFycmF5ICYmIFVpbnQ4Q2xhbXBlZEFycmF5LnByb3RvdHlwZTtcbnZhciBUeXBlZEFycmF5ID0gSW50OEFycmF5ICYmIGdldFByb3RvdHlwZU9mKEludDhBcnJheSk7XG52YXIgVHlwZWRBcnJheVByb3RvdHlwZSA9IEludDhBcnJheVByb3RvdHlwZSAmJiBnZXRQcm90b3R5cGVPZihJbnQ4QXJyYXlQcm90b3R5cGUpO1xudmFyIE9iamVjdFByb3RvdHlwZSA9IE9iamVjdC5wcm90b3R5cGU7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBUT19TVFJJTkdfVEFHID0gd2VsbEtub3duU3ltYm9sKCd0b1N0cmluZ1RhZycpO1xudmFyIFRZUEVEX0FSUkFZX1RBRyA9IHVpZCgnVFlQRURfQVJSQVlfVEFHJyk7XG52YXIgVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IgPSAnVHlwZWRBcnJheUNvbnN0cnVjdG9yJztcbnZhciBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTID0gTkFUSVZFX0FSUkFZX0JVRkZFUiAmJiAhIXNldFByb3RvdHlwZU9mICYmIGNsYXNzb2YoZ2xvYmFsLm9wZXJhKSAhPT0gJ09wZXJhJztcbnZhciBUWVBFRF9BUlJBWV9UQUdfUkVRVUlSRUQgPSBmYWxzZTtcbnZhciBOQU1FLCBDb25zdHJ1Y3RvciwgUHJvdG90eXBlO1xudmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0ID0ge1xuIEludDhBcnJheTogMSxcbiBVaW50OEFycmF5OiAxLFxuIFVpbnQ4Q2xhbXBlZEFycmF5OiAxLFxuIEludDE2QXJyYXk6IDIsXG4gVWludDE2QXJyYXk6IDIsXG4gSW50MzJBcnJheTogNCxcbiBVaW50MzJBcnJheTogNCxcbiBGbG9hdDMyQXJyYXk6IDQsXG4gRmxvYXQ2NEFycmF5OiA4XG59O1xudmFyIEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCA9IHtcbiBCaWdJbnQ2NEFycmF5OiA4LFxuIEJpZ1VpbnQ2NEFycmF5OiA4XG59O1xudmFyIGlzVmlldyA9IGZ1bmN0aW9uIGlzVmlldyhpdCkge1xuIGlmICghaXNPYmplY3QoaXQpKVxuICByZXR1cm4gZmFsc2U7XG4gdmFyIGtsYXNzID0gY2xhc3NvZihpdCk7XG4gcmV0dXJuIGtsYXNzID09PSAnRGF0YVZpZXcnIHx8IGhhc093bihUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpIHx8IGhhc093bihCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QsIGtsYXNzKTtcbn07XG52YXIgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKGl0KSB7XG4gdmFyIHByb3RvID0gZ2V0UHJvdG90eXBlT2YoaXQpO1xuIGlmICghaXNPYmplY3QocHJvdG8pKVxuICByZXR1cm47XG4gdmFyIHN0YXRlID0gZ2V0SW50ZXJuYWxTdGF0ZShwcm90byk7XG4gcmV0dXJuIHN0YXRlICYmIGhhc093bihzdGF0ZSwgVFlQRURfQVJSQVlfQ09OU1RSVUNUT1IpID8gc3RhdGVbVFlQRURfQVJSQVlfQ09OU1RSVUNUT1JdIDogZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yKHByb3RvKTtcbn07XG52YXIgaXNUeXBlZEFycmF5ID0gZnVuY3Rpb24gKGl0KSB7XG4gaWYgKCFpc09iamVjdChpdCkpXG4gIHJldHVybiBmYWxzZTtcbiB2YXIga2xhc3MgPSBjbGFzc29mKGl0KTtcbiByZXR1cm4gaGFzT3duKFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0LCBrbGFzcykgfHwgaGFzT3duKEJpZ0ludEFycmF5Q29uc3RydWN0b3JzTGlzdCwga2xhc3MpO1xufTtcbnZhciBhVHlwZWRBcnJheSA9IGZ1bmN0aW9uIChpdCkge1xuIGlmIChpc1R5cGVkQXJyYXkoaXQpKVxuICByZXR1cm4gaXQ7XG4gdGhyb3cgVHlwZUVycm9yKCdUYXJnZXQgaXMgbm90IGEgdHlwZWQgYXJyYXknKTtcbn07XG52YXIgYVR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGZ1bmN0aW9uIChDKSB7XG4gaWYgKGlzQ2FsbGFibGUoQykgJiYgKCFzZXRQcm90b3R5cGVPZiB8fCBpc1Byb3RvdHlwZU9mKFR5cGVkQXJyYXksIEMpKSlcbiAgcmV0dXJuIEM7XG4gdGhyb3cgVHlwZUVycm9yKHRyeVRvU3RyaW5nKEMpICsgJyBpcyBub3QgYSB0eXBlZCBhcnJheSBjb25zdHJ1Y3RvcicpO1xufTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gZnVuY3Rpb24gKEtFWSwgcHJvcGVydHksIGZvcmNlZCwgb3B0aW9ucykge1xuIGlmICghREVTQ1JJUFRPUlMpXG4gIHJldHVybjtcbiBpZiAoZm9yY2VkKVxuICBmb3IgKHZhciBBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgdmFyIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtBUlJBWV07XG4gICBpZiAoVHlwZWRBcnJheUNvbnN0cnVjdG9yICYmIGhhc093bihUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlLCBLRVkpKVxuICAgIHRyeSB7XG4gICAgIGRlbGV0ZSBUeXBlZEFycmF5Q29uc3RydWN0b3IucHJvdG90eXBlW0tFWV07XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgdHJ5IHtcbiAgICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3Rvci5wcm90b3R5cGVbS0VZXSA9IHByb3BlcnR5O1xuICAgICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgICAgfVxuICAgIH1cbiAgfVxuIGlmICghVHlwZWRBcnJheVByb3RvdHlwZVtLRVldIHx8IGZvcmNlZCkge1xuICBkZWZpbmVCdWlsdEluKFR5cGVkQXJyYXlQcm90b3R5cGUsIEtFWSwgZm9yY2VkID8gcHJvcGVydHkgOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIEludDhBcnJheVByb3RvdHlwZVtLRVldIHx8IHByb3BlcnR5LCBvcHRpb25zKTtcbiB9XG59O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QgPSBmdW5jdGlvbiAoS0VZLCBwcm9wZXJ0eSwgZm9yY2VkKSB7XG4gdmFyIEFSUkFZLCBUeXBlZEFycmF5Q29uc3RydWN0b3I7XG4gaWYgKCFERVNDUklQVE9SUylcbiAgcmV0dXJuO1xuIGlmIChzZXRQcm90b3R5cGVPZikge1xuICBpZiAoZm9yY2VkKVxuICAgZm9yIChBUlJBWSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgIFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IGdsb2JhbFtBUlJBWV07XG4gICAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiBoYXNPd24oVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVkpKVxuICAgICB0cnkge1xuICAgICAgZGVsZXRlIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcltLRVldO1xuICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICB9XG4gICB9XG4gIGlmICghVHlwZWRBcnJheVtLRVldIHx8IGZvcmNlZCkge1xuICAgdHJ5IHtcbiAgICByZXR1cm4gZGVmaW5lQnVpbHRJbihUeXBlZEFycmF5LCBLRVksIGZvcmNlZCA/IHByb3BlcnR5IDogTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyAmJiBUeXBlZEFycmF5W0tFWV0gfHwgcHJvcGVydHkpO1xuICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgIH1cbiAgfSBlbHNlXG4gICByZXR1cm47XG4gfVxuIGZvciAoQVJSQVkgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgVHlwZWRBcnJheUNvbnN0cnVjdG9yID0gZ2xvYmFsW0FSUkFZXTtcbiAgaWYgKFR5cGVkQXJyYXlDb25zdHJ1Y3RvciAmJiAoIVR5cGVkQXJyYXlDb25zdHJ1Y3RvcltLRVldIHx8IGZvcmNlZCkpIHtcbiAgIGRlZmluZUJ1aWx0SW4oVHlwZWRBcnJheUNvbnN0cnVjdG9yLCBLRVksIHByb3BlcnR5KTtcbiAgfVxuIH1cbn07XG5mb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiBDb25zdHJ1Y3RvciA9IGdsb2JhbFtOQU1FXTtcbiBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gaWYgKFByb3RvdHlwZSlcbiAgZW5mb3JjZUludGVybmFsU3RhdGUoUHJvdG90eXBlKVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gPSBDb25zdHJ1Y3RvcjtcbiBlbHNlXG4gIE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgPSBmYWxzZTtcbn1cbmZvciAoTkFNRSBpbiBCaWdJbnRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiBDb25zdHJ1Y3RvciA9IGdsb2JhbFtOQU1FXTtcbiBQcm90b3R5cGUgPSBDb25zdHJ1Y3RvciAmJiBDb25zdHJ1Y3Rvci5wcm90b3R5cGU7XG4gaWYgKFByb3RvdHlwZSlcbiAgZW5mb3JjZUludGVybmFsU3RhdGUoUHJvdG90eXBlKVtUWVBFRF9BUlJBWV9DT05TVFJVQ1RPUl0gPSBDb25zdHJ1Y3Rvcjtcbn1cbmlmICghTkFUSVZFX0FSUkFZX0JVRkZFUl9WSUVXUyB8fCAhaXNDYWxsYWJsZShUeXBlZEFycmF5KSB8fCBUeXBlZEFycmF5ID09PSBGdW5jdGlvbi5wcm90b3R5cGUpIHtcbiBUeXBlZEFycmF5ID0gZnVuY3Rpb24gVHlwZWRBcnJheSgpIHtcbiAgdGhyb3cgVHlwZUVycm9yKCdJbmNvcnJlY3QgaW52b2NhdGlvbicpO1xuIH07XG4gaWYgKE5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MpXG4gIGZvciAoTkFNRSBpbiBUeXBlZEFycmF5Q29uc3RydWN0b3JzTGlzdCkge1xuICAgaWYgKGdsb2JhbFtOQU1FXSlcbiAgICBzZXRQcm90b3R5cGVPZihnbG9iYWxbTkFNRV0sIFR5cGVkQXJyYXkpO1xuICB9XG59XG5pZiAoIU5BVElWRV9BUlJBWV9CVUZGRVJfVklFV1MgfHwgIVR5cGVkQXJyYXlQcm90b3R5cGUgfHwgVHlwZWRBcnJheVByb3RvdHlwZSA9PT0gT2JqZWN0UHJvdG90eXBlKSB7XG4gVHlwZWRBcnJheVByb3RvdHlwZSA9IFR5cGVkQXJyYXkucHJvdG90eXBlO1xuIGlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTKVxuICBmb3IgKE5BTUUgaW4gVHlwZWRBcnJheUNvbnN0cnVjdG9yc0xpc3QpIHtcbiAgIGlmIChnbG9iYWxbTkFNRV0pXG4gICAgc2V0UHJvdG90eXBlT2YoZ2xvYmFsW05BTUVdLnByb3RvdHlwZSwgVHlwZWRBcnJheVByb3RvdHlwZSk7XG4gIH1cbn1cbmlmIChOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIGdldFByb3RvdHlwZU9mKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlKSAhPT0gVHlwZWRBcnJheVByb3RvdHlwZSkge1xuIHNldFByb3RvdHlwZU9mKFVpbnQ4Q2xhbXBlZEFycmF5UHJvdG90eXBlLCBUeXBlZEFycmF5UHJvdG90eXBlKTtcbn1cbmlmIChERVNDUklQVE9SUyAmJiAhaGFzT3duKFR5cGVkQXJyYXlQcm90b3R5cGUsIFRPX1NUUklOR19UQUcpKSB7XG4gVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEID0gdHJ1ZTtcbiBkZWZpbmVCdWlsdEluQWNjZXNzb3IoVHlwZWRBcnJheVByb3RvdHlwZSwgVE9fU1RSSU5HX1RBRywge1xuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgcmV0dXJuIGlzT2JqZWN0KHRoaXMpID8gdGhpc1tUWVBFRF9BUlJBWV9UQUddIDogdW5kZWZpbmVkO1xuICB9XG4gfSk7XG4gZm9yIChOQU1FIGluIFR5cGVkQXJyYXlDb25zdHJ1Y3RvcnNMaXN0KVxuICBpZiAoZ2xvYmFsW05BTUVdKSB7XG4gICBjcmVhdGVOb25FbnVtZXJhYmxlUHJvcGVydHkoZ2xvYmFsW05BTUVdLCBUWVBFRF9BUlJBWV9UQUcsIE5BTUUpO1xuICB9XG59XG5tb2R1bGUuZXhwb3J0cyA9IHtcbiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTOiBOQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTLFxuIFRZUEVEX0FSUkFZX1RBRzogVFlQRURfQVJSQVlfVEFHX1JFUVVJUkVEICYmIFRZUEVEX0FSUkFZX1RBRyxcbiBhVHlwZWRBcnJheTogYVR5cGVkQXJyYXksXG4gYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcjogYVR5cGVkQXJyYXlDb25zdHJ1Y3RvcixcbiBleHBvcnRUeXBlZEFycmF5TWV0aG9kOiBleHBvcnRUeXBlZEFycmF5TWV0aG9kLFxuIGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2Q6IGV4cG9ydFR5cGVkQXJyYXlTdGF0aWNNZXRob2QsXG4gZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yOiBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IsXG4gaXNWaWV3OiBpc1ZpZXcsXG4gaXNUeXBlZEFycmF5OiBpc1R5cGVkQXJyYXksXG4gVHlwZWRBcnJheTogVHlwZWRBcnJheSxcbiBUeXBlZEFycmF5UHJvdG90eXBlOiBUeXBlZEFycmF5UHJvdG90eXBlXG59O1xuXG4vKioqLyB9KSxcbi8qIDk1ICovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0gdHlwZW9mIEFycmF5QnVmZmVyICE9ICd1bmRlZmluZWQnICYmIHR5cGVvZiBEYXRhVmlldyAhPSAndW5kZWZpbmVkJztcblxuLyoqKi8gfSksXG4vKiA5NiAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBoYXNPd24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM5KTtcbnZhciBpc0NhbGxhYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG52YXIgdG9PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQwKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU0KTtcbnZhciBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk3KTtcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciAkT2JqZWN0ID0gT2JqZWN0O1xudmFyIE9iamVjdFByb3RvdHlwZSA9ICRPYmplY3QucHJvdG90eXBlO1xubW9kdWxlLmV4cG9ydHMgPSBDT1JSRUNUX1BST1RPVFlQRV9HRVRURVIgPyAkT2JqZWN0LmdldFByb3RvdHlwZU9mIDogZnVuY3Rpb24gKE8pIHtcbiB2YXIgb2JqZWN0ID0gdG9PYmplY3QoTyk7XG4gaWYgKGhhc093bihvYmplY3QsIElFX1BST1RPKSlcbiAgcmV0dXJuIG9iamVjdFtJRV9QUk9UT107XG4gdmFyIGNvbnN0cnVjdG9yID0gb2JqZWN0LmNvbnN0cnVjdG9yO1xuIGlmIChpc0NhbGxhYmxlKGNvbnN0cnVjdG9yKSAmJiBvYmplY3QgaW5zdGFuY2VvZiBjb25zdHJ1Y3Rvcikge1xuICByZXR1cm4gY29uc3RydWN0b3IucHJvdG90eXBlO1xuIH1cbiByZXR1cm4gb2JqZWN0IGluc3RhbmNlb2YgJE9iamVjdCA/IE9iamVjdFByb3RvdHlwZSA6IG51bGw7XG59O1xuXG4vKioqLyB9KSxcbi8qIDk3ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbm1vZHVsZS5leHBvcnRzID0gIWZhaWxzKGZ1bmN0aW9uICgpIHtcbiBmdW5jdGlvbiBGKCkge1xuIH1cbiBGLnByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IG51bGw7XG4gcmV0dXJuIE9iamVjdC5nZXRQcm90b3R5cGVPZihuZXcgRigpKSAhPT0gRi5wcm90b3R5cGU7XG59KTtcblxuLyoqKi8gfSksXG4vKiA5OCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBiaW5kID0gX193X3BkZmpzX3JlcXVpcmVfXyg5OSk7XG52YXIgSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMpO1xudmFyIHRvT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0MCk7XG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY0KTtcbnZhciBjcmVhdGVNZXRob2QgPSBmdW5jdGlvbiAoVFlQRSkge1xuIHZhciBJU19GSU5EX0xBU1RfSU5ERVggPSBUWVBFID09PSAxO1xuIHJldHVybiBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQpIHtcbiAgdmFyIE8gPSB0b09iamVjdCgkdGhpcyk7XG4gIHZhciBzZWxmID0gSW5kZXhlZE9iamVjdChPKTtcbiAgdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQpO1xuICB2YXIgaW5kZXggPSBsZW5ndGhPZkFycmF5TGlrZShzZWxmKTtcbiAgdmFyIHZhbHVlLCByZXN1bHQ7XG4gIHdoaWxlIChpbmRleC0tID4gMCkge1xuICAgdmFsdWUgPSBzZWxmW2luZGV4XTtcbiAgIHJlc3VsdCA9IGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKTtcbiAgIGlmIChyZXN1bHQpXG4gICAgc3dpdGNoIChUWVBFKSB7XG4gICAgY2FzZSAwOlxuICAgICByZXR1cm4gdmFsdWU7XG4gICAgY2FzZSAxOlxuICAgICByZXR1cm4gaW5kZXg7XG4gICAgfVxuICB9XG4gIHJldHVybiBJU19GSU5EX0xBU1RfSU5ERVggPyAtMSA6IHVuZGVmaW5lZDtcbiB9O1xufTtcbm1vZHVsZS5leHBvcnRzID0ge1xuIGZpbmRMYXN0OiBjcmVhdGVNZXRob2QoMCksXG4gZmluZExhc3RJbmRleDogY3JlYXRlTWV0aG9kKDEpXG59O1xuXG4vKioqLyB9KSxcbi8qIDk5ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDApO1xudmFyIGFDYWxsYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzEpO1xudmFyIE5BVElWRV9CSU5EID0gX193X3BkZmpzX3JlcXVpcmVfXyg5KTtcbnZhciBiaW5kID0gdW5jdXJyeVRoaXModW5jdXJyeVRoaXMuYmluZCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChmbiwgdGhhdCkge1xuIGFDYWxsYWJsZShmbik7XG4gcmV0dXJuIHRoYXQgPT09IHVuZGVmaW5lZCA/IGZuIDogTkFUSVZFX0JJTkQgPyBiaW5kKGZuLCB0aGF0KSA6IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIGZuLmFwcGx5KHRoYXQsIGFyZ3VtZW50cyk7XG4gfTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTAwICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNsYXNzb2ZSYXcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE1KTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoZm4pIHtcbiBpZiAoY2xhc3NvZlJhdyhmbikgPT09ICdGdW5jdGlvbicpXG4gIHJldHVybiB1bmN1cnJ5VGhpcyhmbik7XG59O1xuXG4vKioqLyB9KSxcbi8qIDEwMSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk0KTtcbnZhciAkZmluZExhc3RJbmRleCA9IChfX3dfcGRmanNfcmVxdWlyZV9fKDk4KS5maW5kTGFzdEluZGV4KTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ2ZpbmRMYXN0SW5kZXgnLCBmdW5jdGlvbiBmaW5kTGFzdEluZGV4KHByZWRpY2F0ZSkge1xuIHJldHVybiAkZmluZExhc3RJbmRleChhVHlwZWRBcnJheSh0aGlzKSwgcHJlZGljYXRlLCBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZCk7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDIgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIGNhbGwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk0KTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNjQpO1xudmFyIHRvT2Zmc2V0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDMpO1xudmFyIHRvSW5kZXhlZE9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDApO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG52YXIgSW50OEFycmF5ID0gZ2xvYmFsLkludDhBcnJheTtcbnZhciBJbnQ4QXJyYXlQcm90b3R5cGUgPSBJbnQ4QXJyYXkgJiYgSW50OEFycmF5LnByb3RvdHlwZTtcbnZhciAkc2V0ID0gSW50OEFycmF5UHJvdG90eXBlICYmIEludDhBcnJheVByb3RvdHlwZS5zZXQ7XG52YXIgYVR5cGVkQXJyYXkgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmFUeXBlZEFycmF5O1xudmFyIGV4cG9ydFR5cGVkQXJyYXlNZXRob2QgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmV4cG9ydFR5cGVkQXJyYXlNZXRob2Q7XG52YXIgV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRU5FUklDX09OX1RZUEVEX0FSUkFZUyA9ICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gdmFyIGFycmF5ID0gbmV3IFVpbnQ4Q2xhbXBlZEFycmF5KDIpO1xuIGNhbGwoJHNldCwgYXJyYXksIHtcbiAgbGVuZ3RoOiAxLFxuICAwOiAzXG4gfSwgMSk7XG4gcmV0dXJuIGFycmF5WzFdICE9PSAzO1xufSk7XG52YXIgVE9fT0JKRUNUX0JVRyA9IFdPUktTX1dJVEhfT0JKRUNUU19BTkRfR0VORVJJQ19PTl9UWVBFRF9BUlJBWVMgJiYgQXJyYXlCdWZmZXJWaWV3Q29yZS5OQVRJVkVfQVJSQVlfQlVGRkVSX1ZJRVdTICYmIGZhaWxzKGZ1bmN0aW9uICgpIHtcbiB2YXIgYXJyYXkgPSBuZXcgSW50OEFycmF5KDIpO1xuIGFycmF5LnNldCgxKTtcbiBhcnJheS5zZXQoJzInLCAxKTtcbiByZXR1cm4gYXJyYXlbMF0gIT09IDAgfHwgYXJyYXlbMV0gIT09IDI7XG59KTtcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3NldCcsIGZ1bmN0aW9uIHNldChhcnJheUxpa2UpIHtcbiBhVHlwZWRBcnJheSh0aGlzKTtcbiB2YXIgb2Zmc2V0ID0gdG9PZmZzZXQoYXJndW1lbnRzLmxlbmd0aCA+IDEgPyBhcmd1bWVudHNbMV0gOiB1bmRlZmluZWQsIDEpO1xuIHZhciBzcmMgPSB0b0luZGV4ZWRPYmplY3QoYXJyYXlMaWtlKTtcbiBpZiAoV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRU5FUklDX09OX1RZUEVEX0FSUkFZUylcbiAgcmV0dXJuIGNhbGwoJHNldCwgdGhpcywgc3JjLCBvZmZzZXQpO1xuIHZhciBsZW5ndGggPSB0aGlzLmxlbmd0aDtcbiB2YXIgbGVuID0gbGVuZ3RoT2ZBcnJheUxpa2Uoc3JjKTtcbiB2YXIgaW5kZXggPSAwO1xuIGlmIChsZW4gKyBvZmZzZXQgPiBsZW5ndGgpXG4gIHRocm93IFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCcpO1xuIHdoaWxlIChpbmRleCA8IGxlbilcbiAgdGhpc1tvZmZzZXQgKyBpbmRleF0gPSBzcmNbaW5kZXgrK107XG59LCAhV09SS1NfV0lUSF9PQkpFQ1RTX0FORF9HRU5FUklDX09OX1RZUEVEX0FSUkFZUyB8fCBUT19PQkpFQ1RfQlVHKTtcblxuLyoqKi8gfSksXG4vKiAxMDMgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdG9Qb3NpdGl2ZUludGVnZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwNCk7XG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIEJZVEVTKSB7XG4gdmFyIG9mZnNldCA9IHRvUG9zaXRpdmVJbnRlZ2VyKGl0KTtcbiBpZiAob2Zmc2V0ICUgQllURVMpXG4gIHRocm93ICRSYW5nZUVycm9yKCdXcm9uZyBvZmZzZXQnKTtcbiByZXR1cm4gb2Zmc2V0O1xufTtcblxuLyoqKi8gfSksXG4vKiAxMDQgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oNjIpO1xudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gdmFyIHJlc3VsdCA9IHRvSW50ZWdlck9ySW5maW5pdHkoaXQpO1xuIGlmIChyZXN1bHQgPCAwKVxuICB0aHJvdyAkUmFuZ2VFcnJvcihcIlRoZSBhcmd1bWVudCBjYW4ndCBiZSBsZXNzIHRoYW4gMFwiKTtcbiByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqKi8gfSksXG4vKiAxMDUgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhcnJheVRvUmV2ZXJzZWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwNik7XG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd19wZGZqc19yZXF1aXJlX18oOTQpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyIGdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyVmlld0NvcmUuZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yO1xuZXhwb3J0VHlwZWRBcnJheU1ldGhvZCgndG9SZXZlcnNlZCcsIGZ1bmN0aW9uIHRvUmV2ZXJzZWQoKSB7XG4gcmV0dXJuIGFycmF5VG9SZXZlcnNlZChhVHlwZWRBcnJheSh0aGlzKSwgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yKHRoaXMpKTtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEwNiAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNjQpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgQykge1xuIHZhciBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShPKTtcbiB2YXIgQSA9IG5ldyBDKGxlbik7XG4gdmFyIGsgPSAwO1xuIGZvciAoOyBrIDwgbGVuOyBrKyspXG4gIEFba10gPSBPW2xlbiAtIGsgLSAxXTtcbiByZXR1cm4gQTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTA3ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgQXJyYXlCdWZmZXJWaWV3Q29yZSA9IF9fd19wZGZqc19yZXF1aXJlX18oOTQpO1xudmFyIHVuY3VycnlUaGlzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgYUNhbGxhYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygzMSk7XG52YXIgYXJyYXlGcm9tQ29uc3RydWN0b3JBbmRMaXN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMDgpO1xudmFyIGFUeXBlZEFycmF5ID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5hVHlwZWRBcnJheTtcbnZhciBnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IgPSBBcnJheUJ1ZmZlclZpZXdDb3JlLmdldFR5cGVkQXJyYXlDb25zdHJ1Y3RvcjtcbnZhciBleHBvcnRUeXBlZEFycmF5TWV0aG9kID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5leHBvcnRUeXBlZEFycmF5TWV0aG9kO1xudmFyIHNvcnQgPSB1bmN1cnJ5VGhpcyhBcnJheUJ1ZmZlclZpZXdDb3JlLlR5cGVkQXJyYXlQcm90b3R5cGUuc29ydCk7XG5leHBvcnRUeXBlZEFycmF5TWV0aG9kKCd0b1NvcnRlZCcsIGZ1bmN0aW9uIHRvU29ydGVkKGNvbXBhcmVGbikge1xuIGlmIChjb21wYXJlRm4gIT09IHVuZGVmaW5lZClcbiAgYUNhbGxhYmxlKGNvbXBhcmVGbik7XG4gdmFyIE8gPSBhVHlwZWRBcnJheSh0aGlzKTtcbiB2YXIgQSA9IGFycmF5RnJvbUNvbnN0cnVjdG9yQW5kTGlzdChnZXRUeXBlZEFycmF5Q29uc3RydWN0b3IoTyksIE8pO1xuIHJldHVybiBzb3J0KEEsIGNvbXBhcmVGbik7XG59KTtcblxuLyoqKi8gfSksXG4vKiAxMDggKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY0KTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBsaXN0KSB7XG4gdmFyIGluZGV4ID0gMDtcbiB2YXIgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2UobGlzdCk7XG4gdmFyIHJlc3VsdCA9IG5ldyBDb25zdHJ1Y3RvcihsZW5ndGgpO1xuIHdoaWxlIChsZW5ndGggPiBpbmRleClcbiAgcmVzdWx0W2luZGV4XSA9IGxpc3RbaW5kZXgrK107XG4gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKiovIH0pLFxuLyogMTA5ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgYXJyYXlXaXRoID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTApO1xudmFyIEFycmF5QnVmZmVyVmlld0NvcmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk0KTtcbnZhciBpc0JpZ0ludEFycmF5ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTEpO1xudmFyIHRvSW50ZWdlck9ySW5maW5pdHkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDYyKTtcbnZhciB0b0JpZ0ludCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEyKTtcbnZhciBhVHlwZWRBcnJheSA9IEFycmF5QnVmZmVyVmlld0NvcmUuYVR5cGVkQXJyYXk7XG52YXIgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yID0gQXJyYXlCdWZmZXJWaWV3Q29yZS5nZXRUeXBlZEFycmF5Q29uc3RydWN0b3I7XG52YXIgZXhwb3J0VHlwZWRBcnJheU1ldGhvZCA9IEFycmF5QnVmZmVyVmlld0NvcmUuZXhwb3J0VHlwZWRBcnJheU1ldGhvZDtcbnZhciBQUk9QRVJfT1JERVIgPSAhIShmdW5jdGlvbiAoKSB7XG4gdHJ5IHtcbiAgbmV3IEludDhBcnJheSgxKVsnd2l0aCddKDIsIHtcbiAgIHZhbHVlT2Y6IGZ1bmN0aW9uICgpIHtcbiAgICB0aHJvdyA4O1xuICAgfVxuICB9KTtcbiB9IGNhdGNoIChlcnJvcikge1xuICByZXR1cm4gZXJyb3IgPT09IDg7XG4gfVxufSgpKTtcbmV4cG9ydFR5cGVkQXJyYXlNZXRob2QoJ3dpdGgnLCB7XG4gJ3dpdGgnOiBmdW5jdGlvbiAoaW5kZXgsIHZhbHVlKSB7XG4gIHZhciBPID0gYVR5cGVkQXJyYXkodGhpcyk7XG4gIHZhciByZWxhdGl2ZUluZGV4ID0gdG9JbnRlZ2VyT3JJbmZpbml0eShpbmRleCk7XG4gIHZhciBhY3R1YWxWYWx1ZSA9IGlzQmlnSW50QXJyYXkoTykgPyB0b0JpZ0ludCh2YWx1ZSkgOiArdmFsdWU7XG4gIHJldHVybiBhcnJheVdpdGgoTywgZ2V0VHlwZWRBcnJheUNvbnN0cnVjdG9yKE8pLCByZWxhdGl2ZUluZGV4LCBhY3R1YWxWYWx1ZSk7XG4gfVxufVsnd2l0aCddLCAhUFJPUEVSX09SREVSKTtcblxuLyoqKi8gfSksXG4vKiAxMTAgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgbGVuZ3RoT2ZBcnJheUxpa2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY0KTtcbnZhciB0b0ludGVnZXJPckluZmluaXR5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg2Mik7XG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoTywgQywgaW5kZXgsIHZhbHVlKSB7XG4gdmFyIGxlbiA9IGxlbmd0aE9mQXJyYXlMaWtlKE8pO1xuIHZhciByZWxhdGl2ZUluZGV4ID0gdG9JbnRlZ2VyT3JJbmZpbml0eShpbmRleCk7XG4gdmFyIGFjdHVhbEluZGV4ID0gcmVsYXRpdmVJbmRleCA8IDAgPyBsZW4gKyByZWxhdGl2ZUluZGV4IDogcmVsYXRpdmVJbmRleDtcbiBpZiAoYWN0dWFsSW5kZXggPj0gbGVuIHx8IGFjdHVhbEluZGV4IDwgMClcbiAgdGhyb3cgJFJhbmdlRXJyb3IoJ0luY29ycmVjdCBpbmRleCcpO1xuIHZhciBBID0gbmV3IEMobGVuKTtcbiB2YXIgayA9IDA7XG4gZm9yICg7IGsgPCBsZW47IGsrKylcbiAgQVtrXSA9IGsgPT09IGFjdHVhbEluZGV4ID8gdmFsdWUgOiBPW2tdO1xuIHJldHVybiBBO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMTEgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2xhc3NvZiA9IF9fd19wZGZqc19yZXF1aXJlX18oNzgpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiB2YXIga2xhc3MgPSBjbGFzc29mKGl0KTtcbiByZXR1cm4ga2xhc3MgPT09ICdCaWdJbnQ2NEFycmF5JyB8fCBrbGFzcyA9PT0gJ0JpZ1VpbnQ2NEFycmF5Jztcbn07XG5cbi8qKiovIH0pLFxuLyogMTEyICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHRvUHJpbWl0aXZlID0gX193X3BkZmpzX3JlcXVpcmVfXygxOSk7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGFyZ3VtZW50KSB7XG4gdmFyIHByaW0gPSB0b1ByaW1pdGl2ZShhcmd1bWVudCwgJ251bWJlcicpO1xuIGlmICh0eXBlb2YgcHJpbSA9PSAnbnVtYmVyJylcbiAgdGhyb3cgJFR5cGVFcnJvcihcIkNhbid0IGNvbnZlcnQgbnVtYmVyIHRvIGJpZ2ludFwiKTtcbiByZXR1cm4gQmlnSW50KHByaW0pO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMTMgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgZGVmaW5lQnVpbHRJbkFjY2Vzc29yID0gX193X3BkZmpzX3JlcXVpcmVfXyg4OCk7XG52YXIgaXNEZXRhY2hlZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTE0KTtcbnZhciBBcnJheUJ1ZmZlclByb3RvdHlwZSA9IEFycmF5QnVmZmVyLnByb3RvdHlwZTtcbmlmIChERVNDUklQVE9SUyAmJiAhKCdkZXRhY2hlZCcgaW4gQXJyYXlCdWZmZXJQcm90b3R5cGUpKSB7XG4gZGVmaW5lQnVpbHRJbkFjY2Vzc29yKEFycmF5QnVmZmVyUHJvdG90eXBlLCAnZGV0YWNoZWQnLCB7XG4gIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiBkZXRhY2hlZCgpIHtcbiAgIHJldHVybiBpc0RldGFjaGVkKHRoaXMpO1xuICB9XG4gfSk7XG59XG5cbi8qKiovIH0pLFxuLyogMTE0ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgYXJyYXlCdWZmZXJCeXRlTGVuZ3RoID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTUpO1xudmFyIHNsaWNlID0gdW5jdXJyeVRoaXMoQXJyYXlCdWZmZXIucHJvdG90eXBlLnNsaWNlKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKE8pIHtcbiBpZiAoYXJyYXlCdWZmZXJCeXRlTGVuZ3RoKE8pICE9PSAwKVxuICByZXR1cm4gZmFsc2U7XG4gdHJ5IHtcbiAgc2xpY2UoTywgMCwgMCk7XG4gIHJldHVybiBmYWxzZTtcbiB9IGNhdGNoIChlcnJvcikge1xuICByZXR1cm4gdHJ1ZTtcbiB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDExNSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpc0FjY2Vzc29yID0gX193X3BkZmpzX3JlcXVpcmVfXyg3Mik7XG52YXIgY2xhc3NvZiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUpO1xudmFyICRUeXBlRXJyb3IgPSBUeXBlRXJyb3I7XG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzQWNjZXNzb3IoQXJyYXlCdWZmZXIucHJvdG90eXBlLCAnYnl0ZUxlbmd0aCcsICdnZXQnKSB8fCBmdW5jdGlvbiAoTykge1xuIGlmIChjbGFzc29mKE8pICE9PSAnQXJyYXlCdWZmZXInKVxuICB0aHJvdyAkVHlwZUVycm9yKCdBcnJheUJ1ZmZlciBleHBlY3RlZCcpO1xuIHJldHVybiBPLmJ5dGVMZW5ndGg7XG59O1xuXG4vKioqLyB9KSxcbi8qIDExNiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xudmFyICR0cmFuc2ZlciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTE3KTtcbmlmICgkdHJhbnNmZXIpXG4gJCh7XG4gIHRhcmdldDogJ0FycmF5QnVmZmVyJyxcbiAgcHJvdG86IHRydWVcbiB9LCB7XG4gIHRyYW5zZmVyOiBmdW5jdGlvbiB0cmFuc2ZlcigpIHtcbiAgIHJldHVybiAkdHJhbnNmZXIodGhpcywgYXJndW1lbnRzLmxlbmd0aCA/IGFyZ3VtZW50c1swXSA6IHVuZGVmaW5lZCwgdHJ1ZSk7XG4gIH1cbiB9KTtcblxuLyoqKi8gfSksXG4vKiAxMTcgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIHVuY3VycnlUaGlzQWNjZXNzb3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcyKTtcbnZhciB0b0luZGV4ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTgpO1xudmFyIGlzRGV0YWNoZWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExNCk7XG52YXIgYXJyYXlCdWZmZXJCeXRlTGVuZ3RoID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTUpO1xudmFyIFBST1BFUl9UUkFOU0ZFUiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTE5KTtcbnZhciBUeXBlRXJyb3IgPSBnbG9iYWwuVHlwZUVycm9yO1xudmFyIHN0cnVjdHVyZWRDbG9uZSA9IGdsb2JhbC5zdHJ1Y3R1cmVkQ2xvbmU7XG52YXIgQXJyYXlCdWZmZXIgPSBnbG9iYWwuQXJyYXlCdWZmZXI7XG52YXIgRGF0YVZpZXcgPSBnbG9iYWwuRGF0YVZpZXc7XG52YXIgbWluID0gTWF0aC5taW47XG52YXIgQXJyYXlCdWZmZXJQcm90b3R5cGUgPSBBcnJheUJ1ZmZlci5wcm90b3R5cGU7XG52YXIgRGF0YVZpZXdQcm90b3R5cGUgPSBEYXRhVmlldy5wcm90b3R5cGU7XG52YXIgc2xpY2UgPSB1bmN1cnJ5VGhpcyhBcnJheUJ1ZmZlclByb3RvdHlwZS5zbGljZSk7XG52YXIgaXNSZXNpemFibGUgPSB1bmN1cnJ5VGhpc0FjY2Vzc29yKEFycmF5QnVmZmVyUHJvdG90eXBlLCAncmVzaXphYmxlJywgJ2dldCcpO1xudmFyIG1heEJ5dGVMZW5ndGggPSB1bmN1cnJ5VGhpc0FjY2Vzc29yKEFycmF5QnVmZmVyUHJvdG90eXBlLCAnbWF4Qnl0ZUxlbmd0aCcsICdnZXQnKTtcbnZhciBnZXRJbnQ4ID0gdW5jdXJyeVRoaXMoRGF0YVZpZXdQcm90b3R5cGUuZ2V0SW50OCk7XG52YXIgc2V0SW50OCA9IHVuY3VycnlUaGlzKERhdGFWaWV3UHJvdG90eXBlLnNldEludDgpO1xubW9kdWxlLmV4cG9ydHMgPSBQUk9QRVJfVFJBTlNGRVIgJiYgZnVuY3Rpb24gKGFycmF5QnVmZmVyLCBuZXdMZW5ndGgsIHByZXNlcnZlUmVzaXphYmlsaXR5KSB7XG4gdmFyIGJ5dGVMZW5ndGggPSBhcnJheUJ1ZmZlckJ5dGVMZW5ndGgoYXJyYXlCdWZmZXIpO1xuIHZhciBuZXdCeXRlTGVuZ3RoID0gbmV3TGVuZ3RoID09PSB1bmRlZmluZWQgPyBieXRlTGVuZ3RoIDogdG9JbmRleChuZXdMZW5ndGgpO1xuIHZhciBmaXhlZExlbmd0aCA9ICFpc1Jlc2l6YWJsZSB8fCAhaXNSZXNpemFibGUoYXJyYXlCdWZmZXIpO1xuIGlmIChpc0RldGFjaGVkKGFycmF5QnVmZmVyKSlcbiAgdGhyb3cgVHlwZUVycm9yKCdBcnJheUJ1ZmZlciBpcyBkZXRhY2hlZCcpO1xuIHZhciBuZXdCdWZmZXIgPSBzdHJ1Y3R1cmVkQ2xvbmUoYXJyYXlCdWZmZXIsIHsgdHJhbnNmZXI6IFthcnJheUJ1ZmZlcl0gfSk7XG4gaWYgKGJ5dGVMZW5ndGggPT09IG5ld0J5dGVMZW5ndGggJiYgKHByZXNlcnZlUmVzaXphYmlsaXR5IHx8IGZpeGVkTGVuZ3RoKSlcbiAgcmV0dXJuIG5ld0J1ZmZlcjtcbiBpZiAoYnl0ZUxlbmd0aCA+PSBuZXdCeXRlTGVuZ3RoICYmICghcHJlc2VydmVSZXNpemFiaWxpdHkgfHwgZml4ZWRMZW5ndGgpKVxuICByZXR1cm4gc2xpY2UobmV3QnVmZmVyLCAwLCBuZXdCeXRlTGVuZ3RoKTtcbiB2YXIgb3B0aW9ucyA9IHByZXNlcnZlUmVzaXphYmlsaXR5ICYmICFmaXhlZExlbmd0aCAmJiBtYXhCeXRlTGVuZ3RoID8geyBtYXhCeXRlTGVuZ3RoOiBtYXhCeXRlTGVuZ3RoKG5ld0J1ZmZlcikgfSA6IHVuZGVmaW5lZDtcbiB2YXIgbmV3TmV3QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKG5ld0J5dGVMZW5ndGgsIG9wdGlvbnMpO1xuIHZhciBhID0gbmV3IERhdGFWaWV3KG5ld0J1ZmZlcik7XG4gdmFyIGIgPSBuZXcgRGF0YVZpZXcobmV3TmV3QnVmZmVyKTtcbiB2YXIgY29weUxlbmd0aCA9IG1pbihuZXdCeXRlTGVuZ3RoLCBieXRlTGVuZ3RoKTtcbiBmb3IgKHZhciBpID0gMDsgaSA8IGNvcHlMZW5ndGg7IGkrKylcbiAgc2V0SW50OChiLCBpLCBnZXRJbnQ4KGEsIGkpKTtcbiByZXR1cm4gbmV3TmV3QnVmZmVyO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMTggKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oNjIpO1xudmFyIHRvTGVuZ3RoID0gX193X3BkZmpzX3JlcXVpcmVfXyg2NSk7XG52YXIgJFJhbmdlRXJyb3IgPSBSYW5nZUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiBpZiAoaXQgPT09IHVuZGVmaW5lZClcbiAgcmV0dXJuIDA7XG4gdmFyIG51bWJlciA9IHRvSW50ZWdlck9ySW5maW5pdHkoaXQpO1xuIHZhciBsZW5ndGggPSB0b0xlbmd0aChudW1iZXIpO1xuIGlmIChudW1iZXIgIT09IGxlbmd0aClcbiAgdGhyb3cgJFJhbmdlRXJyb3IoJ1dyb25nIGxlbmd0aCBvciBpbmRleCcpO1xuIHJldHVybiBsZW5ndGg7XG59O1xuXG4vKioqLyB9KSxcbi8qIDExOSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciBWOCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjgpO1xudmFyIElTX0JST1dTRVIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyMCk7XG52YXIgSVNfREVOTyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTIxKTtcbnZhciBJU19OT0RFID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjIpO1xudmFyIHN0cnVjdHVyZWRDbG9uZSA9IGdsb2JhbC5zdHJ1Y3R1cmVkQ2xvbmU7XG5tb2R1bGUuZXhwb3J0cyA9ICEhc3RydWN0dXJlZENsb25lICYmICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gaWYgKElTX0RFTk8gJiYgVjggPiA5MiB8fCBJU19OT0RFICYmIFY4ID4gOTQgfHwgSVNfQlJPV1NFUiAmJiBWOCA+IDk3KVxuICByZXR1cm4gZmFsc2U7XG4gdmFyIGJ1ZmZlciA9IG5ldyBBcnJheUJ1ZmZlcig4KTtcbiB2YXIgY2xvbmUgPSBzdHJ1Y3R1cmVkQ2xvbmUoYnVmZmVyLCB7IHRyYW5zZmVyOiBbYnVmZmVyXSB9KTtcbiByZXR1cm4gYnVmZmVyLmJ5dGVMZW5ndGggIT09IDAgfHwgY2xvbmUuYnl0ZUxlbmd0aCAhPT0gODtcbn0pO1xuXG4vKioqLyB9KSxcbi8qIDEyMCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBJU19ERU5PID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjEpO1xudmFyIElTX05PREUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyMik7XG5tb2R1bGUuZXhwb3J0cyA9ICFJU19ERU5PICYmICFJU19OT0RFICYmIHR5cGVvZiB3aW5kb3cgPT0gJ29iamVjdCcgJiYgdHlwZW9mIGRvY3VtZW50ID09ICdvYmplY3QnO1xuXG4vKioqLyB9KSxcbi8qIDEyMSAqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXG5tb2R1bGUuZXhwb3J0cyA9IHR5cGVvZiBEZW5vID09ICdvYmplY3QnICYmIERlbm8gJiYgdHlwZW9mIERlbm8udmVyc2lvbiA9PSAnb2JqZWN0JztcblxuLyoqKi8gfSksXG4vKiAxMjIgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBjbGFzc29mID0gX193X3BkZmpzX3JlcXVpcmVfXygxNSk7XG5tb2R1bGUuZXhwb3J0cyA9IGNsYXNzb2YoZ2xvYmFsLnByb2Nlc3MpID09PSAncHJvY2Vzcyc7XG5cbi8qKiovIH0pLFxuLyogMTIzICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMyk7XG52YXIgJHRyYW5zZmVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxMTcpO1xuaWYgKCR0cmFuc2ZlcilcbiAkKHtcbiAgdGFyZ2V0OiAnQXJyYXlCdWZmZXInLFxuICBwcm90bzogdHJ1ZVxuIH0sIHtcbiAgdHJhbnNmZXJUb0ZpeGVkTGVuZ3RoOiBmdW5jdGlvbiB0cmFuc2ZlclRvRml4ZWRMZW5ndGgoKSB7XG4gICByZXR1cm4gJHRyYW5zZmVyKHRoaXMsIGFyZ3VtZW50cy5sZW5ndGggPyBhcmd1bWVudHNbMF0gOiB1bmRlZmluZWQsIGZhbHNlKTtcbiAgfVxuIH0pO1xuXG4vKioqLyB9KSxcbi8qIDEyNCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5SZW5kZXJUYXNrID0gZXhwb3J0cy5QREZXb3JrZXJVdGlsID0gZXhwb3J0cy5QREZXb3JrZXIgPSBleHBvcnRzLlBERlBhZ2VQcm94eSA9IGV4cG9ydHMuUERGRG9jdW1lbnRQcm94eSA9IGV4cG9ydHMuUERGRG9jdW1lbnRMb2FkaW5nVGFzayA9IGV4cG9ydHMuUERGRGF0YVJhbmdlVHJhbnNwb3J0ID0gZXhwb3J0cy5Mb29wYmFja1BvcnQgPSBleHBvcnRzLkRlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGV4cG9ydHMuRGVmYXVsdEZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkRlZmF1bHRDYW52YXNGYWN0b3J5ID0gZXhwb3J0cy5EZWZhdWx0Q01hcFJlYWRlckZhY3RvcnkgPSB2b2lkIDA7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJTVkdHcmFwaGljc1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlTdmcuU1ZHR3JhcGhpY3M7XG4gIH1cbn0pKTtcbmV4cG9ydHMuYnVpbGQgPSB2b2lkIDA7XG5leHBvcnRzLmdldERvY3VtZW50ID0gZ2V0RG9jdW1lbnQ7XG5leHBvcnRzLnZlcnNpb24gPSB2b2lkIDA7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDg0KTtcbl9fd19wZGZqc19yZXF1aXJlX18oODYpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4Nyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg5Myk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwOSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExNik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDg5KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTI1KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTM2KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTM4KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTQxKTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTQzKTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTQ1KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTQ3KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTQ5KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTUyKTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Fubm90YXRpb25fc3RvcmFnZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTYzKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTY4KTtcbnZhciBfZm9udF9sb2FkZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3MSk7XG52YXIgX2Rpc3BsYXlOb2RlX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNzIpO1xudmFyIF9jYW52YXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3Myk7XG52YXIgX3dvcmtlcl9vcHRpb25zID0gX193X3BkZmpzX3JlcXVpcmVfXygxNzYpO1xudmFyIF9tZXNzYWdlX2hhbmRsZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3Nyk7XG52YXIgX21ldGFkYXRhID0gX193X3BkZmpzX3JlcXVpcmVfXygxNzgpO1xudmFyIF9vcHRpb25hbF9jb250ZW50X2NvbmZpZyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTc5KTtcbnZhciBfdHJhbnNwb3J0X3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTgwKTtcbnZhciBfZGlzcGxheUZldGNoX3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTgxKTtcbnZhciBfZGlzcGxheU5ldHdvcmsgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4NCk7XG52YXIgX2Rpc3BsYXlOb2RlX3N0cmVhbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTg1KTtcbnZhciBfZGlzcGxheVN2ZyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTg2KTtcbnZhciBfeGZhX3RleHQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5NCk7XG5jb25zdCBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkUgPSA2NTUzNjtcbmNvbnN0IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVCA9IDEwMDtcbmNvbnN0IERFTEFZRURfQ0xFQU5VUF9USU1FT1VUID0gNTAwMDtcbmNvbnN0IERlZmF1bHRDYW52YXNGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZUNhbnZhc0ZhY3RvcnkgOiBfZGlzcGxheV91dGlscy5ET01DYW52YXNGYWN0b3J5O1xuZXhwb3J0cy5EZWZhdWx0Q2FudmFzRmFjdG9yeSA9IERlZmF1bHRDYW52YXNGYWN0b3J5O1xuY29uc3QgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZUNNYXBSZWFkZXJGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHMuRE9NQ01hcFJlYWRlckZhY3Rvcnk7XG5leHBvcnRzLkRlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeSA9IERlZmF1bHRDTWFwUmVhZGVyRmFjdG9yeTtcbmNvbnN0IERlZmF1bHRGaWx0ZXJGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZUZpbHRlckZhY3RvcnkgOiBfZGlzcGxheV91dGlscy5ET01GaWx0ZXJGYWN0b3J5O1xuZXhwb3J0cy5EZWZhdWx0RmlsdGVyRmFjdG9yeSA9IERlZmF1bHRGaWx0ZXJGYWN0b3J5O1xuY29uc3QgRGVmYXVsdFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gX3V0aWwuaXNOb2RlSlMgPyBfZGlzcGxheU5vZGVfdXRpbHMuTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IDogX2Rpc3BsYXlfdXRpbHMuRE9NU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5leHBvcnRzLkRlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IERlZmF1bHRTdGFuZGFyZEZvbnREYXRhRmFjdG9yeTtcbmZ1bmN0aW9uIGdldERvY3VtZW50KHNyYykge1xuICBpZiAodHlwZW9mIHNyYyA9PT0gXCJzdHJpbmdcIiB8fCBzcmMgaW5zdGFuY2VvZiBVUkwpIHtcbiAgICBzcmMgPSB7XG4gICAgICB1cmw6IHNyY1xuICAgIH07XG4gIH0gZWxzZSBpZiAoKDAsIF91dGlsLmlzQXJyYXlCdWZmZXIpKHNyYykpIHtcbiAgICBzcmMgPSB7XG4gICAgICBkYXRhOiBzcmNcbiAgICB9O1xuICB9XG4gIGlmICh0eXBlb2Ygc3JjICE9PSBcIm9iamVjdFwiKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgaW4gZ2V0RG9jdW1lbnQsIG5lZWQgcGFyYW1ldGVyIG9iamVjdC5cIik7XG4gIH1cbiAgaWYgKCFzcmMudXJsICYmICFzcmMuZGF0YSAmJiAhc3JjLnJhbmdlKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBwYXJhbWV0ZXIgb2JqZWN0OiBuZWVkIGVpdGhlciAuZGF0YSwgLnJhbmdlIG9yIC51cmxcIik7XG4gIH1cbiAgY29uc3QgdGFzayA9IG5ldyBQREZEb2N1bWVudExvYWRpbmdUYXNrKCk7XG4gIGNvbnN0IHtcbiAgICBkb2NJZFxuICB9ID0gdGFzaztcbiAgY29uc3QgdXJsID0gc3JjLnVybCA/IGdldFVybFByb3Aoc3JjLnVybCkgOiBudWxsO1xuICBjb25zdCBkYXRhID0gc3JjLmRhdGEgPyBnZXREYXRhUHJvcChzcmMuZGF0YSkgOiBudWxsO1xuICBjb25zdCBodHRwSGVhZGVycyA9IHNyYy5odHRwSGVhZGVycyB8fCBudWxsO1xuICBjb25zdCB3aXRoQ3JlZGVudGlhbHMgPSBzcmMud2l0aENyZWRlbnRpYWxzID09PSB0cnVlO1xuICBjb25zdCBwYXNzd29yZCA9IHNyYy5wYXNzd29yZCA/PyBudWxsO1xuICBjb25zdCByYW5nZVRyYW5zcG9ydCA9IHNyYy5yYW5nZSBpbnN0YW5jZW9mIFBERkRhdGFSYW5nZVRyYW5zcG9ydCA/IHNyYy5yYW5nZSA6IG51bGw7XG4gIGNvbnN0IHJhbmdlQ2h1bmtTaXplID0gTnVtYmVyLmlzSW50ZWdlcihzcmMucmFuZ2VDaHVua1NpemUpICYmIHNyYy5yYW5nZUNodW5rU2l6ZSA+IDAgPyBzcmMucmFuZ2VDaHVua1NpemUgOiBERUZBVUxUX1JBTkdFX0NIVU5LX1NJWkU7XG4gIGxldCB3b3JrZXIgPSBzcmMud29ya2VyIGluc3RhbmNlb2YgUERGV29ya2VyID8gc3JjLndvcmtlciA6IG51bGw7XG4gIGNvbnN0IHZlcmJvc2l0eSA9IHNyYy52ZXJib3NpdHk7XG4gIGNvbnN0IGRvY0Jhc2VVcmwgPSB0eXBlb2Ygc3JjLmRvY0Jhc2VVcmwgPT09IFwic3RyaW5nXCIgJiYgISgwLCBfZGlzcGxheV91dGlscy5pc0RhdGFTY2hlbWUpKHNyYy5kb2NCYXNlVXJsKSA/IHNyYy5kb2NCYXNlVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFVybCA9IHR5cGVvZiBzcmMuY01hcFVybCA9PT0gXCJzdHJpbmdcIiA/IHNyYy5jTWFwVXJsIDogbnVsbDtcbiAgY29uc3QgY01hcFBhY2tlZCA9IHNyYy5jTWFwUGFja2VkICE9PSBmYWxzZTtcbiAgY29uc3QgQ01hcFJlYWRlckZhY3RvcnkgPSBzcmMuQ01hcFJlYWRlckZhY3RvcnkgfHwgRGVmYXVsdENNYXBSZWFkZXJGYWN0b3J5O1xuICBjb25zdCBzdGFuZGFyZEZvbnREYXRhVXJsID0gdHlwZW9mIHNyYy5zdGFuZGFyZEZvbnREYXRhVXJsID09PSBcInN0cmluZ1wiID8gc3JjLnN0YW5kYXJkRm9udERhdGFVcmwgOiBudWxsO1xuICBjb25zdCBTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IHNyYy5TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB8fCBEZWZhdWx0U3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gIGNvbnN0IGlnbm9yZUVycm9ycyA9IHNyYy5zdG9wQXRFcnJvcnMgIT09IHRydWU7XG4gIGNvbnN0IG1heEltYWdlU2l6ZSA9IE51bWJlci5pc0ludGVnZXIoc3JjLm1heEltYWdlU2l6ZSkgJiYgc3JjLm1heEltYWdlU2l6ZSA+IC0xID8gc3JjLm1heEltYWdlU2l6ZSA6IC0xO1xuICBjb25zdCBpc0V2YWxTdXBwb3J0ZWQgPSBzcmMuaXNFdmFsU3VwcG9ydGVkICE9PSBmYWxzZTtcbiAgY29uc3QgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSB0eXBlb2Ygc3JjLmlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkID09PSBcImJvb2xlYW5cIiA/IHNyYy5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCA6ICFfdXRpbC5pc05vZGVKUztcbiAgY29uc3QgY2FudmFzTWF4QXJlYUluQnl0ZXMgPSBOdW1iZXIuaXNJbnRlZ2VyKHNyYy5jYW52YXNNYXhBcmVhSW5CeXRlcykgPyBzcmMuY2FudmFzTWF4QXJlYUluQnl0ZXMgOiAtMTtcbiAgY29uc3QgZGlzYWJsZUZvbnRGYWNlID0gdHlwZW9mIHNyYy5kaXNhYmxlRm9udEZhY2UgPT09IFwiYm9vbGVhblwiID8gc3JjLmRpc2FibGVGb250RmFjZSA6IF91dGlsLmlzTm9kZUpTO1xuICBjb25zdCBmb250RXh0cmFQcm9wZXJ0aWVzID0gc3JjLmZvbnRFeHRyYVByb3BlcnRpZXMgPT09IHRydWU7XG4gIGNvbnN0IGVuYWJsZVhmYSA9IHNyYy5lbmFibGVYZmEgPT09IHRydWU7XG4gIGNvbnN0IG93bmVyRG9jdW1lbnQgPSBzcmMub3duZXJEb2N1bWVudCB8fCBnbG9iYWxUaGlzLmRvY3VtZW50O1xuICBjb25zdCBkaXNhYmxlUmFuZ2UgPSBzcmMuZGlzYWJsZVJhbmdlID09PSB0cnVlO1xuICBjb25zdCBkaXNhYmxlU3RyZWFtID0gc3JjLmRpc2FibGVTdHJlYW0gPT09IHRydWU7XG4gIGNvbnN0IGRpc2FibGVBdXRvRmV0Y2ggPSBzcmMuZGlzYWJsZUF1dG9GZXRjaCA9PT0gdHJ1ZTtcbiAgY29uc3QgcGRmQnVnID0gc3JjLnBkZkJ1ZyA9PT0gdHJ1ZTtcbiAgY29uc3QgbGVuZ3RoID0gcmFuZ2VUcmFuc3BvcnQgPyByYW5nZVRyYW5zcG9ydC5sZW5ndGggOiBzcmMubGVuZ3RoID8/IE5hTjtcbiAgY29uc3QgdXNlU3lzdGVtRm9udHMgPSB0eXBlb2Ygc3JjLnVzZVN5c3RlbUZvbnRzID09PSBcImJvb2xlYW5cIiA/IHNyYy51c2VTeXN0ZW1Gb250cyA6ICFfdXRpbC5pc05vZGVKUyAmJiAhZGlzYWJsZUZvbnRGYWNlO1xuICBjb25zdCB1c2VXb3JrZXJGZXRjaCA9IHR5cGVvZiBzcmMudXNlV29ya2VyRmV0Y2ggPT09IFwiYm9vbGVhblwiID8gc3JjLnVzZVdvcmtlckZldGNoIDogQ01hcFJlYWRlckZhY3RvcnkgPT09IF9kaXNwbGF5X3V0aWxzLkRPTUNNYXBSZWFkZXJGYWN0b3J5ICYmIFN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID09PSBfZGlzcGxheV91dGlscy5ET01TdGFuZGFyZEZvbnREYXRhRmFjdG9yeSAmJiBjTWFwVXJsICYmIHN0YW5kYXJkRm9udERhdGFVcmwgJiYgKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkoY01hcFVybCwgZG9jdW1lbnQuYmFzZVVSSSkgJiYgKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkoc3RhbmRhcmRGb250RGF0YVVybCwgZG9jdW1lbnQuYmFzZVVSSSk7XG4gIGNvbnN0IGNhbnZhc0ZhY3RvcnkgPSBzcmMuY2FudmFzRmFjdG9yeSB8fCBuZXcgRGVmYXVsdENhbnZhc0ZhY3Rvcnkoe1xuICAgIG93bmVyRG9jdW1lbnRcbiAgfSk7XG4gIGNvbnN0IGZpbHRlckZhY3RvcnkgPSBzcmMuZmlsdGVyRmFjdG9yeSB8fCBuZXcgRGVmYXVsdEZpbHRlckZhY3Rvcnkoe1xuICAgIGRvY0lkLFxuICAgIG93bmVyRG9jdW1lbnRcbiAgfSk7XG4gIGNvbnN0IHN0eWxlRWxlbWVudCA9IG51bGw7XG4gICgwLCBfdXRpbC5zZXRWZXJib3NpdHlMZXZlbCkodmVyYm9zaXR5KTtcbiAgY29uc3QgdHJhbnNwb3J0RmFjdG9yeSA9IHtcbiAgICBjYW52YXNGYWN0b3J5LFxuICAgIGZpbHRlckZhY3RvcnlcbiAgfTtcbiAgaWYgKCF1c2VXb3JrZXJGZXRjaCkge1xuICAgIHRyYW5zcG9ydEZhY3RvcnkuY01hcFJlYWRlckZhY3RvcnkgPSBuZXcgQ01hcFJlYWRlckZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogY01hcFVybCxcbiAgICAgIGlzQ29tcHJlc3NlZDogY01hcFBhY2tlZFxuICAgIH0pO1xuICAgIHRyYW5zcG9ydEZhY3Rvcnkuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBuZXcgU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkoe1xuICAgICAgYmFzZVVybDogc3RhbmRhcmRGb250RGF0YVVybFxuICAgIH0pO1xuICB9XG4gIGlmICghd29ya2VyKSB7XG4gICAgY29uc3Qgd29ya2VyUGFyYW1zID0ge1xuICAgICAgdmVyYm9zaXR5LFxuICAgICAgcG9ydDogX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydFxuICAgIH07XG4gICAgd29ya2VyID0gd29ya2VyUGFyYW1zLnBvcnQgPyBQREZXb3JrZXIuZnJvbVBvcnQod29ya2VyUGFyYW1zKSA6IG5ldyBQREZXb3JrZXIod29ya2VyUGFyYW1zKTtcbiAgICB0YXNrLl93b3JrZXIgPSB3b3JrZXI7XG4gIH1cbiAgY29uc3QgZmV0Y2hEb2NQYXJhbXMgPSB7XG4gICAgZG9jSWQsXG4gICAgYXBpVmVyc2lvbjogJzMuMTEuMTc0JyxcbiAgICBkYXRhLFxuICAgIHBhc3N3b3JkLFxuICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgcmFuZ2VDaHVua1NpemUsXG4gICAgbGVuZ3RoLFxuICAgIGRvY0Jhc2VVcmwsXG4gICAgZW5hYmxlWGZhLFxuICAgIGV2YWx1YXRvck9wdGlvbnM6IHtcbiAgICAgIG1heEltYWdlU2l6ZSxcbiAgICAgIGRpc2FibGVGb250RmFjZSxcbiAgICAgIGlnbm9yZUVycm9ycyxcbiAgICAgIGlzRXZhbFN1cHBvcnRlZCxcbiAgICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICAgICAgY2FudmFzTWF4QXJlYUluQnl0ZXMsXG4gICAgICBmb250RXh0cmFQcm9wZXJ0aWVzLFxuICAgICAgdXNlU3lzdGVtRm9udHMsXG4gICAgICBjTWFwVXJsOiB1c2VXb3JrZXJGZXRjaCA/IGNNYXBVcmwgOiBudWxsLFxuICAgICAgc3RhbmRhcmRGb250RGF0YVVybDogdXNlV29ya2VyRmV0Y2ggPyBzdGFuZGFyZEZvbnREYXRhVXJsIDogbnVsbFxuICAgIH1cbiAgfTtcbiAgY29uc3QgdHJhbnNwb3J0UGFyYW1zID0ge1xuICAgIGlnbm9yZUVycm9ycyxcbiAgICBpc0V2YWxTdXBwb3J0ZWQsXG4gICAgZGlzYWJsZUZvbnRGYWNlLFxuICAgIGZvbnRFeHRyYVByb3BlcnRpZXMsXG4gICAgZW5hYmxlWGZhLFxuICAgIG93bmVyRG9jdW1lbnQsXG4gICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICBwZGZCdWcsXG4gICAgc3R5bGVFbGVtZW50XG4gIH07XG4gIHdvcmtlci5wcm9taXNlLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTG9hZGluZyBhYm9ydGVkXCIpO1xuICAgIH1cbiAgICBjb25zdCB3b3JrZXJJZFByb21pc2UgPSBfZmV0Y2hEb2N1bWVudCh3b3JrZXIsIGZldGNoRG9jUGFyYW1zKTtcbiAgICBjb25zdCBuZXR3b3JrU3RyZWFtUHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBsZXQgbmV0d29ya1N0cmVhbTtcbiAgICAgIGlmIChyYW5nZVRyYW5zcG9ydCkge1xuICAgICAgICBuZXR3b3JrU3RyZWFtID0gbmV3IF90cmFuc3BvcnRfc3RyZWFtLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0oe1xuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBpbml0aWFsRGF0YTogcmFuZ2VUcmFuc3BvcnQuaW5pdGlhbERhdGEsXG4gICAgICAgICAgcHJvZ3Jlc3NpdmVEb25lOiByYW5nZVRyYW5zcG9ydC5wcm9ncmVzc2l2ZURvbmUsXG4gICAgICAgICAgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWU6IHJhbmdlVHJhbnNwb3J0LmNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lLFxuICAgICAgICAgIGRpc2FibGVSYW5nZSxcbiAgICAgICAgICBkaXNhYmxlU3RyZWFtXG4gICAgICAgIH0sIHJhbmdlVHJhbnNwb3J0KTtcbiAgICAgIH0gZWxzZSBpZiAoIWRhdGEpIHtcbiAgICAgICAgY29uc3QgY3JlYXRlUERGTmV0d29ya1N0cmVhbSA9IHBhcmFtcyA9PiB7XG4gICAgICAgICAgaWYgKF91dGlsLmlzTm9kZUpTKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IF9kaXNwbGF5Tm9kZV9zdHJlYW0uUERGTm9kZVN0cmVhbShwYXJhbXMpO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gKDAsIF9kaXNwbGF5X3V0aWxzLmlzVmFsaWRGZXRjaFVybCkocGFyYW1zLnVybCkgPyBuZXcgX2Rpc3BsYXlGZXRjaF9zdHJlYW0uUERGRmV0Y2hTdHJlYW0ocGFyYW1zKSA6IG5ldyBfZGlzcGxheU5ldHdvcmsuUERGTmV0d29ya1N0cmVhbShwYXJhbXMpO1xuICAgICAgICB9O1xuICAgICAgICBuZXR3b3JrU3RyZWFtID0gY3JlYXRlUERGTmV0d29ya1N0cmVhbSh7XG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIGxlbmd0aCxcbiAgICAgICAgICBodHRwSGVhZGVycyxcbiAgICAgICAgICB3aXRoQ3JlZGVudGlhbHMsXG4gICAgICAgICAgcmFuZ2VDaHVua1NpemUsXG4gICAgICAgICAgZGlzYWJsZVJhbmdlLFxuICAgICAgICAgIGRpc2FibGVTdHJlYW1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICByZXNvbHZlKG5ldHdvcmtTdHJlYW0pO1xuICAgIH0pO1xuICAgIHJldHVybiBQcm9taXNlLmFsbChbd29ya2VySWRQcm9taXNlLCBuZXR3b3JrU3RyZWFtUHJvbWlzZV0pLnRoZW4oZnVuY3Rpb24gKF9yZWYpIHtcbiAgICAgIGxldCBbd29ya2VySWQsIG5ldHdvcmtTdHJlYW1dID0gX3JlZjtcbiAgICAgIGlmICh0YXNrLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJMb2FkaW5nIGFib3J0ZWRcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKGRvY0lkLCB3b3JrZXJJZCwgd29ya2VyLnBvcnQpO1xuICAgICAgY29uc3QgdHJhbnNwb3J0ID0gbmV3IFdvcmtlclRyYW5zcG9ydChtZXNzYWdlSGFuZGxlciwgdGFzaywgbmV0d29ya1N0cmVhbSwgdHJhbnNwb3J0UGFyYW1zLCB0cmFuc3BvcnRGYWN0b3J5KTtcbiAgICAgIHRhc2suX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJSZWFkeVwiLCBudWxsKTtcbiAgICB9KTtcbiAgfSkuY2F0Y2godGFzay5fY2FwYWJpbGl0eS5yZWplY3QpO1xuICByZXR1cm4gdGFzaztcbn1cbmFzeW5jIGZ1bmN0aW9uIF9mZXRjaERvY3VtZW50KHdvcmtlciwgc291cmNlKSB7XG4gIGlmICh3b3JrZXIuZGVzdHJveWVkKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIik7XG4gIH1cbiAgY29uc3Qgd29ya2VySWQgPSBhd2FpdCB3b3JrZXIubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RG9jUmVxdWVzdFwiLCBzb3VyY2UsIHNvdXJjZS5kYXRhID8gW3NvdXJjZS5kYXRhLmJ1ZmZlcl0gOiBudWxsKTtcbiAgaWYgKHdvcmtlci5kZXN0cm95ZWQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKTtcbiAgfVxuICByZXR1cm4gd29ya2VySWQ7XG59XG5mdW5jdGlvbiBnZXRVcmxQcm9wKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVVJMKSB7XG4gICAgcmV0dXJuIHZhbC5ocmVmO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIG5ldyBVUkwodmFsLCB3aW5kb3cubG9jYXRpb24pLmhyZWY7XG4gIH0gY2F0Y2gge1xuICAgIGlmIChfdXRpbC5pc05vZGVKUyAmJiB0eXBlb2YgdmFsID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gdmFsO1xuICAgIH1cbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFBERiB1cmwgZGF0YTogXCIgKyBcImVpdGhlciBzdHJpbmcgb3IgVVJMLW9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgdXJsIHByb3BlcnR5LlwiKTtcbn1cbmZ1bmN0aW9uIGdldERhdGFQcm9wKHZhbCkge1xuICBpZiAoX3V0aWwuaXNOb2RlSlMgJiYgdHlwZW9mIEJ1ZmZlciAhPT0gXCJ1bmRlZmluZWRcIiAmJiB2YWwgaW5zdGFuY2VvZiBCdWZmZXIpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJQbGVhc2UgcHJvdmlkZSBiaW5hcnkgZGF0YSBhcyBgVWludDhBcnJheWAsIHJhdGhlciB0aGFuIGBCdWZmZXJgLlwiKTtcbiAgfVxuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiB2YWwuYnl0ZUxlbmd0aCA9PT0gdmFsLmJ1ZmZlci5ieXRlTGVuZ3RoKSB7XG4gICAgcmV0dXJuIHZhbDtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykodmFsKTtcbiAgfVxuICBpZiAodHlwZW9mIHZhbCA9PT0gXCJvYmplY3RcIiAmJiAhaXNOYU4odmFsPy5sZW5ndGgpIHx8ICgwLCBfdXRpbC5pc0FycmF5QnVmZmVyKSh2YWwpKSB7XG4gICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KHZhbCk7XG4gIH1cbiAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBQREYgYmluYXJ5IGRhdGE6IGVpdGhlciBUeXBlZEFycmF5LCBcIiArIFwic3RyaW5nLCBvciBhcnJheS1saWtlIG9iamVjdCBpcyBleHBlY3RlZCBpbiB0aGUgZGF0YSBwcm9wZXJ0eS5cIik7XG59XG5jbGFzcyBQREZEb2N1bWVudExvYWRpbmdUYXNrIHtcbiAgc3RhdGljICNkb2NJZCA9IDA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuX2NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl90cmFuc3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgdGhpcy5kb2NJZCA9IGBkJHtQREZEb2N1bWVudExvYWRpbmdUYXNrLiNkb2NJZCsrfWA7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLm9uUGFzc3dvcmQgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBhc3luYyBkZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICB0cnkge1xuICAgICAgaWYgKHRoaXMuX3dvcmtlcj8ucG9ydCkge1xuICAgICAgICB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95ID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHRoaXMuX3RyYW5zcG9ydD8uZGVzdHJveSgpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAodGhpcy5fd29ya2VyPy5wb3J0KSB7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl93b3JrZXIuX3BlbmRpbmdEZXN0cm95O1xuICAgICAgfVxuICAgICAgdGhyb3cgZXg7XG4gICAgfVxuICAgIHRoaXMuX3RyYW5zcG9ydCA9IG51bGw7XG4gICAgaWYgKHRoaXMuX3dvcmtlcikge1xuICAgICAgdGhpcy5fd29ya2VyLmRlc3Ryb3koKTtcbiAgICAgIHRoaXMuX3dvcmtlciA9IG51bGw7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBERkRvY3VtZW50TG9hZGluZ1Rhc2sgPSBQREZEb2N1bWVudExvYWRpbmdUYXNrO1xuY2xhc3MgUERGRGF0YVJhbmdlVHJhbnNwb3J0IHtcbiAgY29uc3RydWN0b3IobGVuZ3RoLCBpbml0aWFsRGF0YSkge1xuICAgIGxldCBwcm9ncmVzc2l2ZURvbmUgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGxldCBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogbnVsbDtcbiAgICB0aGlzLmxlbmd0aCA9IGxlbmd0aDtcbiAgICB0aGlzLmluaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgdGhpcy5wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5jb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA9IGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lO1xuICAgIHRoaXMuX3JhbmdlTGlzdGVuZXJzID0gW107XG4gICAgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMgPSBbXTtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgfVxuICBhZGRSYW5nZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XG4gIH1cbiAgYWRkUHJvZ3Jlc3NMaXN0ZW5lcihsaXN0ZW5lcikge1xuICAgIHRoaXMuX3Byb2dyZXNzTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlUmVhZExpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVSZWFkTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIGFkZFByb2dyZXNzaXZlRG9uZUxpc3RlbmVyKGxpc3RlbmVyKSB7XG4gICAgdGhpcy5fcHJvZ3Jlc3NpdmVEb25lTGlzdGVuZXJzLnB1c2gobGlzdGVuZXIpO1xuICB9XG4gIG9uRGF0YVJhbmdlKGJlZ2luLCBjaHVuaykge1xuICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcmFuZ2VMaXN0ZW5lcnMpIHtcbiAgICAgIGxpc3RlbmVyKGJlZ2luLCBjaHVuayk7XG4gICAgfVxuICB9XG4gIG9uRGF0YVByb2dyZXNzKGxvYWRlZCwgdG90YWwpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZS50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy5fcHJvZ3Jlc3NMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIobG9hZGVkLCB0b3RhbCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVSZWFkKGNodW5rKSB7XG4gICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGxpc3RlbmVyIG9mIHRoaXMuX3Byb2dyZXNzaXZlUmVhZExpc3RlbmVycykge1xuICAgICAgICBsaXN0ZW5lcihjaHVuayk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgb25EYXRhUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4ge1xuICAgICAgZm9yIChjb25zdCBsaXN0ZW5lciBvZiB0aGlzLl9wcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcnMpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICB0cmFuc3BvcnRSZWFkeSgpIHtcbiAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICB9XG4gIHJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJBYnN0cmFjdCBtZXRob2QgUERGRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2VcIik7XG4gIH1cbiAgYWJvcnQoKSB7fVxufVxuZXhwb3J0cy5QREZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBQREZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG5jbGFzcyBQREZEb2N1bWVudFByb3h5IHtcbiAgY29uc3RydWN0b3IocGRmSW5mbywgdHJhbnNwb3J0KSB7XG4gICAgdGhpcy5fcGRmSW5mbyA9IHBkZkluZm87XG4gICAgdGhpcy5fdHJhbnNwb3J0ID0gdHJhbnNwb3J0O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCBcImdldEphdmFTY3JpcHRcIiwge1xuICAgICAgdmFsdWU6ICgpID0+IHtcbiAgICAgICAgKDAsIF9kaXNwbGF5X3V0aWxzLmRlcHJlY2F0ZWQpKFwiYFBERkRvY3VtZW50UHJveHkuZ2V0SmF2YVNjcmlwdGAsIFwiICsgXCJwbGVhc2UgdXNlIGBQREZEb2N1bWVudFByb3h5LmdldEpTQWN0aW9uc2AgaW5zdGVhZC5cIik7XG4gICAgICAgIHJldHVybiB0aGlzLmdldEpTQWN0aW9ucygpLnRoZW4oanMgPT4ge1xuICAgICAgICAgIGlmICghanMpIHtcbiAgICAgICAgICAgIHJldHVybiBqcztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QganNBcnIgPSBbXTtcbiAgICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4ganMpIHtcbiAgICAgICAgICAgIGpzQXJyLnB1c2goLi4uanNbbmFtZV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4ganNBcnI7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBhbm5vdGF0aW9uU3RvcmFnZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmFubm90YXRpb25TdG9yYWdlO1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgbnVtUGFnZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BkZkluZm8ubnVtUGFnZXM7XG4gIH1cbiAgZ2V0IGZpbmdlcnByaW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fcGRmSW5mby5maW5nZXJwcmludHM7XG4gIH1cbiAgZ2V0IGlzUHVyZVhmYSgpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc1B1cmVYZmFcIiwgISF0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmEpO1xuICB9XG4gIGdldCBhbGxYZmFIdG1sKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE7XG4gIH1cbiAgZ2V0UGFnZShwYWdlTnVtYmVyKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRQYWdlKHBhZ2VOdW1iZXIpO1xuICB9XG4gIGdldFBhZ2VJbmRleChyZWYpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VJbmRleChyZWYpO1xuICB9XG4gIGdldERlc3RpbmF0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldERlc3RpbmF0aW9ucygpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXREZXN0aW5hdGlvbihpZCk7XG4gIH1cbiAgZ2V0UGFnZUxhYmVscygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBhZ2VMYWJlbHMoKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUxheW91dCgpO1xuICB9XG4gIGdldFBhZ2VNb2RlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZU1vZGUoKTtcbiAgfVxuICBnZXRWaWV3ZXJQcmVmZXJlbmNlcygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFZpZXdlclByZWZlcmVuY2VzKCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE9wZW5BY3Rpb24oKTtcbiAgfVxuICBnZXRBdHRhY2htZW50cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEF0dGFjaG1lbnRzKCk7XG4gIH1cbiAgZ2V0SlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RG9jSlNBY3Rpb25zKCk7XG4gIH1cbiAgZ2V0T3V0bGluZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldE91dGxpbmUoKTtcbiAgfVxuICBnZXRPcHRpb25hbENvbnRlbnRDb25maWcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRPcHRpb25hbENvbnRlbnRDb25maWcoKTtcbiAgfVxuICBnZXRQZXJtaXNzaW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldFBlcm1pc3Npb25zKCk7XG4gIH1cbiAgZ2V0TWV0YWRhdGEoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRNZXRhZGF0YSgpO1xuICB9XG4gIGdldE1hcmtJbmZvKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0TWFya0luZm8oKTtcbiAgfVxuICBnZXREYXRhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0RGF0YSgpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LnNhdmVEb2N1bWVudCgpO1xuICB9XG4gIGdldERvd25sb2FkSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmRvd25sb2FkSW5mb0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGxldCBrZWVwTG9hZGVkRm9udHMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuc3RhcnRDbGVhbnVwKGtlZXBMb2FkZWRGb250cyB8fCB0aGlzLmlzUHVyZVhmYSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICByZXR1cm4gdGhpcy5sb2FkaW5nVGFzay5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0IGxvYWRpbmdQYXJhbXMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5sb2FkaW5nUGFyYW1zO1xuICB9XG4gIGdldCBsb2FkaW5nVGFzaygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmxvYWRpbmdUYXNrO1xuICB9XG4gIGdldEZpZWxkT2JqZWN0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0LmdldEZpZWxkT2JqZWN0cygpO1xuICB9XG4gIGhhc0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy5fdHJhbnNwb3J0Lmhhc0pTQWN0aW9ucygpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5nZXRDYWxjdWxhdGlvbk9yZGVySWRzKCk7XG4gIH1cbn1cbmV4cG9ydHMuUERGRG9jdW1lbnRQcm94eSA9IFBERkRvY3VtZW50UHJveHk7XG5jbGFzcyBQREZQYWdlUHJveHkge1xuICAjZGVsYXllZENsZWFudXBUaW1lb3V0ID0gbnVsbDtcbiAgI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gIGNvbnN0cnVjdG9yKHBhZ2VJbmRleCwgcGFnZUluZm8sIHRyYW5zcG9ydCkge1xuICAgIGxldCBwZGZCdWcgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgIHRoaXMuX3BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICB0aGlzLl9wYWdlSW5mbyA9IHBhZ2VJbmZvO1xuICAgIHRoaXMuX3RyYW5zcG9ydCA9IHRyYW5zcG9ydDtcbiAgICB0aGlzLl9zdGF0cyA9IHBkZkJ1ZyA/IG5ldyBfZGlzcGxheV91dGlscy5TdGF0VGltZXIoKSA6IG51bGw7XG4gICAgdGhpcy5fcGRmQnVnID0gcGRmQnVnO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IHRyYW5zcG9ydC5jb21tb25PYmpzO1xuICAgIHRoaXMub2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5fbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIgPSBmYWxzZTtcbiAgICB0aGlzLl9pbnRlbnRTdGF0ZXMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgfVxuICBnZXQgcGFnZU51bWJlcigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZGV4ICsgMTtcbiAgfVxuICBnZXQgcm90YXRlKCkge1xuICAgIHJldHVybiB0aGlzLl9wYWdlSW5mby5yb3RhdGU7XG4gIH1cbiAgZ2V0IHJlZigpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8ucmVmO1xuICB9XG4gIGdldCB1c2VyVW5pdCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcGFnZUluZm8udXNlclVuaXQ7XG4gIH1cbiAgZ2V0IHZpZXcoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3BhZ2VJbmZvLnZpZXc7XG4gIH1cbiAgZ2V0Vmlld3BvcnQoKSB7XG4gICAgbGV0IHtcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24gPSB0aGlzLnJvdGF0ZSxcbiAgICAgIG9mZnNldFggPSAwLFxuICAgICAgb2Zmc2V0WSA9IDAsXG4gICAgICBkb250RmxpcCA9IGZhbHNlXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgcmV0dXJuIG5ldyBfZGlzcGxheV91dGlscy5QYWdlVmlld3BvcnQoe1xuICAgICAgdmlld0JveDogdGhpcy52aWV3LFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBnZXRBbm5vdGF0aW9ucygpIHtcbiAgICBsZXQge1xuICAgICAgaW50ZW50ID0gXCJkaXNwbGF5XCJcbiAgICB9ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpO1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0QW5ub3RhdGlvbnModGhpcy5fcGFnZUluZGV4LCBpbnRlbnRBcmdzLnJlbmRlcmluZ0ludGVudCk7XG4gIH1cbiAgZ2V0SlNBY3Rpb25zKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0UGFnZUpTQWN0aW9ucyh0aGlzLl9wYWdlSW5kZXgpO1xuICB9XG4gIGdldCBmaWx0ZXJGYWN0b3J5KCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZmlsdGVyRmFjdG9yeTtcbiAgfVxuICBnZXQgaXNQdXJlWGZhKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImlzUHVyZVhmYVwiLCAhIXRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSk7XG4gIH1cbiAgYXN5bmMgZ2V0WGZhKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuX2h0bWxGb3JYZmE/LmNoaWxkcmVuW3RoaXMuX3BhZ2VJbmRleF0gfHwgbnVsbDtcbiAgfVxuICByZW5kZXIoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgY2FudmFzQ29udGV4dCxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgaW50ZW50ID0gXCJkaXNwbGF5XCIsXG4gICAgICBhbm5vdGF0aW9uTW9kZSA9IF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRSxcbiAgICAgIHRyYW5zZm9ybSA9IG51bGwsXG4gICAgICBiYWNrZ3JvdW5kID0gbnVsbCxcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSBudWxsLFxuICAgICAgYW5ub3RhdGlvbkNhbnZhc01hcCA9IG51bGwsXG4gICAgICBwYWdlQ29sb3JzID0gbnVsbCxcbiAgICAgIHByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsXG4gICAgfSA9IF9yZWYyO1xuICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiT3ZlcmFsbFwiKTtcbiAgICBjb25zdCBpbnRlbnRBcmdzID0gdGhpcy5fdHJhbnNwb3J0LmdldFJlbmRlcmluZ0ludGVudChpbnRlbnQsIGFubm90YXRpb25Nb2RlLCBwcmludEFubm90YXRpb25TdG9yYWdlKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHRoaXMuI2Fib3J0RGVsYXllZENsZWFudXAoKTtcbiAgICBpZiAoIW9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UpIHtcbiAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1Byb21pc2UgPSB0aGlzLl90cmFuc3BvcnQuZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCk7XG4gICAgfVxuICAgIGxldCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoaW50ZW50QXJncy5jYWNoZUtleSk7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZSkge1xuICAgICAgaW50ZW50U3RhdGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgdGhpcy5faW50ZW50U3RhdGVzLnNldChpbnRlbnRBcmdzLmNhY2hlS2V5LCBpbnRlbnRTdGF0ZSk7XG4gICAgfVxuICAgIGlmIChpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0KSB7XG4gICAgICBjbGVhclRpbWVvdXQoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCk7XG4gICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgaW50ZW50UHJpbnQgPSAhIShpbnRlbnRBcmdzLnJlbmRlcmluZ0ludGVudCAmIF91dGlsLlJlbmRlcmluZ0ludGVudEZsYWcuUFJJTlQpO1xuICAgIGlmICghaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSkge1xuICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0ID0ge1xuICAgICAgICBmbkFycmF5OiBbXSxcbiAgICAgICAgYXJnc0FycmF5OiBbXSxcbiAgICAgICAgbGFzdENodW5rOiBmYWxzZSxcbiAgICAgICAgc2VwYXJhdGVBbm5vdHM6IG51bGxcbiAgICAgIH07XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlBhZ2UgUmVxdWVzdFwiKTtcbiAgICAgIHRoaXMuX3B1bXBPcGVyYXRvckxpc3QoaW50ZW50QXJncyk7XG4gICAgfVxuICAgIGNvbnN0IGNvbXBsZXRlID0gZXJyb3IgPT4ge1xuICAgICAgaW50ZW50U3RhdGUucmVuZGVyVGFza3MuZGVsZXRlKGludGVybmFsUmVuZGVyVGFzayk7XG4gICAgICBpZiAodGhpcy5fbWF5YmVDbGVhbnVwQWZ0ZXJSZW5kZXIgfHwgaW50ZW50UHJpbnQpIHtcbiAgICAgICAgdGhpcy4jcGVuZGluZ0NsZWFudXAgPSB0cnVlO1xuICAgICAgfVxuICAgICAgdGhpcy4jdHJ5Q2xlYW51cCghaW50ZW50UHJpbnQpO1xuICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgIGludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHRoaXMuX2Fib3J0T3BlcmF0b3JMaXN0KHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgICByZWFzb246IGVycm9yIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvciA6IG5ldyBFcnJvcihlcnJvcilcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2suY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0cz8udGltZUVuZChcIlJlbmRlcmluZ1wiKTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lRW5kKFwiT3ZlcmFsbFwiKTtcbiAgICB9O1xuICAgIGNvbnN0IGludGVybmFsUmVuZGVyVGFzayA9IG5ldyBJbnRlcm5hbFJlbmRlclRhc2soe1xuICAgICAgY2FsbGJhY2s6IGNvbXBsZXRlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGNhbnZhc0NvbnRleHQsXG4gICAgICAgIHZpZXdwb3J0LFxuICAgICAgICB0cmFuc2Zvcm0sXG4gICAgICAgIGJhY2tncm91bmRcbiAgICAgIH0sXG4gICAgICBvYmpzOiB0aGlzLm9ianMsXG4gICAgICBjb21tb25PYmpzOiB0aGlzLmNvbW1vbk9ianMsXG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgICAgb3BlcmF0b3JMaXN0OiBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGNhbnZhc0ZhY3Rvcnk6IHRoaXMuX3RyYW5zcG9ydC5jYW52YXNGYWN0b3J5LFxuICAgICAgZmlsdGVyRmFjdG9yeTogdGhpcy5fdHJhbnNwb3J0LmZpbHRlckZhY3RvcnksXG4gICAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWU6ICFpbnRlbnRQcmludCxcbiAgICAgIHBkZkJ1ZzogdGhpcy5fcGRmQnVnLFxuICAgICAgcGFnZUNvbG9yc1xuICAgIH0pO1xuICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQoaW50ZXJuYWxSZW5kZXJUYXNrKTtcbiAgICBjb25zdCByZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrLnRhc2s7XG4gICAgUHJvbWlzZS5hbGwoW2ludGVudFN0YXRlLmRpc3BsYXlSZWFkeUNhcGFiaWxpdHkucHJvbWlzZSwgb3B0aW9uYWxDb250ZW50Q29uZmlnUHJvbWlzZV0pLnRoZW4oX3JlZjMgPT4ge1xuICAgICAgbGV0IFt0cmFuc3BhcmVuY3ksIG9wdGlvbmFsQ29udGVudENvbmZpZ10gPSBfcmVmMztcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICBjb21wbGV0ZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zdGF0cz8udGltZShcIlJlbmRlcmluZ1wiKTtcbiAgICAgIGludGVybmFsUmVuZGVyVGFzay5pbml0aWFsaXplR3JhcGhpY3Moe1xuICAgICAgICB0cmFuc3BhcmVuY3ksXG4gICAgICAgIG9wdGlvbmFsQ29udGVudENvbmZpZ1xuICAgICAgfSk7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH0pLmNhdGNoKGNvbXBsZXRlKTtcbiAgICByZXR1cm4gcmVuZGVyVGFzaztcbiAgfVxuICBnZXRPcGVyYXRvckxpc3QoKSB7XG4gICAgbGV0IHtcbiAgICAgIGludGVudCA9IFwiZGlzcGxheVwiLFxuICAgICAgYW5ub3RhdGlvbk1vZGUgPSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5FTkFCTEUsXG4gICAgICBwcmludEFubm90YXRpb25TdG9yYWdlID0gbnVsbFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIGZ1bmN0aW9uIG9wZXJhdG9yTGlzdENoYW5nZWQoKSB7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICBpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCk7XG4gICAgICAgIGludGVudFN0YXRlLnJlbmRlclRhc2tzLmRlbGV0ZShvcExpc3RUYXNrKTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaW50ZW50QXJncyA9IHRoaXMuX3RyYW5zcG9ydC5nZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50LCBhbm5vdGF0aW9uTW9kZSwgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSwgdHJ1ZSk7XG4gICAgbGV0IGludGVudFN0YXRlID0gdGhpcy5faW50ZW50U3RhdGVzLmdldChpbnRlbnRBcmdzLmNhY2hlS2V5KTtcbiAgICBpZiAoIWludGVudFN0YXRlKSB7XG4gICAgICBpbnRlbnRTdGF0ZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuc2V0KGludGVudEFyZ3MuY2FjaGVLZXksIGludGVudFN0YXRlKTtcbiAgICB9XG4gICAgbGV0IG9wTGlzdFRhc2s7XG4gICAgaWYgKCFpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgb3BMaXN0VGFzayA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICBvcExpc3RUYXNrLm9wZXJhdG9yTGlzdENoYW5nZWQgPSBvcGVyYXRvckxpc3RDaGFuZ2VkO1xuICAgICAgaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcyB8fD0gbmV3IFNldCgpKS5hZGQob3BMaXN0VGFzayk7XG4gICAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QgPSB7XG4gICAgICAgIGZuQXJyYXk6IFtdLFxuICAgICAgICBhcmdzQXJyYXk6IFtdLFxuICAgICAgICBsYXN0Q2h1bms6IGZhbHNlLFxuICAgICAgICBzZXBhcmF0ZUFubm90czogbnVsbFxuICAgICAgfTtcbiAgICAgIHRoaXMuX3N0YXRzPy50aW1lKFwiUGFnZSBSZXF1ZXN0XCIpO1xuICAgICAgdGhpcy5fcHVtcE9wZXJhdG9yTGlzdChpbnRlbnRBcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc3RyZWFtVGV4dENvbnRlbnQoKSB7XG4gICAgbGV0IHtcbiAgICAgIGluY2x1ZGVNYXJrZWRDb250ZW50ID0gZmFsc2UsXG4gICAgICBkaXNhYmxlTm9ybWFsaXphdGlvbiA9IGZhbHNlXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgY29uc3QgVEVYVF9DT05URU5UX0NIVU5LX1NJWkUgPSAxMDA7XG4gICAgcmV0dXJuIHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldFRleHRDb250ZW50XCIsIHtcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5fcGFnZUluZGV4LFxuICAgICAgaW5jbHVkZU1hcmtlZENvbnRlbnQ6IGluY2x1ZGVNYXJrZWRDb250ZW50ID09PSB0cnVlLFxuICAgICAgZGlzYWJsZU5vcm1hbGl6YXRpb246IGRpc2FibGVOb3JtYWxpemF0aW9uID09PSB0cnVlXG4gICAgfSwge1xuICAgICAgaGlnaFdhdGVyTWFyazogVEVYVF9DT05URU5UX0NIVU5LX1NJWkUsXG4gICAgICBzaXplKHRleHRDb250ZW50KSB7XG4gICAgICAgIHJldHVybiB0ZXh0Q29udGVudC5pdGVtcy5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0VGV4dENvbnRlbnQoKSB7XG4gICAgbGV0IHBhcmFtcyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5faHRtbEZvclhmYSkge1xuICAgICAgcmV0dXJuIHRoaXMuZ2V0WGZhKCkudGhlbih4ZmEgPT4ge1xuICAgICAgICByZXR1cm4gX3hmYV90ZXh0LlhmYVRleHQudGV4dENvbnRlbnQoeGZhKTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuc3RyZWFtVGV4dENvbnRlbnQocGFyYW1zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgZnVuY3Rpb24gcHVtcCgpIHtcbiAgICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKGZ1bmN0aW9uIChfcmVmNCkge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmVcbiAgICAgICAgICB9ID0gX3JlZjQ7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIHJlc29sdmUodGV4dENvbnRlbnQpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHRleHRDb250ZW50LnN0eWxlcywgdmFsdWUuc3R5bGVzKTtcbiAgICAgICAgICB0ZXh0Q29udGVudC5pdGVtcy5wdXNoKC4uLnZhbHVlLml0ZW1zKTtcbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIHJlamVjdCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICAgIGNvbnN0IHRleHRDb250ZW50ID0ge1xuICAgICAgICBpdGVtczogW10sXG4gICAgICAgIHN0eWxlczogT2JqZWN0LmNyZWF0ZShudWxsKVxuICAgICAgfTtcbiAgICAgIHB1bXAoKTtcbiAgICB9KTtcbiAgfVxuICBnZXRTdHJ1Y3RUcmVlKCkge1xuICAgIHJldHVybiB0aGlzLl90cmFuc3BvcnQuZ2V0U3RydWN0VHJlZSh0aGlzLl9wYWdlSW5kZXgpO1xuICB9XG4gIF9kZXN0cm95KCkge1xuICAgIHRoaXMuZGVzdHJveWVkID0gdHJ1ZTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGludGVudFN0YXRlIG9mIHRoaXMuX2ludGVudFN0YXRlcy52YWx1ZXMoKSkge1xuICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICBpbnRlbnRTdGF0ZSxcbiAgICAgICAgcmVhc29uOiBuZXcgRXJyb3IoXCJQYWdlIHdhcyBkZXN0cm95ZWQuXCIpLFxuICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgICBpZiAoaW50ZW50U3RhdGUub3BMaXN0UmVhZENhcGFiaWxpdHkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGludGVybmFsUmVuZGVyVGFzayBvZiBpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcykge1xuICAgICAgICB3YWl0T24ucHVzaChpbnRlcm5hbFJlbmRlclRhc2suY29tcGxldGVkKTtcbiAgICAgICAgaW50ZXJuYWxSZW5kZXJUYXNrLmNhbmNlbCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLm9ianMuY2xlYXIoKTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IGZhbHNlO1xuICAgIHRoaXMuI2Fib3J0RGVsYXllZENsZWFudXAoKTtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwod2FpdE9uKTtcbiAgfVxuICBjbGVhbnVwKCkge1xuICAgIGxldCByZXNldFN0YXRzID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB0aGlzLiNwZW5kaW5nQ2xlYW51cCA9IHRydWU7XG4gICAgY29uc3Qgc3VjY2VzcyA9IHRoaXMuI3RyeUNsZWFudXAoZmFsc2UpO1xuICAgIGlmIChyZXNldFN0YXRzICYmIHN1Y2Nlc3MpIHtcbiAgICAgIHRoaXMuX3N0YXRzICYmPSBuZXcgX2Rpc3BsYXlfdXRpbHMuU3RhdFRpbWVyKCk7XG4gICAgfVxuICAgIHJldHVybiBzdWNjZXNzO1xuICB9XG4gICN0cnlDbGVhbnVwKCkge1xuICAgIGxldCBkZWxheWVkID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICB0aGlzLiNhYm9ydERlbGF5ZWRDbGVhbnVwKCk7XG4gICAgaWYgKCF0aGlzLiNwZW5kaW5nQ2xlYW51cCB8fCB0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoZGVsYXllZCkge1xuICAgICAgdGhpcy4jZGVsYXllZENsZWFudXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgIHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCA9IG51bGw7XG4gICAgICAgIHRoaXMuI3RyeUNsZWFudXAoZmFsc2UpO1xuICAgICAgfSwgREVMQVlFRF9DTEVBTlVQX1RJTUVPVVQpO1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIHJlbmRlclRhc2tzLFxuICAgICAgb3BlcmF0b3JMaXN0XG4gICAgfSBvZiB0aGlzLl9pbnRlbnRTdGF0ZXMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChyZW5kZXJUYXNrcy5zaXplID4gMCB8fCAhb3BlcmF0b3JMaXN0Lmxhc3RDaHVuaykge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuX2ludGVudFN0YXRlcy5jbGVhcigpO1xuICAgIHRoaXMub2Jqcy5jbGVhcigpO1xuICAgIHRoaXMuI3BlbmRpbmdDbGVhbnVwID0gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgI2Fib3J0RGVsYXllZENsZWFudXAoKSB7XG4gICAgaWYgKHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI2RlbGF5ZWRDbGVhbnVwVGltZW91dCk7XG4gICAgICB0aGlzLiNkZWxheWVkQ2xlYW51cFRpbWVvdXQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBfc3RhcnRSZW5kZXJQYWdlKHRyYW5zcGFyZW5jeSwgY2FjaGVLZXkpIHtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGlmICghaW50ZW50U3RhdGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fc3RhdHM/LnRpbWVFbmQoXCJQYWdlIFJlcXVlc3RcIik7XG4gICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eT8ucmVzb2x2ZSh0cmFuc3BhcmVuY3kpO1xuICB9XG4gIF9yZW5kZXJQYWdlQ2h1bmsob3BlcmF0b3JMaXN0Q2h1bmssIGludGVudFN0YXRlKSB7XG4gICAgZm9yIChsZXQgaSA9IDAsIGlpID0gb3BlcmF0b3JMaXN0Q2h1bmsubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgaW50ZW50U3RhdGUub3BlcmF0b3JMaXN0LmZuQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5mbkFycmF5W2ldKTtcbiAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5hcmdzQXJyYXkucHVzaChvcGVyYXRvckxpc3RDaHVuay5hcmdzQXJyYXlbaV0pO1xuICAgIH1cbiAgICBpbnRlbnRTdGF0ZS5vcGVyYXRvckxpc3QubGFzdENodW5rID0gb3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rO1xuICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5zZXBhcmF0ZUFubm90cyA9IG9wZXJhdG9yTGlzdENodW5rLnNlcGFyYXRlQW5ub3RzO1xuICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgIH1cbiAgICBpZiAob3BlcmF0b3JMaXN0Q2h1bmsubGFzdENodW5rKSB7XG4gICAgICB0aGlzLiN0cnlDbGVhbnVwKHRydWUpO1xuICAgIH1cbiAgfVxuICBfcHVtcE9wZXJhdG9yTGlzdChfcmVmNSkge1xuICAgIGxldCB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleSxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlXG4gICAgfSA9IF9yZWY1O1xuICAgIGNvbnN0IHtcbiAgICAgIG1hcCxcbiAgICAgIHRyYW5zZmVyc1xuICAgIH0gPSBhbm5vdGF0aW9uU3RvcmFnZVNlcmlhbGl6YWJsZTtcbiAgICBjb25zdCByZWFkYWJsZVN0cmVhbSA9IHRoaXMuX3RyYW5zcG9ydC5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFN0cmVhbShcIkdldE9wZXJhdG9yTGlzdFwiLCB7XG4gICAgICBwYWdlSW5kZXg6IHRoaXMuX3BhZ2VJbmRleCxcbiAgICAgIGludGVudDogcmVuZGVyaW5nSW50ZW50LFxuICAgICAgY2FjaGVLZXksXG4gICAgICBhbm5vdGF0aW9uU3RvcmFnZTogbWFwXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgICBjb25zdCByZWFkZXIgPSByZWFkYWJsZVN0cmVhbS5nZXRSZWFkZXIoKTtcbiAgICBjb25zdCBpbnRlbnRTdGF0ZSA9IHRoaXMuX2ludGVudFN0YXRlcy5nZXQoY2FjaGVLZXkpO1xuICAgIGludGVudFN0YXRlLnN0cmVhbVJlYWRlciA9IHJlYWRlcjtcbiAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgcmVhZGVyLnJlYWQoKS50aGVuKF9yZWY2ID0+IHtcbiAgICAgICAgbGV0IHtcbiAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICBkb25lXG4gICAgICAgIH0gPSBfcmVmNjtcbiAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXIgPSBudWxsO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW5kZXJQYWdlQ2h1bmsodmFsdWUsIGludGVudFN0YXRlKTtcbiAgICAgICAgcHVtcCgpO1xuICAgICAgfSwgcmVhc29uID0+IHtcbiAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICAgICAgaWYgKHRoaXMuX3RyYW5zcG9ydC5kZXN0cm95ZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudFN0YXRlLm9wZXJhdG9yTGlzdCkge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wZXJhdG9yTGlzdC5sYXN0Q2h1bmsgPSB0cnVlO1xuICAgICAgICAgIGZvciAoY29uc3QgaW50ZXJuYWxSZW5kZXJUYXNrIG9mIGludGVudFN0YXRlLnJlbmRlclRhc2tzKSB7XG4gICAgICAgICAgICBpbnRlcm5hbFJlbmRlclRhc2sub3BlcmF0b3JMaXN0Q2hhbmdlZCgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICB0aGlzLiN0cnlDbGVhbnVwKHRydWUpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChpbnRlbnRTdGF0ZS5kaXNwbGF5UmVhZHlDYXBhYmlsaXR5KSB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuZGlzcGxheVJlYWR5Q2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICAgICAgfSBlbHNlIGlmIChpbnRlbnRTdGF0ZS5vcExpc3RSZWFkQ2FwYWJpbGl0eSkge1xuICAgICAgICAgIGludGVudFN0YXRlLm9wTGlzdFJlYWRDYXBhYmlsaXR5LnJlamVjdChyZWFzb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRocm93IHJlYXNvbjtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfTtcbiAgICBwdW1wKCk7XG4gIH1cbiAgX2Fib3J0T3BlcmF0b3JMaXN0KF9yZWY3KSB7XG4gICAgbGV0IHtcbiAgICAgIGludGVudFN0YXRlLFxuICAgICAgcmVhc29uLFxuICAgICAgZm9yY2UgPSBmYWxzZVxuICAgIH0gPSBfcmVmNztcbiAgICBpZiAoIWludGVudFN0YXRlLnN0cmVhbVJlYWRlcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KGludGVudFN0YXRlLnN0cmVhbVJlYWRlckNhbmNlbFRpbWVvdXQpO1xuICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgfVxuICAgIGlmICghZm9yY2UpIHtcbiAgICAgIGlmIChpbnRlbnRTdGF0ZS5yZW5kZXJUYXNrcy5zaXplID4gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVhc29uIGluc3RhbmNlb2YgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKSB7XG4gICAgICAgIGxldCBkZWxheSA9IFJFTkRFUklOR19DQU5DRUxMRURfVElNRU9VVDtcbiAgICAgICAgaWYgKHJlYXNvbi5leHRyYURlbGF5ID4gMCAmJiByZWFzb24uZXh0cmFEZWxheSA8IDEwMDApIHtcbiAgICAgICAgICBkZWxheSArPSByZWFzb24uZXh0cmFEZWxheTtcbiAgICAgICAgfVxuICAgICAgICBpbnRlbnRTdGF0ZS5zdHJlYW1SZWFkZXJDYW5jZWxUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyQ2FuY2VsVGltZW91dCA9IG51bGw7XG4gICAgICAgICAgdGhpcy5fYWJvcnRPcGVyYXRvckxpc3Qoe1xuICAgICAgICAgICAgaW50ZW50U3RhdGUsXG4gICAgICAgICAgICByZWFzb24sXG4gICAgICAgICAgICBmb3JjZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBkZWxheSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyLmNhbmNlbChuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UpKS5jYXRjaCgoKSA9PiB7fSk7XG4gICAgaW50ZW50U3RhdGUuc3RyZWFtUmVhZGVyID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdHJhbnNwb3J0LmRlc3Ryb3llZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IFtjdXJDYWNoZUtleSwgY3VySW50ZW50U3RhdGVdIG9mIHRoaXMuX2ludGVudFN0YXRlcykge1xuICAgICAgaWYgKGN1ckludGVudFN0YXRlID09PSBpbnRlbnRTdGF0ZSkge1xuICAgICAgICB0aGlzLl9pbnRlbnRTdGF0ZXMuZGVsZXRlKGN1ckNhY2hlS2V5KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIHRoaXMuY2xlYW51cCgpO1xuICB9XG4gIGdldCBzdGF0cygpIHtcbiAgICByZXR1cm4gdGhpcy5fc3RhdHM7XG4gIH1cbn1cbmV4cG9ydHMuUERGUGFnZVByb3h5ID0gUERGUGFnZVByb3h5O1xuY2xhc3MgTG9vcGJhY2tQb3J0IHtcbiAgI2xpc3RlbmVycyA9IG5ldyBTZXQoKTtcbiAgI2RlZmVycmVkID0gUHJvbWlzZS5yZXNvbHZlKCk7XG4gIHBvc3RNZXNzYWdlKG9iaiwgdHJhbnNmZXIpIHtcbiAgICBjb25zdCBldmVudCA9IHtcbiAgICAgIGRhdGE6IHN0cnVjdHVyZWRDbG9uZShvYmosIG51bGwpXG4gICAgfTtcbiAgICB0aGlzLiNkZWZlcnJlZC50aGVuKCgpID0+IHtcbiAgICAgIGZvciAoY29uc3QgbGlzdGVuZXIgb2YgdGhpcy4jbGlzdGVuZXJzKSB7XG4gICAgICAgIGxpc3RlbmVyLmNhbGwodGhpcywgZXZlbnQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFkZEV2ZW50TGlzdGVuZXIobmFtZSwgbGlzdGVuZXIpIHtcbiAgICB0aGlzLiNsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgfVxuICByZW1vdmVFdmVudExpc3RlbmVyKG5hbWUsIGxpc3RlbmVyKSB7XG4gICAgdGhpcy4jbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH1cbiAgdGVybWluYXRlKCkge1xuICAgIHRoaXMuI2xpc3RlbmVycy5jbGVhcigpO1xuICB9XG59XG5leHBvcnRzLkxvb3BiYWNrUG9ydCA9IExvb3BiYWNrUG9ydDtcbmNvbnN0IFBERldvcmtlclV0aWwgPSB7XG4gIGlzV29ya2VyRGlzYWJsZWQ6IGZhbHNlLFxuICBmYWxsYmFja1dvcmtlclNyYzogbnVsbCxcbiAgZmFrZVdvcmtlcklkOiAwXG59O1xuZXhwb3J0cy5QREZXb3JrZXJVdGlsID0gUERGV29ya2VyVXRpbDtcbntcbiAgaWYgKF91dGlsLmlzTm9kZUpTICYmIHR5cGVvZiByZXF1aXJlID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICBQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQgPSB0cnVlO1xuICAgIFBERldvcmtlclV0aWwuZmFsbGJhY2tXb3JrZXJTcmMgPSBcIi4vcGRmLndvcmtlci5qc1wiO1xuICB9IGVsc2UgaWYgKHR5cGVvZiBkb2N1bWVudCA9PT0gXCJvYmplY3RcIikge1xuICAgIGNvbnN0IHBkZmpzRmlsZVBhdGggPSBkb2N1bWVudD8uY3VycmVudFNjcmlwdD8uc3JjO1xuICAgIGlmIChwZGZqc0ZpbGVQYXRoKSB7XG4gICAgICBQREZXb3JrZXJVdGlsLmZhbGxiYWNrV29ya2VyU3JjID0gcGRmanNGaWxlUGF0aC5yZXBsYWNlKC8oXFwuKD86bWluXFwuKT9qcykoXFw/LiopPyQvaSwgXCIud29ya2VyJDEkMlwiKTtcbiAgICB9XG4gIH1cbiAgUERGV29ya2VyVXRpbC5pc1NhbWVPcmlnaW4gPSBmdW5jdGlvbiAoYmFzZVVybCwgb3RoZXJVcmwpIHtcbiAgICBsZXQgYmFzZTtcbiAgICB0cnkge1xuICAgICAgYmFzZSA9IG5ldyBVUkwoYmFzZVVybCk7XG4gICAgICBpZiAoIWJhc2Uub3JpZ2luIHx8IGJhc2Uub3JpZ2luID09PSBcIm51bGxcIikge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG90aGVyID0gbmV3IFVSTChvdGhlclVybCwgYmFzZSk7XG4gICAgcmV0dXJuIGJhc2Uub3JpZ2luID09PSBvdGhlci5vcmlnaW47XG4gIH07XG4gIFBERldvcmtlclV0aWwuY3JlYXRlQ0ROV3JhcHBlciA9IGZ1bmN0aW9uICh1cmwpIHtcbiAgICBjb25zdCB3cmFwcGVyID0gYGltcG9ydFNjcmlwdHMoXCIke3VybH1cIik7YDtcbiAgICByZXR1cm4gVVJMLmNyZWF0ZU9iamVjdFVSTChuZXcgQmxvYihbd3JhcHBlcl0pKTtcbiAgfTtcbn1cbmNsYXNzIFBERldvcmtlciB7XG4gIHN0YXRpYyAjd29ya2VyUG9ydHM7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB7XG4gICAgICBuYW1lID0gbnVsbCxcbiAgICAgIHBvcnQgPSBudWxsLFxuICAgICAgdmVyYm9zaXR5ID0gKDAsIF91dGlsLmdldFZlcmJvc2l0eUxldmVsKSgpXG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgdGhpcy5uYW1lID0gbmFtZTtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IGZhbHNlO1xuICAgIHRoaXMudmVyYm9zaXR5ID0gdmVyYm9zaXR5O1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIHRoaXMuX3dlYldvcmtlciA9IG51bGw7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgIGlmIChwb3J0KSB7XG4gICAgICBpZiAoUERGV29ya2VyLiN3b3JrZXJQb3J0cz8uaGFzKHBvcnQpKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCB1c2UgbW9yZSB0aGFuIG9uZSBQREZXb3JrZXIgcGVyIHBvcnQuXCIpO1xuICAgICAgfVxuICAgICAgKFBERldvcmtlci4jd29ya2VyUG9ydHMgfHw9IG5ldyBXZWFrTWFwKCkpLnNldChwb3J0LCB0aGlzKTtcbiAgICAgIHRoaXMuX2luaXRpYWxpemVGcm9tUG9ydChwb3J0KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbGl6ZSgpO1xuICB9XG4gIGdldCBwcm9taXNlKCkge1xuICAgIHJldHVybiB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBnZXQgcG9ydCgpIHtcbiAgICByZXR1cm4gdGhpcy5fcG9ydDtcbiAgfVxuICBnZXQgbWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX21lc3NhZ2VIYW5kbGVyO1xuICB9XG4gIF9pbml0aWFsaXplRnJvbVBvcnQocG9ydCkge1xuICAgIHRoaXMuX3BvcnQgPSBwb3J0O1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoXCJtYWluXCIsIFwid29ya2VyXCIsIHBvcnQpO1xuICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyLm9uKFwicmVhZHlcIiwgZnVuY3Rpb24gKCkge30pO1xuICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgfSk7XG4gIH1cbiAgX2luaXRpYWxpemUoKSB7XG4gICAgaWYgKCFQREZXb3JrZXJVdGlsLmlzV29ya2VyRGlzYWJsZWQgJiYgIVBERldvcmtlci5fbWFpblRocmVhZFdvcmtlck1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICBsZXQge1xuICAgICAgICB3b3JrZXJTcmNcbiAgICAgIH0gPSBQREZXb3JrZXI7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIVBERldvcmtlclV0aWwuaXNTYW1lT3JpZ2luKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB3b3JrZXJTcmMpKSB7XG4gICAgICAgICAgd29ya2VyU3JjID0gUERGV29ya2VyVXRpbC5jcmVhdGVDRE5XcmFwcGVyKG5ldyBVUkwod29ya2VyU3JjLCB3aW5kb3cubG9jYXRpb24pLmhyZWYpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IG5ldyBXb3JrZXIod29ya2VyU3JjKTtcbiAgICAgICAgY29uc3QgbWVzc2FnZUhhbmRsZXIgPSBuZXcgX21lc3NhZ2VfaGFuZGxlci5NZXNzYWdlSGFuZGxlcihcIm1haW5cIiwgXCJ3b3JrZXJcIiwgd29ya2VyKTtcbiAgICAgICAgY29uc3QgdGVybWluYXRlRWFybHkgPSAoKSA9PiB7XG4gICAgICAgICAgd29ya2VyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJlcnJvclwiLCBvbldvcmtlckVycm9yKTtcbiAgICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgd29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlamVjdChuZXcgRXJyb3IoXCJXb3JrZXIgd2FzIGRlc3Ryb3llZFwiKSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3NldHVwRmFrZVdvcmtlcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgb25Xb3JrZXJFcnJvciA9ICgpID0+IHtcbiAgICAgICAgICBpZiAoIXRoaXMuX3dlYldvcmtlcikge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHdvcmtlci5hZGRFdmVudExpc3RlbmVyKFwiZXJyb3JcIiwgb25Xb3JrZXJFcnJvcik7XG4gICAgICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwidGVzdFwiLCBkYXRhID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICAgICAgICB0aGlzLl9wb3J0ID0gd29ya2VyO1xuICAgICAgICAgICAgdGhpcy5fd2ViV29ya2VyID0gd29ya2VyO1xuICAgICAgICAgICAgdGhpcy5fcmVhZHlDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgICAgICAgIG1lc3NhZ2VIYW5kbGVyLnNlbmQoXCJjb25maWd1cmVcIiwge1xuICAgICAgICAgICAgICB2ZXJib3NpdHk6IHRoaXMudmVyYm9zaXR5XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fc2V0dXBGYWtlV29ya2VyKCk7XG4gICAgICAgICAgICBtZXNzYWdlSGFuZGxlci5kZXN0cm95KCk7XG4gICAgICAgICAgICB3b3JrZXIudGVybWluYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZUhhbmRsZXIub24oXCJyZWFkeVwiLCBkYXRhID0+IHtcbiAgICAgICAgICB3b3JrZXIucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImVycm9yXCIsIG9uV29ya2VyRXJyb3IpO1xuICAgICAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICAgICAgdGVybWluYXRlRWFybHkoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHNlbmRUZXN0KCk7XG4gICAgICAgICAgfSBjYXRjaCB7XG4gICAgICAgICAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBzZW5kVGVzdCA9ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB0ZXN0T2JqID0gbmV3IFVpbnQ4QXJyYXkoKTtcbiAgICAgICAgICBtZXNzYWdlSGFuZGxlci5zZW5kKFwidGVzdFwiLCB0ZXN0T2JqLCBbdGVzdE9iai5idWZmZXJdKTtcbiAgICAgICAgfTtcbiAgICAgICAgc2VuZFRlc3QoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgICgwLCBfdXRpbC5pbmZvKShcIlRoZSB3b3JrZXIgaGFzIGJlZW4gZGlzYWJsZWQuXCIpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLl9zZXR1cEZha2VXb3JrZXIoKTtcbiAgfVxuICBfc2V0dXBGYWtlV29ya2VyKCkge1xuICAgIGlmICghUERGV29ya2VyVXRpbC5pc1dvcmtlckRpc2FibGVkKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJTZXR0aW5nIHVwIGZha2Ugd29ya2VyLlwiKTtcbiAgICAgIFBERldvcmtlclV0aWwuaXNXb3JrZXJEaXNhYmxlZCA9IHRydWU7XG4gICAgfVxuICAgIFBERldvcmtlci5fc2V0dXBGYWtlV29ya2VyR2xvYmFsLnRoZW4oV29ya2VyTWVzc2FnZUhhbmRsZXIgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHRoaXMuX3JlYWR5Q2FwYWJpbGl0eS5yZWplY3QobmV3IEVycm9yKFwiV29ya2VyIHdhcyBkZXN0cm95ZWRcIikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCBwb3J0ID0gbmV3IExvb3BiYWNrUG9ydCgpO1xuICAgICAgdGhpcy5fcG9ydCA9IHBvcnQ7XG4gICAgICBjb25zdCBpZCA9IGBmYWtlJHtQREZXb3JrZXJVdGlsLmZha2VXb3JrZXJJZCsrfWA7XG4gICAgICBjb25zdCB3b3JrZXJIYW5kbGVyID0gbmV3IF9tZXNzYWdlX2hhbmRsZXIuTWVzc2FnZUhhbmRsZXIoaWQgKyBcIl93b3JrZXJcIiwgaWQsIHBvcnQpO1xuICAgICAgV29ya2VyTWVzc2FnZUhhbmRsZXIuc2V0dXAod29ya2VySGFuZGxlciwgcG9ydCk7XG4gICAgICBjb25zdCBtZXNzYWdlSGFuZGxlciA9IG5ldyBfbWVzc2FnZV9oYW5kbGVyLk1lc3NhZ2VIYW5kbGVyKGlkLCBpZCArIFwiX3dvcmtlclwiLCBwb3J0KTtcbiAgICAgIHRoaXMuX21lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgbWVzc2FnZUhhbmRsZXIuc2VuZChcImNvbmZpZ3VyZVwiLCB7XG4gICAgICAgIHZlcmJvc2l0eTogdGhpcy52ZXJib3NpdHlcbiAgICAgIH0pO1xuICAgIH0pLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9yZWFkeUNhcGFiaWxpdHkucmVqZWN0KG5ldyBFcnJvcihgU2V0dGluZyB1cCBmYWtlIHdvcmtlciBmYWlsZWQ6IFwiJHtyZWFzb24ubWVzc2FnZX1cIi5gKSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgaWYgKHRoaXMuX3dlYldvcmtlcikge1xuICAgICAgdGhpcy5fd2ViV29ya2VyLnRlcm1pbmF0ZSgpO1xuICAgICAgdGhpcy5fd2ViV29ya2VyID0gbnVsbDtcbiAgICB9XG4gICAgUERGV29ya2VyLiN3b3JrZXJQb3J0cz8uZGVsZXRlKHRoaXMuX3BvcnQpO1xuICAgIHRoaXMuX3BvcnQgPSBudWxsO1xuICAgIGlmICh0aGlzLl9tZXNzYWdlSGFuZGxlcikge1xuICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgdGhpcy5fbWVzc2FnZUhhbmRsZXIgPSBudWxsO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZnJvbVBvcnQocGFyYW1zKSB7XG4gICAgaWYgKCFwYXJhbXM/LnBvcnQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5mcm9tUG9ydCAtIGludmFsaWQgbWV0aG9kIHNpZ25hdHVyZS5cIik7XG4gICAgfVxuICAgIGNvbnN0IGNhY2hlZFBvcnQgPSB0aGlzLiN3b3JrZXJQb3J0cz8uZ2V0KHBhcmFtcy5wb3J0KTtcbiAgICBpZiAoY2FjaGVkUG9ydCkge1xuICAgICAgaWYgKGNhY2hlZFBvcnQuX3BlbmRpbmdEZXN0cm95KSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBERldvcmtlci5mcm9tUG9ydCAtIHRoZSB3b3JrZXIgaXMgYmVpbmcgZGVzdHJveWVkLlxcblwiICsgXCJQbGVhc2UgcmVtZW1iZXIgdG8gYXdhaXQgYFBERkRvY3VtZW50TG9hZGluZ1Rhc2suZGVzdHJveSgpYC1jYWxscy5cIik7XG4gICAgICB9XG4gICAgICByZXR1cm4gY2FjaGVkUG9ydDtcbiAgICB9XG4gICAgcmV0dXJuIG5ldyBQREZXb3JrZXIocGFyYW1zKTtcbiAgfVxuICBzdGF0aWMgZ2V0IHdvcmtlclNyYygpIHtcbiAgICBpZiAoX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjKSB7XG4gICAgICByZXR1cm4gX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjO1xuICAgIH1cbiAgICBpZiAoUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYyAhPT0gbnVsbCkge1xuICAgICAgaWYgKCFfdXRpbC5pc05vZGVKUykge1xuICAgICAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZGVwcmVjYXRlZCkoJ05vIFwiR2xvYmFsV29ya2VyT3B0aW9ucy53b3JrZXJTcmNcIiBzcGVjaWZpZWQuJyk7XG4gICAgICB9XG4gICAgICByZXR1cm4gUERGV29ya2VyVXRpbC5mYWxsYmFja1dvcmtlclNyYztcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdObyBcIkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyU3JjXCIgc3BlY2lmaWVkLicpO1xuICB9XG4gIHN0YXRpYyBnZXQgX21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcigpIHtcbiAgICB0cnkge1xuICAgICAgcmV0dXJuIGdsb2JhbFRoaXMucGRmanNXb3JrZXI/Lldvcmtlck1lc3NhZ2VIYW5kbGVyIHx8IG51bGw7XG4gICAgfSBjYXRjaCB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gIH1cbiAgc3RhdGljIGdldCBfc2V0dXBGYWtlV29ya2VyR2xvYmFsKCkge1xuICAgIGNvbnN0IGxvYWRlciA9IGFzeW5jICgpID0+IHtcbiAgICAgIGNvbnN0IG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlciA9IHRoaXMuX21haW5UaHJlYWRXb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIGlmIChtYWluV29ya2VyTWVzc2FnZUhhbmRsZXIpIHtcbiAgICAgICAgcmV0dXJuIG1haW5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGlmIChfdXRpbC5pc05vZGVKUyAmJiB0eXBlb2YgcmVxdWlyZSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNvbnN0IHdvcmtlciA9IGV2YWwoXCJyZXF1aXJlXCIpKHRoaXMud29ya2VyU3JjKTtcbiAgICAgICAgcmV0dXJuIHdvcmtlci5Xb3JrZXJNZXNzYWdlSGFuZGxlcjtcbiAgICAgIH1cbiAgICAgIGF3YWl0ICgwLCBfZGlzcGxheV91dGlscy5sb2FkU2NyaXB0KSh0aGlzLndvcmtlclNyYyk7XG4gICAgICByZXR1cm4gd2luZG93LnBkZmpzV29ya2VyLldvcmtlck1lc3NhZ2VIYW5kbGVyO1xuICAgIH07XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX3NldHVwRmFrZVdvcmtlckdsb2JhbFwiLCBsb2FkZXIoKSk7XG4gIH1cbn1cbmV4cG9ydHMuUERGV29ya2VyID0gUERGV29ya2VyO1xuY2xhc3MgV29ya2VyVHJhbnNwb3J0IHtcbiAgI21ldGhvZFByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFnZUNhY2hlID0gbmV3IE1hcCgpO1xuICAjcGFnZVByb21pc2VzID0gbmV3IE1hcCgpO1xuICAjcGFzc3dvcmRDYXBhYmlsaXR5ID0gbnVsbDtcbiAgY29uc3RydWN0b3IobWVzc2FnZUhhbmRsZXIsIGxvYWRpbmdUYXNrLCBuZXR3b3JrU3RyZWFtLCBwYXJhbXMsIGZhY3RvcnkpIHtcbiAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbWVzc2FnZUhhbmRsZXI7XG4gICAgdGhpcy5sb2FkaW5nVGFzayA9IGxvYWRpbmdUYXNrO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IG5ldyBQREZPYmplY3RzKCk7XG4gICAgdGhpcy5mb250TG9hZGVyID0gbmV3IF9mb250X2xvYWRlci5Gb250TG9hZGVyKHtcbiAgICAgIG93bmVyRG9jdW1lbnQ6IHBhcmFtcy5vd25lckRvY3VtZW50LFxuICAgICAgc3R5bGVFbGVtZW50OiBwYXJhbXMuc3R5bGVFbGVtZW50XG4gICAgfSk7XG4gICAgdGhpcy5fcGFyYW1zID0gcGFyYW1zO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGZhY3RvcnkuY2FudmFzRmFjdG9yeTtcbiAgICB0aGlzLmZpbHRlckZhY3RvcnkgPSBmYWN0b3J5LmZpbHRlckZhY3Rvcnk7XG4gICAgdGhpcy5jTWFwUmVhZGVyRmFjdG9yeSA9IGZhY3RvcnkuY01hcFJlYWRlckZhY3Rvcnk7XG4gICAgdGhpcy5zdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGZhY3Rvcnkuc3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG4gICAgdGhpcy5kZXN0cm95ZWQgPSBmYWxzZTtcbiAgICB0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5ID0gbnVsbDtcbiAgICB0aGlzLl9uZXR3b3JrU3RyZWFtID0gbmV0d29ya1N0cmVhbTtcbiAgICB0aGlzLl9mdWxsUmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sYXN0UHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuZG93bmxvYWRJbmZvQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuc2V0dXBNZXNzYWdlSGFuZGxlcigpO1xuICB9XG4gICNjYWNoZVNpbXBsZU1ldGhvZChuYW1lKSB7XG4gICAgbGV0IGRhdGEgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgY29uc3QgY2FjaGVkUHJvbWlzZSA9IHRoaXMuI21ldGhvZFByb21pc2VzLmdldChuYW1lKTtcbiAgICBpZiAoY2FjaGVkUHJvbWlzZSkge1xuICAgICAgcmV0dXJuIGNhY2hlZFByb21pc2U7XG4gICAgfVxuICAgIGNvbnN0IHByb21pc2UgPSB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShuYW1lLCBkYXRhKTtcbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5zZXQobmFtZSwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0IGFubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImFubm90YXRpb25TdG9yYWdlXCIsIG5ldyBfYW5ub3RhdGlvbl9zdG9yYWdlLkFubm90YXRpb25TdG9yYWdlKCkpO1xuICB9XG4gIGdldFJlbmRlcmluZ0ludGVudChpbnRlbnQpIHtcbiAgICBsZXQgYW5ub3RhdGlvbk1vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IF91dGlsLkFubm90YXRpb25Nb2RlLkVOQUJMRTtcbiAgICBsZXQgcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogbnVsbDtcbiAgICBsZXQgaXNPcExpc3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IGZhbHNlO1xuICAgIGxldCByZW5kZXJpbmdJbnRlbnQgPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLkRJU1BMQVk7XG4gICAgbGV0IGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlID0gX2Fubm90YXRpb25fc3RvcmFnZS5TZXJpYWxpemFibGVFbXB0eTtcbiAgICBzd2l0Y2ggKGludGVudCkge1xuICAgICAgY2FzZSBcImFueVwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLkFOWTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiZGlzcGxheVwiOlxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJwcmludFwiOlxuICAgICAgICByZW5kZXJpbmdJbnRlbnQgPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLlBSSU5UO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBpbnRlbnQ6ICR7aW50ZW50fWApO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFubm90YXRpb25Nb2RlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Nb2RlLkRJU0FCTEU6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX0RJU0FCTEU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5FTkFCTEU6XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uTW9kZS5FTkFCTEVfRk9STVM6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX0ZPUk1TO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbk1vZGUuRU5BQkxFX1NUT1JBR0U6XG4gICAgICAgIHJlbmRlcmluZ0ludGVudCArPSBfdXRpbC5SZW5kZXJpbmdJbnRlbnRGbGFnLkFOTk9UQVRJT05TX1NUT1JBR0U7XG4gICAgICAgIGNvbnN0IGFubm90YXRpb25TdG9yYWdlID0gcmVuZGVyaW5nSW50ZW50ICYgX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5QUklOVCAmJiBwcmludEFubm90YXRpb25TdG9yYWdlIGluc3RhbmNlb2YgX2Fubm90YXRpb25fc3RvcmFnZS5QcmludEFubm90YXRpb25TdG9yYWdlID8gcHJpbnRBbm5vdGF0aW9uU3RvcmFnZSA6IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlID0gYW5ub3RhdGlvblN0b3JhZ2Uuc2VyaWFsaXphYmxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgZ2V0UmVuZGVyaW5nSW50ZW50IC0gaW52YWxpZCBhbm5vdGF0aW9uTW9kZTogJHthbm5vdGF0aW9uTW9kZX1gKTtcbiAgICB9XG4gICAgaWYgKGlzT3BMaXN0KSB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQgKz0gX3V0aWwuUmVuZGVyaW5nSW50ZW50RmxhZy5PUExJU1Q7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICByZW5kZXJpbmdJbnRlbnQsXG4gICAgICBjYWNoZUtleTogYCR7cmVuZGVyaW5nSW50ZW50fV8ke2Fubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlLmhhc2h9YCxcbiAgICAgIGFubm90YXRpb25TdG9yYWdlU2VyaWFsaXphYmxlXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLmRlc3Ryb3lDYXBhYmlsaXR5KSB7XG4gICAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLmRlc3Ryb3llZCA9IHRydWU7XG4gICAgdGhpcy5kZXN0cm95Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eT8ucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkIGR1cmluZyBvblBhc3N3b3JkIGNhbGxiYWNrXCIpKTtcbiAgICBjb25zdCB3YWl0T24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICB3YWl0T24ucHVzaChwYWdlLl9kZXN0cm95KCkpO1xuICAgIH1cbiAgICB0aGlzLiNwYWdlQ2FjaGUuY2xlYXIoKTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5oYXNPd25Qcm9wZXJ0eShcImFubm90YXRpb25TdG9yYWdlXCIpKSB7XG4gICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnJlc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgY29uc3QgdGVybWluYXRlZCA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiVGVybWluYXRlXCIsIG51bGwpO1xuICAgIHdhaXRPbi5wdXNoKHRlcm1pbmF0ZWQpO1xuICAgIFByb21pc2UuYWxsKHdhaXRPbikudGhlbigoKSA9PiB7XG4gICAgICB0aGlzLmNvbW1vbk9ianMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgICAgdGhpcy4jbWV0aG9kUHJvbWlzZXMuY2xlYXIoKTtcbiAgICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9uZXR3b3JrU3RyZWFtPy5jYW5jZWxBbGxSZXF1ZXN0cyhuZXcgX3V0aWwuQWJvcnRFeGNlcHRpb24oXCJXb3JrZXIgd2FzIHRlcm1pbmF0ZWQuXCIpKTtcbiAgICAgIGlmICh0aGlzLm1lc3NhZ2VIYW5kbGVyKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZUhhbmRsZXIuZGVzdHJveSgpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VIYW5kbGVyID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0sIHRoaXMuZGVzdHJveUNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICByZXR1cm4gdGhpcy5kZXN0cm95Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIHNldHVwTWVzc2FnZUhhbmRsZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgbWVzc2FnZUhhbmRsZXIsXG4gICAgICBsb2FkaW5nVGFza1xuICAgIH0gPSB0aGlzO1xuICAgIG1lc3NhZ2VIYW5kbGVyLm9uKFwiR2V0UmVhZGVyXCIsIChkYXRhLCBzaW5rKSA9PiB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh0aGlzLl9uZXR3b3JrU3RyZWFtLCBcIkdldFJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlciA9IHRoaXMuX25ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlcigpO1xuICAgICAgdGhpcy5fZnVsbFJlYWRlci5vblByb2dyZXNzID0gZXZ0ID0+IHtcbiAgICAgICAgdGhpcy5fbGFzdFByb2dyZXNzID0ge1xuICAgICAgICAgIGxvYWRlZDogZXZ0LmxvYWRlZCxcbiAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgIH07XG4gICAgICB9O1xuICAgICAgc2luay5vblB1bGwgPSAoKSA9PiB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWY4KSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZG9uZVxuICAgICAgICAgIH0gPSBfcmVmODtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJlYWRlciAtIGV4cGVjdGVkIGFuIEFycmF5QnVmZmVyLlwiKTtcbiAgICAgICAgICBzaW5rLmVucXVldWUobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCAxLCBbdmFsdWVdKTtcbiAgICAgICAgfSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgICAgICBzaW5rLmVycm9yKHJlYXNvbik7XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICAgIHNpbmsub25DYW5jZWwgPSByZWFzb24gPT4ge1xuICAgICAgICB0aGlzLl9mdWxsUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIlJlYWRlckhlYWRlcnNSZWFkeVwiLCBkYXRhID0+IHtcbiAgICAgIGNvbnN0IGhlYWRlcnNDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICBjb25zdCBmdWxsUmVhZGVyID0gdGhpcy5fZnVsbFJlYWRlcjtcbiAgICAgIGZ1bGxSZWFkZXIuaGVhZGVyc1JlYWR5LnRoZW4oKCkgPT4ge1xuICAgICAgICBpZiAoIWZ1bGxSZWFkZXIuaXNTdHJlYW1pbmdTdXBwb3J0ZWQgfHwgIWZ1bGxSZWFkZXIuaXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgICAgIGlmICh0aGlzLl9sYXN0UHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih0aGlzLl9sYXN0UHJvZ3Jlc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmdWxsUmVhZGVyLm9uUHJvZ3Jlc3MgPSBldnQgPT4ge1xuICAgICAgICAgICAgbG9hZGluZ1Rhc2sub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGhlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIGlzU3RyZWFtaW5nU3VwcG9ydGVkOiBmdWxsUmVhZGVyLmlzU3RyZWFtaW5nU3VwcG9ydGVkLFxuICAgICAgICAgIGlzUmFuZ2VTdXBwb3J0ZWQ6IGZ1bGxSZWFkZXIuaXNSYW5nZVN1cHBvcnRlZCxcbiAgICAgICAgICBjb250ZW50TGVuZ3RoOiBmdWxsUmVhZGVyLmNvbnRlbnRMZW5ndGhcbiAgICAgICAgfSk7XG4gICAgICB9LCBoZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QpO1xuICAgICAgcmV0dXJuIGhlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJHZXRSYW5nZVJlYWRlclwiLCAoZGF0YSwgc2luaykgPT4ge1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkodGhpcy5fbmV0d29ya1N0cmVhbSwgXCJHZXRSYW5nZVJlYWRlciAtIG5vIGBJUERGU3RyZWFtYCBpbnN0YW5jZSBhdmFpbGFibGUuXCIpO1xuICAgICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLl9uZXR3b3JrU3RyZWFtLmdldFJhbmdlUmVhZGVyKGRhdGEuYmVnaW4sIGRhdGEuZW5kKTtcbiAgICAgIGlmICghcmFuZ2VSZWFkZXIpIHtcbiAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzaW5rLm9uUHVsbCA9ICgpID0+IHtcbiAgICAgICAgcmFuZ2VSZWFkZXIucmVhZCgpLnRoZW4oZnVuY3Rpb24gKF9yZWY5KSB7XG4gICAgICAgICAgbGV0IHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgZG9uZVxuICAgICAgICAgIH0gPSBfcmVmOTtcbiAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgc2luay5jbG9zZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KSh2YWx1ZSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyLCBcIkdldFJhbmdlUmVhZGVyIC0gZXhwZWN0ZWQgYW4gQXJyYXlCdWZmZXIuXCIpO1xuICAgICAgICAgIHNpbmsuZW5xdWV1ZShuZXcgVWludDhBcnJheSh2YWx1ZSksIDEsIFt2YWx1ZV0pO1xuICAgICAgICB9KS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgICAgIHNpbmsuZXJyb3IocmVhc29uKTtcbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgICAgc2luay5vbkNhbmNlbCA9IHJlYXNvbiA9PiB7XG4gICAgICAgIHJhbmdlUmVhZGVyLmNhbmNlbChyZWFzb24pO1xuICAgICAgICBzaW5rLnJlYWR5LmNhdGNoKHJlYWR5UmVhc29uID0+IHtcbiAgICAgICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgdGhyb3cgcmVhZHlSZWFzb247XG4gICAgICAgIH0pO1xuICAgICAgfTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkdldERvY1wiLCBfcmVmMTAgPT4ge1xuICAgICAgbGV0IHtcbiAgICAgICAgcGRmSW5mb1xuICAgICAgfSA9IF9yZWYxMDtcbiAgICAgIHRoaXMuX251bVBhZ2VzID0gcGRmSW5mby5udW1QYWdlcztcbiAgICAgIHRoaXMuX2h0bWxGb3JYZmEgPSBwZGZJbmZvLmh0bWxGb3JYZmE7XG4gICAgICBkZWxldGUgcGRmSW5mby5odG1sRm9yWGZhO1xuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVzb2x2ZShuZXcgUERGRG9jdW1lbnRQcm94eShwZGZJbmZvLCB0aGlzKSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJEb2NFeGNlcHRpb25cIiwgZnVuY3Rpb24gKGV4KSB7XG4gICAgICBsZXQgcmVhc29uO1xuICAgICAgc3dpdGNoIChleC5uYW1lKSB7XG4gICAgICAgIGNhc2UgXCJQYXNzd29yZEV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5QYXNzd29yZEV4Y2VwdGlvbihleC5tZXNzYWdlLCBleC5jb2RlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkludmFsaWRQREZFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuSW52YWxpZFBERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1pc3NpbmdQREZFeGNlcHRpb25cIjpcbiAgICAgICAgICByZWFzb24gPSBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihleC5tZXNzYWdlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguc3RhdHVzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlVua25vd25FcnJvckV4Y2VwdGlvblwiOlxuICAgICAgICAgIHJlYXNvbiA9IG5ldyBfdXRpbC5Vbmtub3duRXJyb3JFeGNlcHRpb24oZXgubWVzc2FnZSwgZXguZGV0YWlscyk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkRvY0V4Y2VwdGlvbiAtIGV4cGVjdGVkIGEgdmFsaWQgRXJyb3IuXCIpO1xuICAgICAgfVxuICAgICAgbG9hZGluZ1Rhc2suX2NhcGFiaWxpdHkucmVqZWN0KHJlYXNvbik7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJQYXNzd29yZFJlcXVlc3RcIiwgZXhjZXB0aW9uID0+IHtcbiAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgaWYgKGxvYWRpbmdUYXNrLm9uUGFzc3dvcmQpIHtcbiAgICAgICAgY29uc3QgdXBkYXRlUGFzc3dvcmQgPSBwYXNzd29yZCA9PiB7XG4gICAgICAgICAgaWYgKHBhc3N3b3JkIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QocGFzc3dvcmQpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgICAgIHBhc3N3b3JkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgbG9hZGluZ1Rhc2sub25QYXNzd29yZCh1cGRhdGVQYXNzd29yZCwgZXhjZXB0aW9uLmNvZGUpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIHRoaXMuI3Bhc3N3b3JkQ2FwYWJpbGl0eS5yZWplY3QoZXgpO1xuICAgICAgICB9XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucmVqZWN0KG5ldyBfdXRpbC5QYXNzd29yZEV4Y2VwdGlvbihleGNlcHRpb24ubWVzc2FnZSwgZXhjZXB0aW9uLmNvZGUpKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLiNwYXNzd29yZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRhdGFMb2FkZWRcIiwgZGF0YSA9PiB7XG4gICAgICBsb2FkaW5nVGFzay5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGRhdGEubGVuZ3RoLFxuICAgICAgICB0b3RhbDogZGF0YS5sZW5ndGhcbiAgICAgIH0pO1xuICAgICAgdGhpcy5kb3dubG9hZEluZm9DYXBhYmlsaXR5LnJlc29sdmUoZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJTdGFydFJlbmRlclBhZ2VcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQoZGF0YS5wYWdlSW5kZXgpO1xuICAgICAgcGFnZS5fc3RhcnRSZW5kZXJQYWdlKGRhdGEudHJhbnNwYXJlbmN5LCBkYXRhLmNhY2hlS2V5KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcImNvbW1vbm9ialwiLCBfcmVmMTEgPT4ge1xuICAgICAgbGV0IFtpZCwgdHlwZSwgZXhwb3J0ZWREYXRhXSA9IF9yZWYxMTtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb21tb25PYmpzLmhhcyhpZCkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgY29uc3QgcGFyYW1zID0gdGhpcy5fcGFyYW1zO1xuICAgICAgICAgIGlmIChcImVycm9yXCIgaW4gZXhwb3J0ZWREYXRhKSB7XG4gICAgICAgICAgICBjb25zdCBleHBvcnRlZEVycm9yID0gZXhwb3J0ZWREYXRhLmVycm9yO1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBFcnJvciBkdXJpbmcgZm9udCBsb2FkaW5nOiAke2V4cG9ydGVkRXJyb3J9YCk7XG4gICAgICAgICAgICB0aGlzLmNvbW1vbk9ianMucmVzb2x2ZShpZCwgZXhwb3J0ZWRFcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgaW5zcGVjdEZvbnQgPSBwYXJhbXMucGRmQnVnICYmIGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvcj8uZW5hYmxlZCA/IChmb250LCB1cmwpID0+IGdsb2JhbFRoaXMuRm9udEluc3BlY3Rvci5mb250QWRkZWQoZm9udCwgdXJsKSA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZm9udCA9IG5ldyBfZm9udF9sb2FkZXIuRm9udEZhY2VPYmplY3QoZXhwb3J0ZWREYXRhLCB7XG4gICAgICAgICAgICBpc0V2YWxTdXBwb3J0ZWQ6IHBhcmFtcy5pc0V2YWxTdXBwb3J0ZWQsXG4gICAgICAgICAgICBkaXNhYmxlRm9udEZhY2U6IHBhcmFtcy5kaXNhYmxlRm9udEZhY2UsXG4gICAgICAgICAgICBpZ25vcmVFcnJvcnM6IHBhcmFtcy5pZ25vcmVFcnJvcnMsXG4gICAgICAgICAgICBpbnNwZWN0Rm9udFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuZm9udExvYWRlci5iaW5kKGZvbnQpLmNhdGNoKHJlYXNvbiA9PiB7XG4gICAgICAgICAgICByZXR1cm4gbWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiRm9udEZhbGxiYWNrXCIsIHtcbiAgICAgICAgICAgICAgaWRcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgICAgaWYgKCFwYXJhbXMuZm9udEV4dHJhUHJvcGVydGllcyAmJiBmb250LmRhdGEpIHtcbiAgICAgICAgICAgICAgZm9udC5kYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBmb250KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRQYXRoXCI6XG4gICAgICAgIGNhc2UgXCJJbWFnZVwiOlxuICAgICAgICBjYXNlIFwiUGF0dGVyblwiOlxuICAgICAgICAgIHRoaXMuY29tbW9uT2Jqcy5yZXNvbHZlKGlkLCBleHBvcnRlZERhdGEpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgR290IHVua25vd24gY29tbW9uIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIm9ialwiLCBfcmVmMTIgPT4ge1xuICAgICAgbGV0IFtpZCwgcGFnZUluZGV4LCB0eXBlLCBpbWFnZURhdGFdID0gX3JlZjEyO1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhZ2VQcm94eSA9IHRoaXMuI3BhZ2VDYWNoZS5nZXQocGFnZUluZGV4KTtcbiAgICAgIGlmIChwYWdlUHJveHkub2Jqcy5oYXMoaWQpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICBjYXNlIFwiSW1hZ2VcIjpcbiAgICAgICAgICBwYWdlUHJveHkub2Jqcy5yZXNvbHZlKGlkLCBpbWFnZURhdGEpO1xuICAgICAgICAgIGlmIChpbWFnZURhdGEpIHtcbiAgICAgICAgICAgIGxldCBsZW5ndGg7XG4gICAgICAgICAgICBpZiAoaW1hZ2VEYXRhLmJpdG1hcCkge1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgd2lkdGgsXG4gICAgICAgICAgICAgICAgaGVpZ2h0XG4gICAgICAgICAgICAgIH0gPSBpbWFnZURhdGE7XG4gICAgICAgICAgICAgIGxlbmd0aCA9IHdpZHRoICogaGVpZ2h0ICogNDtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIGxlbmd0aCA9IGltYWdlRGF0YS5kYXRhPy5sZW5ndGggfHwgMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChsZW5ndGggPiBfdXRpbC5NQVhfSU1BR0VfU0laRV9UT19DQUNIRSkge1xuICAgICAgICAgICAgICBwYWdlUHJveHkuX21heWJlQ2xlYW51cEFmdGVyUmVuZGVyID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJQYXR0ZXJuXCI6XG4gICAgICAgICAgcGFnZVByb3h5Lm9ianMucmVzb2x2ZShpZCwgaW1hZ2VEYXRhKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYEdvdCB1bmtub3duIG9iamVjdCB0eXBlICR7dHlwZX1gKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkRvY1Byb2dyZXNzXCIsIGRhdGEgPT4ge1xuICAgICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxvYWRpbmdUYXNrLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICAgIGxvYWRlZDogZGF0YS5sb2FkZWQsXG4gICAgICAgIHRvdGFsOiBkYXRhLnRvdGFsXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBtZXNzYWdlSGFuZGxlci5vbihcIkZldGNoQnVpbHRJbkNNYXBcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuY01hcFJlYWRlckZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkNNYXBSZWFkZXJGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuY01hcFJlYWRlckZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gICAgbWVzc2FnZUhhbmRsZXIub24oXCJGZXRjaFN0YW5kYXJkRm9udERhdGFcIiwgZGF0YSA9PiB7XG4gICAgICBpZiAodGhpcy5kZXN0cm95ZWQpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIldvcmtlciB3YXMgZGVzdHJveWVkLlwiKSk7XG4gICAgICB9XG4gICAgICBpZiAoIXRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkpIHtcbiAgICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIlN0YW5kYXJkRm9udERhdGFGYWN0b3J5IG5vdCBpbml0aWFsaXplZCwgc2VlIHRoZSBgdXNlV29ya2VyRmV0Y2hgIHBhcmFtZXRlci5cIikpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuc3RhbmRhcmRGb250RGF0YUZhY3RvcnkuZmV0Y2goZGF0YSk7XG4gICAgfSk7XG4gIH1cbiAgZ2V0RGF0YSgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREYXRhXCIsIG51bGwpO1xuICB9XG4gIHNhdmVEb2N1bWVudCgpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zaXplIDw9IDApIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcInNhdmVEb2N1bWVudCBjYWxsZWQgd2hpbGUgYGFubm90YXRpb25TdG9yYWdlYCBpcyBlbXB0eSwgXCIgKyBcInBsZWFzZSB1c2UgdGhlIGdldERhdGEtbWV0aG9kIGluc3RlYWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBtYXAsXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9ID0gdGhpcy5hbm5vdGF0aW9uU3RvcmFnZS5zZXJpYWxpemFibGU7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiU2F2ZURvY3VtZW50XCIsIHtcbiAgICAgIGlzUHVyZVhmYTogISF0aGlzLl9odG1sRm9yWGZhLFxuICAgICAgbnVtUGFnZXM6IHRoaXMuX251bVBhZ2VzLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IG1hcCxcbiAgICAgIGZpbGVuYW1lOiB0aGlzLl9mdWxsUmVhZGVyPy5maWxlbmFtZSA/PyBudWxsXG4gICAgfSwgdHJhbnNmZXJzKS5maW5hbGx5KCgpID0+IHtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UucmVzZXRNb2RpZmllZCgpO1xuICAgIH0pO1xuICB9XG4gIGdldFBhZ2UocGFnZU51bWJlcikge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihwYWdlTnVtYmVyKSB8fCBwYWdlTnVtYmVyIDw9IDAgfHwgcGFnZU51bWJlciA+IHRoaXMuX251bVBhZ2VzKSB7XG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QobmV3IEVycm9yKFwiSW52YWxpZCBwYWdlIHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgY29uc3QgcGFnZUluZGV4ID0gcGFnZU51bWJlciAtIDEsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jcGFnZVByb21pc2VzLmdldChwYWdlSW5kZXgpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KS50aGVuKHBhZ2VJbmZvID0+IHtcbiAgICAgIGlmICh0aGlzLmRlc3Ryb3llZCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUcmFuc3BvcnQgZGVzdHJveWVkXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgcGFnZSA9IG5ldyBQREZQYWdlUHJveHkocGFnZUluZGV4LCBwYWdlSW5mbywgdGhpcywgdGhpcy5fcGFyYW1zLnBkZkJ1Zyk7XG4gICAgICB0aGlzLiNwYWdlQ2FjaGUuc2V0KHBhZ2VJbmRleCwgcGFnZSk7XG4gICAgICByZXR1cm4gcGFnZTtcbiAgICB9KTtcbiAgICB0aGlzLiNwYWdlUHJvbWlzZXMuc2V0KHBhZ2VJbmRleCwgcHJvbWlzZSk7XG4gICAgcmV0dXJuIHByb21pc2U7XG4gIH1cbiAgZ2V0UGFnZUluZGV4KHJlZikge1xuICAgIGlmICh0eXBlb2YgcmVmICE9PSBcIm9iamVjdFwiIHx8IHJlZiA9PT0gbnVsbCB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZWYubnVtKSB8fCByZWYubnVtIDwgMCB8fCAhTnVtYmVyLmlzSW50ZWdlcihyZWYuZ2VuKSB8fCByZWYuZ2VuIDwgMCkge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgcGFnZUluZGV4IHJlcXVlc3QuXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUluZGV4XCIsIHtcbiAgICAgIG51bTogcmVmLm51bSxcbiAgICAgIGdlbjogcmVmLmdlblxuICAgIH0pO1xuICB9XG4gIGdldEFubm90YXRpb25zKHBhZ2VJbmRleCwgaW50ZW50KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0QW5ub3RhdGlvbnNcIiwge1xuICAgICAgcGFnZUluZGV4LFxuICAgICAgaW50ZW50XG4gICAgfSk7XG4gIH1cbiAgZ2V0RmllbGRPYmplY3RzKCkge1xuICAgIHJldHVybiB0aGlzLiNjYWNoZVNpbXBsZU1ldGhvZChcIkdldEZpZWxkT2JqZWN0c1wiKTtcbiAgfVxuICBoYXNKU0FjdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NhY2hlU2ltcGxlTWV0aG9kKFwiSGFzSlNBY3Rpb25zXCIpO1xuICB9XG4gIGdldENhbGN1bGF0aW9uT3JkZXJJZHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Q2FsY3VsYXRpb25PcmRlcklkc1wiLCBudWxsKTtcbiAgfVxuICBnZXREZXN0aW5hdGlvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0RGVzdGluYXRpb25zXCIsIG51bGwpO1xuICB9XG4gIGdldERlc3RpbmF0aW9uKGlkKSB7XG4gICAgaWYgKHR5cGVvZiBpZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIFByb21pc2UucmVqZWN0KG5ldyBFcnJvcihcIkludmFsaWQgZGVzdGluYXRpb24gcmVxdWVzdC5cIikpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXREZXN0aW5hdGlvblwiLCB7XG4gICAgICBpZFxuICAgIH0pO1xuICB9XG4gIGdldFBhZ2VMYWJlbHMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZUxhYmVsc1wiLCBudWxsKTtcbiAgfVxuICBnZXRQYWdlTGF5b3V0KCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBhZ2VMYXlvdXRcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0UGFnZU1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0UGFnZU1vZGVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0Vmlld2VyUHJlZmVyZW5jZXMoKSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0Vmlld2VyUHJlZmVyZW5jZXNcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3BlbkFjdGlvbigpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRPcGVuQWN0aW9uXCIsIG51bGwpO1xuICB9XG4gIGdldEF0dGFjaG1lbnRzKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldEF0dGFjaG1lbnRzXCIsIG51bGwpO1xuICB9XG4gIGdldERvY0pTQWN0aW9ucygpIHtcbiAgICByZXR1cm4gdGhpcy4jY2FjaGVTaW1wbGVNZXRob2QoXCJHZXREb2NKU0FjdGlvbnNcIik7XG4gIH1cbiAgZ2V0UGFnZUpTQWN0aW9ucyhwYWdlSW5kZXgpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRQYWdlSlNBY3Rpb25zXCIsIHtcbiAgICAgIHBhZ2VJbmRleFxuICAgIH0pO1xuICB9XG4gIGdldFN0cnVjdFRyZWUocGFnZUluZGV4KSB7XG4gICAgcmV0dXJuIHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiR2V0U3RydWN0VHJlZVwiLCB7XG4gICAgICBwYWdlSW5kZXhcbiAgICB9KTtcbiAgfVxuICBnZXRPdXRsaW5lKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE91dGxpbmVcIiwgbnVsbCk7XG4gIH1cbiAgZ2V0T3B0aW9uYWxDb250ZW50Q29uZmlnKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldE9wdGlvbmFsQ29udGVudENvbmZpZ1wiLCBudWxsKS50aGVuKHJlc3VsdHMgPT4ge1xuICAgICAgcmV0dXJuIG5ldyBfb3B0aW9uYWxfY29udGVudF9jb25maWcuT3B0aW9uYWxDb250ZW50Q29uZmlnKHJlc3VsdHMpO1xuICAgIH0pO1xuICB9XG4gIGdldFBlcm1pc3Npb25zKCkge1xuICAgIHJldHVybiB0aGlzLm1lc3NhZ2VIYW5kbGVyLnNlbmRXaXRoUHJvbWlzZShcIkdldFBlcm1pc3Npb25zXCIsIG51bGwpO1xuICB9XG4gIGdldE1ldGFkYXRhKCkge1xuICAgIGNvbnN0IG5hbWUgPSBcIkdldE1ldGFkYXRhXCIsXG4gICAgICBjYWNoZWRQcm9taXNlID0gdGhpcy4jbWV0aG9kUHJvbWlzZXMuZ2V0KG5hbWUpO1xuICAgIGlmIChjYWNoZWRQcm9taXNlKSB7XG4gICAgICByZXR1cm4gY2FjaGVkUHJvbWlzZTtcbiAgICB9XG4gICAgY29uc3QgcHJvbWlzZSA9IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKG5hbWUsIG51bGwpLnRoZW4ocmVzdWx0cyA9PiB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBpbmZvOiByZXN1bHRzWzBdLFxuICAgICAgICBtZXRhZGF0YTogcmVzdWx0c1sxXSA/IG5ldyBfbWV0YWRhdGEuTWV0YWRhdGEocmVzdWx0c1sxXSkgOiBudWxsLFxuICAgICAgICBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTogdGhpcy5fZnVsbFJlYWRlcj8uZmlsZW5hbWUgPz8gbnVsbCxcbiAgICAgICAgY29udGVudExlbmd0aDogdGhpcy5fZnVsbFJlYWRlcj8uY29udGVudExlbmd0aCA/PyBudWxsXG4gICAgICB9O1xuICAgIH0pO1xuICAgIHRoaXMuI21ldGhvZFByb21pc2VzLnNldChuYW1lLCBwcm9taXNlKTtcbiAgICByZXR1cm4gcHJvbWlzZTtcbiAgfVxuICBnZXRNYXJrSW5mbygpIHtcbiAgICByZXR1cm4gdGhpcy5tZXNzYWdlSGFuZGxlci5zZW5kV2l0aFByb21pc2UoXCJHZXRNYXJrSW5mb1wiLCBudWxsKTtcbiAgfVxuICBhc3luYyBzdGFydENsZWFudXAoKSB7XG4gICAgbGV0IGtlZXBMb2FkZWRGb250cyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgaWYgKHRoaXMuZGVzdHJveWVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGF3YWl0IHRoaXMubWVzc2FnZUhhbmRsZXIuc2VuZFdpdGhQcm9taXNlKFwiQ2xlYW51cFwiLCBudWxsKTtcbiAgICBmb3IgKGNvbnN0IHBhZ2Ugb2YgdGhpcy4jcGFnZUNhY2hlLnZhbHVlcygpKSB7XG4gICAgICBjb25zdCBjbGVhbnVwU3VjY2Vzc2Z1bCA9IHBhZ2UuY2xlYW51cCgpO1xuICAgICAgaWYgKCFjbGVhbnVwU3VjY2Vzc2Z1bCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYHN0YXJ0Q2xlYW51cDogUGFnZSAke3BhZ2UucGFnZU51bWJlcn0gaXMgY3VycmVudGx5IHJlbmRlcmluZy5gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb21tb25PYmpzLmNsZWFyKCk7XG4gICAgaWYgKCFrZWVwTG9hZGVkRm9udHMpIHtcbiAgICAgIHRoaXMuZm9udExvYWRlci5jbGVhcigpO1xuICAgIH1cbiAgICB0aGlzLiNtZXRob2RQcm9taXNlcy5jbGVhcigpO1xuICAgIHRoaXMuZmlsdGVyRmFjdG9yeS5kZXN0cm95KHRydWUpO1xuICB9XG4gIGdldCBsb2FkaW5nUGFyYW1zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpc2FibGVBdXRvRmV0Y2gsXG4gICAgICBlbmFibGVYZmFcbiAgICB9ID0gdGhpcy5fcGFyYW1zO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImxvYWRpbmdQYXJhbXNcIiwge1xuICAgICAgZGlzYWJsZUF1dG9GZXRjaCxcbiAgICAgIGVuYWJsZVhmYVxuICAgIH0pO1xuICB9XG59XG5jbGFzcyBQREZPYmplY3RzIHtcbiAgI29ianMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAjZW5zdXJlT2JqKG9iaklkKSB7XG4gICAgcmV0dXJuIHRoaXMuI29ianNbb2JqSWRdIHx8PSB7XG4gICAgICBjYXBhYmlsaXR5OiBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKSxcbiAgICAgIGRhdGE6IG51bGxcbiAgICB9O1xuICB9XG4gIGdldChvYmpJZCkge1xuICAgIGxldCBjYWxsYmFjayA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgIGNvbnN0IG9iaiA9IHRoaXMuI2Vuc3VyZU9iaihvYmpJZCk7XG4gICAgICBvYmouY2FwYWJpbGl0eS5wcm9taXNlLnRoZW4oKCkgPT4gY2FsbGJhY2sob2JqLmRhdGEpKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBvYmogPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICBpZiAoIW9iaj8uY2FwYWJpbGl0eS5zZXR0bGVkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYFJlcXVlc3Rpbmcgb2JqZWN0IHRoYXQgaXNuJ3QgcmVzb2x2ZWQgeWV0ICR7b2JqSWR9LmApO1xuICAgIH1cbiAgICByZXR1cm4gb2JqLmRhdGE7XG4gIH1cbiAgaGFzKG9iaklkKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jb2Jqc1tvYmpJZF07XG4gICAgcmV0dXJuIG9iaj8uY2FwYWJpbGl0eS5zZXR0bGVkIHx8IGZhbHNlO1xuICB9XG4gIHJlc29sdmUob2JqSWQpIHtcbiAgICBsZXQgZGF0YSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICBjb25zdCBvYmogPSB0aGlzLiNlbnN1cmVPYmoob2JqSWQpO1xuICAgIG9iai5kYXRhID0gZGF0YTtcbiAgICBvYmouY2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgY2xlYXIoKSB7XG4gICAgZm9yIChjb25zdCBvYmpJZCBpbiB0aGlzLiNvYmpzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGFcbiAgICAgIH0gPSB0aGlzLiNvYmpzW29iaklkXTtcbiAgICAgIGRhdGE/LmJpdG1hcD8uY2xvc2UoKTtcbiAgICB9XG4gICAgdGhpcy4jb2JqcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbn1cbmNsYXNzIFJlbmRlclRhc2sge1xuICAjaW50ZXJuYWxSZW5kZXJUYXNrID0gbnVsbDtcbiAgY29uc3RydWN0b3IoaW50ZXJuYWxSZW5kZXJUYXNrKSB7XG4gICAgdGhpcy4jaW50ZXJuYWxSZW5kZXJUYXNrID0gaW50ZXJuYWxSZW5kZXJUYXNrO1xuICAgIHRoaXMub25Db250aW51ZSA9IG51bGw7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKCkge1xuICAgIGxldCBleHRyYURlbGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAwO1xuICAgIHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5jYW5jZWwobnVsbCwgZXh0cmFEZWxheSk7XG4gIH1cbiAgZ2V0IHNlcGFyYXRlQW5ub3RzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHNlcGFyYXRlQW5ub3RzXG4gICAgfSA9IHRoaXMuI2ludGVybmFsUmVuZGVyVGFzay5vcGVyYXRvckxpc3Q7XG4gICAgaWYgKCFzZXBhcmF0ZUFubm90cykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwXG4gICAgfSA9IHRoaXMuI2ludGVybmFsUmVuZGVyVGFzaztcbiAgICByZXR1cm4gc2VwYXJhdGVBbm5vdHMuZm9ybSB8fCBzZXBhcmF0ZUFubm90cy5jYW52YXMgJiYgYW5ub3RhdGlvbkNhbnZhc01hcD8uc2l6ZSA+IDA7XG4gIH1cbn1cbmV4cG9ydHMuUmVuZGVyVGFzayA9IFJlbmRlclRhc2s7XG5jbGFzcyBJbnRlcm5hbFJlbmRlclRhc2sge1xuICBzdGF0aWMgI2NhbnZhc0luVXNlID0gbmV3IFdlYWtTZXQoKTtcbiAgY29uc3RydWN0b3IoX3JlZjEzKSB7XG4gICAgbGV0IHtcbiAgICAgIGNhbGxiYWNrLFxuICAgICAgcGFyYW1zLFxuICAgICAgb2JqcyxcbiAgICAgIGNvbW1vbk9ianMsXG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgICAgb3BlcmF0b3JMaXN0LFxuICAgICAgcGFnZUluZGV4LFxuICAgICAgY2FudmFzRmFjdG9yeSxcbiAgICAgIGZpbHRlckZhY3RvcnksXG4gICAgICB1c2VSZXF1ZXN0QW5pbWF0aW9uRnJhbWUgPSBmYWxzZSxcbiAgICAgIHBkZkJ1ZyA9IGZhbHNlLFxuICAgICAgcGFnZUNvbG9ycyA9IG51bGxcbiAgICB9ID0gX3JlZjEzO1xuICAgIHRoaXMuY2FsbGJhY2sgPSBjYWxsYmFjaztcbiAgICB0aGlzLnBhcmFtcyA9IHBhcmFtcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IG51bGw7XG4gICAgdGhpcy5vcGVyYXRvckxpc3QgPSBvcGVyYXRvckxpc3Q7XG4gICAgdGhpcy5fcGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLl9wZGZCdWcgPSBwZGZCdWc7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLnJ1bm5pbmcgPSBmYWxzZTtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHlDYWxsYmFjayA9IG51bGw7XG4gICAgdGhpcy5ncmFwaGljc1JlYWR5ID0gZmFsc2U7XG4gICAgdGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID0gdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lID09PSB0cnVlICYmIHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCI7XG4gICAgdGhpcy5jYW5jZWxsZWQgPSBmYWxzZTtcbiAgICB0aGlzLmNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLnRhc2sgPSBuZXcgUmVuZGVyVGFzayh0aGlzKTtcbiAgICB0aGlzLl9jYW5jZWxCb3VuZCA9IHRoaXMuY2FuY2VsLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY29udGludWVCb3VuZCA9IHRoaXMuX2NvbnRpbnVlLmJpbmQodGhpcyk7XG4gICAgdGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQgPSB0aGlzLl9zY2hlZHVsZU5leHQuYmluZCh0aGlzKTtcbiAgICB0aGlzLl9uZXh0Qm91bmQgPSB0aGlzLl9uZXh0LmJpbmQodGhpcyk7XG4gICAgdGhpcy5fY2FudmFzID0gcGFyYW1zLmNhbnZhc0NvbnRleHQuY2FudmFzO1xuICB9XG4gIGdldCBjb21wbGV0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY2FwYWJpbGl0eS5wcm9taXNlLmNhdGNoKGZ1bmN0aW9uICgpIHt9KTtcbiAgfVxuICBpbml0aWFsaXplR3JhcGhpY3MoX3JlZjE0KSB7XG4gICAgbGV0IHtcbiAgICAgIHRyYW5zcGFyZW5jeSA9IGZhbHNlLFxuICAgICAgb3B0aW9uYWxDb250ZW50Q29uZmlnXG4gICAgfSA9IF9yZWYxNDtcbiAgICBpZiAodGhpcy5jYW5jZWxsZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2NhbnZhcykge1xuICAgICAgaWYgKEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuaGFzKHRoaXMuX2NhbnZhcykpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IHVzZSB0aGUgc2FtZSBjYW52YXMgZHVyaW5nIG11bHRpcGxlIHJlbmRlcigpIG9wZXJhdGlvbnMuIFwiICsgXCJVc2UgZGlmZmVyZW50IGNhbnZhcyBvciBlbnN1cmUgcHJldmlvdXMgb3BlcmF0aW9ucyB3ZXJlIFwiICsgXCJjYW5jZWxsZWQgb3IgY29tcGxldGVkLlwiKTtcbiAgICAgIH1cbiAgICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuYWRkKHRoaXMuX2NhbnZhcyk7XG4gICAgfVxuICAgIGlmICh0aGlzLl9wZGZCdWcgJiYgZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlcj8uZW5hYmxlZCkge1xuICAgICAgdGhpcy5zdGVwcGVyID0gZ2xvYmFsVGhpcy5TdGVwcGVyTWFuYWdlci5jcmVhdGUodGhpcy5fcGFnZUluZGV4KTtcbiAgICAgIHRoaXMuc3RlcHBlci5pbml0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICAgIHRoaXMuc3RlcHBlci5uZXh0QnJlYWtQb2ludCA9IHRoaXMuc3RlcHBlci5nZXROZXh0QnJlYWtQb2ludCgpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNDb250ZXh0LFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc2Zvcm0sXG4gICAgICBiYWNrZ3JvdW5kXG4gICAgfSA9IHRoaXMucGFyYW1zO1xuICAgIHRoaXMuZ2Z4ID0gbmV3IF9jYW52YXMuQ2FudmFzR3JhcGhpY3MoY2FudmFzQ29udGV4dCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICBvcHRpb25hbENvbnRlbnRDb25maWdcbiAgICB9LCB0aGlzLmFubm90YXRpb25DYW52YXNNYXAsIHRoaXMucGFnZUNvbG9ycyk7XG4gICAgdGhpcy5nZnguYmVnaW5EcmF3aW5nKHtcbiAgICAgIHRyYW5zZm9ybSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgdHJhbnNwYXJlbmN5LFxuICAgICAgYmFja2dyb3VuZFxuICAgIH0pO1xuICAgIHRoaXMub3BlcmF0b3JMaXN0SWR4ID0gMDtcbiAgICB0aGlzLmdyYXBoaWNzUmVhZHkgPSB0cnVlO1xuICAgIHRoaXMuZ3JhcGhpY3NSZWFkeUNhbGxiYWNrPy4oKTtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgbGV0IGVycm9yID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBudWxsO1xuICAgIGxldCBleHRyYURlbGF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiAwO1xuICAgIHRoaXMucnVubmluZyA9IGZhbHNlO1xuICAgIHRoaXMuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICB0aGlzLmdmeD8uZW5kRHJhd2luZygpO1xuICAgIEludGVybmFsUmVuZGVyVGFzay4jY2FudmFzSW5Vc2UuZGVsZXRlKHRoaXMuX2NhbnZhcyk7XG4gICAgdGhpcy5jYWxsYmFjayhlcnJvciB8fCBuZXcgX2Rpc3BsYXlfdXRpbHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uKGBSZW5kZXJpbmcgY2FuY2VsbGVkLCBwYWdlICR7dGhpcy5fcGFnZUluZGV4ICsgMX1gLCBleHRyYURlbGF5KSk7XG4gIH1cbiAgb3BlcmF0b3JMaXN0Q2hhbmdlZCgpIHtcbiAgICBpZiAoIXRoaXMuZ3JhcGhpY3NSZWFkeSkge1xuICAgICAgdGhpcy5ncmFwaGljc1JlYWR5Q2FsbGJhY2sgfHw9IHRoaXMuX2NvbnRpbnVlQm91bmQ7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc3RlcHBlcj8udXBkYXRlT3BlcmF0b3JMaXN0KHRoaXMub3BlcmF0b3JMaXN0KTtcbiAgICBpZiAodGhpcy5ydW5uaW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2NvbnRpbnVlKCk7XG4gIH1cbiAgX2NvbnRpbnVlKCkge1xuICAgIHRoaXMucnVubmluZyA9IHRydWU7XG4gICAgaWYgKHRoaXMuY2FuY2VsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLnRhc2sub25Db250aW51ZSkge1xuICAgICAgdGhpcy50YXNrLm9uQ29udGludWUodGhpcy5fc2NoZWR1bGVOZXh0Qm91bmQpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9zY2hlZHVsZU5leHQoKTtcbiAgICB9XG4gIH1cbiAgX3NjaGVkdWxlTmV4dCgpIHtcbiAgICBpZiAodGhpcy5fdXNlUmVxdWVzdEFuaW1hdGlvbkZyYW1lKSB7XG4gICAgICB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lKCgpID0+IHtcbiAgICAgICAgdGhpcy5fbmV4dEJvdW5kKCkuY2F0Y2godGhpcy5fY2FuY2VsQm91bmQpO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFByb21pc2UucmVzb2x2ZSgpLnRoZW4odGhpcy5fbmV4dEJvdW5kKS5jYXRjaCh0aGlzLl9jYW5jZWxCb3VuZCk7XG4gICAgfVxuICB9XG4gIGFzeW5jIF9uZXh0KCkge1xuICAgIGlmICh0aGlzLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm9wZXJhdG9yTGlzdElkeCA9IHRoaXMuZ2Z4LmV4ZWN1dGVPcGVyYXRvckxpc3QodGhpcy5vcGVyYXRvckxpc3QsIHRoaXMub3BlcmF0b3JMaXN0SWR4LCB0aGlzLl9jb250aW51ZUJvdW5kLCB0aGlzLnN0ZXBwZXIpO1xuICAgIGlmICh0aGlzLm9wZXJhdG9yTGlzdElkeCA9PT0gdGhpcy5vcGVyYXRvckxpc3QuYXJnc0FycmF5Lmxlbmd0aCkge1xuICAgICAgdGhpcy5ydW5uaW5nID0gZmFsc2U7XG4gICAgICBpZiAodGhpcy5vcGVyYXRvckxpc3QubGFzdENodW5rKSB7XG4gICAgICAgIHRoaXMuZ2Z4LmVuZERyYXdpbmcoKTtcbiAgICAgICAgSW50ZXJuYWxSZW5kZXJUYXNrLiNjYW52YXNJblVzZS5kZWxldGUodGhpcy5fY2FudmFzKTtcbiAgICAgICAgdGhpcy5jYWxsYmFjaygpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuY29uc3QgdmVyc2lvbiA9ICczLjExLjE3NCc7XG5leHBvcnRzLnZlcnNpb24gPSB2ZXJzaW9uO1xuY29uc3QgYnVpbGQgPSAnY2U4NzE2NzQzJztcbmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcblxuLyoqKi8gfSksXG4vKiAxMjUgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcbnZhciBkaWZmZXJlbmNlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjYpO1xudmFyIHNldE1ldGhvZEFjY2VwdFNldExpa2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzNSk7XG4kKHtcbiB0YXJnZXQ6ICdTZXQnLFxuIHByb3RvOiB0cnVlLFxuIHJlYWw6IHRydWUsXG4gZm9yY2VkOiAhc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSgnZGlmZmVyZW5jZScpXG59LCB7IGRpZmZlcmVuY2U6IGRpZmZlcmVuY2UgfSk7XG5cbi8qKiovIH0pLFxuLyogMTI2ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFTZXQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNyk7XG52YXIgU2V0SGVscGVycyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI4KTtcbnZhciBjbG9uZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI5KTtcbnZhciBzaXplID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzIpO1xudmFyIGdldFNldFJlY29yZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMzKTtcbnZhciBpdGVyYXRlU2V0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzApO1xudmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzMSk7XG52YXIgaGFzID0gU2V0SGVscGVycy5oYXM7XG52YXIgcmVtb3ZlID0gU2V0SGVscGVycy5yZW1vdmU7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGRpZmZlcmVuY2Uob3RoZXIpIHtcbiB2YXIgTyA9IGFTZXQodGhpcyk7XG4gdmFyIG90aGVyUmVjID0gZ2V0U2V0UmVjb3JkKG90aGVyKTtcbiB2YXIgcmVzdWx0ID0gY2xvbmUoTyk7XG4gaWYgKHNpemUoTykgPD0gb3RoZXJSZWMuc2l6ZSlcbiAgaXRlcmF0ZVNldChPLCBmdW5jdGlvbiAoZSkge1xuICAgaWYgKG90aGVyUmVjLmluY2x1ZGVzKGUpKVxuICAgIHJlbW92ZShyZXN1bHQsIGUpO1xuICB9KTtcbiBlbHNlXG4gIGl0ZXJhdGVTaW1wbGUob3RoZXJSZWMuZ2V0SXRlcmF0b3IoKSwgZnVuY3Rpb24gKGUpIHtcbiAgIGlmIChoYXMoTywgZSkpXG4gICAgcmVtb3ZlKHJlc3VsdCwgZSk7XG4gIH0pO1xuIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDEyNyAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBoYXMgPSAoX193X3BkZmpzX3JlcXVpcmVfXygxMjgpLmhhcyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChpdCkge1xuIGhhcyhpdCk7XG4gcmV0dXJuIGl0O1xufTtcblxuLyoqKi8gfSksXG4vKiAxMjggKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBTZXRQcm90b3R5cGUgPSBTZXQucHJvdG90eXBlO1xubW9kdWxlLmV4cG9ydHMgPSB7XG4gU2V0OiBTZXQsXG4gYWRkOiB1bmN1cnJ5VGhpcyhTZXRQcm90b3R5cGUuYWRkKSxcbiBoYXM6IHVuY3VycnlUaGlzKFNldFByb3RvdHlwZS5oYXMpLFxuIHJlbW92ZTogdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlWydkZWxldGUnXSksXG4gcHJvdG86IFNldFByb3RvdHlwZVxufTtcblxuLyoqKi8gfSksXG4vKiAxMjkgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgU2V0SGVscGVycyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI4KTtcbnZhciBpdGVyYXRlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzApO1xudmFyIFNldCA9IFNldEhlbHBlcnMuU2V0O1xudmFyIGFkZCA9IFNldEhlbHBlcnMuYWRkO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2V0KSB7XG4gdmFyIHJlc3VsdCA9IG5ldyBTZXQoKTtcbiBpdGVyYXRlKHNldCwgZnVuY3Rpb24gKGl0KSB7XG4gIGFkZChyZXN1bHQsIGl0KTtcbiB9KTtcbiByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqKi8gfSksXG4vKiAxMzAgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBpdGVyYXRlU2ltcGxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzEpO1xudmFyIFNldEhlbHBlcnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyOCk7XG52YXIgU2V0ID0gU2V0SGVscGVycy5TZXQ7XG52YXIgU2V0UHJvdG90eXBlID0gU2V0SGVscGVycy5wcm90bztcbnZhciBmb3JFYWNoID0gdW5jdXJyeVRoaXMoU2V0UHJvdG90eXBlLmZvckVhY2gpO1xudmFyIGtleXMgPSB1bmN1cnJ5VGhpcyhTZXRQcm90b3R5cGUua2V5cyk7XG52YXIgbmV4dCA9IGtleXMobmV3IFNldCgpKS5uZXh0O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2V0LCBmbiwgaW50ZXJydXB0aWJsZSkge1xuIHJldHVybiBpbnRlcnJ1cHRpYmxlID8gaXRlcmF0ZVNpbXBsZSh7XG4gIGl0ZXJhdG9yOiBrZXlzKHNldCksXG4gIG5leHQ6IG5leHRcbiB9LCBmbikgOiBmb3JFYWNoKHNldCwgZm4pO1xufTtcblxuLyoqKi8gfSksXG4vKiAxMzEgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgY2FsbCA9IF9fd19wZGZqc19yZXF1aXJlX18oOCk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChyZWNvcmQsIGZuLCBJVEVSQVRPUl9JTlNURUFEX09GX1JFQ09SRCkge1xuIHZhciBpdGVyYXRvciA9IElURVJBVE9SX0lOU1RFQURfT0ZfUkVDT1JEID8gcmVjb3JkIDogcmVjb3JkLml0ZXJhdG9yO1xuIHZhciBuZXh0ID0gcmVjb3JkLm5leHQ7XG4gdmFyIHN0ZXAsIHJlc3VsdDtcbiB3aGlsZSAoIShzdGVwID0gY2FsbChuZXh0LCBpdGVyYXRvcikpLmRvbmUpIHtcbiAgcmVzdWx0ID0gZm4oc3RlcC52YWx1ZSk7XG4gIGlmIChyZXN1bHQgIT09IHVuZGVmaW5lZClcbiAgIHJldHVybiByZXN1bHQ7XG4gfVxufTtcblxuLyoqKi8gfSksXG4vKiAxMzIgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXNBY2Nlc3NvciA9IF9fd19wZGZqc19yZXF1aXJlX18oNzIpO1xudmFyIFNldEhlbHBlcnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyOCk7XG5tb2R1bGUuZXhwb3J0cyA9IHVuY3VycnlUaGlzQWNjZXNzb3IoU2V0SGVscGVycy5wcm90bywgJ3NpemUnLCAnZ2V0JykgfHwgZnVuY3Rpb24gKHNldCkge1xuIHJldHVybiBzZXQuc2l6ZTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTMzICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFDYWxsYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzEpO1xudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Nyk7XG52YXIgY2FsbCA9IF9fd19wZGZqc19yZXF1aXJlX18oOCk7XG52YXIgdG9JbnRlZ2VyT3JJbmZpbml0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oNjIpO1xudmFyIGdldEl0ZXJhdG9yRGlyZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzQpO1xudmFyIElOVkFMSURfU0laRSA9ICdJbnZhbGlkIHNpemUnO1xudmFyICRSYW5nZUVycm9yID0gUmFuZ2VFcnJvcjtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xudmFyIG1heCA9IE1hdGgubWF4O1xudmFyIFNldFJlY29yZCA9IGZ1bmN0aW9uIChzZXQsIHNpemUsIGhhcywga2V5cykge1xuIHRoaXMuc2V0ID0gc2V0O1xuIHRoaXMuc2l6ZSA9IHNpemU7XG4gdGhpcy5oYXMgPSBoYXM7XG4gdGhpcy5rZXlzID0ga2V5cztcbn07XG5TZXRSZWNvcmQucHJvdG90eXBlID0ge1xuIGdldEl0ZXJhdG9yOiBmdW5jdGlvbiAoKSB7XG4gIHJldHVybiBnZXRJdGVyYXRvckRpcmVjdChhbk9iamVjdChjYWxsKHRoaXMua2V5cywgdGhpcy5zZXQpKSk7XG4gfSxcbiBpbmNsdWRlczogZnVuY3Rpb24gKGl0KSB7XG4gIHJldHVybiBjYWxsKHRoaXMuaGFzLCB0aGlzLnNldCwgaXQpO1xuIH1cbn07XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiBhbk9iamVjdChvYmopO1xuIHZhciBudW1TaXplID0gK29iai5zaXplO1xuIGlmIChudW1TaXplICE9PSBudW1TaXplKVxuICB0aHJvdyAkVHlwZUVycm9yKElOVkFMSURfU0laRSk7XG4gdmFyIGludFNpemUgPSB0b0ludGVnZXJPckluZmluaXR5KG51bVNpemUpO1xuIGlmIChpbnRTaXplIDwgMClcbiAgdGhyb3cgJFJhbmdlRXJyb3IoSU5WQUxJRF9TSVpFKTtcbiByZXR1cm4gbmV3IFNldFJlY29yZChvYmosIG1heChpbnRTaXplLCAwKSwgYUNhbGxhYmxlKG9iai5oYXMpLCBhQ2FsbGFibGUob2JqLmtleXMpKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTM0ICovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKG9iaikge1xuIHJldHVybiB7XG4gIGl0ZXJhdG9yOiBvYmosXG4gIG5leHQ6IG9iai5uZXh0LFxuICBkb25lOiBmYWxzZVxuIH07XG59O1xuXG4vKioqLyB9KSxcbi8qIDEzNSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG52YXIgY3JlYXRlU2V0TGlrZSA9IGZ1bmN0aW9uIChzaXplKSB7XG4gcmV0dXJuIHtcbiAgc2l6ZTogc2l6ZSxcbiAgaGFzOiBmdW5jdGlvbiAoKSB7XG4gICByZXR1cm4gZmFsc2U7XG4gIH0sXG4gIGtleXM6IGZ1bmN0aW9uICgpIHtcbiAgIHJldHVybiB7XG4gICAgbmV4dDogZnVuY3Rpb24gKCkge1xuICAgICByZXR1cm4geyBkb25lOiB0cnVlIH07XG4gICAgfVxuICAgfTtcbiAgfVxuIH07XG59O1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAobmFtZSkge1xuIHZhciBTZXQgPSBnZXRCdWlsdEluKCdTZXQnKTtcbiB0cnkge1xuICBuZXcgU2V0KClbbmFtZV0oY3JlYXRlU2V0TGlrZSgwKSk7XG4gIHRyeSB7XG4gICBuZXcgU2V0KClbbmFtZV0oY3JlYXRlU2V0TGlrZSgtMSkpO1xuICAgcmV0dXJuIGZhbHNlO1xuICB9IGNhdGNoIChlcnJvcjIpIHtcbiAgIHJldHVybiB0cnVlO1xuICB9XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgcmV0dXJuIGZhbHNlO1xuIH1cbn07XG5cbi8qKiovIH0pLFxuLyogMTM2ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMyk7XG52YXIgZmFpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDcpO1xudmFyIGludGVyc2VjdGlvbiA9IF9fd19wZGZqc19yZXF1aXJlX18oMTM3KTtcbnZhciBzZXRNZXRob2RBY2NlcHRTZXRMaWtlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzUpO1xudmFyIElOQ09SUkVDVCA9ICFzZXRNZXRob2RBY2NlcHRTZXRMaWtlKCdpbnRlcnNlY3Rpb24nKSB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChbXG4gIDEsXG4gIDIsXG4gIDNcbiBdKS5pbnRlcnNlY3Rpb24obmV3IFNldChbXG4gIDMsXG4gIDJcbiBdKSkpICE9PSAnMywyJztcbn0pO1xuJCh7XG4gdGFyZ2V0OiAnU2V0JyxcbiBwcm90bzogdHJ1ZSxcbiByZWFsOiB0cnVlLFxuIGZvcmNlZDogSU5DT1JSRUNUXG59LCB7IGludGVyc2VjdGlvbjogaW50ZXJzZWN0aW9uIH0pO1xuXG4vKioqLyB9KSxcbi8qIDEzNyAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhU2V0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjcpO1xudmFyIFNldEhlbHBlcnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyOCk7XG52YXIgc2l6ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMyKTtcbnZhciBnZXRTZXRSZWNvcmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzMyk7XG52YXIgaXRlcmF0ZVNldCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMwKTtcbnZhciBpdGVyYXRlU2ltcGxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzEpO1xudmFyIFNldCA9IFNldEhlbHBlcnMuU2V0O1xudmFyIGFkZCA9IFNldEhlbHBlcnMuYWRkO1xudmFyIGhhcyA9IFNldEhlbHBlcnMuaGFzO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpbnRlcnNlY3Rpb24ob3RoZXIpIHtcbiB2YXIgTyA9IGFTZXQodGhpcyk7XG4gdmFyIG90aGVyUmVjID0gZ2V0U2V0UmVjb3JkKG90aGVyKTtcbiB2YXIgcmVzdWx0ID0gbmV3IFNldCgpO1xuIGlmIChzaXplKE8pID4gb3RoZXJSZWMuc2l6ZSkge1xuICBpdGVyYXRlU2ltcGxlKG90aGVyUmVjLmdldEl0ZXJhdG9yKCksIGZ1bmN0aW9uIChlKSB7XG4gICBpZiAoaGFzKE8sIGUpKVxuICAgIGFkZChyZXN1bHQsIGUpO1xuICB9KTtcbiB9IGVsc2Uge1xuICBpdGVyYXRlU2V0KE8sIGZ1bmN0aW9uIChlKSB7XG4gICBpZiAob3RoZXJSZWMuaW5jbHVkZXMoZSkpXG4gICAgYWRkKHJlc3VsdCwgZSk7XG4gIH0pO1xuIH1cbiByZXR1cm4gcmVzdWx0O1xufTtcblxuLyoqKi8gfSksXG4vKiAxMzggKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcbnZhciBpc0Rpc2pvaW50RnJvbSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTM5KTtcbnZhciBzZXRNZXRob2RBY2NlcHRTZXRMaWtlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzUpO1xuJCh7XG4gdGFyZ2V0OiAnU2V0JyxcbiBwcm90bzogdHJ1ZSxcbiByZWFsOiB0cnVlLFxuIGZvcmNlZDogIXNldE1ldGhvZEFjY2VwdFNldExpa2UoJ2lzRGlzam9pbnRGcm9tJylcbn0sIHsgaXNEaXNqb2ludEZyb206IGlzRGlzam9pbnRGcm9tIH0pO1xuXG4vKioqLyB9KSxcbi8qIDEzOSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhU2V0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjcpO1xudmFyIGhhcyA9IChfX3dfcGRmanNfcmVxdWlyZV9fKDEyOCkuaGFzKTtcbnZhciBzaXplID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzIpO1xudmFyIGdldFNldFJlY29yZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMzKTtcbnZhciBpdGVyYXRlU2V0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzApO1xudmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzMSk7XG52YXIgaXRlcmF0b3JDbG9zZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQwKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNEaXNqb2ludEZyb20ob3RoZXIpIHtcbiB2YXIgTyA9IGFTZXQodGhpcyk7XG4gdmFyIG90aGVyUmVjID0gZ2V0U2V0UmVjb3JkKG90aGVyKTtcbiBpZiAoc2l6ZShPKSA8PSBvdGhlclJlYy5zaXplKVxuICByZXR1cm4gaXRlcmF0ZVNldChPLCBmdW5jdGlvbiAoZSkge1xuICAgaWYgKG90aGVyUmVjLmluY2x1ZGVzKGUpKVxuICAgIHJldHVybiBmYWxzZTtcbiAgfSwgdHJ1ZSkgIT09IGZhbHNlO1xuIHZhciBpdGVyYXRvciA9IG90aGVyUmVjLmdldEl0ZXJhdG9yKCk7XG4gcmV0dXJuIGl0ZXJhdGVTaW1wbGUoaXRlcmF0b3IsIGZ1bmN0aW9uIChlKSB7XG4gIGlmIChoYXMoTywgZSkpXG4gICByZXR1cm4gaXRlcmF0b3JDbG9zZShpdGVyYXRvciwgJ25vcm1hbCcsIGZhbHNlKTtcbiB9KSAhPT0gZmFsc2U7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE0MCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBjYWxsID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcbnZhciBhbk9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDcpO1xudmFyIGdldE1ldGhvZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMzApO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXRlcmF0b3IsIGtpbmQsIHZhbHVlKSB7XG4gdmFyIGlubmVyUmVzdWx0LCBpbm5lckVycm9yO1xuIGFuT2JqZWN0KGl0ZXJhdG9yKTtcbiB0cnkge1xuICBpbm5lclJlc3VsdCA9IGdldE1ldGhvZChpdGVyYXRvciwgJ3JldHVybicpO1xuICBpZiAoIWlubmVyUmVzdWx0KSB7XG4gICBpZiAoa2luZCA9PT0gJ3Rocm93JylcbiAgICB0aHJvdyB2YWx1ZTtcbiAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBpbm5lclJlc3VsdCA9IGNhbGwoaW5uZXJSZXN1bHQsIGl0ZXJhdG9yKTtcbiB9IGNhdGNoIChlcnJvcikge1xuICBpbm5lckVycm9yID0gdHJ1ZTtcbiAgaW5uZXJSZXN1bHQgPSBlcnJvcjtcbiB9XG4gaWYgKGtpbmQgPT09ICd0aHJvdycpXG4gIHRocm93IHZhbHVlO1xuIGlmIChpbm5lckVycm9yKVxuICB0aHJvdyBpbm5lclJlc3VsdDtcbiBhbk9iamVjdChpbm5lclJlc3VsdCk7XG4gcmV0dXJuIHZhbHVlO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNDEgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcbnZhciBpc1N1YnNldE9mID0gX193X3BkZmpzX3JlcXVpcmVfXygxNDIpO1xudmFyIHNldE1ldGhvZEFjY2VwdFNldExpa2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzNSk7XG4kKHtcbiB0YXJnZXQ6ICdTZXQnLFxuIHByb3RvOiB0cnVlLFxuIHJlYWw6IHRydWUsXG4gZm9yY2VkOiAhc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSgnaXNTdWJzZXRPZicpXG59LCB7IGlzU3Vic2V0T2Y6IGlzU3Vic2V0T2YgfSk7XG5cbi8qKiovIH0pLFxuLyogMTQyICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFTZXQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNyk7XG52YXIgc2l6ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMyKTtcbnZhciBpdGVyYXRlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzApO1xudmFyIGdldFNldFJlY29yZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMzKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNTdWJzZXRPZihvdGhlcikge1xuIHZhciBPID0gYVNldCh0aGlzKTtcbiB2YXIgb3RoZXJSZWMgPSBnZXRTZXRSZWNvcmQob3RoZXIpO1xuIGlmIChzaXplKE8pID4gb3RoZXJSZWMuc2l6ZSlcbiAgcmV0dXJuIGZhbHNlO1xuIHJldHVybiBpdGVyYXRlKE8sIGZ1bmN0aW9uIChlKSB7XG4gIGlmICghb3RoZXJSZWMuaW5jbHVkZXMoZSkpXG4gICByZXR1cm4gZmFsc2U7XG4gfSwgdHJ1ZSkgIT09IGZhbHNlO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNDMgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcbnZhciBpc1N1cGVyc2V0T2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0NCk7XG52YXIgc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTM1KTtcbiQoe1xuIHRhcmdldDogJ1NldCcsXG4gcHJvdG86IHRydWUsXG4gcmVhbDogdHJ1ZSxcbiBmb3JjZWQ6ICFzZXRNZXRob2RBY2NlcHRTZXRMaWtlKCdpc1N1cGVyc2V0T2YnKVxufSwgeyBpc1N1cGVyc2V0T2Y6IGlzU3VwZXJzZXRPZiB9KTtcblxuLyoqKi8gfSksXG4vKiAxNDQgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgYVNldCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI3KTtcbnZhciBoYXMgPSAoX193X3BkZmpzX3JlcXVpcmVfXygxMjgpLmhhcyk7XG52YXIgc2l6ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMyKTtcbnZhciBnZXRTZXRSZWNvcmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzMyk7XG52YXIgaXRlcmF0ZVNpbXBsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMxKTtcbnZhciBpdGVyYXRvckNsb3NlID0gX193X3BkZmpzX3JlcXVpcmVfXygxNDApO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc1N1cGVyc2V0T2Yob3RoZXIpIHtcbiB2YXIgTyA9IGFTZXQodGhpcyk7XG4gdmFyIG90aGVyUmVjID0gZ2V0U2V0UmVjb3JkKG90aGVyKTtcbiBpZiAoc2l6ZShPKSA8IG90aGVyUmVjLnNpemUpXG4gIHJldHVybiBmYWxzZTtcbiB2YXIgaXRlcmF0b3IgPSBvdGhlclJlYy5nZXRJdGVyYXRvcigpO1xuIHJldHVybiBpdGVyYXRlU2ltcGxlKGl0ZXJhdG9yLCBmdW5jdGlvbiAoZSkge1xuICBpZiAoIWhhcyhPLCBlKSlcbiAgIHJldHVybiBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAnbm9ybWFsJywgZmFsc2UpO1xuIH0pICE9PSBmYWxzZTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTQ1ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMyk7XG52YXIgc3ltbWV0cmljRGlmZmVyZW5jZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQ2KTtcbnZhciBzZXRNZXRob2RBY2NlcHRTZXRMaWtlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzUpO1xuJCh7XG4gdGFyZ2V0OiAnU2V0JyxcbiBwcm90bzogdHJ1ZSxcbiByZWFsOiB0cnVlLFxuIGZvcmNlZDogIXNldE1ldGhvZEFjY2VwdFNldExpa2UoJ3N5bW1ldHJpY0RpZmZlcmVuY2UnKVxufSwgeyBzeW1tZXRyaWNEaWZmZXJlbmNlOiBzeW1tZXRyaWNEaWZmZXJlbmNlIH0pO1xuXG4vKioqLyB9KSxcbi8qIDE0NiAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhU2V0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjcpO1xudmFyIFNldEhlbHBlcnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyOCk7XG52YXIgY2xvbmUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyOSk7XG52YXIgZ2V0U2V0UmVjb3JkID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzMpO1xudmFyIGl0ZXJhdGVTaW1wbGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzMSk7XG52YXIgYWRkID0gU2V0SGVscGVycy5hZGQ7XG52YXIgaGFzID0gU2V0SGVscGVycy5oYXM7XG52YXIgcmVtb3ZlID0gU2V0SGVscGVycy5yZW1vdmU7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHN5bW1ldHJpY0RpZmZlcmVuY2Uob3RoZXIpIHtcbiB2YXIgTyA9IGFTZXQodGhpcyk7XG4gdmFyIGtleXNJdGVyID0gZ2V0U2V0UmVjb3JkKG90aGVyKS5nZXRJdGVyYXRvcigpO1xuIHZhciByZXN1bHQgPSBjbG9uZShPKTtcbiBpdGVyYXRlU2ltcGxlKGtleXNJdGVyLCBmdW5jdGlvbiAoZSkge1xuICBpZiAoaGFzKE8sIGUpKVxuICAgcmVtb3ZlKHJlc3VsdCwgZSk7XG4gIGVsc2VcbiAgIGFkZChyZXN1bHQsIGUpO1xuIH0pO1xuIHJldHVybiByZXN1bHQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE0NyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xudmFyIHVuaW9uID0gX193X3BkZmpzX3JlcXVpcmVfXygxNDgpO1xudmFyIHNldE1ldGhvZEFjY2VwdFNldExpa2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzNSk7XG4kKHtcbiB0YXJnZXQ6ICdTZXQnLFxuIHByb3RvOiB0cnVlLFxuIHJlYWw6IHRydWUsXG4gZm9yY2VkOiAhc2V0TWV0aG9kQWNjZXB0U2V0TGlrZSgndW5pb24nKVxufSwgeyB1bmlvbjogdW5pb24gfSk7XG5cbi8qKiovIH0pLFxuLyogMTQ4ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFTZXQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyNyk7XG52YXIgYWRkID0gKF9fd19wZGZqc19yZXF1aXJlX18oMTI4KS5hZGQpO1xudmFyIGNsb25lID0gX193X3BkZmpzX3JlcXVpcmVfXygxMjkpO1xudmFyIGdldFNldFJlY29yZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTMzKTtcbnZhciBpdGVyYXRlU2ltcGxlID0gX193X3BkZmpzX3JlcXVpcmVfXygxMzEpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB1bmlvbihvdGhlcikge1xuIHZhciBPID0gYVNldCh0aGlzKTtcbiB2YXIga2V5c0l0ZXIgPSBnZXRTZXRSZWNvcmQob3RoZXIpLmdldEl0ZXJhdG9yKCk7XG4gdmFyIHJlc3VsdCA9IGNsb25lKE8pO1xuIGl0ZXJhdGVTaW1wbGUoa2V5c0l0ZXIsIGZ1bmN0aW9uIChpdCkge1xuICBhZGQocmVzdWx0LCBpdCk7XG4gfSk7XG4gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKiovIH0pLFxuLyogMTQ5ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgJCA9IF9fd19wZGZqc19yZXF1aXJlX18oMyk7XG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG52YXIgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxMSk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSAoX193X3BkZmpzX3JlcXVpcmVfXyg0NSkuZik7XG52YXIgaGFzT3duID0gX193X3BkZmpzX3JlcXVpcmVfXygzOSk7XG52YXIgYW5JbnN0YW5jZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUwKTtcbnZhciBpbmhlcml0SWZSZXF1aXJlZCA9IF9fd19wZGZqc19yZXF1aXJlX18oNzUpO1xudmFyIG5vcm1hbGl6ZVN0cmluZ0FyZ3VtZW50ID0gX193X3BkZmpzX3JlcXVpcmVfXyg3Nik7XG52YXIgRE9NRXhjZXB0aW9uQ29uc3RhbnRzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTEpO1xudmFyIGNsZWFyRXJyb3JTdGFjayA9IF9fd19wZGZqc19yZXF1aXJlX18oODIpO1xudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBJU19QVVJFID0gX193X3BkZmpzX3JlcXVpcmVfXygzNik7XG52YXIgRE9NX0VYQ0VQVElPTiA9ICdET01FeGNlcHRpb24nO1xudmFyIEVycm9yID0gZ2V0QnVpbHRJbignRXJyb3InKTtcbnZhciBOYXRpdmVET01FeGNlcHRpb24gPSBnZXRCdWlsdEluKERPTV9FWENFUFRJT04pO1xudmFyICRET01FeGNlcHRpb24gPSBmdW5jdGlvbiBET01FeGNlcHRpb24oKSB7XG4gYW5JbnN0YW5jZSh0aGlzLCBET01FeGNlcHRpb25Qcm90b3R5cGUpO1xuIHZhciBhcmd1bWVudHNMZW5ndGggPSBhcmd1bWVudHMubGVuZ3RoO1xuIHZhciBtZXNzYWdlID0gbm9ybWFsaXplU3RyaW5nQXJndW1lbnQoYXJndW1lbnRzTGVuZ3RoIDwgMSA/IHVuZGVmaW5lZCA6IGFyZ3VtZW50c1swXSk7XG4gdmFyIG5hbWUgPSBub3JtYWxpemVTdHJpbmdBcmd1bWVudChhcmd1bWVudHNMZW5ndGggPCAyID8gdW5kZWZpbmVkIDogYXJndW1lbnRzWzFdLCAnRXJyb3InKTtcbiB2YXIgdGhhdCA9IG5ldyBOYXRpdmVET01FeGNlcHRpb24obWVzc2FnZSwgbmFtZSk7XG4gdmFyIGVycm9yID0gRXJyb3IobWVzc2FnZSk7XG4gZXJyb3IubmFtZSA9IERPTV9FWENFUFRJT047XG4gZGVmaW5lUHJvcGVydHkodGhhdCwgJ3N0YWNrJywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIGNsZWFyRXJyb3JTdGFjayhlcnJvci5zdGFjaywgMSkpKTtcbiBpbmhlcml0SWZSZXF1aXJlZCh0aGF0LCB0aGlzLCAkRE9NRXhjZXB0aW9uKTtcbiByZXR1cm4gdGhhdDtcbn07XG52YXIgRE9NRXhjZXB0aW9uUHJvdG90eXBlID0gJERPTUV4Y2VwdGlvbi5wcm90b3R5cGUgPSBOYXRpdmVET01FeGNlcHRpb24ucHJvdG90eXBlO1xudmFyIEVSUk9SX0hBU19TVEFDSyA9ICdzdGFjaycgaW4gRXJyb3IoRE9NX0VYQ0VQVElPTik7XG52YXIgRE9NX0VYQ0VQVElPTl9IQVNfU1RBQ0sgPSAnc3RhY2snIGluIG5ldyBOYXRpdmVET01FeGNlcHRpb24oMSwgMik7XG52YXIgZGVzY3JpcHRvciA9IE5hdGl2ZURPTUV4Y2VwdGlvbiAmJiBERVNDUklQVE9SUyAmJiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGdsb2JhbCwgRE9NX0VYQ0VQVElPTik7XG52YXIgQlVHR1lfREVTQ1JJUFRPUiA9ICEhZGVzY3JpcHRvciAmJiAhKGRlc2NyaXB0b3Iud3JpdGFibGUgJiYgZGVzY3JpcHRvci5jb25maWd1cmFibGUpO1xudmFyIEZPUkNFRF9DT05TVFJVQ1RPUiA9IEVSUk9SX0hBU19TVEFDSyAmJiAhQlVHR1lfREVTQ1JJUFRPUiAmJiAhRE9NX0VYQ0VQVElPTl9IQVNfU1RBQ0s7XG4kKHtcbiBnbG9iYWw6IHRydWUsXG4gY29uc3RydWN0b3I6IHRydWUsXG4gZm9yY2VkOiBJU19QVVJFIHx8IEZPUkNFRF9DT05TVFJVQ1RPUlxufSwgeyBET01FeGNlcHRpb246IEZPUkNFRF9DT05TVFJVQ1RPUiA/ICRET01FeGNlcHRpb24gOiBOYXRpdmVET01FeGNlcHRpb24gfSk7XG52YXIgUG9seWZpbGxlZERPTUV4Y2VwdGlvbiA9IGdldEJ1aWx0SW4oRE9NX0VYQ0VQVElPTik7XG52YXIgUG9seWZpbGxlZERPTUV4Y2VwdGlvblByb3RvdHlwZSA9IFBvbHlmaWxsZWRET01FeGNlcHRpb24ucHJvdG90eXBlO1xuaWYgKFBvbHlmaWxsZWRET01FeGNlcHRpb25Qcm90b3R5cGUuY29uc3RydWN0b3IgIT09IFBvbHlmaWxsZWRET01FeGNlcHRpb24pIHtcbiBpZiAoIUlTX1BVUkUpIHtcbiAgZGVmaW5lUHJvcGVydHkoUG9seWZpbGxlZERPTUV4Y2VwdGlvblByb3RvdHlwZSwgJ2NvbnN0cnVjdG9yJywgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDEsIFBvbHlmaWxsZWRET01FeGNlcHRpb24pKTtcbiB9XG4gZm9yICh2YXIga2V5IGluIERPTUV4Y2VwdGlvbkNvbnN0YW50cylcbiAgaWYgKGhhc093bihET01FeGNlcHRpb25Db25zdGFudHMsIGtleSkpIHtcbiAgIHZhciBjb25zdGFudCA9IERPTUV4Y2VwdGlvbkNvbnN0YW50c1trZXldO1xuICAgdmFyIGNvbnN0YW50TmFtZSA9IGNvbnN0YW50LnM7XG4gICBpZiAoIWhhc093bihQb2x5ZmlsbGVkRE9NRXhjZXB0aW9uLCBjb25zdGFudE5hbWUpKSB7XG4gICAgZGVmaW5lUHJvcGVydHkoUG9seWZpbGxlZERPTUV4Y2VwdGlvbiwgY29uc3RhbnROYW1lLCBjcmVhdGVQcm9wZXJ0eURlc2NyaXB0b3IoNiwgY29uc3RhbnQuYykpO1xuICAgfVxuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMTUwICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGlzUHJvdG90eXBlT2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI1KTtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQsIFByb3RvdHlwZSkge1xuIGlmIChpc1Byb3RvdHlwZU9mKFByb3RvdHlwZSwgaXQpKVxuICByZXR1cm4gaXQ7XG4gdGhyb3cgJFR5cGVFcnJvcignSW5jb3JyZWN0IGludm9jYXRpb24nKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTUxICovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuIEluZGV4U2l6ZUVycm9yOiB7XG4gIHM6ICdJTkRFWF9TSVpFX0VSUicsXG4gIGM6IDEsXG4gIG06IDFcbiB9LFxuIERPTVN0cmluZ1NpemVFcnJvcjoge1xuICBzOiAnRE9NU1RSSU5HX1NJWkVfRVJSJyxcbiAgYzogMixcbiAgbTogMFxuIH0sXG4gSGllcmFyY2h5UmVxdWVzdEVycm9yOiB7XG4gIHM6ICdISUVSQVJDSFlfUkVRVUVTVF9FUlInLFxuICBjOiAzLFxuICBtOiAxXG4gfSxcbiBXcm9uZ0RvY3VtZW50RXJyb3I6IHtcbiAgczogJ1dST05HX0RPQ1VNRU5UX0VSUicsXG4gIGM6IDQsXG4gIG06IDFcbiB9LFxuIEludmFsaWRDaGFyYWN0ZXJFcnJvcjoge1xuICBzOiAnSU5WQUxJRF9DSEFSQUNURVJfRVJSJyxcbiAgYzogNSxcbiAgbTogMVxuIH0sXG4gTm9EYXRhQWxsb3dlZEVycm9yOiB7XG4gIHM6ICdOT19EQVRBX0FMTE9XRURfRVJSJyxcbiAgYzogNixcbiAgbTogMFxuIH0sXG4gTm9Nb2RpZmljYXRpb25BbGxvd2VkRXJyb3I6IHtcbiAgczogJ05PX01PRElGSUNBVElPTl9BTExPV0VEX0VSUicsXG4gIGM6IDcsXG4gIG06IDFcbiB9LFxuIE5vdEZvdW5kRXJyb3I6IHtcbiAgczogJ05PVF9GT1VORF9FUlInLFxuICBjOiA4LFxuICBtOiAxXG4gfSxcbiBOb3RTdXBwb3J0ZWRFcnJvcjoge1xuICBzOiAnTk9UX1NVUFBPUlRFRF9FUlInLFxuICBjOiA5LFxuICBtOiAxXG4gfSxcbiBJblVzZUF0dHJpYnV0ZUVycm9yOiB7XG4gIHM6ICdJTlVTRV9BVFRSSUJVVEVfRVJSJyxcbiAgYzogMTAsXG4gIG06IDFcbiB9LFxuIEludmFsaWRTdGF0ZUVycm9yOiB7XG4gIHM6ICdJTlZBTElEX1NUQVRFX0VSUicsXG4gIGM6IDExLFxuICBtOiAxXG4gfSxcbiBTeW50YXhFcnJvcjoge1xuICBzOiAnU1lOVEFYX0VSUicsXG4gIGM6IDEyLFxuICBtOiAxXG4gfSxcbiBJbnZhbGlkTW9kaWZpY2F0aW9uRXJyb3I6IHtcbiAgczogJ0lOVkFMSURfTU9ESUZJQ0FUSU9OX0VSUicsXG4gIGM6IDEzLFxuICBtOiAxXG4gfSxcbiBOYW1lc3BhY2VFcnJvcjoge1xuICBzOiAnTkFNRVNQQUNFX0VSUicsXG4gIGM6IDE0LFxuICBtOiAxXG4gfSxcbiBJbnZhbGlkQWNjZXNzRXJyb3I6IHtcbiAgczogJ0lOVkFMSURfQUNDRVNTX0VSUicsXG4gIGM6IDE1LFxuICBtOiAxXG4gfSxcbiBWYWxpZGF0aW9uRXJyb3I6IHtcbiAgczogJ1ZBTElEQVRJT05fRVJSJyxcbiAgYzogMTYsXG4gIG06IDBcbiB9LFxuIFR5cGVNaXNtYXRjaEVycm9yOiB7XG4gIHM6ICdUWVBFX01JU01BVENIX0VSUicsXG4gIGM6IDE3LFxuICBtOiAxXG4gfSxcbiBTZWN1cml0eUVycm9yOiB7XG4gIHM6ICdTRUNVUklUWV9FUlInLFxuICBjOiAxOCxcbiAgbTogMVxuIH0sXG4gTmV0d29ya0Vycm9yOiB7XG4gIHM6ICdORVRXT1JLX0VSUicsXG4gIGM6IDE5LFxuICBtOiAxXG4gfSxcbiBBYm9ydEVycm9yOiB7XG4gIHM6ICdBQk9SVF9FUlInLFxuICBjOiAyMCxcbiAgbTogMVxuIH0sXG4gVVJMTWlzbWF0Y2hFcnJvcjoge1xuICBzOiAnVVJMX01JU01BVENIX0VSUicsXG4gIGM6IDIxLFxuICBtOiAxXG4gfSxcbiBRdW90YUV4Y2VlZGVkRXJyb3I6IHtcbiAgczogJ1FVT1RBX0VYQ0VFREVEX0VSUicsXG4gIGM6IDIyLFxuICBtOiAxXG4gfSxcbiBUaW1lb3V0RXJyb3I6IHtcbiAgczogJ1RJTUVPVVRfRVJSJyxcbiAgYzogMjMsXG4gIG06IDFcbiB9LFxuIEludmFsaWROb2RlVHlwZUVycm9yOiB7XG4gIHM6ICdJTlZBTElEX05PREVfVFlQRV9FUlInLFxuICBjOiAyNCxcbiAgbTogMVxuIH0sXG4gRGF0YUNsb25lRXJyb3I6IHtcbiAgczogJ0RBVEFfQ0xPTkVfRVJSJyxcbiAgYzogMjUsXG4gIG06IDFcbiB9XG59O1xuXG4vKioqLyB9KSxcbi8qIDE1MiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIElTX1BVUkUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM2KTtcbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcbnZhciBnbG9iYWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQpO1xudmFyIGdldEJ1aWx0aW4gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDI0KTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciB1aWQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQxKTtcbnZhciBpc0NhbGxhYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG52YXIgaXNDb25zdHJ1Y3RvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTUzKTtcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTcpO1xudmFyIGlzT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXygyMCk7XG52YXIgaXNTeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIzKTtcbnZhciBpdGVyYXRlID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTQpO1xudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Nyk7XG52YXIgY2xhc3NvZiA9IF9fd19wZGZqc19yZXF1aXJlX18oNzgpO1xudmFyIGhhc093biA9IF9fd19wZGZqc19yZXF1aXJlX18oMzkpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTkpO1xudmFyIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eSA9IF9fd19wZGZqc19yZXF1aXJlX18oNDQpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gX193X3BkZmpzX3JlcXVpcmVfXyg2NCk7XG52YXIgdmFsaWRhdGVBcmd1bWVudHNMZW5ndGggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDg1KTtcbnZhciBnZXRSZWdFeHBGbGFncyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTYwKTtcbnZhciBNYXBIZWxwZXJzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjIpO1xudmFyIFNldEhlbHBlcnMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyOCk7XG52YXIgRVJST1JfU1RBQ0tfSU5TVEFMTEFCTEUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgzKTtcbnZhciBQUk9QRVJfVFJBTlNGRVIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDExOSk7XG52YXIgT2JqZWN0ID0gZ2xvYmFsLk9iamVjdDtcbnZhciBBcnJheSA9IGdsb2JhbC5BcnJheTtcbnZhciBEYXRlID0gZ2xvYmFsLkRhdGU7XG52YXIgRXJyb3IgPSBnbG9iYWwuRXJyb3I7XG52YXIgRXZhbEVycm9yID0gZ2xvYmFsLkV2YWxFcnJvcjtcbnZhciBSYW5nZUVycm9yID0gZ2xvYmFsLlJhbmdlRXJyb3I7XG52YXIgUmVmZXJlbmNlRXJyb3IgPSBnbG9iYWwuUmVmZXJlbmNlRXJyb3I7XG52YXIgU3ludGF4RXJyb3IgPSBnbG9iYWwuU3ludGF4RXJyb3I7XG52YXIgVHlwZUVycm9yID0gZ2xvYmFsLlR5cGVFcnJvcjtcbnZhciBVUklFcnJvciA9IGdsb2JhbC5VUklFcnJvcjtcbnZhciBQZXJmb3JtYW5jZU1hcmsgPSBnbG9iYWwuUGVyZm9ybWFuY2VNYXJrO1xudmFyIFdlYkFzc2VtYmx5ID0gZ2xvYmFsLldlYkFzc2VtYmx5O1xudmFyIENvbXBpbGVFcnJvciA9IFdlYkFzc2VtYmx5ICYmIFdlYkFzc2VtYmx5LkNvbXBpbGVFcnJvciB8fCBFcnJvcjtcbnZhciBMaW5rRXJyb3IgPSBXZWJBc3NlbWJseSAmJiBXZWJBc3NlbWJseS5MaW5rRXJyb3IgfHwgRXJyb3I7XG52YXIgUnVudGltZUVycm9yID0gV2ViQXNzZW1ibHkgJiYgV2ViQXNzZW1ibHkuUnVudGltZUVycm9yIHx8IEVycm9yO1xudmFyIERPTUV4Y2VwdGlvbiA9IGdldEJ1aWx0aW4oJ0RPTUV4Y2VwdGlvbicpO1xudmFyIE1hcCA9IE1hcEhlbHBlcnMuTWFwO1xudmFyIG1hcEhhcyA9IE1hcEhlbHBlcnMuaGFzO1xudmFyIG1hcEdldCA9IE1hcEhlbHBlcnMuZ2V0O1xudmFyIG1hcFNldCA9IE1hcEhlbHBlcnMuc2V0O1xudmFyIFNldCA9IFNldEhlbHBlcnMuU2V0O1xudmFyIHNldEFkZCA9IFNldEhlbHBlcnMuYWRkO1xudmFyIG9iamVjdEtleXMgPSBnZXRCdWlsdGluKCdPYmplY3QnLCAna2V5cycpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbnZhciB0aGlzQm9vbGVhblZhbHVlID0gdW5jdXJyeVRoaXModHJ1ZS52YWx1ZU9mKTtcbnZhciB0aGlzTnVtYmVyVmFsdWUgPSB1bmN1cnJ5VGhpcygxLjAudmFsdWVPZik7XG52YXIgdGhpc1N0cmluZ1ZhbHVlID0gdW5jdXJyeVRoaXMoJycudmFsdWVPZik7XG52YXIgdGhpc1RpbWVWYWx1ZSA9IHVuY3VycnlUaGlzKERhdGUucHJvdG90eXBlLmdldFRpbWUpO1xudmFyIFBFUkZPUk1BTkNFX01BUksgPSB1aWQoJ3N0cnVjdHVyZWRDbG9uZScpO1xudmFyIERBVEFfQ0xPTkVfRVJST1IgPSAnRGF0YUNsb25lRXJyb3InO1xudmFyIFRSQU5TRkVSUklORyA9ICdUcmFuc2ZlcnJpbmcnO1xudmFyIGNoZWNrQmFzaWNTZW1hbnRpYyA9IGZ1bmN0aW9uIChzdHJ1Y3R1cmVkQ2xvbmVJbXBsZW1lbnRhdGlvbikge1xuIHJldHVybiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgc2V0MSA9IG5ldyBnbG9iYWwuU2V0KFs3XSk7XG4gIHZhciBzZXQyID0gc3RydWN0dXJlZENsb25lSW1wbGVtZW50YXRpb24oc2V0MSk7XG4gIHZhciBudW1iZXIgPSBzdHJ1Y3R1cmVkQ2xvbmVJbXBsZW1lbnRhdGlvbihPYmplY3QoNykpO1xuICByZXR1cm4gc2V0MiA9PT0gc2V0MSB8fCAhc2V0Mi5oYXMoNykgfHwgdHlwZW9mIG51bWJlciAhPSAnb2JqZWN0JyB8fCArbnVtYmVyICE9PSA3O1xuIH0pICYmIHN0cnVjdHVyZWRDbG9uZUltcGxlbWVudGF0aW9uO1xufTtcbnZhciBjaGVja0Vycm9yc0Nsb25pbmcgPSBmdW5jdGlvbiAoc3RydWN0dXJlZENsb25lSW1wbGVtZW50YXRpb24sICRFcnJvcikge1xuIHJldHVybiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuICB2YXIgZXJyb3IgPSBuZXcgJEVycm9yKCk7XG4gIHZhciB0ZXN0ID0gc3RydWN0dXJlZENsb25lSW1wbGVtZW50YXRpb24oe1xuICAgYTogZXJyb3IsXG4gICBiOiBlcnJvclxuICB9KTtcbiAgcmV0dXJuICEodGVzdCAmJiB0ZXN0LmEgPT09IHRlc3QuYiAmJiB0ZXN0LmEgaW5zdGFuY2VvZiAkRXJyb3IgJiYgdGVzdC5hLnN0YWNrID09PSBlcnJvci5zdGFjayk7XG4gfSk7XG59O1xudmFyIGNoZWNrTmV3RXJyb3JzQ2xvbmluZ1NlbWFudGljID0gZnVuY3Rpb24gKHN0cnVjdHVyZWRDbG9uZUltcGxlbWVudGF0aW9uKSB7XG4gcmV0dXJuICFmYWlscyhmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXN0ID0gc3RydWN0dXJlZENsb25lSW1wbGVtZW50YXRpb24obmV3IGdsb2JhbC5BZ2dyZWdhdGVFcnJvcihbMV0sIFBFUkZPUk1BTkNFX01BUkssIHsgY2F1c2U6IDMgfSkpO1xuICByZXR1cm4gdGVzdC5uYW1lICE9PSAnQWdncmVnYXRlRXJyb3InIHx8IHRlc3QuZXJyb3JzWzBdICE9PSAxIHx8IHRlc3QubWVzc2FnZSAhPT0gUEVSRk9STUFOQ0VfTUFSSyB8fCB0ZXN0LmNhdXNlICE9PSAzO1xuIH0pO1xufTtcbnZhciBuYXRpdmVTdHJ1Y3R1cmVkQ2xvbmUgPSBnbG9iYWwuc3RydWN0dXJlZENsb25lO1xudmFyIEZPUkNFRF9SRVBMQUNFTUVOVCA9IElTX1BVUkUgfHwgIWNoZWNrRXJyb3JzQ2xvbmluZyhuYXRpdmVTdHJ1Y3R1cmVkQ2xvbmUsIEVycm9yKSB8fCAhY2hlY2tFcnJvcnNDbG9uaW5nKG5hdGl2ZVN0cnVjdHVyZWRDbG9uZSwgRE9NRXhjZXB0aW9uKSB8fCAhY2hlY2tOZXdFcnJvcnNDbG9uaW5nU2VtYW50aWMobmF0aXZlU3RydWN0dXJlZENsb25lKTtcbnZhciBzdHJ1Y3R1cmVkQ2xvbmVGcm9tTWFyayA9ICFuYXRpdmVTdHJ1Y3R1cmVkQ2xvbmUgJiYgY2hlY2tCYXNpY1NlbWFudGljKGZ1bmN0aW9uICh2YWx1ZSkge1xuIHJldHVybiBuZXcgUGVyZm9ybWFuY2VNYXJrKFBFUkZPUk1BTkNFX01BUkssIHsgZGV0YWlsOiB2YWx1ZSB9KS5kZXRhaWw7XG59KTtcbnZhciBuYXRpdmVSZXN0cmljdGVkU3RydWN0dXJlZENsb25lID0gY2hlY2tCYXNpY1NlbWFudGljKG5hdGl2ZVN0cnVjdHVyZWRDbG9uZSkgfHwgc3RydWN0dXJlZENsb25lRnJvbU1hcms7XG52YXIgdGhyb3dVbmNsb25lYWJsZSA9IGZ1bmN0aW9uICh0eXBlKSB7XG4gdGhyb3cgbmV3IERPTUV4Y2VwdGlvbignVW5jbG9uZWFibGUgdHlwZTogJyArIHR5cGUsIERBVEFfQ0xPTkVfRVJST1IpO1xufTtcbnZhciB0aHJvd1VucG9seWZpbGxhYmxlID0gZnVuY3Rpb24gKHR5cGUsIGFjdGlvbikge1xuIHRocm93IG5ldyBET01FeGNlcHRpb24oKGFjdGlvbiB8fCAnQ2xvbmluZycpICsgJyBvZiAnICsgdHlwZSArICcgY2Fubm90IGJlIHByb3Blcmx5IHBvbHlmaWxsZWQgaW4gdGhpcyBlbmdpbmUnLCBEQVRBX0NMT05FX0VSUk9SKTtcbn07XG52YXIgdHJ5TmF0aXZlUmVzdHJpY3RlZFN0cnVjdHVyZWRDbG9uZSA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSkge1xuIGlmICghbmF0aXZlUmVzdHJpY3RlZFN0cnVjdHVyZWRDbG9uZSlcbiAgdGhyb3dVbnBvbHlmaWxsYWJsZSh0eXBlKTtcbiByZXR1cm4gbmF0aXZlUmVzdHJpY3RlZFN0cnVjdHVyZWRDbG9uZSh2YWx1ZSk7XG59O1xudmFyIGNyZWF0ZURhdGFUcmFuc2ZlciA9IGZ1bmN0aW9uICgpIHtcbiB2YXIgZGF0YVRyYW5zZmVyO1xuIHRyeSB7XG4gIGRhdGFUcmFuc2ZlciA9IG5ldyBnbG9iYWwuRGF0YVRyYW5zZmVyKCk7XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgdHJ5IHtcbiAgIGRhdGFUcmFuc2ZlciA9IG5ldyBnbG9iYWwuQ2xpcGJvYXJkRXZlbnQoJycpLmNsaXBib2FyZERhdGE7XG4gIH0gY2F0Y2ggKGVycm9yMikge1xuICB9XG4gfVxuIHJldHVybiBkYXRhVHJhbnNmZXIgJiYgZGF0YVRyYW5zZmVyLml0ZW1zICYmIGRhdGFUcmFuc2Zlci5maWxlcyA/IGRhdGFUcmFuc2ZlciA6IG51bGw7XG59O1xudmFyIGNsb25lQnVmZmVyID0gZnVuY3Rpb24gKHZhbHVlLCBtYXAsICR0eXBlKSB7XG4gaWYgKG1hcEhhcyhtYXAsIHZhbHVlKSlcbiAgcmV0dXJuIG1hcEdldChtYXAsIHZhbHVlKTtcbiB2YXIgdHlwZSA9ICR0eXBlIHx8IGNsYXNzb2YodmFsdWUpO1xuIHZhciBjbG9uZSwgbGVuZ3RoLCBvcHRpb25zLCBzb3VyY2UsIHRhcmdldCwgaTtcbiBpZiAodHlwZSA9PT0gJ1NoYXJlZEFycmF5QnVmZmVyJykge1xuICBpZiAobmF0aXZlUmVzdHJpY3RlZFN0cnVjdHVyZWRDbG9uZSlcbiAgIGNsb25lID0gbmF0aXZlUmVzdHJpY3RlZFN0cnVjdHVyZWRDbG9uZSh2YWx1ZSk7XG4gIGVsc2VcbiAgIGNsb25lID0gdmFsdWU7XG4gfSBlbHNlIHtcbiAgdmFyIERhdGFWaWV3ID0gZ2xvYmFsLkRhdGFWaWV3O1xuICBpZiAoIURhdGFWaWV3ICYmIHR5cGVvZiB2YWx1ZS5zbGljZSAhPSAnZnVuY3Rpb24nKVxuICAgdGhyb3dVbnBvbHlmaWxsYWJsZSgnQXJyYXlCdWZmZXInKTtcbiAgdHJ5IHtcbiAgIGlmICh0eXBlb2YgdmFsdWUuc2xpY2UgPT0gJ2Z1bmN0aW9uJyAmJiAhdmFsdWUucmVzaXphYmxlKSB7XG4gICAgY2xvbmUgPSB2YWx1ZS5zbGljZSgwKTtcbiAgIH0gZWxzZSB7XG4gICAgbGVuZ3RoID0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICBvcHRpb25zID0gJ21heEJ5dGVMZW5ndGgnIGluIHZhbHVlID8geyBtYXhCeXRlTGVuZ3RoOiB2YWx1ZS5tYXhCeXRlTGVuZ3RoIH0gOiB1bmRlZmluZWQ7XG4gICAgY2xvbmUgPSBuZXcgQXJyYXlCdWZmZXIobGVuZ3RoLCBvcHRpb25zKTtcbiAgICBzb3VyY2UgPSBuZXcgRGF0YVZpZXcodmFsdWUpO1xuICAgIHRhcmdldCA9IG5ldyBEYXRhVmlldyhjbG9uZSk7XG4gICAgZm9yIChpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgIHRhcmdldC5zZXRVaW50OChpLCBzb3VyY2UuZ2V0VWludDgoaSkpO1xuICAgIH1cbiAgIH1cbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0FycmF5QnVmZmVyIGlzIGRldGFjaGVkJywgREFUQV9DTE9ORV9FUlJPUik7XG4gIH1cbiB9XG4gbWFwU2V0KG1hcCwgdmFsdWUsIGNsb25lKTtcbiByZXR1cm4gY2xvbmU7XG59O1xudmFyIGNsb25lVmlldyA9IGZ1bmN0aW9uICh2YWx1ZSwgdHlwZSwgb2Zmc2V0LCBsZW5ndGgsIG1hcCkge1xuIHZhciBDID0gZ2xvYmFsW3R5cGVdO1xuIGlmICghaXNPYmplY3QoQykpXG4gIHRocm93VW5wb2x5ZmlsbGFibGUodHlwZSk7XG4gcmV0dXJuIG5ldyBDKGNsb25lQnVmZmVyKHZhbHVlLmJ1ZmZlciwgbWFwKSwgb2Zmc2V0LCBsZW5ndGgpO1xufTtcbnZhciBQbGFjZWhvbGRlciA9IGZ1bmN0aW9uIChvYmplY3QsIHR5cGUsIG1ldGFkYXRhKSB7XG4gdGhpcy5vYmplY3QgPSBvYmplY3Q7XG4gdGhpcy50eXBlID0gdHlwZTtcbiB0aGlzLm1ldGFkYXRhID0gbWV0YWRhdGE7XG59O1xudmFyIHN0cnVjdHVyZWRDbG9uZUludGVybmFsID0gZnVuY3Rpb24gKHZhbHVlLCBtYXAsIHRyYW5zZmVycmVkQnVmZmVycykge1xuIGlmIChpc1N5bWJvbCh2YWx1ZSkpXG4gIHRocm93VW5jbG9uZWFibGUoJ1N5bWJvbCcpO1xuIGlmICghaXNPYmplY3QodmFsdWUpKVxuICByZXR1cm4gdmFsdWU7XG4gaWYgKG1hcCkge1xuICBpZiAobWFwSGFzKG1hcCwgdmFsdWUpKVxuICAgcmV0dXJuIG1hcEdldChtYXAsIHZhbHVlKTtcbiB9IGVsc2VcbiAgbWFwID0gbmV3IE1hcCgpO1xuIHZhciB0eXBlID0gY2xhc3NvZih2YWx1ZSk7XG4gdmFyIEMsIG5hbWUsIGNsb25lZCwgZGF0YVRyYW5zZmVyLCBpLCBsZW5ndGgsIGtleXMsIGtleTtcbiBzd2l0Y2ggKHR5cGUpIHtcbiBjYXNlICdBcnJheSc6XG4gIGNsb25lZCA9IEFycmF5KGxlbmd0aE9mQXJyYXlMaWtlKHZhbHVlKSk7XG4gIGJyZWFrO1xuIGNhc2UgJ09iamVjdCc6XG4gIGNsb25lZCA9IHt9O1xuICBicmVhaztcbiBjYXNlICdNYXAnOlxuICBjbG9uZWQgPSBuZXcgTWFwKCk7XG4gIGJyZWFrO1xuIGNhc2UgJ1NldCc6XG4gIGNsb25lZCA9IG5ldyBTZXQoKTtcbiAgYnJlYWs7XG4gY2FzZSAnUmVnRXhwJzpcbiAgY2xvbmVkID0gbmV3IFJlZ0V4cCh2YWx1ZS5zb3VyY2UsIGdldFJlZ0V4cEZsYWdzKHZhbHVlKSk7XG4gIGJyZWFrO1xuIGNhc2UgJ0Vycm9yJzpcbiAgbmFtZSA9IHZhbHVlLm5hbWU7XG4gIHN3aXRjaCAobmFtZSkge1xuICBjYXNlICdBZ2dyZWdhdGVFcnJvcic6XG4gICBjbG9uZWQgPSBnZXRCdWlsdGluKCdBZ2dyZWdhdGVFcnJvcicpKFtdKTtcbiAgIGJyZWFrO1xuICBjYXNlICdFdmFsRXJyb3InOlxuICAgY2xvbmVkID0gRXZhbEVycm9yKCk7XG4gICBicmVhaztcbiAgY2FzZSAnUmFuZ2VFcnJvcic6XG4gICBjbG9uZWQgPSBSYW5nZUVycm9yKCk7XG4gICBicmVhaztcbiAgY2FzZSAnUmVmZXJlbmNlRXJyb3InOlxuICAgY2xvbmVkID0gUmVmZXJlbmNlRXJyb3IoKTtcbiAgIGJyZWFrO1xuICBjYXNlICdTeW50YXhFcnJvcic6XG4gICBjbG9uZWQgPSBTeW50YXhFcnJvcigpO1xuICAgYnJlYWs7XG4gIGNhc2UgJ1R5cGVFcnJvcic6XG4gICBjbG9uZWQgPSBUeXBlRXJyb3IoKTtcbiAgIGJyZWFrO1xuICBjYXNlICdVUklFcnJvcic6XG4gICBjbG9uZWQgPSBVUklFcnJvcigpO1xuICAgYnJlYWs7XG4gIGNhc2UgJ0NvbXBpbGVFcnJvcic6XG4gICBjbG9uZWQgPSBDb21waWxlRXJyb3IoKTtcbiAgIGJyZWFrO1xuICBjYXNlICdMaW5rRXJyb3InOlxuICAgY2xvbmVkID0gTGlua0Vycm9yKCk7XG4gICBicmVhaztcbiAgY2FzZSAnUnVudGltZUVycm9yJzpcbiAgIGNsb25lZCA9IFJ1bnRpbWVFcnJvcigpO1xuICAgYnJlYWs7XG4gIGRlZmF1bHQ6XG4gICBjbG9uZWQgPSBFcnJvcigpO1xuICB9XG4gIGJyZWFrO1xuIGNhc2UgJ0RPTUV4Y2VwdGlvbic6XG4gIGNsb25lZCA9IG5ldyBET01FeGNlcHRpb24odmFsdWUubWVzc2FnZSwgdmFsdWUubmFtZSk7XG4gIGJyZWFrO1xuIGNhc2UgJ0FycmF5QnVmZmVyJzpcbiBjYXNlICdTaGFyZWRBcnJheUJ1ZmZlcic6XG4gIGNsb25lZCA9IHRyYW5zZmVycmVkQnVmZmVycyA/IG5ldyBQbGFjZWhvbGRlcih2YWx1ZSwgdHlwZSkgOiBjbG9uZUJ1ZmZlcih2YWx1ZSwgbWFwLCB0eXBlKTtcbiAgYnJlYWs7XG4gY2FzZSAnRGF0YVZpZXcnOlxuIGNhc2UgJ0ludDhBcnJheSc6XG4gY2FzZSAnVWludDhBcnJheSc6XG4gY2FzZSAnVWludDhDbGFtcGVkQXJyYXknOlxuIGNhc2UgJ0ludDE2QXJyYXknOlxuIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiBjYXNlICdJbnQzMkFycmF5JzpcbiBjYXNlICdVaW50MzJBcnJheSc6XG4gY2FzZSAnRmxvYXQxNkFycmF5JzpcbiBjYXNlICdGbG9hdDMyQXJyYXknOlxuIGNhc2UgJ0Zsb2F0NjRBcnJheSc6XG4gY2FzZSAnQmlnSW50NjRBcnJheSc6XG4gY2FzZSAnQmlnVWludDY0QXJyYXknOlxuICBsZW5ndGggPSB0eXBlID09PSAnRGF0YVZpZXcnID8gdmFsdWUuYnl0ZUxlbmd0aCA6IHZhbHVlLmxlbmd0aDtcbiAgY2xvbmVkID0gdHJhbnNmZXJyZWRCdWZmZXJzID8gbmV3IFBsYWNlaG9sZGVyKHZhbHVlLCB0eXBlLCB7XG4gICBvZmZzZXQ6IHZhbHVlLmJ5dGVPZmZzZXQsXG4gICBsZW5ndGg6IGxlbmd0aFxuICB9KSA6IGNsb25lVmlldyh2YWx1ZSwgdHlwZSwgdmFsdWUuYnl0ZU9mZnNldCwgbGVuZ3RoLCBtYXApO1xuICBicmVhaztcbiBjYXNlICdET01RdWFkJzpcbiAgdHJ5IHtcbiAgIGNsb25lZCA9IG5ldyBET01RdWFkKHN0cnVjdHVyZWRDbG9uZUludGVybmFsKHZhbHVlLnAxLCBtYXAsIHRyYW5zZmVycmVkQnVmZmVycyksIHN0cnVjdHVyZWRDbG9uZUludGVybmFsKHZhbHVlLnAyLCBtYXAsIHRyYW5zZmVycmVkQnVmZmVycyksIHN0cnVjdHVyZWRDbG9uZUludGVybmFsKHZhbHVlLnAzLCBtYXAsIHRyYW5zZmVycmVkQnVmZmVycyksIHN0cnVjdHVyZWRDbG9uZUludGVybmFsKHZhbHVlLnA0LCBtYXAsIHRyYW5zZmVycmVkQnVmZmVycykpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgY2xvbmVkID0gdHJ5TmF0aXZlUmVzdHJpY3RlZFN0cnVjdHVyZWRDbG9uZSh2YWx1ZSwgdHlwZSk7XG4gIH1cbiAgYnJlYWs7XG4gY2FzZSAnRmlsZSc6XG4gIGlmIChuYXRpdmVSZXN0cmljdGVkU3RydWN0dXJlZENsb25lKVxuICAgdHJ5IHtcbiAgICBjbG9uZWQgPSBuYXRpdmVSZXN0cmljdGVkU3RydWN0dXJlZENsb25lKHZhbHVlKTtcbiAgICBpZiAoY2xhc3NvZihjbG9uZWQpICE9PSB0eXBlKVxuICAgICBjbG9uZWQgPSB1bmRlZmluZWQ7XG4gICB9IGNhdGNoIChlcnJvcikge1xuICAgfVxuICBpZiAoIWNsb25lZClcbiAgIHRyeSB7XG4gICAgY2xvbmVkID0gbmV3IEZpbGUoW3ZhbHVlXSwgdmFsdWUubmFtZSwgdmFsdWUpO1xuICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgIH1cbiAgaWYgKCFjbG9uZWQpXG4gICB0aHJvd1VucG9seWZpbGxhYmxlKHR5cGUpO1xuICBicmVhaztcbiBjYXNlICdGaWxlTGlzdCc6XG4gIGRhdGFUcmFuc2ZlciA9IGNyZWF0ZURhdGFUcmFuc2ZlcigpO1xuICBpZiAoZGF0YVRyYW5zZmVyKSB7XG4gICBmb3IgKGkgPSAwLCBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSh2YWx1ZSk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGRhdGFUcmFuc2Zlci5pdGVtcy5hZGQoc3RydWN0dXJlZENsb25lSW50ZXJuYWwodmFsdWVbaV0sIG1hcCwgdHJhbnNmZXJyZWRCdWZmZXJzKSk7XG4gICB9XG4gICBjbG9uZWQgPSBkYXRhVHJhbnNmZXIuZmlsZXM7XG4gIH0gZWxzZVxuICAgY2xvbmVkID0gdHJ5TmF0aXZlUmVzdHJpY3RlZFN0cnVjdHVyZWRDbG9uZSh2YWx1ZSwgdHlwZSk7XG4gIGJyZWFrO1xuIGNhc2UgJ0ltYWdlRGF0YSc6XG4gIHRyeSB7XG4gICBjbG9uZWQgPSBuZXcgSW1hZ2VEYXRhKHN0cnVjdHVyZWRDbG9uZUludGVybmFsKHZhbHVlLmRhdGEsIG1hcCwgdHJhbnNmZXJyZWRCdWZmZXJzKSwgdmFsdWUud2lkdGgsIHZhbHVlLmhlaWdodCwgeyBjb2xvclNwYWNlOiB2YWx1ZS5jb2xvclNwYWNlIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgY2xvbmVkID0gdHJ5TmF0aXZlUmVzdHJpY3RlZFN0cnVjdHVyZWRDbG9uZSh2YWx1ZSwgdHlwZSk7XG4gIH1cbiAgYnJlYWs7XG4gZGVmYXVsdDpcbiAgaWYgKG5hdGl2ZVJlc3RyaWN0ZWRTdHJ1Y3R1cmVkQ2xvbmUpIHtcbiAgIGNsb25lZCA9IG5hdGl2ZVJlc3RyaWN0ZWRTdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpO1xuICB9IGVsc2VcbiAgIHN3aXRjaCAodHlwZSkge1xuICAgY2FzZSAnQmlnSW50JzpcbiAgICBjbG9uZWQgPSBPYmplY3QodmFsdWUudmFsdWVPZigpKTtcbiAgICBicmVhaztcbiAgIGNhc2UgJ0Jvb2xlYW4nOlxuICAgIGNsb25lZCA9IE9iamVjdCh0aGlzQm9vbGVhblZhbHVlKHZhbHVlKSk7XG4gICAgYnJlYWs7XG4gICBjYXNlICdOdW1iZXInOlxuICAgIGNsb25lZCA9IE9iamVjdCh0aGlzTnVtYmVyVmFsdWUodmFsdWUpKTtcbiAgICBicmVhaztcbiAgIGNhc2UgJ1N0cmluZyc6XG4gICAgY2xvbmVkID0gT2JqZWN0KHRoaXNTdHJpbmdWYWx1ZSh2YWx1ZSkpO1xuICAgIGJyZWFrO1xuICAgY2FzZSAnRGF0ZSc6XG4gICAgY2xvbmVkID0gbmV3IERhdGUodGhpc1RpbWVWYWx1ZSh2YWx1ZSkpO1xuICAgIGJyZWFrO1xuICAgY2FzZSAnQmxvYic6XG4gICAgdHJ5IHtcbiAgICAgY2xvbmVkID0gdmFsdWUuc2xpY2UoMCwgdmFsdWUuc2l6ZSwgdmFsdWUudHlwZSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgdGhyb3dVbnBvbHlmaWxsYWJsZSh0eXBlKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gICBjYXNlICdET01Qb2ludCc6XG4gICBjYXNlICdET01Qb2ludFJlYWRPbmx5JzpcbiAgICBDID0gZ2xvYmFsW3R5cGVdO1xuICAgIHRyeSB7XG4gICAgIGNsb25lZCA9IEMuZnJvbVBvaW50ID8gQy5mcm9tUG9pbnQodmFsdWUpIDogbmV3IEModmFsdWUueCwgdmFsdWUueSwgdmFsdWUueiwgdmFsdWUudyk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgdGhyb3dVbnBvbHlmaWxsYWJsZSh0eXBlKTtcbiAgICB9XG4gICAgYnJlYWs7XG4gICBjYXNlICdET01SZWN0JzpcbiAgIGNhc2UgJ0RPTVJlY3RSZWFkT25seSc6XG4gICAgQyA9IGdsb2JhbFt0eXBlXTtcbiAgICB0cnkge1xuICAgICBjbG9uZWQgPSBDLmZyb21SZWN0ID8gQy5mcm9tUmVjdCh2YWx1ZSkgOiBuZXcgQyh2YWx1ZS54LCB2YWx1ZS55LCB2YWx1ZS53aWR0aCwgdmFsdWUuaGVpZ2h0KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICB0aHJvd1VucG9seWZpbGxhYmxlKHR5cGUpO1xuICAgIH1cbiAgICBicmVhaztcbiAgIGNhc2UgJ0RPTU1hdHJpeCc6XG4gICBjYXNlICdET01NYXRyaXhSZWFkT25seSc6XG4gICAgQyA9IGdsb2JhbFt0eXBlXTtcbiAgICB0cnkge1xuICAgICBjbG9uZWQgPSBDLmZyb21NYXRyaXggPyBDLmZyb21NYXRyaXgodmFsdWUpIDogbmV3IEModmFsdWUpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgIHRocm93VW5wb2x5ZmlsbGFibGUodHlwZSk7XG4gICAgfVxuICAgIGJyZWFrO1xuICAgY2FzZSAnQXVkaW9EYXRhJzpcbiAgIGNhc2UgJ1ZpZGVvRnJhbWUnOlxuICAgIGlmICghaXNDYWxsYWJsZSh2YWx1ZS5jbG9uZSkpXG4gICAgIHRocm93VW5wb2x5ZmlsbGFibGUodHlwZSk7XG4gICAgdHJ5IHtcbiAgICAgY2xvbmVkID0gdmFsdWUuY2xvbmUoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICB0aHJvd1VuY2xvbmVhYmxlKHR5cGUpO1xuICAgIH1cbiAgICBicmVhaztcbiAgIGNhc2UgJ0Nyb3BUYXJnZXQnOlxuICAgY2FzZSAnQ3J5cHRvS2V5JzpcbiAgIGNhc2UgJ0ZpbGVTeXN0ZW1EaXJlY3RvcnlIYW5kbGUnOlxuICAgY2FzZSAnRmlsZVN5c3RlbUZpbGVIYW5kbGUnOlxuICAgY2FzZSAnRmlsZVN5c3RlbUhhbmRsZSc6XG4gICBjYXNlICdHUFVDb21waWxhdGlvbkluZm8nOlxuICAgY2FzZSAnR1BVQ29tcGlsYXRpb25NZXNzYWdlJzpcbiAgIGNhc2UgJ0ltYWdlQml0bWFwJzpcbiAgIGNhc2UgJ1JUQ0NlcnRpZmljYXRlJzpcbiAgIGNhc2UgJ1dlYkFzc2VtYmx5Lk1vZHVsZSc6XG4gICAgdGhyb3dVbnBvbHlmaWxsYWJsZSh0eXBlKTtcbiAgIGRlZmF1bHQ6XG4gICAgdGhyb3dVbmNsb25lYWJsZSh0eXBlKTtcbiAgIH1cbiB9XG4gbWFwU2V0KG1hcCwgdmFsdWUsIGNsb25lZCk7XG4gc3dpdGNoICh0eXBlKSB7XG4gY2FzZSAnQXJyYXknOlxuIGNhc2UgJ09iamVjdCc6XG4gIGtleXMgPSBvYmplY3RLZXlzKHZhbHVlKTtcbiAgZm9yIChpID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2Uoa2V5cyk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAga2V5ID0ga2V5c1tpXTtcbiAgIGNyZWF0ZVByb3BlcnR5KGNsb25lZCwga2V5LCBzdHJ1Y3R1cmVkQ2xvbmVJbnRlcm5hbCh2YWx1ZVtrZXldLCBtYXAsIHRyYW5zZmVycmVkQnVmZmVycykpO1xuICB9XG4gIGJyZWFrO1xuIGNhc2UgJ01hcCc6XG4gIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYsIGspIHtcbiAgIG1hcFNldChjbG9uZWQsIHN0cnVjdHVyZWRDbG9uZUludGVybmFsKGssIG1hcCwgdHJhbnNmZXJyZWRCdWZmZXJzKSwgc3RydWN0dXJlZENsb25lSW50ZXJuYWwodiwgbWFwLCB0cmFuc2ZlcnJlZEJ1ZmZlcnMpKTtcbiAgfSk7XG4gIGJyZWFrO1xuIGNhc2UgJ1NldCc6XG4gIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHYpIHtcbiAgIHNldEFkZChjbG9uZWQsIHN0cnVjdHVyZWRDbG9uZUludGVybmFsKHYsIG1hcCwgdHJhbnNmZXJyZWRCdWZmZXJzKSk7XG4gIH0pO1xuICBicmVhaztcbiBjYXNlICdFcnJvcic6XG4gIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShjbG9uZWQsICdtZXNzYWdlJywgc3RydWN0dXJlZENsb25lSW50ZXJuYWwodmFsdWUubWVzc2FnZSwgbWFwLCB0cmFuc2ZlcnJlZEJ1ZmZlcnMpKTtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ2NhdXNlJykpIHtcbiAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShjbG9uZWQsICdjYXVzZScsIHN0cnVjdHVyZWRDbG9uZUludGVybmFsKHZhbHVlLmNhdXNlLCBtYXAsIHRyYW5zZmVycmVkQnVmZmVycykpO1xuICB9XG4gIGlmIChuYW1lID09PSAnQWdncmVnYXRlRXJyb3InKSB7XG4gICBjbG9uZWQuZXJyb3JzID0gc3RydWN0dXJlZENsb25lSW50ZXJuYWwodmFsdWUuZXJyb3JzLCBtYXAsIHRyYW5zZmVycmVkQnVmZmVycyk7XG4gIH1cbiBjYXNlICdET01FeGNlcHRpb24nOlxuICBpZiAoRVJST1JfU1RBQ0tfSU5TVEFMTEFCTEUpIHtcbiAgIGNyZWF0ZU5vbkVudW1lcmFibGVQcm9wZXJ0eShjbG9uZWQsICdzdGFjaycsIHN0cnVjdHVyZWRDbG9uZUludGVybmFsKHZhbHVlLnN0YWNrLCBtYXAsIHRyYW5zZmVycmVkQnVmZmVycykpO1xuICB9XG4gfVxuIHJldHVybiBjbG9uZWQ7XG59O1xudmFyIHJlcGxhY2VQbGFjZWhvbGRlcnMgPSBmdW5jdGlvbiAodmFsdWUsIG1hcCkge1xuIGlmICghaXNPYmplY3QodmFsdWUpKVxuICByZXR1cm4gdmFsdWU7XG4gaWYgKG1hcEhhcyhtYXAsIHZhbHVlKSlcbiAgcmV0dXJuIG1hcEdldChtYXAsIHZhbHVlKTtcbiB2YXIgdHlwZSwgb2JqZWN0LCBtZXRhZGF0YSwgaSwgbGVuZ3RoLCBrZXlzLCBrZXksIHJlcGxhY2VtZW50O1xuIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFBsYWNlaG9sZGVyKSB7XG4gIHR5cGUgPSB2YWx1ZS50eXBlO1xuICBvYmplY3QgPSB2YWx1ZS5vYmplY3Q7XG4gIHN3aXRjaCAodHlwZSkge1xuICBjYXNlICdBcnJheUJ1ZmZlcic6XG4gIGNhc2UgJ1NoYXJlZEFycmF5QnVmZmVyJzpcbiAgIHJlcGxhY2VtZW50ID0gY2xvbmVCdWZmZXIob2JqZWN0LCBtYXAsIHR5cGUpO1xuICAgYnJlYWs7XG4gIGNhc2UgJ0RhdGFWaWV3JzpcbiAgY2FzZSAnSW50OEFycmF5JzpcbiAgY2FzZSAnVWludDhBcnJheSc6XG4gIGNhc2UgJ1VpbnQ4Q2xhbXBlZEFycmF5JzpcbiAgY2FzZSAnSW50MTZBcnJheSc6XG4gIGNhc2UgJ1VpbnQxNkFycmF5JzpcbiAgY2FzZSAnSW50MzJBcnJheSc6XG4gIGNhc2UgJ1VpbnQzMkFycmF5JzpcbiAgY2FzZSAnRmxvYXQxNkFycmF5JzpcbiAgY2FzZSAnRmxvYXQzMkFycmF5JzpcbiAgY2FzZSAnRmxvYXQ2NEFycmF5JzpcbiAgY2FzZSAnQmlnSW50NjRBcnJheSc6XG4gIGNhc2UgJ0JpZ1VpbnQ2NEFycmF5JzpcbiAgIG1ldGFkYXRhID0gdmFsdWUubWV0YWRhdGE7XG4gICByZXBsYWNlbWVudCA9IGNsb25lVmlldyhvYmplY3QsIHR5cGUsIG1ldGFkYXRhLm9mZnNldCwgbWV0YWRhdGEubGVuZ3RoLCBtYXApO1xuICB9XG4gfSBlbHNlXG4gIHN3aXRjaCAoY2xhc3NvZih2YWx1ZSkpIHtcbiAgY2FzZSAnQXJyYXknOlxuICBjYXNlICdPYmplY3QnOlxuICAga2V5cyA9IG9iamVjdEtleXModmFsdWUpO1xuICAgZm9yIChpID0gMCwgbGVuZ3RoID0gbGVuZ3RoT2ZBcnJheUxpa2Uoa2V5cyk7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdmFsdWVba2V5XSA9IHJlcGxhY2VQbGFjZWhvbGRlcnModmFsdWVba2V5XSwgbWFwKTtcbiAgIH1cbiAgIGJyZWFrO1xuICBjYXNlICdNYXAnOlxuICAgcmVwbGFjZW1lbnQgPSBuZXcgTWFwKCk7XG4gICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2LCBrKSB7XG4gICAgbWFwU2V0KHJlcGxhY2VtZW50LCByZXBsYWNlUGxhY2Vob2xkZXJzKGssIG1hcCksIHJlcGxhY2VQbGFjZWhvbGRlcnModiwgbWFwKSk7XG4gICB9KTtcbiAgIGJyZWFrO1xuICBjYXNlICdTZXQnOlxuICAgcmVwbGFjZW1lbnQgPSBuZXcgU2V0KCk7XG4gICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2KSB7XG4gICAgc2V0QWRkKHJlcGxhY2VtZW50LCByZXBsYWNlUGxhY2Vob2xkZXJzKHYsIG1hcCkpO1xuICAgfSk7XG4gICBicmVhaztcbiAgY2FzZSAnRXJyb3InOlxuICAgdmFsdWUubWVzc2FnZSA9IHJlcGxhY2VQbGFjZWhvbGRlcnModmFsdWUubWVzc2FnZSwgbWFwKTtcbiAgIGlmIChoYXNPd24odmFsdWUsICdjYXVzZScpKSB7XG4gICAgdmFsdWUuY2F1c2UgPSByZXBsYWNlUGxhY2Vob2xkZXJzKHZhbHVlLmNhdXNlLCBtYXApO1xuICAgfVxuICAgaWYgKHZhbHVlLm5hbWUgPT09ICdBZ2dyZWdhdGVFcnJvcicpIHtcbiAgICB2YWx1ZS5lcnJvcnMgPSByZXBsYWNlUGxhY2Vob2xkZXJzKHZhbHVlLmVycm9ycywgbWFwKTtcbiAgIH1cbiAgY2FzZSAnRE9NRXhjZXB0aW9uJzpcbiAgIGlmIChFUlJPUl9TVEFDS19JTlNUQUxMQUJMRSkge1xuICAgIHZhbHVlLnN0YWNrID0gcmVwbGFjZVBsYWNlaG9sZGVycyh2YWx1ZS5zdGFjaywgbWFwKTtcbiAgIH1cbiAgfVxuIG1hcFNldChtYXAsIHZhbHVlLCByZXBsYWNlbWVudCB8fCB2YWx1ZSk7XG4gcmV0dXJuIHJlcGxhY2VtZW50IHx8IHZhbHVlO1xufTtcbnZhciB0cnlUb1RyYW5zZmVyID0gZnVuY3Rpb24gKHJhd1RyYW5zZmVyLCBtYXApIHtcbiBpZiAoIWlzT2JqZWN0KHJhd1RyYW5zZmVyKSlcbiAgdGhyb3cgVHlwZUVycm9yKCdUcmFuc2ZlciBvcHRpb24gY2Fubm90IGJlIGNvbnZlcnRlZCB0byBhIHNlcXVlbmNlJyk7XG4gdmFyIHRyYW5zZmVyID0gW107XG4gaXRlcmF0ZShyYXdUcmFuc2ZlciwgZnVuY3Rpb24gKHZhbHVlKSB7XG4gIHB1c2godHJhbnNmZXIsIGFuT2JqZWN0KHZhbHVlKSk7XG4gfSk7XG4gdmFyIGkgPSAwO1xuIHZhciBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZSh0cmFuc2Zlcik7XG4gdmFyIGJ1ZmZlcnMgPSBbXTtcbiB2YXIgdmFsdWUsIHR5cGUsIEMsIHRyYW5zZmVycmVkLCBjYW52YXMsIGNvbnRleHQ7XG4gd2hpbGUgKGkgPCBsZW5ndGgpIHtcbiAgdmFsdWUgPSB0cmFuc2ZlcltpKytdO1xuICB0eXBlID0gY2xhc3NvZih2YWx1ZSk7XG4gIGlmICh0eXBlID09PSAnQXJyYXlCdWZmZXInKSB7XG4gICBwdXNoKGJ1ZmZlcnMsIHZhbHVlKTtcbiAgIGNvbnRpbnVlO1xuICB9XG4gIGlmIChtYXBIYXMobWFwLCB2YWx1ZSkpXG4gICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdEdXBsaWNhdGUgdHJhbnNmZXJhYmxlJywgREFUQV9DTE9ORV9FUlJPUik7XG4gIGlmIChQUk9QRVJfVFJBTlNGRVIpIHtcbiAgIHRyYW5zZmVycmVkID0gbmF0aXZlU3RydWN0dXJlZENsb25lKHZhbHVlLCB7IHRyYW5zZmVyOiBbdmFsdWVdIH0pO1xuICB9IGVsc2VcbiAgIHN3aXRjaCAodHlwZSkge1xuICAgY2FzZSAnSW1hZ2VCaXRtYXAnOlxuICAgIEMgPSBnbG9iYWwuT2Zmc2NyZWVuQ2FudmFzO1xuICAgIGlmICghaXNDb25zdHJ1Y3RvcihDKSlcbiAgICAgdGhyb3dVbnBvbHlmaWxsYWJsZSh0eXBlLCBUUkFOU0ZFUlJJTkcpO1xuICAgIHRyeSB7XG4gICAgIGNhbnZhcyA9IG5ldyBDKHZhbHVlLndpZHRoLCB2YWx1ZS5oZWlnaHQpO1xuICAgICBjb250ZXh0ID0gY2FudmFzLmdldENvbnRleHQoJ2JpdG1hcHJlbmRlcmVyJyk7XG4gICAgIGNvbnRleHQudHJhbnNmZXJGcm9tSW1hZ2VCaXRtYXAodmFsdWUpO1xuICAgICB0cmFuc2ZlcnJlZCA9IGNhbnZhcy50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgICBicmVhaztcbiAgIGNhc2UgJ0F1ZGlvRGF0YSc6XG4gICBjYXNlICdWaWRlb0ZyYW1lJzpcbiAgICBpZiAoIWlzQ2FsbGFibGUodmFsdWUuY2xvbmUpIHx8ICFpc0NhbGxhYmxlKHZhbHVlLmNsb3NlKSlcbiAgICAgdGhyb3dVbnBvbHlmaWxsYWJsZSh0eXBlLCBUUkFOU0ZFUlJJTkcpO1xuICAgIHRyeSB7XG4gICAgIHRyYW5zZmVycmVkID0gdmFsdWUuY2xvbmUoKTtcbiAgICAgdmFsdWUuY2xvc2UoKTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgIH1cbiAgICBicmVhaztcbiAgIGNhc2UgJ01lZGlhU291cmNlSGFuZGxlJzpcbiAgIGNhc2UgJ01lc3NhZ2VQb3J0JzpcbiAgIGNhc2UgJ09mZnNjcmVlbkNhbnZhcyc6XG4gICBjYXNlICdSZWFkYWJsZVN0cmVhbSc6XG4gICBjYXNlICdUcmFuc2Zvcm1TdHJlYW0nOlxuICAgY2FzZSAnV3JpdGFibGVTdHJlYW0nOlxuICAgIHRocm93VW5wb2x5ZmlsbGFibGUodHlwZSwgVFJBTlNGRVJSSU5HKTtcbiAgIH1cbiAgaWYgKHRyYW5zZmVycmVkID09PSB1bmRlZmluZWQpXG4gICB0aHJvdyBuZXcgRE9NRXhjZXB0aW9uKCdUaGlzIG9iamVjdCBjYW5ub3QgYmUgdHJhbnNmZXJyZWQ6ICcgKyB0eXBlLCBEQVRBX0NMT05FX0VSUk9SKTtcbiAgbWFwU2V0KG1hcCwgdmFsdWUsIHRyYW5zZmVycmVkKTtcbiB9XG4gcmV0dXJuIGJ1ZmZlcnM7XG59O1xudmFyIHRyeVRvVHJhbnNmZXJCdWZmZXJzID0gZnVuY3Rpb24gKHRyYW5zZmVyLCBtYXApIHtcbiB2YXIgaSA9IDA7XG4gdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKHRyYW5zZmVyKTtcbiB2YXIgdmFsdWUsIHRyYW5zZmVycmVkO1xuIHdoaWxlIChpIDwgbGVuZ3RoKSB7XG4gIHZhbHVlID0gdHJhbnNmZXJbaSsrXTtcbiAgaWYgKG1hcEhhcyhtYXAsIHZhbHVlKSlcbiAgIHRocm93IG5ldyBET01FeGNlcHRpb24oJ0R1cGxpY2F0ZSB0cmFuc2ZlcmFibGUnLCBEQVRBX0NMT05FX0VSUk9SKTtcbiAgaWYgKFBST1BFUl9UUkFOU0ZFUikge1xuICAgdHJhbnNmZXJyZWQgPSBuYXRpdmVTdHJ1Y3R1cmVkQ2xvbmUodmFsdWUsIHsgdHJhbnNmZXI6IFt2YWx1ZV0gfSk7XG4gIH0gZWxzZSB7XG4gICBpZiAoIWlzQ2FsbGFibGUodmFsdWUudHJhbnNmZXIpKVxuICAgIHRocm93VW5wb2x5ZmlsbGFibGUoJ0FycmF5QnVmZmVyJywgVFJBTlNGRVJSSU5HKTtcbiAgIHRyYW5zZmVycmVkID0gdmFsdWUudHJhbnNmZXIoKTtcbiAgfVxuICBtYXBTZXQobWFwLCB2YWx1ZSwgdHJhbnNmZXJyZWQpO1xuIH1cbn07XG4kKHtcbiBnbG9iYWw6IHRydWUsXG4gZW51bWVyYWJsZTogdHJ1ZSxcbiBzaGFtOiAhUFJPUEVSX1RSQU5TRkVSLFxuIGZvcmNlZDogRk9SQ0VEX1JFUExBQ0VNRU5UXG59LCB7XG4gc3RydWN0dXJlZENsb25lOiBmdW5jdGlvbiBzdHJ1Y3R1cmVkQ2xvbmUodmFsdWUpIHtcbiAgdmFyIG9wdGlvbnMgPSB2YWxpZGF0ZUFyZ3VtZW50c0xlbmd0aChhcmd1bWVudHMubGVuZ3RoLCAxKSA+IDEgJiYgIWlzTnVsbE9yVW5kZWZpbmVkKGFyZ3VtZW50c1sxXSkgPyBhbk9iamVjdChhcmd1bWVudHNbMV0pIDogdW5kZWZpbmVkO1xuICB2YXIgdHJhbnNmZXIgPSBvcHRpb25zID8gb3B0aW9ucy50cmFuc2ZlciA6IHVuZGVmaW5lZDtcbiAgdmFyIHRyYW5zZmVycmVkQnVmZmVycyA9IGZhbHNlO1xuICB2YXIgbWFwLCBidWZmZXJzO1xuICBpZiAodHJhbnNmZXIgIT09IHVuZGVmaW5lZCkge1xuICAgbWFwID0gbmV3IE1hcCgpO1xuICAgYnVmZmVycyA9IHRyeVRvVHJhbnNmZXIodHJhbnNmZXIsIG1hcCk7XG4gICB0cmFuc2ZlcnJlZEJ1ZmZlcnMgPSAhIWxlbmd0aE9mQXJyYXlMaWtlKGJ1ZmZlcnMpO1xuICB9XG4gIHZhciBjbG9uZSA9IHN0cnVjdHVyZWRDbG9uZUludGVybmFsKHZhbHVlLCBtYXAsIHRyYW5zZmVycmVkQnVmZmVycyk7XG4gIGlmICh0cmFuc2ZlcnJlZEJ1ZmZlcnMpIHtcbiAgIG1hcCA9IG5ldyBNYXAoKTtcbiAgIHRyeVRvVHJhbnNmZXJCdWZmZXJzKHRyYW5zZmVyLCBtYXApO1xuICAgY2xvbmUgPSByZXBsYWNlUGxhY2Vob2xkZXJzKGNsb25lLCBtYXApO1xuICB9XG4gIHJldHVybiBjbG9uZTtcbiB9XG59KTtcblxuLyoqKi8gfSksXG4vKiAxNTMgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgdW5jdXJyeVRoaXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBmYWlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oNyk7XG52YXIgaXNDYWxsYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMjEpO1xudmFyIGNsYXNzb2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc4KTtcbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG52YXIgaW5zcGVjdFNvdXJjZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNTEpO1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7XG59O1xudmFyIGVtcHR5ID0gW107XG52YXIgY29uc3RydWN0ID0gZ2V0QnVpbHRJbignUmVmbGVjdCcsICdjb25zdHJ1Y3QnKTtcbnZhciBjb25zdHJ1Y3RvclJlZ0V4cCA9IC9eXFxzKig/OmNsYXNzfGZ1bmN0aW9uKVxcYi87XG52YXIgZXhlYyA9IHVuY3VycnlUaGlzKGNvbnN0cnVjdG9yUmVnRXhwLmV4ZWMpO1xudmFyIElOQ09SUkVDVF9UT19TVFJJTkcgPSAhY29uc3RydWN0b3JSZWdFeHAuZXhlYyhub29wKTtcbnZhciBpc0NvbnN0cnVjdG9yTW9kZXJuID0gZnVuY3Rpb24gaXNDb25zdHJ1Y3Rvcihhcmd1bWVudCkge1xuIGlmICghaXNDYWxsYWJsZShhcmd1bWVudCkpXG4gIHJldHVybiBmYWxzZTtcbiB0cnkge1xuICBjb25zdHJ1Y3Qobm9vcCwgZW1wdHksIGFyZ3VtZW50KTtcbiAgcmV0dXJuIHRydWU7XG4gfSBjYXRjaCAoZXJyb3IpIHtcbiAgcmV0dXJuIGZhbHNlO1xuIH1cbn07XG52YXIgaXNDb25zdHJ1Y3RvckxlZ2FjeSA9IGZ1bmN0aW9uIGlzQ29uc3RydWN0b3IoYXJndW1lbnQpIHtcbiBpZiAoIWlzQ2FsbGFibGUoYXJndW1lbnQpKVxuICByZXR1cm4gZmFsc2U7XG4gc3dpdGNoIChjbGFzc29mKGFyZ3VtZW50KSkge1xuIGNhc2UgJ0FzeW5jRnVuY3Rpb24nOlxuIGNhc2UgJ0dlbmVyYXRvckZ1bmN0aW9uJzpcbiBjYXNlICdBc3luY0dlbmVyYXRvckZ1bmN0aW9uJzpcbiAgcmV0dXJuIGZhbHNlO1xuIH1cbiB0cnkge1xuICByZXR1cm4gSU5DT1JSRUNUX1RPX1NUUklORyB8fCAhIWV4ZWMoY29uc3RydWN0b3JSZWdFeHAsIGluc3BlY3RTb3VyY2UoYXJndW1lbnQpKTtcbiB9IGNhdGNoIChlcnJvcikge1xuICByZXR1cm4gdHJ1ZTtcbiB9XG59O1xuaXNDb25zdHJ1Y3RvckxlZ2FjeS5zaGFtID0gdHJ1ZTtcbm1vZHVsZS5leHBvcnRzID0gIWNvbnN0cnVjdCB8fCBmYWlscyhmdW5jdGlvbiAoKSB7XG4gdmFyIGNhbGxlZDtcbiByZXR1cm4gaXNDb25zdHJ1Y3Rvck1vZGVybihpc0NvbnN0cnVjdG9yTW9kZXJuLmNhbGwpIHx8ICFpc0NvbnN0cnVjdG9yTW9kZXJuKE9iamVjdCkgfHwgIWlzQ29uc3RydWN0b3JNb2Rlcm4oZnVuY3Rpb24gKCkge1xuICBjYWxsZWQgPSB0cnVlO1xuIH0pIHx8IGNhbGxlZDtcbn0pID8gaXNDb25zdHJ1Y3RvckxlZ2FjeSA6IGlzQ29uc3RydWN0b3JNb2Rlcm47XG5cbi8qKiovIH0pLFxuLyogMTU0ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk5KTtcbnZhciBjYWxsID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcbnZhciBhbk9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDcpO1xudmFyIHRyeVRvU3RyaW5nID0gX193X3BkZmpzX3JlcXVpcmVfXygzMik7XG52YXIgaXNBcnJheUl0ZXJhdG9yTWV0aG9kID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTUpO1xudmFyIGxlbmd0aE9mQXJyYXlMaWtlID0gX193X3BkZmpzX3JlcXVpcmVfXyg2NCk7XG52YXIgaXNQcm90b3R5cGVPZiA9IF9fd19wZGZqc19yZXF1aXJlX18oMjUpO1xudmFyIGdldEl0ZXJhdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTcpO1xudmFyIGdldEl0ZXJhdG9yTWV0aG9kID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTgpO1xudmFyIGl0ZXJhdG9yQ2xvc2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0MCk7XG52YXIgJFR5cGVFcnJvciA9IFR5cGVFcnJvcjtcbnZhciBSZXN1bHQgPSBmdW5jdGlvbiAoc3RvcHBlZCwgcmVzdWx0KSB7XG4gdGhpcy5zdG9wcGVkID0gc3RvcHBlZDtcbiB0aGlzLnJlc3VsdCA9IHJlc3VsdDtcbn07XG52YXIgUmVzdWx0UHJvdG90eXBlID0gUmVzdWx0LnByb3RvdHlwZTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0ZXJhYmxlLCB1bmJvdW5kRnVuY3Rpb24sIG9wdGlvbnMpIHtcbiB2YXIgdGhhdCA9IG9wdGlvbnMgJiYgb3B0aW9ucy50aGF0O1xuIHZhciBBU19FTlRSSUVTID0gISEob3B0aW9ucyAmJiBvcHRpb25zLkFTX0VOVFJJRVMpO1xuIHZhciBJU19SRUNPUkQgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfUkVDT1JEKTtcbiB2YXIgSVNfSVRFUkFUT1IgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuSVNfSVRFUkFUT1IpO1xuIHZhciBJTlRFUlJVUFRFRCA9ICEhKG9wdGlvbnMgJiYgb3B0aW9ucy5JTlRFUlJVUFRFRCk7XG4gdmFyIGZuID0gYmluZCh1bmJvdW5kRnVuY3Rpb24sIHRoYXQpO1xuIHZhciBpdGVyYXRvciwgaXRlckZuLCBpbmRleCwgbGVuZ3RoLCByZXN1bHQsIG5leHQsIHN0ZXA7XG4gdmFyIHN0b3AgPSBmdW5jdGlvbiAoY29uZGl0aW9uKSB7XG4gIGlmIChpdGVyYXRvcilcbiAgIGl0ZXJhdG9yQ2xvc2UoaXRlcmF0b3IsICdub3JtYWwnLCBjb25kaXRpb24pO1xuICByZXR1cm4gbmV3IFJlc3VsdCh0cnVlLCBjb25kaXRpb24pO1xuIH07XG4gdmFyIGNhbGxGbiA9IGZ1bmN0aW9uICh2YWx1ZSkge1xuICBpZiAoQVNfRU5UUklFUykge1xuICAgYW5PYmplY3QodmFsdWUpO1xuICAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWVbMF0sIHZhbHVlWzFdLCBzdG9wKSA6IGZuKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gIH1cbiAgcmV0dXJuIElOVEVSUlVQVEVEID8gZm4odmFsdWUsIHN0b3ApIDogZm4odmFsdWUpO1xuIH07XG4gaWYgKElTX1JFQ09SRCkge1xuICBpdGVyYXRvciA9IGl0ZXJhYmxlLml0ZXJhdG9yO1xuIH0gZWxzZSBpZiAoSVNfSVRFUkFUT1IpIHtcbiAgaXRlcmF0b3IgPSBpdGVyYWJsZTtcbiB9IGVsc2Uge1xuICBpdGVyRm4gPSBnZXRJdGVyYXRvck1ldGhvZChpdGVyYWJsZSk7XG4gIGlmICghaXRlckZuKVxuICAgdGhyb3cgJFR5cGVFcnJvcih0cnlUb1N0cmluZyhpdGVyYWJsZSkgKyAnIGlzIG5vdCBpdGVyYWJsZScpO1xuICBpZiAoaXNBcnJheUl0ZXJhdG9yTWV0aG9kKGl0ZXJGbikpIHtcbiAgIGZvciAoaW5kZXggPSAwLCBsZW5ndGggPSBsZW5ndGhPZkFycmF5TGlrZShpdGVyYWJsZSk7IGxlbmd0aCA+IGluZGV4OyBpbmRleCsrKSB7XG4gICAgcmVzdWx0ID0gY2FsbEZuKGl0ZXJhYmxlW2luZGV4XSk7XG4gICAgaWYgKHJlc3VsdCAmJiBpc1Byb3RvdHlwZU9mKFJlc3VsdFByb3RvdHlwZSwgcmVzdWx0KSlcbiAgICAgcmV0dXJuIHJlc3VsdDtcbiAgIH1cbiAgIHJldHVybiBuZXcgUmVzdWx0KGZhbHNlKTtcbiAgfVxuICBpdGVyYXRvciA9IGdldEl0ZXJhdG9yKGl0ZXJhYmxlLCBpdGVyRm4pO1xuIH1cbiBuZXh0ID0gSVNfUkVDT1JEID8gaXRlcmFibGUubmV4dCA6IGl0ZXJhdG9yLm5leHQ7XG4gd2hpbGUgKCEoc3RlcCA9IGNhbGwobmV4dCwgaXRlcmF0b3IpKS5kb25lKSB7XG4gIHRyeSB7XG4gICByZXN1bHQgPSBjYWxsRm4oc3RlcC52YWx1ZSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICBpdGVyYXRvckNsb3NlKGl0ZXJhdG9yLCAndGhyb3cnLCBlcnJvcik7XG4gIH1cbiAgaWYgKHR5cGVvZiByZXN1bHQgPT0gJ29iamVjdCcgJiYgcmVzdWx0ICYmIGlzUHJvdG90eXBlT2YoUmVzdWx0UHJvdG90eXBlLCByZXN1bHQpKVxuICAgcmV0dXJuIHJlc3VsdDtcbiB9XG4gcmV0dXJuIG5ldyBSZXN1bHQoZmFsc2UpO1xufTtcblxuLyoqKi8gfSksXG4vKiAxNTUgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgd2VsbEtub3duU3ltYm9sID0gX193X3BkZmpzX3JlcXVpcmVfXygzNCk7XG52YXIgSXRlcmF0b3JzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTYpO1xudmFyIElURVJBVE9SID0gd2VsbEtub3duU3ltYm9sKCdpdGVyYXRvcicpO1xudmFyIEFycmF5UHJvdG90eXBlID0gQXJyYXkucHJvdG90eXBlO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoaXQpIHtcbiByZXR1cm4gaXQgIT09IHVuZGVmaW5lZCAmJiAoSXRlcmF0b3JzLkFycmF5ID09PSBpdCB8fCBBcnJheVByb3RvdHlwZVtJVEVSQVRPUl0gPT09IGl0KTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTU2ICovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cbm1vZHVsZS5leHBvcnRzID0ge307XG5cbi8qKiovIH0pLFxuLyogMTU3ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNhbGwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDgpO1xudmFyIGFDYWxsYWJsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMzEpO1xudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Nyk7XG52YXIgdHJ5VG9TdHJpbmcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMyKTtcbnZhciBnZXRJdGVyYXRvck1ldGhvZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTU4KTtcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoYXJndW1lbnQsIHVzaW5nSXRlcmF0b3IpIHtcbiB2YXIgaXRlcmF0b3JNZXRob2QgPSBhcmd1bWVudHMubGVuZ3RoIDwgMiA/IGdldEl0ZXJhdG9yTWV0aG9kKGFyZ3VtZW50KSA6IHVzaW5nSXRlcmF0b3I7XG4gaWYgKGFDYWxsYWJsZShpdGVyYXRvck1ldGhvZCkpXG4gIHJldHVybiBhbk9iamVjdChjYWxsKGl0ZXJhdG9yTWV0aG9kLCBhcmd1bWVudCkpO1xuIHRocm93ICRUeXBlRXJyb3IodHJ5VG9TdHJpbmcoYXJndW1lbnQpICsgJyBpcyBub3QgaXRlcmFibGUnKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTU4ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGNsYXNzb2YgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc4KTtcbnZhciBnZXRNZXRob2QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMwKTtcbnZhciBpc051bGxPclVuZGVmaW5lZCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTcpO1xudmFyIEl0ZXJhdG9ycyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTU2KTtcbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM0KTtcbnZhciBJVEVSQVRPUiA9IHdlbGxLbm93blN5bWJvbCgnaXRlcmF0b3InKTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGl0KSB7XG4gaWYgKCFpc051bGxPclVuZGVmaW5lZChpdCkpXG4gIHJldHVybiBnZXRNZXRob2QoaXQsIElURVJBVE9SKSB8fCBnZXRNZXRob2QoaXQsICdAQGl0ZXJhdG9yJykgfHwgSXRlcmF0b3JzW2NsYXNzb2YoaXQpXTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTU5ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4KTtcbnZhciBkZWZpbmVQcm9wZXJ0eU1vZHVsZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNDUpO1xudmFyIGNyZWF0ZVByb3BlcnR5RGVzY3JpcHRvciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTEpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAob2JqZWN0LCBrZXksIHZhbHVlKSB7XG4gdmFyIHByb3BlcnR5S2V5ID0gdG9Qcm9wZXJ0eUtleShrZXkpO1xuIGlmIChwcm9wZXJ0eUtleSBpbiBvYmplY3QpXG4gIGRlZmluZVByb3BlcnR5TW9kdWxlLmYob2JqZWN0LCBwcm9wZXJ0eUtleSwgY3JlYXRlUHJvcGVydHlEZXNjcmlwdG9yKDAsIHZhbHVlKSk7XG4gZWxzZVxuICBvYmplY3RbcHJvcGVydHlLZXldID0gdmFsdWU7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE2MCAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBjYWxsID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcbnZhciBoYXNPd24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM5KTtcbnZhciBpc1Byb3RvdHlwZU9mID0gX193X3BkZmpzX3JlcXVpcmVfXygyNSk7XG52YXIgcmVnRXhwRmxhZ3MgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2MSk7XG52YXIgUmVnRXhwUHJvdG90eXBlID0gUmVnRXhwLnByb3RvdHlwZTtcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKFIpIHtcbiB2YXIgZmxhZ3MgPSBSLmZsYWdzO1xuIHJldHVybiBmbGFncyA9PT0gdW5kZWZpbmVkICYmICEoJ2ZsYWdzJyBpbiBSZWdFeHBQcm90b3R5cGUpICYmICFoYXNPd24oUiwgJ2ZsYWdzJykgJiYgaXNQcm90b3R5cGVPZihSZWdFeHBQcm90b3R5cGUsIFIpID8gY2FsbChyZWdFeHBGbGFncywgUikgOiBmbGFncztcbn07XG5cbi8qKiovIH0pLFxuLyogMTYxICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGFuT2JqZWN0ID0gX193X3BkZmpzX3JlcXVpcmVfXyg0Nyk7XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiB2YXIgdGhhdCA9IGFuT2JqZWN0KHRoaXMpO1xuIHZhciByZXN1bHQgPSAnJztcbiBpZiAodGhhdC5oYXNJbmRpY2VzKVxuICByZXN1bHQgKz0gJ2QnO1xuIGlmICh0aGF0Lmdsb2JhbClcbiAgcmVzdWx0ICs9ICdnJztcbiBpZiAodGhhdC5pZ25vcmVDYXNlKVxuICByZXN1bHQgKz0gJ2knO1xuIGlmICh0aGF0Lm11bHRpbGluZSlcbiAgcmVzdWx0ICs9ICdtJztcbiBpZiAodGhhdC5kb3RBbGwpXG4gIHJlc3VsdCArPSAncyc7XG4gaWYgKHRoYXQudW5pY29kZSlcbiAgcmVzdWx0ICs9ICd1JztcbiBpZiAodGhhdC51bmljb2RlU2V0cylcbiAgcmVzdWx0ICs9ICd2JztcbiBpZiAodGhhdC5zdGlja3kpXG4gIHJlc3VsdCArPSAneSc7XG4gcmV0dXJuIHJlc3VsdDtcbn07XG5cbi8qKiovIH0pLFxuLyogMTYyICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIHVuY3VycnlUaGlzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNCk7XG52YXIgTWFwUHJvdG90eXBlID0gTWFwLnByb3RvdHlwZTtcbm1vZHVsZS5leHBvcnRzID0ge1xuIE1hcDogTWFwLFxuIHNldDogdW5jdXJyeVRoaXMoTWFwUHJvdG90eXBlLnNldCksXG4gZ2V0OiB1bmN1cnJ5VGhpcyhNYXBQcm90b3R5cGUuZ2V0KSxcbiBoYXM6IHVuY3VycnlUaGlzKE1hcFByb3RvdHlwZS5oYXMpLFxuIHJlbW92ZTogdW5jdXJyeVRoaXMoTWFwUHJvdG90eXBlWydkZWxldGUnXSksXG4gcHJvdG86IE1hcFByb3RvdHlwZVxufTtcblxuLyoqKi8gfSksXG4vKiAxNjMgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU2VyaWFsaXphYmxlRW1wdHkgPSBleHBvcnRzLlByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBleHBvcnRzLkFubm90YXRpb25TdG9yYWdlID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDE0OSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDE1Mik7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9lZGl0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2NCk7XG52YXIgX211cm11cmhhc2ggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3MCk7XG5jb25zdCBTZXJpYWxpemFibGVFbXB0eSA9IE9iamVjdC5mcmVlemUoe1xuICBtYXA6IG51bGwsXG4gIGhhc2g6IFwiXCIsXG4gIHRyYW5zZmVyczogdW5kZWZpbmVkXG59KTtcbmV4cG9ydHMuU2VyaWFsaXphYmxlRW1wdHkgPSBTZXJpYWxpemFibGVFbXB0eTtcbmNsYXNzIEFubm90YXRpb25TdG9yYWdlIHtcbiAgI21vZGlmaWVkID0gZmFsc2U7XG4gICNzdG9yYWdlID0gbmV3IE1hcCgpO1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLm9uU2V0TW9kaWZpZWQgPSBudWxsO1xuICAgIHRoaXMub25SZXNldE1vZGlmaWVkID0gbnVsbDtcbiAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9IG51bGw7XG4gIH1cbiAgZ2V0VmFsdWUoa2V5LCBkZWZhdWx0VmFsdWUpIHtcbiAgICBjb25zdCB2YWx1ZSA9IHRoaXMuI3N0b3JhZ2UuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBPYmplY3QuYXNzaWduKGRlZmF1bHRWYWx1ZSwgdmFsdWUpO1xuICB9XG4gIGdldFJhd1ZhbHVlKGtleSkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLmdldChrZXkpO1xuICB9XG4gIHJlbW92ZShrZXkpIHtcbiAgICB0aGlzLiNzdG9yYWdlLmRlbGV0ZShrZXkpO1xuICAgIGlmICh0aGlzLiNzdG9yYWdlLnNpemUgPT09IDApIHtcbiAgICAgIHRoaXMucmVzZXRNb2RpZmllZCgpO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGZvciAoY29uc3QgdmFsdWUgb2YgdGhpcy4jc3RvcmFnZS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHRoaXMub25Bbm5vdGF0aW9uRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgfVxuICBzZXRWYWx1ZShrZXksIHZhbHVlKSB7XG4gICAgY29uc3Qgb2JqID0gdGhpcy4jc3RvcmFnZS5nZXQoa2V5KTtcbiAgICBsZXQgbW9kaWZpZWQgPSBmYWxzZTtcbiAgICBpZiAob2JqICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIGZvciAoY29uc3QgW2VudHJ5LCB2YWxdIG9mIE9iamVjdC5lbnRyaWVzKHZhbHVlKSkge1xuICAgICAgICBpZiAob2JqW2VudHJ5XSAhPT0gdmFsKSB7XG4gICAgICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgICAgIG9ialtlbnRyeV0gPSB2YWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbW9kaWZpZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc3RvcmFnZS5zZXQoa2V5LCB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChtb2RpZmllZCkge1xuICAgICAgdGhpcy4jc2V0TW9kaWZpZWQoKTtcbiAgICB9XG4gICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yICYmIHR5cGVvZiB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvciA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLm9uQW5ub3RhdGlvbkVkaXRvcih2YWx1ZS5jb25zdHJ1Y3Rvci5fdHlwZSk7XG4gICAgfVxuICB9XG4gIGhhcyhrZXkpIHtcbiAgICByZXR1cm4gdGhpcy4jc3RvcmFnZS5oYXMoa2V5KTtcbiAgfVxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3N0b3JhZ2Uuc2l6ZSA+IDAgPyAoMCwgX3V0aWwub2JqZWN0RnJvbU1hcCkodGhpcy4jc3RvcmFnZSkgOiBudWxsO1xuICB9XG4gIHNldEFsbChvYmopIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgT2JqZWN0LmVudHJpZXMob2JqKSkge1xuICAgICAgdGhpcy5zZXRWYWx1ZShrZXksIHZhbCk7XG4gICAgfVxuICB9XG4gIGdldCBzaXplKCkge1xuICAgIHJldHVybiB0aGlzLiNzdG9yYWdlLnNpemU7XG4gIH1cbiAgI3NldE1vZGlmaWVkKCkge1xuICAgIGlmICghdGhpcy4jbW9kaWZpZWQpIHtcbiAgICAgIHRoaXMuI21vZGlmaWVkID0gdHJ1ZTtcbiAgICAgIGlmICh0eXBlb2YgdGhpcy5vblNldE1vZGlmaWVkID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgICAgdGhpcy5vblNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJlc2V0TW9kaWZpZWQoKSB7XG4gICAgaWYgKHRoaXMuI21vZGlmaWVkKSB7XG4gICAgICB0aGlzLiNtb2RpZmllZCA9IGZhbHNlO1xuICAgICAgaWYgKHR5cGVvZiB0aGlzLm9uUmVzZXRNb2RpZmllZCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIHRoaXMub25SZXNldE1vZGlmaWVkKCk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICByZXR1cm4gbmV3IFByaW50QW5ub3RhdGlvblN0b3JhZ2UodGhpcyk7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICBpZiAodGhpcy4jc3RvcmFnZS5zaXplID09PSAwKSB7XG4gICAgICByZXR1cm4gU2VyaWFsaXphYmxlRW1wdHk7XG4gICAgfVxuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoKSxcbiAgICAgIGhhc2ggPSBuZXcgX211cm11cmhhc2guTXVybXVySGFzaDNfNjQoKSxcbiAgICAgIHRyYW5zZmVycyA9IFtdO1xuICAgIGNvbnN0IGNvbnRleHQgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGxldCBoYXNCaXRtYXAgPSBmYWxzZTtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbF0gb2YgdGhpcy4jc3RvcmFnZSkge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IHZhbCBpbnN0YW5jZW9mIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvciA/IHZhbC5zZXJpYWxpemUoZmFsc2UsIGNvbnRleHQpIDogdmFsO1xuICAgICAgaWYgKHNlcmlhbGl6ZWQpIHtcbiAgICAgICAgbWFwLnNldChrZXksIHNlcmlhbGl6ZWQpO1xuICAgICAgICBoYXNoLnVwZGF0ZShgJHtrZXl9OiR7SlNPTi5zdHJpbmdpZnkoc2VyaWFsaXplZCl9YCk7XG4gICAgICAgIGhhc0JpdG1hcCB8fD0gISFzZXJpYWxpemVkLmJpdG1hcDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGhhc0JpdG1hcCkge1xuICAgICAgZm9yIChjb25zdCB2YWx1ZSBvZiBtYXAudmFsdWVzKCkpIHtcbiAgICAgICAgaWYgKHZhbHVlLmJpdG1hcCkge1xuICAgICAgICAgIHRyYW5zZmVycy5wdXNoKHZhbHVlLmJpdG1hcCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG1hcC5zaXplID4gMCA/IHtcbiAgICAgIG1hcCxcbiAgICAgIGhhc2g6IGhhc2guaGV4ZGlnZXN0KCksXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9IDogU2VyaWFsaXphYmxlRW1wdHk7XG4gIH1cbn1cbmV4cG9ydHMuQW5ub3RhdGlvblN0b3JhZ2UgPSBBbm5vdGF0aW9uU3RvcmFnZTtcbmNsYXNzIFByaW50QW5ub3RhdGlvblN0b3JhZ2UgZXh0ZW5kcyBBbm5vdGF0aW9uU3RvcmFnZSB7XG4gICNzZXJpYWxpemFibGU7XG4gIGNvbnN0cnVjdG9yKHBhcmVudCkge1xuICAgIHN1cGVyKCk7XG4gICAgY29uc3Qge1xuICAgICAgbWFwLFxuICAgICAgaGFzaCxcbiAgICAgIHRyYW5zZmVyc1xuICAgIH0gPSBwYXJlbnQuc2VyaWFsaXphYmxlO1xuICAgIGNvbnN0IGNsb25lID0gc3RydWN0dXJlZENsb25lKG1hcCwgbnVsbCk7XG4gICAgdGhpcy4jc2VyaWFsaXphYmxlID0ge1xuICAgICAgbWFwOiBjbG9uZSxcbiAgICAgIGhhc2gsXG4gICAgICB0cmFuc2ZlcnNcbiAgICB9O1xuICB9XG4gIGdldCBwcmludCgpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiU2hvdWxkIG5vdCBjYWxsIFByaW50QW5ub3RhdGlvblN0b3JhZ2UucHJpbnRcIik7XG4gIH1cbiAgZ2V0IHNlcmlhbGl6YWJsZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jc2VyaWFsaXphYmxlO1xuICB9XG59XG5leHBvcnRzLlByaW50QW5ub3RhdGlvblN0b3JhZ2UgPSBQcmludEFubm90YXRpb25TdG9yYWdlO1xuXG4vKioqLyB9KSxcbi8qIDE2NCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xudmFyIF90b29scyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTY1KTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2OCk7XG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2FsdFRleHQgPSBcIlwiO1xuICAjYWx0VGV4dERlY29yYXRpdmUgPSBmYWxzZTtcbiAgI2FsdFRleHRCdXR0b24gPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICAjYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgI2tlZXBBc3BlY3RSYXRpbyA9IGZhbHNlO1xuICAjcmVzaXplcnNEaXYgPSBudWxsO1xuICAjYm91bmRGb2N1c2luID0gdGhpcy5mb2N1c2luLmJpbmQodGhpcyk7XG4gICNib3VuZEZvY3Vzb3V0ID0gdGhpcy5mb2N1c291dC5iaW5kKHRoaXMpO1xuICAjaGFzQmVlbkNsaWNrZWQgPSBmYWxzZTtcbiAgI2lzRWRpdGluZyA9IGZhbHNlO1xuICAjaXNJbkVkaXRNb2RlID0gZmFsc2U7XG4gIF9pbml0aWFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIF91aU1hbmFnZXIgPSBudWxsO1xuICBfZm9jdXNFdmVudHNBbGxvd2VkID0gdHJ1ZTtcbiAgX2wxMG5Qcm9taXNlID0gbnVsbDtcbiAgI2lzRHJhZ2dhYmxlID0gZmFsc2U7XG4gICN6SW5kZXggPSBBbm5vdGF0aW9uRWRpdG9yLl96SW5kZXgrKztcbiAgc3RhdGljIF9ib3JkZXJMaW5lV2lkdGggPSAtMTtcbiAgc3RhdGljIF9jb2xvck1hbmFnZXIgPSBuZXcgX3Rvb2xzLkNvbG9yTWFuYWdlcigpO1xuICBzdGF0aWMgX3pJbmRleCA9IDE7XG4gIHN0YXRpYyBTTUFMTF9FRElUT1JfU0laRSA9IDA7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQW5ub3RhdGlvbkVkaXRvcikge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEFubm90YXRpb25FZGl0b3IuXCIpO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIHRoaXMuaWQgPSBwYXJhbWV0ZXJzLmlkO1xuICAgIHRoaXMud2lkdGggPSB0aGlzLmhlaWdodCA9IG51bGw7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYXJhbWV0ZXJzLnBhcmVudC5wYWdlSW5kZXg7XG4gICAgdGhpcy5uYW1lID0gcGFyYW1ldGVycy5uYW1lO1xuICAgIHRoaXMuZGl2ID0gbnVsbDtcbiAgICB0aGlzLl91aU1hbmFnZXIgPSBwYXJhbWV0ZXJzLnVpTWFuYWdlcjtcbiAgICB0aGlzLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSBmYWxzZTtcbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucy5pc0NlbnRlcmVkID0gcGFyYW1ldGVycy5pc0NlbnRlcmVkO1xuICAgIHRoaXMuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IG51bGw7XG4gICAgY29uc3Qge1xuICAgICAgcm90YXRpb24sXG4gICAgICByYXdEaW1zOiB7XG4gICAgICAgIHBhZ2VXaWR0aCxcbiAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgcGFnZVgsXG4gICAgICAgIHBhZ2VZXG4gICAgICB9XG4gICAgfSA9IHRoaXMucGFyZW50LnZpZXdwb3J0O1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLnBhZ2VSb3RhdGlvbiA9ICgzNjAgKyByb3RhdGlvbiAtIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yb3RhdGlvbikgJSAzNjA7XG4gICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMucGFnZVRyYW5zbGF0aW9uID0gW3BhZ2VYLCBwYWdlWV07XG4gICAgY29uc3QgW3dpZHRoLCBoZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMueCA9IHBhcmFtZXRlcnMueCAvIHdpZHRoO1xuICAgIHRoaXMueSA9IHBhcmFtZXRlcnMueSAvIGhlaWdodDtcbiAgICB0aGlzLmlzQXR0YWNoZWRUb0RPTSA9IGZhbHNlO1xuICAgIHRoaXMuZGVsZXRlZCA9IGZhbHNlO1xuICB9XG4gIGdldCBlZGl0b3JUeXBlKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2YodGhpcykuY29uc3RydWN0b3IuX3R5cGU7XG4gIH1cbiAgc3RhdGljIGdldCBfZGVmYXVsdExpbmVDb2xvcigpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfZGVmYXVsdExpbmVDb2xvclwiLCB0aGlzLl9jb2xvck1hbmFnZXIuZ2V0SGV4Q29kZShcIkNhbnZhc1RleHRcIikpO1xuICB9XG4gIHN0YXRpYyBkZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICBjb25zdCBmYWtlRWRpdG9yID0gbmV3IEZha2VFZGl0b3Ioe1xuICAgICAgaWQ6IGVkaXRvci5wYXJlbnQuZ2V0TmV4dElkKCksXG4gICAgICBwYXJlbnQ6IGVkaXRvci5wYXJlbnQsXG4gICAgICB1aU1hbmFnZXI6IGVkaXRvci5fdWlNYW5hZ2VyXG4gICAgfSk7XG4gICAgZmFrZUVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkID0gZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgZmFrZUVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgICBmYWtlRWRpdG9yLl91aU1hbmFnZXIuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZShmYWtlRWRpdG9yKTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UgfHw9IG5ldyBNYXAoW1wiZWRpdG9yX2FsdF90ZXh0X2J1dHRvbl9sYWJlbFwiLCBcImVkaXRvcl9hbHRfdGV4dF9lZGl0X2J1dHRvbl9sYWJlbFwiLCBcImVkaXRvcl9hbHRfdGV4dF9kZWNvcmF0aXZlX3Rvb2x0aXBcIl0ubWFwKHN0ciA9PiBbc3RyLCBsMTBuLmdldChzdHIpXSkpO1xuICAgIGlmIChvcHRpb25zPy5zdHJpbmdzKSB7XG4gICAgICBmb3IgKGNvbnN0IHN0ciBvZiBvcHRpb25zLnN0cmluZ3MpIHtcbiAgICAgICAgQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2Uuc2V0KHN0ciwgbDEwbi5nZXQoc3RyKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChBbm5vdGF0aW9uRWRpdG9yLl9ib3JkZXJMaW5lV2lkdGggIT09IC0xKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQpO1xuICAgIEFubm90YXRpb25FZGl0b3IuX2JvcmRlckxpbmVXaWR0aCA9IHBhcnNlRmxvYXQoc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcIi0tb3V0bGluZS13aWR0aFwiKSkgfHwgMDtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyhfdHlwZSwgX3ZhbHVlKSB7fVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIHN0YXRpYyBpc0hhbmRsaW5nTWltZUZvclBhc3RpbmcobWltZSkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBzdGF0aWMgcGFzdGUoaXRlbSwgcGFyZW50KSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIk5vdCBpbXBsZW1lbnRlZFwiKTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbXTtcbiAgfVxuICBnZXQgX2lzRHJhZ2dhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLiNpc0RyYWdnYWJsZTtcbiAgfVxuICBzZXQgX2lzRHJhZ2dhYmxlKHZhbHVlKSB7XG4gICAgdGhpcy4jaXNEcmFnZ2FibGUgPSB2YWx1ZTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LnRvZ2dsZShcImRyYWdnYWJsZVwiLCB2YWx1ZSk7XG4gIH1cbiAgY2VudGVyKCkge1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBzd2l0Y2ggKHRoaXMucGFyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHRoaXMueCAtPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQgLyAocGFnZVdpZHRoICogMik7XG4gICAgICAgIHRoaXMueSArPSB0aGlzLndpZHRoICogcGFnZVdpZHRoIC8gKHBhZ2VIZWlnaHQgKiAyKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgdGhpcy54ICs9IHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnkgKz0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB0aGlzLnggKz0gdGhpcy5oZWlnaHQgKiBwYWdlSGVpZ2h0IC8gKHBhZ2VXaWR0aCAqIDIpO1xuICAgICAgICB0aGlzLnkgLT0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAvIChwYWdlSGVpZ2h0ICogMik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhpcy54IC09IHRoaXMud2lkdGggLyAyO1xuICAgICAgICB0aGlzLnkgLT0gdGhpcy5oZWlnaHQgLyAyO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGFkZENvbW1hbmRzKHBhcmFtcykge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRDb21tYW5kcyhwYXJhbXMpO1xuICB9XG4gIGdldCBjdXJyZW50TGF5ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci5jdXJyZW50TGF5ZXI7XG4gIH1cbiAgc2V0SW5CYWNrZ3JvdW5kKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IDA7XG4gIH1cbiAgc2V0SW5Gb3JlZ3JvdW5kKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnpJbmRleCA9IHRoaXMuI3pJbmRleDtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudCAhPT0gbnVsbCkge1xuICAgICAgdGhpcy5wYWdlSW5kZXggPSBwYXJlbnQucGFnZUluZGV4O1xuICAgICAgdGhpcy5wYWdlRGltZW5zaW9ucyA9IHBhcmVudC5wYWdlRGltZW5zaW9ucztcbiAgICB9XG4gICAgdGhpcy5wYXJlbnQgPSBwYXJlbnQ7XG4gIH1cbiAgZm9jdXNpbihldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jaGFzQmVlbkNsaWNrZWQpIHtcbiAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBmb2N1c291dChldmVudCkge1xuICAgIGlmICghdGhpcy5fZm9jdXNFdmVudHNBbGxvd2VkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGFyZ2V0ID0gZXZlbnQucmVsYXRlZFRhcmdldDtcbiAgICBpZiAodGFyZ2V0Py5jbG9zZXN0KGAjJHt0aGlzLmlkfWApKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgaWYgKCF0aGlzLnBhcmVudD8uaXNNdWx0aXBsZVNlbGVjdGlvbikge1xuICAgICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIH1cbiAgfVxuICBjb21taXRPclJlbW92ZSgpIHtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICB9XG4gIGNvbW1pdCgpIHtcbiAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoKTtcbiAgfVxuICBhZGRUb0Fubm90YXRpb25TdG9yYWdlKCkge1xuICAgIHRoaXMuX3VpTWFuYWdlci5hZGRUb0Fubm90YXRpb25TdG9yYWdlKHRoaXMpO1xuICB9XG4gIHNldEF0KHgsIHksIHR4LCB0eSkge1xuICAgIGNvbnN0IFt3aWR0aCwgaGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBbdHgsIHR5XSA9IHRoaXMuc2NyZWVuVG9QYWdlVHJhbnNsYXRpb24odHgsIHR5KTtcbiAgICB0aGlzLnggPSAoeCArIHR4KSAvIHdpZHRoO1xuICAgIHRoaXMueSA9ICh5ICsgdHkpIC8gaGVpZ2h0O1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICAjdHJhbnNsYXRlKF9yZWYsIHgsIHkpIHtcbiAgICBsZXQgW3dpZHRoLCBoZWlnaHRdID0gX3JlZjtcbiAgICBbeCwgeV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKHgsIHkpO1xuICAgIHRoaXMueCArPSB4IC8gd2lkdGg7XG4gICAgdGhpcy55ICs9IHkgLyBoZWlnaHQ7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIHRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgdGhpcy4jdHJhbnNsYXRlKHRoaXMucGFyZW50RGltZW5zaW9ucywgeCwgeSk7XG4gIH1cbiAgdHJhbnNsYXRlSW5QYWdlKHgsIHkpIHtcbiAgICB0aGlzLiN0cmFuc2xhdGUodGhpcy5wYWdlRGltZW5zaW9ucywgeCwgeSk7XG4gICAgdGhpcy5kaXYuc2Nyb2xsSW50b1ZpZXcoe1xuICAgICAgYmxvY2s6IFwibmVhcmVzdFwiXG4gICAgfSk7XG4gIH1cbiAgZHJhZyh0eCwgdHkpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy54ICs9IHR4IC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy55ICs9IHR5IC8gcGFyZW50SGVpZ2h0O1xuICAgIGlmICh0aGlzLnBhcmVudCAmJiAodGhpcy54IDwgMCB8fCB0aGlzLnggPiAxIHx8IHRoaXMueSA8IDAgfHwgdGhpcy55ID4gMSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeCxcbiAgICAgICAgeVxuICAgICAgfSA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgICAgaWYgKHRoaXMucGFyZW50LmZpbmROZXdQYXJlbnQodGhpcywgeCwgeSkpIHtcbiAgICAgICAgdGhpcy54IC09IE1hdGguZmxvb3IodGhpcy54KTtcbiAgICAgICAgdGhpcy55IC09IE1hdGguZmxvb3IodGhpcy55KTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHtcbiAgICAgIHgsXG4gICAgICB5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3QgW2J4LCBieV0gPSB0aGlzLiNnZXRCYXNlVHJhbnNsYXRpb24oKTtcbiAgICB4ICs9IGJ4O1xuICAgIHkgKz0gYnk7XG4gICAgdGhpcy5kaXYuc3R5bGUubGVmdCA9IGAkeygxMDAgKiB4KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuZGl2LnN0eWxlLnRvcCA9IGAkeygxMDAgKiB5KS50b0ZpeGVkKDIpfSVgO1xuICAgIHRoaXMuZGl2LnNjcm9sbEludG9WaWV3KHtcbiAgICAgIGJsb2NrOiBcIm5lYXJlc3RcIlxuICAgIH0pO1xuICB9XG4gICNnZXRCYXNlVHJhbnNsYXRpb24oKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGNvbnN0IHtcbiAgICAgIF9ib3JkZXJMaW5lV2lkdGhcbiAgICB9ID0gQW5ub3RhdGlvbkVkaXRvcjtcbiAgICBjb25zdCB4ID0gX2JvcmRlckxpbmVXaWR0aCAvIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHkgPSBfYm9yZGVyTGluZVdpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFsteCwgeV07XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcmV0dXJuIFt4LCB5XTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByZXR1cm4gW3gsIC15XTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBbLXgsIC15XTtcbiAgICB9XG4gIH1cbiAgZml4QW5kU2V0UG9zaXRpb24oKSB7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGxldCB7XG4gICAgICB4LFxuICAgICAgeSxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IHRoaXM7XG4gICAgd2lkdGggKj0gcGFnZVdpZHRoO1xuICAgIGhlaWdodCAqPSBwYWdlSGVpZ2h0O1xuICAgIHggKj0gcGFnZVdpZHRoO1xuICAgIHkgKj0gcGFnZUhlaWdodDtcbiAgICBzd2l0Y2ggKHRoaXMucm90YXRpb24pIHtcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VXaWR0aCAtIHdpZHRoLCB4KSk7XG4gICAgICAgIHkgPSBNYXRoLm1heCgwLCBNYXRoLm1pbihwYWdlSGVpZ2h0IC0gaGVpZ2h0LCB5KSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgeCA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VXaWR0aCAtIGhlaWdodCwgeCkpO1xuICAgICAgICB5ID0gTWF0aC5taW4ocGFnZUhlaWdodCwgTWF0aC5tYXgod2lkdGgsIHkpKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgeCA9IE1hdGgubWluKHBhZ2VXaWR0aCwgTWF0aC5tYXgod2lkdGgsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWluKHBhZ2VIZWlnaHQsIE1hdGgubWF4KGhlaWdodCwgeSkpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB4ID0gTWF0aC5taW4ocGFnZVdpZHRoLCBNYXRoLm1heChoZWlnaHQsIHgpKTtcbiAgICAgICAgeSA9IE1hdGgubWF4KDAsIE1hdGgubWluKHBhZ2VIZWlnaHQgLSB3aWR0aCwgeSkpO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gICAgdGhpcy54ID0geCAvPSBwYWdlV2lkdGg7XG4gICAgdGhpcy55ID0geSAvPSBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IFtieCwgYnldID0gdGhpcy4jZ2V0QmFzZVRyYW5zbGF0aW9uKCk7XG4gICAgeCArPSBieDtcbiAgICB5ICs9IGJ5O1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZGl2O1xuICAgIHN0eWxlLmxlZnQgPSBgJHsoMTAwICogeCkudG9GaXhlZCgyKX0lYDtcbiAgICBzdHlsZS50b3AgPSBgJHsoMTAwICogeSkudG9GaXhlZCgyKX0lYDtcbiAgICB0aGlzLm1vdmVJbkRPTSgpO1xuICB9XG4gIHN0YXRpYyAjcm90YXRlUG9pbnQoeCwgeSwgYW5nbGUpIHtcbiAgICBzd2l0Y2ggKGFuZ2xlKSB7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ksIC14XTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gWy14LCAteV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFsteSwgeF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gW3gsIHldO1xuICAgIH1cbiAgfVxuICBzY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbih4LCB5KSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FZGl0b3IuI3JvdGF0ZVBvaW50KHgsIHksIHRoaXMucGFyZW50Um90YXRpb24pO1xuICB9XG4gIHBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHgsIHkpIHtcbiAgICByZXR1cm4gQW5ub3RhdGlvbkVkaXRvci4jcm90YXRlUG9pbnQoeCwgeSwgMzYwIC0gdGhpcy5wYXJlbnRSb3RhdGlvbik7XG4gIH1cbiAgI2dldFJvdGF0aW9uTWF0cml4KHJvdGF0aW9uKSB7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAge1xuICAgICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgICByZXR1cm4gWzAsIC1wYWdlV2lkdGggLyBwYWdlSGVpZ2h0LCBwYWdlSGVpZ2h0IC8gcGFnZVdpZHRoLCAwXTtcbiAgICAgICAgfVxuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbLTEsIDAsIDAsIC0xXTtcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICB7XG4gICAgICAgICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgICAgICAgIHJldHVybiBbMCwgcGFnZVdpZHRoIC8gcGFnZUhlaWdodCwgLXBhZ2VIZWlnaHQgLyBwYWdlV2lkdGgsIDBdO1xuICAgICAgICB9XG4gICAgICBkZWZhdWx0OlxuICAgICAgICByZXR1cm4gWzEsIDAsIDAsIDFdO1xuICAgIH1cbiAgfVxuICBnZXQgcGFyZW50U2NhbGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX3VpTWFuYWdlci52aWV3UGFyYW1ldGVycy5yZWFsU2NhbGU7XG4gIH1cbiAgZ2V0IHBhcmVudFJvdGF0aW9uKCkge1xuICAgIHJldHVybiAodGhpcy5fdWlNYW5hZ2VyLnZpZXdQYXJhbWV0ZXJzLnJvdGF0aW9uICsgdGhpcy5wYWdlUm90YXRpb24pICUgMzYwO1xuICB9XG4gIGdldCBwYXJlbnREaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhcmVudFNjYWxlLFxuICAgICAgcGFnZURpbWVuc2lvbnM6IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdXG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc2NhbGVkV2lkdGggPSBwYWdlV2lkdGggKiBwYXJlbnRTY2FsZTtcbiAgICBjb25zdCBzY2FsZWRIZWlnaHQgPSBwYWdlSGVpZ2h0ICogcGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIF91dGlsLkZlYXR1cmVUZXN0LmlzQ1NTUm91bmRTdXBwb3J0ZWQgPyBbTWF0aC5yb3VuZChzY2FsZWRXaWR0aCksIE1hdGgucm91bmQoc2NhbGVkSGVpZ2h0KV0gOiBbc2NhbGVkV2lkdGgsIHNjYWxlZEhlaWdodF07XG4gIH1cbiAgc2V0RGltcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuZGl2LnN0eWxlLndpZHRoID0gYCR7KDEwMCAqIHdpZHRoIC8gcGFyZW50V2lkdGgpLnRvRml4ZWQoMil9JWA7XG4gICAgaWYgKCF0aGlzLiNrZWVwQXNwZWN0UmF0aW8pIHtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmhlaWdodCA9IGAkeygxMDAgKiBoZWlnaHQgLyBwYXJlbnRIZWlnaHQpLnRvRml4ZWQoMil9JWA7XG4gICAgfVxuICAgIHRoaXMuI2FsdFRleHRCdXR0b24/LmNsYXNzTGlzdC50b2dnbGUoXCJzbWFsbFwiLCB3aWR0aCA8IEFubm90YXRpb25FZGl0b3IuU01BTExfRURJVE9SX1NJWkUgfHwgaGVpZ2h0IDwgQW5ub3RhdGlvbkVkaXRvci5TTUFMTF9FRElUT1JfU0laRSk7XG4gIH1cbiAgZml4RGltcygpIHtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBjb25zdCB7XG4gICAgICBoZWlnaHQsXG4gICAgICB3aWR0aFxuICAgIH0gPSBzdHlsZTtcbiAgICBjb25zdCB3aWR0aFBlcmNlbnQgPSB3aWR0aC5lbmRzV2l0aChcIiVcIik7XG4gICAgY29uc3QgaGVpZ2h0UGVyY2VudCA9ICF0aGlzLiNrZWVwQXNwZWN0UmF0aW8gJiYgaGVpZ2h0LmVuZHNXaXRoKFwiJVwiKTtcbiAgICBpZiAod2lkdGhQZXJjZW50ICYmIGhlaWdodFBlcmNlbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGlmICghd2lkdGhQZXJjZW50KSB7XG4gICAgICBzdHlsZS53aWR0aCA9IGAkeygxMDAgKiBwYXJzZUZsb2F0KHdpZHRoKSAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2tlZXBBc3BlY3RSYXRpbyAmJiAhaGVpZ2h0UGVyY2VudCkge1xuICAgICAgc3R5bGUuaGVpZ2h0ID0gYCR7KDEwMCAqIHBhcnNlRmxvYXQoaGVpZ2h0KSAvIHBhcmVudEhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgICB9XG4gIH1cbiAgZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCkge1xuICAgIHJldHVybiBbMCwgMF07XG4gIH1cbiAgI2NyZWF0ZVJlc2l6ZXJzKCkge1xuICAgIGlmICh0aGlzLiNyZXNpemVyc0Rpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNyZXNpemVyc0RpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy4jcmVzaXplcnNEaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJzXCIpO1xuICAgIGNvbnN0IGNsYXNzZXMgPSBbXCJ0b3BMZWZ0XCIsIFwidG9wUmlnaHRcIiwgXCJib3R0b21SaWdodFwiLCBcImJvdHRvbUxlZnRcIl07XG4gICAgaWYgKCF0aGlzLl93aWxsS2VlcEFzcGVjdFJhdGlvKSB7XG4gICAgICBjbGFzc2VzLnB1c2goXCJ0b3BNaWRkbGVcIiwgXCJtaWRkbGVSaWdodFwiLCBcImJvdHRvbU1pZGRsZVwiLCBcIm1pZGRsZUxlZnRcIik7XG4gICAgfVxuICAgIGZvciAoY29uc3QgbmFtZSBvZiBjbGFzc2VzKSB7XG4gICAgICBjb25zdCBkaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgICAgdGhpcy4jcmVzaXplcnNEaXYuYXBwZW5kKGRpdik7XG4gICAgICBkaXYuY2xhc3NMaXN0LmFkZChcInJlc2l6ZXJcIiwgbmFtZSk7XG4gICAgICBkaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI3Jlc2l6ZXJQb2ludGVyZG93bi5iaW5kKHRoaXMsIG5hbWUpKTtcbiAgICAgIGRpdi5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudSk7XG4gICAgfVxuICAgIHRoaXMuZGl2LnByZXBlbmQodGhpcy4jcmVzaXplcnNEaXYpO1xuICB9XG4gICNyZXNpemVyUG9pbnRlcmRvd24obmFtZSwgZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBib3VuZFJlc2l6ZXJQb2ludGVybW92ZSA9IHRoaXMuI3Jlc2l6ZXJQb2ludGVybW92ZS5iaW5kKHRoaXMsIG5hbWUpO1xuICAgIGNvbnN0IHNhdmVkRHJhZ2dhYmxlID0gdGhpcy5faXNEcmFnZ2FibGU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICBjb25zdCBwb2ludGVyTW92ZU9wdGlvbnMgPSB7XG4gICAgICBwYXNzaXZlOiB0cnVlLFxuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBib3VuZFJlc2l6ZXJQb2ludGVybW92ZSwgcG9pbnRlck1vdmVPcHRpb25zKTtcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRQYXJlbnRDdXJzb3IgPSB0aGlzLnBhcmVudC5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIGNvbnN0IHNhdmVkQ3Vyc29yID0gdGhpcy5kaXYuc3R5bGUuY3Vyc29yO1xuICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZShldmVudC50YXJnZXQpLmN1cnNvcjtcbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gc2F2ZWREcmFnZ2FibGU7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBib3VuZFJlc2l6ZXJQb2ludGVybW92ZSwgcG9pbnRlck1vdmVPcHRpb25zKTtcbiAgICAgIHRoaXMucGFyZW50LmRpdi5zdHlsZS5jdXJzb3IgPSBzYXZlZFBhcmVudEN1cnNvcjtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLmN1cnNvciA9IHNhdmVkQ3Vyc29yO1xuICAgICAgY29uc3QgbmV3WCA9IHRoaXMueDtcbiAgICAgIGNvbnN0IG5ld1kgPSB0aGlzLnk7XG4gICAgICBjb25zdCBuZXdXaWR0aCA9IHRoaXMud2lkdGg7XG4gICAgICBjb25zdCBuZXdIZWlnaHQgPSB0aGlzLmhlaWdodDtcbiAgICAgIGlmIChuZXdYID09PSBzYXZlZFggJiYgbmV3WSA9PT0gc2F2ZWRZICYmIG5ld1dpZHRoID09PSBzYXZlZFdpZHRoICYmIG5ld0hlaWdodCA9PT0gc2F2ZWRIZWlnaHQpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2lkdGggPSBuZXdXaWR0aDtcbiAgICAgICAgICB0aGlzLmhlaWdodCA9IG5ld0hlaWdodDtcbiAgICAgICAgICB0aGlzLnggPSBuZXdYO1xuICAgICAgICAgIHRoaXMueSA9IG5ld1k7XG4gICAgICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgICAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIHRoaXMud2lkdGggPSBzYXZlZFdpZHRoO1xuICAgICAgICAgIHRoaXMuaGVpZ2h0ID0gc2F2ZWRIZWlnaHQ7XG4gICAgICAgICAgdGhpcy54ID0gc2F2ZWRYO1xuICAgICAgICAgIHRoaXMueSA9IHNhdmVkWTtcbiAgICAgICAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgICAgICAgdGhpcy5zZXREaW1zKHBhcmVudFdpZHRoICogc2F2ZWRXaWR0aCwgcGFyZW50SGVpZ2h0ICogc2F2ZWRIZWlnaHQpO1xuICAgICAgICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICAgICAgfSxcbiAgICAgICAgbXVzdEV4ZWM6IHRydWVcbiAgICAgIH0pO1xuICAgIH07XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgcG9pbnRlclVwQ2FsbGJhY2spO1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gIH1cbiAgI3Jlc2l6ZXJQb2ludGVybW92ZShuYW1lLCBldmVudCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCBzYXZlZFggPSB0aGlzLng7XG4gICAgY29uc3Qgc2F2ZWRZID0gdGhpcy55O1xuICAgIGNvbnN0IHNhdmVkV2lkdGggPSB0aGlzLndpZHRoO1xuICAgIGNvbnN0IHNhdmVkSGVpZ2h0ID0gdGhpcy5oZWlnaHQ7XG4gICAgY29uc3QgbWluV2lkdGggPSBBbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFIC8gcGFyZW50V2lkdGg7XG4gICAgY29uc3QgbWluSGVpZ2h0ID0gQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSAvIHBhcmVudEhlaWdodDtcbiAgICBjb25zdCByb3VuZCA9IHggPT4gTWF0aC5yb3VuZCh4ICogMTAwMDApIC8gMTAwMDA7XG4gICAgY29uc3Qgcm90YXRpb25NYXRyaXggPSB0aGlzLiNnZXRSb3RhdGlvbk1hdHJpeCh0aGlzLnJvdGF0aW9uKTtcbiAgICBjb25zdCB0cmFuc2YgPSAoeCwgeSkgPT4gW3JvdGF0aW9uTWF0cml4WzBdICogeCArIHJvdGF0aW9uTWF0cml4WzJdICogeSwgcm90YXRpb25NYXRyaXhbMV0gKiB4ICsgcm90YXRpb25NYXRyaXhbM10gKiB5XTtcbiAgICBjb25zdCBpbnZSb3RhdGlvbk1hdHJpeCA9IHRoaXMuI2dldFJvdGF0aW9uTWF0cml4KDM2MCAtIHRoaXMucm90YXRpb24pO1xuICAgIGNvbnN0IGludlRyYW5zZiA9ICh4LCB5KSA9PiBbaW52Um90YXRpb25NYXRyaXhbMF0gKiB4ICsgaW52Um90YXRpb25NYXRyaXhbMl0gKiB5LCBpbnZSb3RhdGlvbk1hdHJpeFsxXSAqIHggKyBpbnZSb3RhdGlvbk1hdHJpeFszXSAqIHldO1xuICAgIGxldCBnZXRQb2ludDtcbiAgICBsZXQgZ2V0T3Bwb3NpdGU7XG4gICAgbGV0IGlzRGlhZ29uYWwgPSBmYWxzZTtcbiAgICBsZXQgaXNIb3Jpem9udGFsID0gZmFsc2U7XG4gICAgc3dpdGNoIChuYW1lKSB7XG4gICAgICBjYXNlIFwidG9wTGVmdFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gWzAsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInRvcE1pZGRsZVwiOlxuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdyAvIDIsIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbdyAvIDIsIGhdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJ0b3BSaWdodFwiOlxuICAgICAgICBpc0RpYWdvbmFsID0gdHJ1ZTtcbiAgICAgICAgZ2V0UG9pbnQgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBnZXRPcHBvc2l0ZSA9ICh3LCBoKSA9PiBbMCwgaF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIm1pZGRsZVJpZ2h0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbVJpZ2h0XCI6XG4gICAgICAgIGlzRGlhZ29uYWwgPSB0cnVlO1xuICAgICAgICBnZXRQb2ludCA9ICh3LCBoKSA9PiBbdywgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFswLCAwXTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFwiYm90dG9tTWlkZGxlXCI6XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFt3IC8gMiwgaF07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3IC8gMiwgMF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImJvdHRvbUxlZnRcIjpcbiAgICAgICAgaXNEaWFnb25hbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoXTtcbiAgICAgICAgZ2V0T3Bwb3NpdGUgPSAodywgaCkgPT4gW3csIDBdO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJtaWRkbGVMZWZ0XCI6XG4gICAgICAgIGlzSG9yaXpvbnRhbCA9IHRydWU7XG4gICAgICAgIGdldFBvaW50ID0gKHcsIGgpID0+IFswLCBoIC8gMl07XG4gICAgICAgIGdldE9wcG9zaXRlID0gKHcsIGgpID0+IFt3LCBoIC8gMl07XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBwb2ludCA9IGdldFBvaW50KHNhdmVkV2lkdGgsIHNhdmVkSGVpZ2h0KTtcbiAgICBjb25zdCBvcHBvc2l0ZVBvaW50ID0gZ2V0T3Bwb3NpdGUoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgIGxldCB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLm9wcG9zaXRlUG9pbnQpO1xuICAgIGNvbnN0IG9wcG9zaXRlWCA9IHJvdW5kKHNhdmVkWCArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMF0pO1xuICAgIGNvbnN0IG9wcG9zaXRlWSA9IHJvdW5kKHNhdmVkWSArIHRyYW5zZk9wcG9zaXRlUG9pbnRbMV0pO1xuICAgIGxldCByYXRpb1ggPSAxO1xuICAgIGxldCByYXRpb1kgPSAxO1xuICAgIGxldCBbZGVsdGFYLCBkZWx0YVldID0gdGhpcy5zY3JlZW5Ub1BhZ2VUcmFuc2xhdGlvbihldmVudC5tb3ZlbWVudFgsIGV2ZW50Lm1vdmVtZW50WSk7XG4gICAgW2RlbHRhWCwgZGVsdGFZXSA9IGludlRyYW5zZihkZWx0YVggLyBwYXJlbnRXaWR0aCwgZGVsdGFZIC8gcGFyZW50SGVpZ2h0KTtcbiAgICBpZiAoaXNEaWFnb25hbCkge1xuICAgICAgY29uc3Qgb2xkRGlhZyA9IE1hdGguaHlwb3Qoc2F2ZWRXaWR0aCwgc2F2ZWRIZWlnaHQpO1xuICAgICAgcmF0aW9YID0gcmF0aW9ZID0gTWF0aC5tYXgoTWF0aC5taW4oTWF0aC5oeXBvdChvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgsIG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkgLyBvbGREaWFnLCAxIC8gc2F2ZWRXaWR0aCwgMSAvIHNhdmVkSGVpZ2h0KSwgbWluV2lkdGggLyBzYXZlZFdpZHRoLCBtaW5IZWlnaHQgLyBzYXZlZEhlaWdodCk7XG4gICAgfSBlbHNlIGlmIChpc0hvcml6b250YWwpIHtcbiAgICAgIHJhdGlvWCA9IE1hdGgubWF4KG1pbldpZHRoLCBNYXRoLm1pbigxLCBNYXRoLmFicyhvcHBvc2l0ZVBvaW50WzBdIC0gcG9pbnRbMF0gLSBkZWx0YVgpKSkgLyBzYXZlZFdpZHRoO1xuICAgIH0gZWxzZSB7XG4gICAgICByYXRpb1kgPSBNYXRoLm1heChtaW5IZWlnaHQsIE1hdGgubWluKDEsIE1hdGguYWJzKG9wcG9zaXRlUG9pbnRbMV0gLSBwb2ludFsxXSAtIGRlbHRhWSkpKSAvIHNhdmVkSGVpZ2h0O1xuICAgIH1cbiAgICBjb25zdCBuZXdXaWR0aCA9IHJvdW5kKHNhdmVkV2lkdGggKiByYXRpb1gpO1xuICAgIGNvbnN0IG5ld0hlaWdodCA9IHJvdW5kKHNhdmVkSGVpZ2h0ICogcmF0aW9ZKTtcbiAgICB0cmFuc2ZPcHBvc2l0ZVBvaW50ID0gdHJhbnNmKC4uLmdldE9wcG9zaXRlKG5ld1dpZHRoLCBuZXdIZWlnaHQpKTtcbiAgICBjb25zdCBuZXdYID0gb3Bwb3NpdGVYIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFswXTtcbiAgICBjb25zdCBuZXdZID0gb3Bwb3NpdGVZIC0gdHJhbnNmT3Bwb3NpdGVQb2ludFsxXTtcbiAgICB0aGlzLndpZHRoID0gbmV3V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgdGhpcy54ID0gbmV3WDtcbiAgICB0aGlzLnkgPSBuZXdZO1xuICAgIHRoaXMuc2V0RGltcyhwYXJlbnRXaWR0aCAqIG5ld1dpZHRoLCBwYXJlbnRIZWlnaHQgKiBuZXdIZWlnaHQpO1xuICAgIHRoaXMuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgfVxuICBhc3luYyBhZGRBbHRUZXh0QnV0dG9uKCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGFsdFRleHQgPSB0aGlzLiNhbHRUZXh0QnV0dG9uID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJ1dHRvblwiKTtcbiAgICBhbHRUZXh0LmNsYXNzTmFtZSA9IFwiYWx0VGV4dFwiO1xuICAgIGNvbnN0IG1zZyA9IGF3YWl0IEFubm90YXRpb25FZGl0b3IuX2wxMG5Qcm9taXNlLmdldChcImVkaXRvcl9hbHRfdGV4dF9idXR0b25fbGFiZWxcIik7XG4gICAgYWx0VGV4dC50ZXh0Q29udGVudCA9IG1zZztcbiAgICBhbHRUZXh0LnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKTtcbiAgICBhbHRUZXh0LnRhYkluZGV4ID0gXCIwXCI7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudSk7XG4gICAgYWx0VGV4dC5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgZXZlbnQgPT4gZXZlbnQuc3RvcFByb3BhZ2F0aW9uKCkpO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsIGV2ZW50ID0+IHtcbiAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcyk7XG4gICAgfSwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICAgIGFsdFRleHQuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgZXZlbnQgPT4ge1xuICAgICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gYWx0VGV4dCAmJiBldmVudC5rZXkgPT09IFwiRW50ZXJcIikge1xuICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICB0aGlzLl91aU1hbmFnZXIuZWRpdEFsdFRleHQodGhpcyk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jc2V0QWx0VGV4dEJ1dHRvblN0YXRlKCk7XG4gICAgdGhpcy5kaXYuYXBwZW5kKGFsdFRleHQpO1xuICAgIGlmICghQW5ub3RhdGlvbkVkaXRvci5TTUFMTF9FRElUT1JfU0laRSkge1xuICAgICAgY29uc3QgUEVSQ0VOVCA9IDQwO1xuICAgICAgQW5ub3RhdGlvbkVkaXRvci5TTUFMTF9FRElUT1JfU0laRSA9IE1hdGgubWluKDEyOCwgTWF0aC5yb3VuZChhbHRUZXh0LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLndpZHRoICogKDEgKyBQRVJDRU5UIC8gMTAwKSkpO1xuICAgIH1cbiAgfVxuICBhc3luYyAjc2V0QWx0VGV4dEJ1dHRvblN0YXRlKCkge1xuICAgIGNvbnN0IGJ1dHRvbiA9IHRoaXMuI2FsdFRleHRCdXR0b247XG4gICAgaWYgKCFidXR0b24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLiNhbHRUZXh0ICYmICF0aGlzLiNhbHRUZXh0RGVjb3JhdGl2ZSkge1xuICAgICAgYnV0dG9uLmNsYXNzTGlzdC5yZW1vdmUoXCJkb25lXCIpO1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LnJlbW92ZSgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBBbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfYWx0X3RleHRfZWRpdF9idXR0b25fbGFiZWxcIikudGhlbihtc2cgPT4ge1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtbGFiZWxcIiwgbXNnKTtcbiAgICB9KTtcbiAgICBsZXQgdG9vbHRpcCA9IHRoaXMuI2FsdFRleHRUb29sdGlwO1xuICAgIGlmICghdG9vbHRpcCkge1xuICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gICAgICB0b29sdGlwLmNsYXNzTmFtZSA9IFwidG9vbHRpcFwiO1xuICAgICAgdG9vbHRpcC5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwidG9vbHRpcFwiKTtcbiAgICAgIGNvbnN0IGlkID0gdG9vbHRpcC5pZCA9IGBhbHQtdGV4dC10b29sdGlwLSR7dGhpcy5pZH1gO1xuICAgICAgYnV0dG9uLnNldEF0dHJpYnV0ZShcImFyaWEtZGVzY3JpYmVkYnlcIiwgaWQpO1xuICAgICAgY29uc3QgREVMQVlfVE9fU0hPV19UT09MVElQID0gMTAwO1xuICAgICAgYnV0dG9uLmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZWVudGVyXCIsICgpID0+IHtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgICB0aGlzLiNhbHRUZXh0VG9vbHRpcC5jbGFzc0xpc3QuYWRkKFwic2hvd1wiKTtcbiAgICAgICAgICB0aGlzLl91aU1hbmFnZXIuX2V2ZW50QnVzLmRpc3BhdGNoKFwicmVwb3J0dGVsZW1ldHJ5XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbHM6IHtcbiAgICAgICAgICAgICAgdHlwZTogXCJlZGl0aW5nXCIsXG4gICAgICAgICAgICAgIHN1YnR5cGU6IHRoaXMuZWRpdG9yVHlwZSxcbiAgICAgICAgICAgICAgZGF0YToge1xuICAgICAgICAgICAgICAgIGFjdGlvbjogXCJhbHRfdGV4dF90b29sdGlwXCJcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBERUxBWV9UT19TSE9XX1RPT0xUSVApO1xuICAgICAgfSk7XG4gICAgICBidXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNlbGVhdmVcIiwgKCkgPT4ge1xuICAgICAgICBjbGVhclRpbWVvdXQodGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0KTtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXBUaW1lb3V0ID0gbnVsbDtcbiAgICAgICAgdGhpcy4jYWx0VGV4dFRvb2x0aXA/LmNsYXNzTGlzdC5yZW1vdmUoXCJzaG93XCIpO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGJ1dHRvbi5jbGFzc0xpc3QuYWRkKFwiZG9uZVwiKTtcbiAgICB0b29sdGlwLmlubmVyVGV4dCA9IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlID8gYXdhaXQgQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZWRpdG9yX2FsdF90ZXh0X2RlY29yYXRpdmVfdG9vbHRpcFwiKSA6IHRoaXMuI2FsdFRleHQ7XG4gICAgaWYgKCF0b29sdGlwLnBhcmVudE5vZGUpIHtcbiAgICAgIGJ1dHRvbi5hcHBlbmQodG9vbHRpcCk7XG4gICAgfVxuICB9XG4gIGdldENsaWVudERpbWVuc2lvbnMoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICB9XG4gIGdldCBhbHRUZXh0RGF0YSgpIHtcbiAgICByZXR1cm4ge1xuICAgICAgYWx0VGV4dDogdGhpcy4jYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmU6IHRoaXMuI2FsdFRleHREZWNvcmF0aXZlXG4gICAgfTtcbiAgfVxuICBzZXQgYWx0VGV4dERhdGEoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgYWx0VGV4dCxcbiAgICAgIGRlY29yYXRpdmVcbiAgICB9ID0gX3JlZjI7XG4gICAgaWYgKHRoaXMuI2FsdFRleHQgPT09IGFsdFRleHQgJiYgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPT09IGRlY29yYXRpdmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dCA9IGFsdFRleHQ7XG4gICAgdGhpcy4jYWx0VGV4dERlY29yYXRpdmUgPSBkZWNvcmF0aXZlO1xuICAgIHRoaXMuI3NldEFsdFRleHRCdXR0b25TdGF0ZSgpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmRpdiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJkaXZcIik7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1lZGl0b3Itcm90YXRpb25cIiwgKDM2MCAtIHRoaXMucm90YXRpb24pICUgMzYwKTtcbiAgICB0aGlzLmRpdi5jbGFzc05hbWUgPSB0aGlzLm5hbWU7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwiaWRcIiwgdGhpcy5pZCk7XG4gICAgdGhpcy5kaXYuc2V0QXR0cmlidXRlKFwidGFiSW5kZXhcIiwgMCk7XG4gICAgdGhpcy5zZXRJbkZvcmVncm91bmQoKTtcbiAgICB0aGlzLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLiNib3VuZEZvY3VzaW4pO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNib3VuZEZvY3Vzb3V0KTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgaWYgKHRoaXMucGFyZW50Um90YXRpb24gJSAxODAgIT09IDApIHtcbiAgICAgIHRoaXMuZGl2LnN0eWxlLm1heFdpZHRoID0gYCR7KDEwMCAqIHBhcmVudEhlaWdodCAvIHBhcmVudFdpZHRoKS50b0ZpeGVkKDIpfSVgO1xuICAgICAgdGhpcy5kaXYuc3R5bGUubWF4SGVpZ2h0ID0gYCR7KDEwMCAqIHBhcmVudFdpZHRoIC8gcGFyZW50SGVpZ2h0KS50b0ZpeGVkKDIpfSVgO1xuICAgIH1cbiAgICBjb25zdCBbdHgsIHR5XSA9IHRoaXMuZ2V0SW5pdGlhbFRyYW5zbGF0aW9uKCk7XG4gICAgdGhpcy50cmFuc2xhdGUodHgsIHR5KTtcbiAgICAoMCwgX3Rvb2xzLmJpbmRFdmVudHMpKHRoaXMsIHRoaXMuZGl2LCBbXCJwb2ludGVyZG93blwiXSk7XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gIHBvaW50ZXJkb3duKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNNYWNcbiAgICB9ID0gX3V0aWwuRmVhdHVyZVRlc3QucGxhdGZvcm07XG4gICAgaWYgKGV2ZW50LmJ1dHRvbiAhPT0gMCB8fCBldmVudC5jdHJsS2V5ICYmIGlzTWFjKSB7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IHRydWU7XG4gICAgdGhpcy4jc2V0VXBEcmFnU2Vzc2lvbihldmVudCk7XG4gIH1cbiAgI3NldFVwRHJhZ1Nlc3Npb24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2lzRHJhZ2dhYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGlzU2VsZWN0ZWQgPSB0aGlzLl91aU1hbmFnZXIuaXNTZWxlY3RlZCh0aGlzKTtcbiAgICB0aGlzLl91aU1hbmFnZXIuc2V0VXBEcmFnU2Vzc2lvbigpO1xuICAgIGxldCBwb2ludGVyTW92ZU9wdGlvbnMsIHBvaW50ZXJNb3ZlQ2FsbGJhY2s7XG4gICAgaWYgKGlzU2VsZWN0ZWQpIHtcbiAgICAgIHBvaW50ZXJNb3ZlT3B0aW9ucyA9IHtcbiAgICAgICAgcGFzc2l2ZTogdHJ1ZSxcbiAgICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgICAgfTtcbiAgICAgIHBvaW50ZXJNb3ZlQ2FsbGJhY2sgPSBlID0+IHtcbiAgICAgICAgY29uc3QgW3R4LCB0eV0gPSB0aGlzLnNjcmVlblRvUGFnZVRyYW5zbGF0aW9uKGUubW92ZW1lbnRYLCBlLm1vdmVtZW50WSk7XG4gICAgICAgIHRoaXMuX3VpTWFuYWdlci5kcmFnU2VsZWN0ZWRFZGl0b3JzKHR4LCB0eSk7XG4gICAgICB9O1xuICAgICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCBwb2ludGVyTW92ZUNhbGxiYWNrLCBwb2ludGVyTW92ZU9wdGlvbnMpO1xuICAgIH1cbiAgICBjb25zdCBwb2ludGVyVXBDYWxsYmFjayA9ICgpID0+IHtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgICBpZiAoaXNTZWxlY3RlZCkge1xuICAgICAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHBvaW50ZXJNb3ZlQ2FsbGJhY2ssIHBvaW50ZXJNb3ZlT3B0aW9ucyk7XG4gICAgICB9XG4gICAgICB0aGlzLiNoYXNCZWVuQ2xpY2tlZCA9IGZhbHNlO1xuICAgICAgaWYgKCF0aGlzLl91aU1hbmFnZXIuZW5kRHJhZ1Nlc3Npb24oKSkge1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgaXNNYWNcbiAgICAgICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgICAgICBpZiAoZXZlbnQuY3RybEtleSAmJiAhaXNNYWMgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQubWV0YUtleSAmJiBpc01hYykge1xuICAgICAgICAgIHRoaXMucGFyZW50LnRvZ2dsZVNlbGVjdGVkKHRoaXMpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRoaXMucGFyZW50LnNldFNlbGVjdGVkKHRoaXMpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfTtcbiAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCBwb2ludGVyVXBDYWxsYmFjayk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHBvaW50ZXJVcENhbGxiYWNrKTtcbiAgfVxuICBtb3ZlSW5ET00oKSB7XG4gICAgdGhpcy5wYXJlbnQ/Lm1vdmVFZGl0b3JJbkRPTSh0aGlzKTtcbiAgfVxuICBfc2V0UGFyZW50QW5kUG9zaXRpb24ocGFyZW50LCB4LCB5KSB7XG4gICAgcGFyZW50LmNoYW5nZVBhcmVudCh0aGlzKTtcbiAgICB0aGlzLnggPSB4O1xuICAgIHRoaXMueSA9IHk7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICB9XG4gIGdldFJlY3QodHgsIHR5KSB7XG4gICAgY29uc3Qgc2NhbGUgPSB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICBjb25zdCBbcGFnZVgsIHBhZ2VZXSA9IHRoaXMucGFnZVRyYW5zbGF0aW9uO1xuICAgIGNvbnN0IHNoaWZ0WCA9IHR4IC8gc2NhbGU7XG4gICAgY29uc3Qgc2hpZnRZID0gdHkgLyBzY2FsZTtcbiAgICBjb25zdCB4ID0gdGhpcy54ICogcGFnZVdpZHRoO1xuICAgIGNvbnN0IHkgPSB0aGlzLnkgKiBwYWdlSGVpZ2h0O1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgc3dpdGNoICh0aGlzLnJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiBbeCArIHNoaWZ0WCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WSAtIGhlaWdodCArIHBhZ2VZLCB4ICsgc2hpZnRYICsgd2lkdGggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgLSBzaGlmdFkgKyBwYWdlWV07XG4gICAgICBjYXNlIDkwOlxuICAgICAgICByZXR1cm4gW3ggKyBzaGlmdFkgKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFggKyBwYWdlWSwgeCArIHNoaWZ0WSArIGhlaWdodCArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSArIHNoaWZ0WCArIHdpZHRoICsgcGFnZVldO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIHJldHVybiBbeCAtIHNoaWZ0WCAtIHdpZHRoICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5ICsgc2hpZnRZICsgcGFnZVksIHggLSBzaGlmdFggKyBwYWdlWCwgcGFnZUhlaWdodCAtIHkgKyBzaGlmdFkgKyBoZWlnaHQgKyBwYWdlWV07XG4gICAgICBjYXNlIDI3MDpcbiAgICAgICAgcmV0dXJuIFt4IC0gc2hpZnRZIC0gaGVpZ2h0ICsgcGFnZVgsIHBhZ2VIZWlnaHQgLSB5IC0gc2hpZnRYIC0gd2lkdGggKyBwYWdlWSwgeCAtIHNoaWZ0WSArIHBhZ2VYLCBwYWdlSGVpZ2h0IC0geSAtIHNoaWZ0WCArIHBhZ2VZXTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICB9XG4gIGdldFJlY3RJbkN1cnJlbnRDb29yZHMocmVjdCwgcGFnZUhlaWdodCkge1xuICAgIGNvbnN0IFt4MSwgeTEsIHgyLCB5Ml0gPSByZWN0O1xuICAgIGNvbnN0IHdpZHRoID0geDIgLSB4MTtcbiAgICBjb25zdCBoZWlnaHQgPSB5MiAtIHkxO1xuICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICByZXR1cm4gW3gxLCBwYWdlSGVpZ2h0IC0geTIsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSA5MDpcbiAgICAgICAgcmV0dXJuIFt4MSwgcGFnZUhlaWdodCAtIHkxLCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3gyLCBwYWdlSGVpZ2h0IC0geTEsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbeDIsIHBhZ2VIZWlnaHQgLSB5MiwgaGVpZ2h0LCB3aWR0aF07XG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHJvdGF0aW9uXCIpO1xuICAgIH1cbiAgfVxuICBvbmNlQWRkZWQoKSB7fVxuICBpc0VtcHR5KCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSB0cnVlO1xuICB9XG4gIGRpc2FibGVFZGl0TW9kZSgpIHtcbiAgICB0aGlzLiNpc0luRWRpdE1vZGUgPSBmYWxzZTtcbiAgfVxuICBpc0luRWRpdE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2lzSW5FZGl0TW9kZTtcbiAgfVxuICBzaG91bGRHZXRLZXlib2FyZEV2ZW50cygpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbmVlZHNUb0JlUmVidWlsdCgpIHtcbiAgICByZXR1cm4gdGhpcy5kaXYgJiYgIXRoaXMuaXNBdHRhY2hlZFRvRE9NO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgdGhpcy5kaXY/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c2luXCIsIHRoaXMuI2JvdW5kRm9jdXNpbik7XG4gICAgdGhpcy5kaXY/LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNib3VuZEZvY3Vzb3V0KTtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgbGV0IGlzRm9yQ29weWluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgbGV0IGNvbnRleHQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFuIGVkaXRvciBtdXN0IGJlIHNlcmlhbGl6YWJsZVwiKTtcbiAgfVxuICBzdGF0aWMgZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpIHtcbiAgICBjb25zdCBlZGl0b3IgPSBuZXcgdGhpcy5wcm90b3R5cGUuY29uc3RydWN0b3Ioe1xuICAgICAgcGFyZW50LFxuICAgICAgaWQ6IHBhcmVudC5nZXROZXh0SWQoKSxcbiAgICAgIHVpTWFuYWdlclxuICAgIH0pO1xuICAgIGVkaXRvci5yb3RhdGlvbiA9IGRhdGEucm90YXRpb247XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3QgW3gsIHksIHdpZHRoLCBoZWlnaHRdID0gZWRpdG9yLmdldFJlY3RJbkN1cnJlbnRDb29yZHMoZGF0YS5yZWN0LCBwYWdlSGVpZ2h0KTtcbiAgICBlZGl0b3IueCA9IHggLyBwYWdlV2lkdGg7XG4gICAgZWRpdG9yLnkgPSB5IC8gcGFnZUhlaWdodDtcbiAgICBlZGl0b3Iud2lkdGggPSB3aWR0aCAvIHBhZ2VXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCB0aGlzLiNib3VuZEZvY3VzaW4pO1xuICAgIHRoaXMuZGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJmb2N1c291dFwiLCB0aGlzLiNib3VuZEZvY3Vzb3V0KTtcbiAgICBpZiAoIXRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLmNvbW1pdCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy5wYXJlbnQpIHtcbiAgICAgIHRoaXMucGFyZW50LnJlbW92ZSh0aGlzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLnJlbW92ZUVkaXRvcih0aGlzKTtcbiAgICB9XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbj8ucmVtb3ZlKCk7XG4gICAgdGhpcy4jYWx0VGV4dEJ1dHRvbiA9IG51bGw7XG4gICAgdGhpcy4jYWx0VGV4dFRvb2x0aXAgPSBudWxsO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgbWFrZVJlc2l6YWJsZSgpIHtcbiAgICBpZiAodGhpcy5pc1Jlc2l6YWJsZSkge1xuICAgICAgdGhpcy4jY3JlYXRlUmVzaXplcnMoKTtcbiAgICAgIHRoaXMuI3Jlc2l6ZXJzRGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJoaWRkZW5cIik7XG4gICAgfVxuICB9XG4gIHNlbGVjdCgpIHtcbiAgICB0aGlzLm1ha2VSZXNpemFibGUoKTtcbiAgICB0aGlzLmRpdj8uY2xhc3NMaXN0LmFkZChcInNlbGVjdGVkRWRpdG9yXCIpO1xuICB9XG4gIHVuc2VsZWN0KCkge1xuICAgIHRoaXMuI3Jlc2l6ZXJzRGl2Py5jbGFzc0xpc3QuYWRkKFwiaGlkZGVuXCIpO1xuICAgIHRoaXMuZGl2Py5jbGFzc0xpc3QucmVtb3ZlKFwic2VsZWN0ZWRFZGl0b3JcIik7XG4gICAgaWYgKHRoaXMuZGl2Py5jb250YWlucyhkb2N1bWVudC5hY3RpdmVFbGVtZW50KSkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmN1cnJlbnRMYXllci5kaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7fVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICBpZiAodGhpcy4jYWx0VGV4dEJ1dHRvbikge1xuICAgICAgdGhpcy4jYWx0VGV4dEJ1dHRvbi5oaWRkZW4gPSB0cnVlO1xuICAgIH1cbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIGlmICh0aGlzLiNhbHRUZXh0QnV0dG9uKSB7XG4gICAgICB0aGlzLiNhbHRUZXh0QnV0dG9uLmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICBlbnRlckluRWRpdE1vZGUoKSB7fVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5kaXY7XG4gIH1cbiAgZ2V0IGlzRWRpdGluZygpIHtcbiAgICByZXR1cm4gdGhpcy4jaXNFZGl0aW5nO1xuICB9XG4gIHNldCBpc0VkaXRpbmcodmFsdWUpIHtcbiAgICB0aGlzLiNpc0VkaXRpbmcgPSB2YWx1ZTtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh2YWx1ZSkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0U2VsZWN0ZWQodGhpcyk7XG4gICAgICB0aGlzLnBhcmVudC5zZXRBY3RpdmVFZGl0b3IodGhpcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMucGFyZW50LnNldEFjdGl2ZUVkaXRvcihudWxsKTtcbiAgICB9XG4gIH1cbiAgc2V0QXNwZWN0UmF0aW8od2lkdGgsIGhlaWdodCkge1xuICAgIHRoaXMuI2tlZXBBc3BlY3RSYXRpbyA9IHRydWU7XG4gICAgY29uc3QgYXNwZWN0UmF0aW8gPSB3aWR0aCAvIGhlaWdodDtcbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmRpdjtcbiAgICBzdHlsZS5hc3BlY3RSYXRpbyA9IGFzcGVjdFJhdGlvO1xuICAgIHN0eWxlLmhlaWdodCA9IFwiYXV0b1wiO1xuICB9XG4gIHN0YXRpYyBnZXQgTUlOX1NJWkUoKSB7XG4gICAgcmV0dXJuIDE2O1xuICB9XG59XG5leHBvcnRzLkFubm90YXRpb25FZGl0b3IgPSBBbm5vdGF0aW9uRWRpdG9yO1xuY2xhc3MgRmFrZUVkaXRvciBleHRlbmRzIEFubm90YXRpb25FZGl0b3Ige1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcihwYXJhbXMpO1xuICAgIHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IHBhcmFtcy5hbm5vdGF0aW9uRWxlbWVudElkO1xuICAgIHRoaXMuZGVsZXRlZCA9IHRydWU7XG4gIH1cbiAgc2VyaWFsaXplKCkge1xuICAgIHJldHVybiB7XG4gICAgICBpZDogdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkLFxuICAgICAgZGVsZXRlZDogdHJ1ZSxcbiAgICAgIHBhZ2VJbmRleDogdGhpcy5wYWdlSW5kZXhcbiAgICB9O1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMTY1ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLktleWJvYXJkTWFuYWdlciA9IGV4cG9ydHMuQ29tbWFuZE1hbmFnZXIgPSBleHBvcnRzLkNvbG9yTWFuYWdlciA9IGV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlciA9IHZvaWQgMDtcbmV4cG9ydHMuYmluZEV2ZW50cyA9IGJpbmRFdmVudHM7XG5leHBvcnRzLm9wYWNpdHlUb0hleCA9IG9wYWNpdHlUb0hleDtcbl9fd19wZGZqc19yZXF1aXJlX18oOTMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDEpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDIpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDcpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDkpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMTMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMTYpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMjMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygyKTtcbl9fd19wZGZqc19yZXF1aXJlX18oODkpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMjUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMzYpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMzgpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDEpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDcpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNjYpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTY4KTtcbmZ1bmN0aW9uIGJpbmRFdmVudHMob2JqLCBlbGVtZW50LCBuYW1lcykge1xuICBmb3IgKGNvbnN0IG5hbWUgb2YgbmFtZXMpIHtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIobmFtZSwgb2JqW25hbWVdLmJpbmQob2JqKSk7XG4gIH1cbn1cbmZ1bmN0aW9uIG9wYWNpdHlUb0hleChvcGFjaXR5KSB7XG4gIHJldHVybiBNYXRoLnJvdW5kKE1hdGgubWluKDI1NSwgTWF0aC5tYXgoMSwgMjU1ICogb3BhY2l0eSkpKS50b1N0cmluZygxNikucGFkU3RhcnQoMiwgXCIwXCIpO1xufVxuY2xhc3MgSWRNYW5hZ2VyIHtcbiAgI2lkID0gMDtcbiAgZ2V0SWQoKSB7XG4gICAgcmV0dXJuIGAke191dGlsLkFubm90YXRpb25FZGl0b3JQcmVmaXh9JHt0aGlzLiNpZCsrfWA7XG4gIH1cbn1cbmNsYXNzIEltYWdlTWFuYWdlciB7XG4gICNiYXNlSWQgPSAoMCwgX3V0aWwuZ2V0VXVpZCkoKTtcbiAgI2lkID0gMDtcbiAgI2NhY2hlID0gbnVsbDtcbiAgc3RhdGljIGdldCBfaXNTVkdGaXR0aW5nQ2FudmFzKCkge1xuICAgIGNvbnN0IHN2ZyA9IGBkYXRhOmltYWdlL3N2Zyt4bWw7Y2hhcnNldD1VVEYtOCw8c3ZnIHZpZXdCb3g9XCIwIDAgMSAxXCIgd2lkdGg9XCIxXCIgaGVpZ2h0PVwiMVwiIHhtbG5zPVwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIj48cmVjdCB3aWR0aD1cIjFcIiBoZWlnaHQ9XCIxXCIgc3R5bGU9XCJmaWxsOnJlZDtcIi8+PC9zdmc+YDtcbiAgICBjb25zdCBjYW52YXMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKDEsIDMpO1xuICAgIGNvbnN0IGN0eCA9IGNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgY29uc3QgaW1hZ2UgPSBuZXcgSW1hZ2UoKTtcbiAgICBpbWFnZS5zcmMgPSBzdmc7XG4gICAgY29uc3QgcHJvbWlzZSA9IGltYWdlLmRlY29kZSgpLnRoZW4oKCkgPT4ge1xuICAgICAgY3R4LmRyYXdJbWFnZShpbWFnZSwgMCwgMCwgMSwgMSwgMCwgMCwgMSwgMyk7XG4gICAgICByZXR1cm4gbmV3IFVpbnQzMkFycmF5KGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgMSwgMSkuZGF0YS5idWZmZXIpWzBdID09PSAwO1xuICAgIH0pO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9pc1NWR0ZpdHRpbmdDYW52YXNcIiwgcHJvbWlzZSk7XG4gIH1cbiAgYXN5bmMgI2dldChrZXksIHJhd0RhdGEpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGxldCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKGRhdGEgPT09IG51bGwpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YT8uYml0bWFwKSB7XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgKz0gMTtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgZGF0YSB8fD0ge1xuICAgICAgICBiaXRtYXA6IG51bGwsXG4gICAgICAgIGlkOiBgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9XyR7dGhpcy4jaWQrK31gLFxuICAgICAgICByZWZDb3VudGVyOiAwLFxuICAgICAgICBpc1N2ZzogZmFsc2VcbiAgICAgIH07XG4gICAgICBsZXQgaW1hZ2U7XG4gICAgICBpZiAodHlwZW9mIHJhd0RhdGEgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgZGF0YS51cmwgPSByYXdEYXRhO1xuICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHJhd0RhdGEpO1xuICAgICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKHJlc3BvbnNlLnN0YXR1c1RleHQpO1xuICAgICAgICB9XG4gICAgICAgIGltYWdlID0gYXdhaXQgcmVzcG9uc2UuYmxvYigpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW1hZ2UgPSBkYXRhLmZpbGUgPSByYXdEYXRhO1xuICAgICAgfVxuICAgICAgaWYgKGltYWdlLnR5cGUgPT09IFwiaW1hZ2Uvc3ZnK3htbFwiKSB7XG4gICAgICAgIGNvbnN0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UgPSBJbWFnZU1hbmFnZXIuX2lzU1ZHRml0dGluZ0NhbnZhcztcbiAgICAgICAgY29uc3QgZmlsZVJlYWRlciA9IG5ldyBGaWxlUmVhZGVyKCk7XG4gICAgICAgIGNvbnN0IGltYWdlRWxlbWVudCA9IG5ldyBJbWFnZSgpO1xuICAgICAgICBjb25zdCBpbWFnZVByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgaW1hZ2VFbGVtZW50Lm9ubG9hZCA9ICgpID0+IHtcbiAgICAgICAgICAgIGRhdGEuYml0bWFwID0gaW1hZ2VFbGVtZW50O1xuICAgICAgICAgICAgZGF0YS5pc1N2ZyA9IHRydWU7XG4gICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICBmaWxlUmVhZGVyLm9ubG9hZCA9IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHVybCA9IGRhdGEuc3ZnVXJsID0gZmlsZVJlYWRlci5yZXN1bHQ7XG4gICAgICAgICAgICBpbWFnZUVsZW1lbnQuc3JjID0gKGF3YWl0IG11c3RSZW1vdmVBc3BlY3RSYXRpb1Byb21pc2UpID8gYCR7dXJsfSNzdmdWaWV3KHByZXNlcnZlQXNwZWN0UmF0aW8obm9uZSkpYCA6IHVybDtcbiAgICAgICAgICB9O1xuICAgICAgICAgIGltYWdlRWxlbWVudC5vbmVycm9yID0gZmlsZVJlYWRlci5vbmVycm9yID0gcmVqZWN0O1xuICAgICAgICB9KTtcbiAgICAgICAgZmlsZVJlYWRlci5yZWFkQXNEYXRhVVJMKGltYWdlKTtcbiAgICAgICAgYXdhaXQgaW1hZ2VQcm9taXNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGF0YS5iaXRtYXAgPSBhd2FpdCBjcmVhdGVJbWFnZUJpdG1hcChpbWFnZSk7XG4gICAgICB9XG4gICAgICBkYXRhLnJlZkNvdW50ZXIgPSAxO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGNvbnNvbGUuZXJyb3IoZSk7XG4gICAgICBkYXRhID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy4jY2FjaGUuc2V0KGtleSwgZGF0YSk7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHRoaXMuI2NhY2hlLnNldChkYXRhLmlkLCBkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGRhdGE7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUZpbGUoZmlsZSkge1xuICAgIGNvbnN0IHtcbiAgICAgIGxhc3RNb2RpZmllZCxcbiAgICAgIG5hbWUsXG4gICAgICBzaXplLFxuICAgICAgdHlwZVxuICAgIH0gPSBmaWxlO1xuICAgIHJldHVybiB0aGlzLiNnZXQoYCR7bGFzdE1vZGlmaWVkfV8ke25hbWV9XyR7c2l6ZX1fJHt0eXBlfWAsIGZpbGUpO1xuICB9XG4gIGFzeW5jIGdldEZyb21VcmwodXJsKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dldCh1cmwsIHVybCk7XG4gIH1cbiAgYXN5bmMgZ2V0RnJvbUlkKGlkKSB7XG4gICAgdGhpcy4jY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy4jY2FjaGUuZ2V0KGlkKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZGF0YS5iaXRtYXApIHtcbiAgICAgIGRhdGEucmVmQ291bnRlciArPSAxO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICAgIGlmIChkYXRhLmZpbGUpIHtcbiAgICAgIHJldHVybiB0aGlzLmdldEZyb21GaWxlKGRhdGEuZmlsZSk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmdldEZyb21VcmwoZGF0YS51cmwpO1xuICB9XG4gIGdldFN2Z1VybChpZCkge1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YT8uaXNTdmcpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YS5zdmdVcmw7XG4gIH1cbiAgZGVsZXRlSWQoaWQpIHtcbiAgICB0aGlzLiNjYWNoZSB8fD0gbmV3IE1hcCgpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLiNjYWNoZS5nZXQoaWQpO1xuICAgIGlmICghZGF0YSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkYXRhLnJlZkNvdW50ZXIgLT0gMTtcbiAgICBpZiAoZGF0YS5yZWZDb3VudGVyICE9PSAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGRhdGEuYml0bWFwID0gbnVsbDtcbiAgfVxuICBpc1ZhbGlkSWQoaWQpIHtcbiAgICByZXR1cm4gaWQuc3RhcnRzV2l0aChgaW1hZ2VfJHt0aGlzLiNiYXNlSWR9X2ApO1xuICB9XG59XG5jbGFzcyBDb21tYW5kTWFuYWdlciB7XG4gICNjb21tYW5kcyA9IFtdO1xuICAjbG9ja2VkID0gZmFsc2U7XG4gICNtYXhTaXplO1xuICAjcG9zaXRpb24gPSAtMTtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgbGV0IG1heFNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IDEyODtcbiAgICB0aGlzLiNtYXhTaXplID0gbWF4U2l6ZTtcbiAgfVxuICBhZGQoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBjbWQsXG4gICAgICB1bmRvLFxuICAgICAgbXVzdEV4ZWMsXG4gICAgICB0eXBlID0gTmFOLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZSA9IGZhbHNlLFxuICAgICAga2VlcFVuZG8gPSBmYWxzZVxuICAgIH0gPSBfcmVmO1xuICAgIGlmIChtdXN0RXhlYykge1xuICAgICAgY21kKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLiNsb2NrZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgc2F2ZSA9IHtcbiAgICAgIGNtZCxcbiAgICAgIHVuZG8sXG4gICAgICB0eXBlXG4gICAgfTtcbiAgICBpZiAodGhpcy4jcG9zaXRpb24gPT09IC0xKSB7XG4gICAgICBpZiAodGhpcy4jY29tbWFuZHMubGVuZ3RoID4gMCkge1xuICAgICAgICB0aGlzLiNjb21tYW5kcy5sZW5ndGggPSAwO1xuICAgICAgfVxuICAgICAgdGhpcy4jcG9zaXRpb24gPSAwO1xuICAgICAgdGhpcy4jY29tbWFuZHMucHVzaChzYXZlKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKG92ZXJ3cml0ZUlmU2FtZVR5cGUgJiYgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLnR5cGUgPT09IHR5cGUpIHtcbiAgICAgIGlmIChrZWVwVW5kbykge1xuICAgICAgICBzYXZlLnVuZG8gPSB0aGlzLiNjb21tYW5kc1t0aGlzLiNwb3NpdGlvbl0udW5kbztcbiAgICAgIH1cbiAgICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXSA9IHNhdmU7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IG5leHQgPSB0aGlzLiNwb3NpdGlvbiArIDE7XG4gICAgaWYgKG5leHQgPT09IHRoaXMuI21heFNpemUpIHtcbiAgICAgIHRoaXMuI2NvbW1hbmRzLnNwbGljZSgwLCAxKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcG9zaXRpb24gPSBuZXh0O1xuICAgICAgaWYgKG5leHQgPCB0aGlzLiNjb21tYW5kcy5sZW5ndGgpIHtcbiAgICAgICAgdGhpcy4jY29tbWFuZHMuc3BsaWNlKG5leHQpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjb21tYW5kcy5wdXNoKHNhdmUpO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgaWYgKHRoaXMuI3Bvc2l0aW9uID09PSAtMSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgIHRoaXMuI2NvbW1hbmRzW3RoaXMuI3Bvc2l0aW9uXS51bmRvKCk7XG4gICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgdGhpcy4jcG9zaXRpb24gLT0gMTtcbiAgfVxuICByZWRvKCkge1xuICAgIGlmICh0aGlzLiNwb3NpdGlvbiA8IHRoaXMuI2NvbW1hbmRzLmxlbmd0aCAtIDEpIHtcbiAgICAgIHRoaXMuI3Bvc2l0aW9uICs9IDE7XG4gICAgICB0aGlzLiNsb2NrZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jY29tbWFuZHNbdGhpcy4jcG9zaXRpb25dLmNtZCgpO1xuICAgICAgdGhpcy4jbG9ja2VkID0gZmFsc2U7XG4gICAgfVxuICB9XG4gIGhhc1NvbWV0aGluZ1RvVW5kbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gIT09IC0xO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvUmVkbygpIHtcbiAgICByZXR1cm4gdGhpcy4jcG9zaXRpb24gPCB0aGlzLiNjb21tYW5kcy5sZW5ndGggLSAxO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgdGhpcy4jY29tbWFuZHMgPSBudWxsO1xuICB9XG59XG5leHBvcnRzLkNvbW1hbmRNYW5hZ2VyID0gQ29tbWFuZE1hbmFnZXI7XG5jbGFzcyBLZXlib2FyZE1hbmFnZXIge1xuICBjb25zdHJ1Y3RvcihjYWxsYmFja3MpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMuY2FsbGJhY2tzID0gbmV3IE1hcCgpO1xuICAgIHRoaXMuYWxsS2V5cyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCB7XG4gICAgICBpc01hY1xuICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICBmb3IgKGNvbnN0IFtrZXlzLCBjYWxsYmFjaywgb3B0aW9ucyA9IHt9XSBvZiBjYWxsYmFja3MpIHtcbiAgICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMpIHtcbiAgICAgICAgY29uc3QgaXNNYWNLZXkgPSBrZXkuc3RhcnRzV2l0aChcIm1hYytcIik7XG4gICAgICAgIGlmIChpc01hYyAmJiBpc01hY0tleSkge1xuICAgICAgICAgIHRoaXMuY2FsbGJhY2tzLnNldChrZXkuc2xpY2UoNCksIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLFxuICAgICAgICAgICAgb3B0aW9uc1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHRoaXMuYWxsS2V5cy5hZGQoa2V5LnNwbGl0KFwiK1wiKS5hdCgtMSkpO1xuICAgICAgICB9IGVsc2UgaWYgKCFpc01hYyAmJiAhaXNNYWNLZXkpIHtcbiAgICAgICAgICB0aGlzLmNhbGxiYWNrcy5zZXQoa2V5LCB7XG4gICAgICAgICAgICBjYWxsYmFjayxcbiAgICAgICAgICAgIG9wdGlvbnNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICB0aGlzLmFsbEtleXMuYWRkKGtleS5zcGxpdChcIitcIikuYXQoLTEpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICAjc2VyaWFsaXplKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LmFsdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcImFsdFwiKTtcbiAgICB9XG4gICAgaWYgKGV2ZW50LmN0cmxLZXkpIHtcbiAgICAgIHRoaXMuYnVmZmVyLnB1c2goXCJjdHJsXCIpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQubWV0YUtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcIm1ldGFcIik7XG4gICAgfVxuICAgIGlmIChldmVudC5zaGlmdEtleSkge1xuICAgICAgdGhpcy5idWZmZXIucHVzaChcInNoaWZ0XCIpO1xuICAgIH1cbiAgICB0aGlzLmJ1ZmZlci5wdXNoKGV2ZW50LmtleSk7XG4gICAgY29uc3Qgc3RyID0gdGhpcy5idWZmZXIuam9pbihcIitcIik7XG4gICAgdGhpcy5idWZmZXIubGVuZ3RoID0gMDtcbiAgICByZXR1cm4gc3RyO1xuICB9XG4gIGV4ZWMoc2VsZiwgZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuYWxsS2V5cy5oYXMoZXZlbnQua2V5KSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbmZvID0gdGhpcy5jYWxsYmFja3MuZ2V0KHRoaXMuI3NlcmlhbGl6ZShldmVudCkpO1xuICAgIGlmICghaW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBjYWxsYmFjayxcbiAgICAgIG9wdGlvbnM6IHtcbiAgICAgICAgYnViYmxlcyA9IGZhbHNlLFxuICAgICAgICBhcmdzID0gW10sXG4gICAgICAgIGNoZWNrZXIgPSBudWxsXG4gICAgICB9XG4gICAgfSA9IGluZm87XG4gICAgaWYgKGNoZWNrZXIgJiYgIWNoZWNrZXIoc2VsZiwgZXZlbnQpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxiYWNrLmJpbmQoc2VsZiwgLi4uYXJncykoKTtcbiAgICBpZiAoIWJ1YmJsZXMpIHtcbiAgICAgIGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuS2V5Ym9hcmRNYW5hZ2VyID0gS2V5Ym9hcmRNYW5hZ2VyO1xuY2xhc3MgQ29sb3JNYW5hZ2VyIHtcbiAgc3RhdGljIF9jb2xvcnNNYXBwaW5nID0gbmV3IE1hcChbW1wiQ2FudmFzVGV4dFwiLCBbMCwgMCwgMF1dLCBbXCJDYW52YXNcIiwgWzI1NSwgMjU1LCAyNTVdXV0pO1xuICBnZXQgX2NvbG9ycygpIHtcbiAgICBjb25zdCBjb2xvcnMgPSBuZXcgTWFwKFtbXCJDYW52YXNUZXh0XCIsIG51bGxdLCBbXCJDYW52YXNcIiwgbnVsbF1dKTtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q29sb3JWYWx1ZXMpKGNvbG9ycyk7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2NvbG9yc1wiLCBjb2xvcnMpO1xuICB9XG4gIGNvbnZlcnQoY29sb3IpIHtcbiAgICBjb25zdCByZ2IgPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0UkdCKShjb2xvcik7XG4gICAgaWYgKCF3aW5kb3cubWF0Y2hNZWRpYShcIihmb3JjZWQtY29sb3JzOiBhY3RpdmUpXCIpLm1hdGNoZXMpIHtcbiAgICAgIHJldHVybiByZ2I7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW25hbWUsIFJHQl0gb2YgdGhpcy5fY29sb3JzKSB7XG4gICAgICBpZiAoUkdCLmV2ZXJ5KCh4LCBpKSA9PiB4ID09PSByZ2JbaV0pKSB7XG4gICAgICAgIHJldHVybiBDb2xvck1hbmFnZXIuX2NvbG9yc01hcHBpbmcuZ2V0KG5hbWUpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcmdiO1xuICB9XG4gIGdldEhleENvZGUobmFtZSkge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuX2NvbG9ycy5nZXQobmFtZSk7XG4gICAgaWYgKCFyZ2IpIHtcbiAgICAgIHJldHVybiBuYW1lO1xuICAgIH1cbiAgICByZXR1cm4gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4ucmdiKTtcbiAgfVxufVxuZXhwb3J0cy5Db2xvck1hbmFnZXIgPSBDb2xvck1hbmFnZXI7XG5jbGFzcyBBbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyIHtcbiAgI2FjdGl2ZUVkaXRvciA9IG51bGw7XG4gICNhbGxFZGl0b3JzID0gbmV3IE1hcCgpO1xuICAjYWxsTGF5ZXJzID0gbmV3IE1hcCgpO1xuICAjYWx0VGV4dE1hbmFnZXIgPSBudWxsO1xuICAjYW5ub3RhdGlvblN0b3JhZ2UgPSBudWxsO1xuICAjY29tbWFuZE1hbmFnZXIgPSBuZXcgQ29tbWFuZE1hbmFnZXIoKTtcbiAgI2N1cnJlbnRQYWdlSW5kZXggPSAwO1xuICAjZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgI2RyYWdnaW5nRWRpdG9ycyA9IG51bGw7XG4gICNlZGl0b3JUeXBlcyA9IG51bGw7XG4gICNlZGl0b3JzVG9SZXNjYWxlID0gbmV3IFNldCgpO1xuICAjZmlsdGVyRmFjdG9yeSA9IG51bGw7XG4gICNpZE1hbmFnZXIgPSBuZXcgSWRNYW5hZ2VyKCk7XG4gICNpc0VuYWJsZWQgPSBmYWxzZTtcbiAgI2lzV2FpdGluZyA9IGZhbHNlO1xuICAjbGFzdEFjdGl2ZUVsZW1lbnQgPSBudWxsO1xuICAjbW9kZSA9IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkU7XG4gICNzZWxlY3RlZEVkaXRvcnMgPSBuZXcgU2V0KCk7XG4gICNwYWdlQ29sb3JzID0gbnVsbDtcbiAgI2JvdW5kQmx1ciA9IHRoaXMuYmx1ci5iaW5kKHRoaXMpO1xuICAjYm91bmRGb2N1cyA9IHRoaXMuZm9jdXMuYmluZCh0aGlzKTtcbiAgI2JvdW5kQ29weSA9IHRoaXMuY29weS5iaW5kKHRoaXMpO1xuICAjYm91bmRDdXQgPSB0aGlzLmN1dC5iaW5kKHRoaXMpO1xuICAjYm91bmRQYXN0ZSA9IHRoaXMucGFzdGUuYmluZCh0aGlzKTtcbiAgI2JvdW5kS2V5ZG93biA9IHRoaXMua2V5ZG93bi5iaW5kKHRoaXMpO1xuICAjYm91bmRPbkVkaXRpbmdBY3Rpb24gPSB0aGlzLm9uRWRpdGluZ0FjdGlvbi5iaW5kKHRoaXMpO1xuICAjYm91bmRPblBhZ2VDaGFuZ2luZyA9IHRoaXMub25QYWdlQ2hhbmdpbmcuYmluZCh0aGlzKTtcbiAgI2JvdW5kT25TY2FsZUNoYW5naW5nID0gdGhpcy5vblNjYWxlQ2hhbmdpbmcuYmluZCh0aGlzKTtcbiAgI2JvdW5kT25Sb3RhdGlvbkNoYW5naW5nID0gdGhpcy5vblJvdGF0aW9uQ2hhbmdpbmcuYmluZCh0aGlzKTtcbiAgI3ByZXZpb3VzU3RhdGVzID0ge1xuICAgIGlzRWRpdGluZzogZmFsc2UsXG4gICAgaXNFbXB0eTogdHJ1ZSxcbiAgICBoYXNTb21ldGhpbmdUb1VuZG86IGZhbHNlLFxuICAgIGhhc1NvbWV0aGluZ1RvUmVkbzogZmFsc2UsXG4gICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gIH07XG4gICN0cmFuc2xhdGlvbiA9IFswLCAwXTtcbiAgI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgI2NvbnRhaW5lciA9IG51bGw7XG4gICN2aWV3ZXIgPSBudWxsO1xuICBzdGF0aWMgVFJBTlNMQVRFX1NNQUxMID0gMTtcbiAgc3RhdGljIFRSQU5TTEFURV9CSUcgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5wcm90b3R5cGU7XG4gICAgY29uc3QgYXJyb3dDaGVja2VyID0gc2VsZiA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICAgIH0gPSBkb2N1bWVudDtcbiAgICAgIHJldHVybiBhY3RpdmVFbGVtZW50ICYmIHNlbGYuI2NvbnRhaW5lci5jb250YWlucyhhY3RpdmVFbGVtZW50KSAmJiBzZWxmLmhhc1NvbWV0aGluZ1RvQ29udHJvbCgpO1xuICAgIH07XG4gICAgY29uc3Qgc21hbGwgPSB0aGlzLlRSQU5TTEFURV9TTUFMTDtcbiAgICBjb25zdCBiaWcgPSB0aGlzLlRSQU5TTEFURV9CSUc7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiX2tleWJvYXJkTWFuYWdlclwiLCBuZXcgS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCthXCIsIFwibWFjK21ldGErYVwiXSwgcHJvdG8uc2VsZWN0QWxsXSwgW1tcImN0cmwrelwiLCBcIm1hYyttZXRhK3pcIl0sIHByb3RvLnVuZG9dLCBbW1wiY3RybCt5XCIsIFwiY3RybCtzaGlmdCt6XCIsIFwibWFjK21ldGErc2hpZnQrelwiLCBcImN0cmwrc2hpZnQrWlwiLCBcIm1hYyttZXRhK3NoaWZ0K1pcIl0sIHByb3RvLnJlZG9dLCBbW1wiQmFja3NwYWNlXCIsIFwiYWx0K0JhY2tzcGFjZVwiLCBcImN0cmwrQmFja3NwYWNlXCIsIFwic2hpZnQrQmFja3NwYWNlXCIsIFwibWFjK0JhY2tzcGFjZVwiLCBcIm1hYythbHQrQmFja3NwYWNlXCIsIFwibWFjK2N0cmwrQmFja3NwYWNlXCIsIFwiRGVsZXRlXCIsIFwiY3RybCtEZWxldGVcIiwgXCJzaGlmdCtEZWxldGVcIiwgXCJtYWMrRGVsZXRlXCJdLCBwcm90by5kZWxldGVdLCBbW1wiRXNjYXBlXCIsIFwibWFjK0VzY2FwZVwiXSwgcHJvdG8udW5zZWxlY3RBbGxdLCBbW1wiQXJyb3dMZWZ0XCIsIFwibWFjK0Fycm93TGVmdFwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbLXNtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd0xlZnRcIiwgXCJtYWMrc2hpZnQrQXJyb3dMZWZ0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFstYmlnLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dSaWdodFwiLCBcIm1hYytBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtzbWFsbCwgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dSaWdodFwiLCBcIm1hYytzaGlmdCtBcnJvd1JpZ2h0XCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFtiaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1VwXCIsIFwibWFjK0Fycm93VXBcIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIC1zbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dVcFwiLCBcIm1hYytzaGlmdCtBcnJvd1VwXCJdLCBwcm90by50cmFuc2xhdGVTZWxlY3RlZEVkaXRvcnMsIHtcbiAgICAgIGFyZ3M6IFswLCAtYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiQXJyb3dEb3duXCIsIFwibWFjK0Fycm93RG93blwiXSwgcHJvdG8udHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzLCB7XG4gICAgICBhcmdzOiBbMCwgc21hbGxdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93RG93blwiLCBcIm1hYytzaGlmdCtBcnJvd0Rvd25cIl0sIHByb3RvLnRyYW5zbGF0ZVNlbGVjdGVkRWRpdG9ycywge1xuICAgICAgYXJnczogWzAsIGJpZ10sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XV0pKTtcbiAgfVxuICBjb25zdHJ1Y3Rvcihjb250YWluZXIsIHZpZXdlciwgYWx0VGV4dE1hbmFnZXIsIGV2ZW50QnVzLCBwZGZEb2N1bWVudCwgcGFnZUNvbG9ycykge1xuICAgIHRoaXMuI2NvbnRhaW5lciA9IGNvbnRhaW5lcjtcbiAgICB0aGlzLiN2aWV3ZXIgPSB2aWV3ZXI7XG4gICAgdGhpcy4jYWx0VGV4dE1hbmFnZXIgPSBhbHRUZXh0TWFuYWdlcjtcbiAgICB0aGlzLl9ldmVudEJ1cyA9IGV2ZW50QnVzO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vbihcImVkaXRpbmdhY3Rpb25cIiwgdGhpcy4jYm91bmRPbkVkaXRpbmdBY3Rpb24pO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vbihcInBhZ2VjaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uUGFnZUNoYW5naW5nKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb24oXCJzY2FsZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25TY2FsZUNoYW5naW5nKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb24oXCJyb3RhdGlvbmNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25Sb3RhdGlvbkNoYW5naW5nKTtcbiAgICB0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZSA9IHBkZkRvY3VtZW50LmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMuI2ZpbHRlckZhY3RvcnkgPSBwZGZEb2N1bWVudC5maWx0ZXJGYWN0b3J5O1xuICAgIHRoaXMuI3BhZ2VDb2xvcnMgPSBwYWdlQ29sb3JzO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMgPSB7XG4gICAgICByZWFsU2NhbGU6IF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyxcbiAgICAgIHJvdGF0aW9uOiAwXG4gICAgfTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIHRoaXMuI3JlbW92ZUtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI3JlbW92ZUZvY3VzTWFuYWdlcigpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vZmYoXCJlZGl0aW5nYWN0aW9uXCIsIHRoaXMuI2JvdW5kT25FZGl0aW5nQWN0aW9uKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwicGFnZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25QYWdlQ2hhbmdpbmcpO1xuICAgIHRoaXMuX2V2ZW50QnVzLl9vZmYoXCJzY2FsZWNoYW5naW5nXCIsIHRoaXMuI2JvdW5kT25TY2FsZUNoYW5naW5nKTtcbiAgICB0aGlzLl9ldmVudEJ1cy5fb2ZmKFwicm90YXRpb25jaGFuZ2luZ1wiLCB0aGlzLiNib3VuZE9uUm90YXRpb25DaGFuZ2luZyk7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGxheWVyLmRlc3Ryb3koKTtcbiAgICB9XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmNsZWFyKCk7XG4gICAgdGhpcy4jYWxsRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuY2xlYXIoKTtcbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBudWxsO1xuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmRlc3Ryb3koKTtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlci5kZXN0cm95KCk7XG4gIH1cbiAgZ2V0IGhjbUZpbHRlcigpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJoY21GaWx0ZXJcIiwgdGhpcy4jcGFnZUNvbG9ycyA/IHRoaXMuI2ZpbHRlckZhY3RvcnkuYWRkSENNRmlsdGVyKHRoaXMuI3BhZ2VDb2xvcnMuZm9yZWdyb3VuZCwgdGhpcy4jcGFnZUNvbG9ycy5iYWNrZ3JvdW5kKSA6IFwibm9uZVwiKTtcbiAgfVxuICBnZXQgZGlyZWN0aW9uKCkge1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcImRpcmVjdGlvblwiLCBnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2NvbnRhaW5lcikuZGlyZWN0aW9uKTtcbiAgfVxuICBlZGl0QWx0VGV4dChlZGl0b3IpIHtcbiAgICB0aGlzLiNhbHRUZXh0TWFuYWdlcj8uZWRpdEFsdFRleHQodGhpcywgZWRpdG9yKTtcbiAgfVxuICBvblBhZ2VDaGFuZ2luZyhfcmVmMikge1xuICAgIGxldCB7XG4gICAgICBwYWdlTnVtYmVyXG4gICAgfSA9IF9yZWYyO1xuICAgIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXggPSBwYWdlTnVtYmVyIC0gMTtcbiAgfVxuICBmb2N1c01haW5Db250YWluZXIoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmZvY3VzKCk7XG4gIH1cbiAgZmluZFBhcmVudCh4LCB5KSB7XG4gICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgeDogbGF5ZXJYLFxuICAgICAgICB5OiBsYXllclksXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBsYXllci5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICBpZiAoeCA+PSBsYXllclggJiYgeCA8PSBsYXllclggKyB3aWR0aCAmJiB5ID49IGxheWVyWSAmJiB5IDw9IGxheWVyWSArIGhlaWdodCkge1xuICAgICAgICByZXR1cm4gbGF5ZXI7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGRpc2FibGVVc2VyU2VsZWN0KCkge1xuICAgIGxldCB2YWx1ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgdGhpcy4jdmlld2VyLmNsYXNzTGlzdC50b2dnbGUoXCJub1VzZXJTZWxlY3RcIiwgdmFsdWUpO1xuICB9XG4gIGFkZFNob3VsZFJlc2NhbGUoZWRpdG9yKSB7XG4gICAgdGhpcy4jZWRpdG9yc1RvUmVzY2FsZS5hZGQoZWRpdG9yKTtcbiAgfVxuICByZW1vdmVTaG91bGRSZXNjYWxlKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUuZGVsZXRlKGVkaXRvcik7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKF9yZWYzKSB7XG4gICAgbGV0IHtcbiAgICAgIHNjYWxlXG4gICAgfSA9IF9yZWYzO1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB0aGlzLnZpZXdQYXJhbWV0ZXJzLnJlYWxTY2FsZSA9IHNjYWxlICogX2Rpc3BsYXlfdXRpbHMuUGl4ZWxzUGVySW5jaC5QREZfVE9fQ1NTX1VOSVRTO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnNUb1Jlc2NhbGUpIHtcbiAgICAgIGVkaXRvci5vblNjYWxlQ2hhbmdpbmcoKTtcbiAgICB9XG4gIH1cbiAgb25Sb3RhdGlvbkNoYW5naW5nKF9yZWY0KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhZ2VzUm90YXRpb25cbiAgICB9ID0gX3JlZjQ7XG4gICAgdGhpcy5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld1BhcmFtZXRlcnMucm90YXRpb24gPSBwYWdlc1JvdGF0aW9uO1xuICB9XG4gIGFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNFbXB0eSgpICYmIHRoaXMuI2Fubm90YXRpb25TdG9yYWdlICYmICF0aGlzLiNhbm5vdGF0aW9uU3RvcmFnZS5oYXMoZWRpdG9yLmlkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUoZWRpdG9yLmlkLCBlZGl0b3IpO1xuICAgIH1cbiAgfVxuICAjYWRkRm9jdXNNYW5hZ2VyKCkge1xuICAgIHdpbmRvdy5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jYm91bmRGb2N1cyk7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuI2JvdW5kQmx1cik7XG4gIH1cbiAgI3JlbW92ZUZvY3VzTWFuYWdlcigpIHtcbiAgICB3aW5kb3cucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI2JvdW5kRm9jdXMpO1xuICAgIHdpbmRvdy5yZW1vdmVFdmVudExpc3RlbmVyKFwiYmx1clwiLCB0aGlzLiNib3VuZEJsdXIpO1xuICB9XG4gIGJsdXIoKSB7XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBhY3RpdmVFbGVtZW50XG4gICAgfSA9IGRvY3VtZW50O1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgICAgdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQgPSBbZWRpdG9yLCBhY3RpdmVFbGVtZW50XTtcbiAgICAgICAgZWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSBmYWxzZTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvY3VzKCkge1xuICAgIGlmICghdGhpcy4jbGFzdEFjdGl2ZUVsZW1lbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW2xhc3RFZGl0b3IsIGxhc3RBY3RpdmVFbGVtZW50XSA9IHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50O1xuICAgIHRoaXMuI2xhc3RBY3RpdmVFbGVtZW50ID0gbnVsbDtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICBsYXN0RWRpdG9yLl9mb2N1c0V2ZW50c0FsbG93ZWQgPSB0cnVlO1xuICAgIH0sIHtcbiAgICAgIG9uY2U6IHRydWVcbiAgICB9KTtcbiAgICBsYXN0QWN0aXZlRWxlbWVudC5mb2N1cygpO1xuICB9XG4gICNhZGRLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5ZG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKSB7XG4gICAgd2luZG93LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5ZG93biwge1xuICAgICAgY2FwdHVyZTogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICNhZGRDb3B5UGFzdGVMaXN0ZW5lcnMoKSB7XG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNvcHlcIiwgdGhpcy4jYm91bmRDb3B5KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwiY3V0XCIsIHRoaXMuI2JvdW5kQ3V0KTtcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwicGFzdGVcIiwgdGhpcy4jYm91bmRQYXN0ZSk7XG4gIH1cbiAgI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpIHtcbiAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29weVwiLCB0aGlzLiNib3VuZENvcHkpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJjdXRcIiwgdGhpcy4jYm91bmRDdXQpO1xuICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwYXN0ZVwiLCB0aGlzLiNib3VuZFBhc3RlKTtcbiAgfVxuICBhZGRFZGl0TGlzdGVuZXJzKCkge1xuICAgIHRoaXMuI2FkZEtleWJvYXJkTWFuYWdlcigpO1xuICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICB9XG4gIHJlbW92ZUVkaXRMaXN0ZW5lcnMoKSB7XG4gICAgdGhpcy4jcmVtb3ZlS2V5Ym9hcmRNYW5hZ2VyKCk7XG4gICAgdGhpcy4jcmVtb3ZlQ29weVBhc3RlTGlzdGVuZXJzKCk7XG4gIH1cbiAgY29weShldmVudCkge1xuICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9ycyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgY29uc3Qgc2VyaWFsaXplZCA9IGVkaXRvci5zZXJpYWxpemUodHJ1ZSk7XG4gICAgICBpZiAoc2VyaWFsaXplZCkge1xuICAgICAgICBlZGl0b3JzLnB1c2goc2VyaWFsaXplZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChlZGl0b3JzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBldmVudC5jbGlwYm9hcmREYXRhLnNldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiLCBKU09OLnN0cmluZ2lmeShlZGl0b3JzKSk7XG4gIH1cbiAgY3V0KGV2ZW50KSB7XG4gICAgdGhpcy5jb3B5KGV2ZW50KTtcbiAgICB0aGlzLmRlbGV0ZSgpO1xuICB9XG4gIHBhc3RlKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBjb25zdCB7XG4gICAgICBjbGlwYm9hcmREYXRhXG4gICAgfSA9IGV2ZW50O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjbGlwYm9hcmREYXRhLml0ZW1zKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgICAgaWYgKGVkaXRvclR5cGUuaXNIYW5kbGluZ01pbWVGb3JQYXN0aW5nKGl0ZW0udHlwZSkpIHtcbiAgICAgICAgICBlZGl0b3JUeXBlLnBhc3RlKGl0ZW0sIHRoaXMuY3VycmVudExheWVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGRhdGEgPSBjbGlwYm9hcmREYXRhLmdldERhdGEoXCJhcHBsaWNhdGlvbi9wZGZqc1wiKTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYHBhc3RlOiBcIiR7ZXgubWVzc2FnZX1cIi5gKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMudW5zZWxlY3RBbGwoKTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuY3VycmVudExheWVyO1xuICAgIHRyeSB7XG4gICAgICBjb25zdCBuZXdFZGl0b3JzID0gW107XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBkYXRhKSB7XG4gICAgICAgIGNvbnN0IGRlc2VyaWFsaXplZEVkaXRvciA9IGxheWVyLmRlc2VyaWFsaXplKGVkaXRvcik7XG4gICAgICAgIGlmICghZGVzZXJpYWxpemVkRWRpdG9yKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIG5ld0VkaXRvcnMucHVzaChkZXNlcmlhbGl6ZWRFZGl0b3IpO1xuICAgICAgfVxuICAgICAgY29uc3QgY21kID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBuZXdFZGl0b3JzKSB7XG4gICAgICAgICAgdGhpcy4jYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuI3NlbGVjdEVkaXRvcnMobmV3RWRpdG9ycyk7XG4gICAgICB9O1xuICAgICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgICAgZm9yIChjb25zdCBlZGl0b3Igb2YgbmV3RWRpdG9ycykge1xuICAgICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgICBjbWQsXG4gICAgICAgIHVuZG8sXG4gICAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChleCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBwYXN0ZTogXCIke2V4Lm1lc3NhZ2V9XCIuYCk7XG4gICAgfVxuICB9XG4gIGtleWRvd24oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuZ2V0QWN0aXZlKCk/LnNob3VsZEdldEtleWJvYXJkRXZlbnRzKCkpIHtcbiAgICAgIEFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgICB9XG4gIH1cbiAgb25FZGl0aW5nQWN0aW9uKGRldGFpbHMpIHtcbiAgICBpZiAoW1widW5kb1wiLCBcInJlZG9cIiwgXCJkZWxldGVcIiwgXCJzZWxlY3RBbGxcIl0uaW5jbHVkZXMoZGV0YWlscy5uYW1lKSkge1xuICAgICAgdGhpc1tkZXRhaWxzLm5hbWVdKCk7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVN0YXRlcyhkZXRhaWxzKSB7XG4gICAgY29uc3QgaGFzQ2hhbmdlZCA9IE9iamVjdC5lbnRyaWVzKGRldGFpbHMpLnNvbWUoX3JlZjUgPT4ge1xuICAgICAgbGV0IFtrZXksIHZhbHVlXSA9IF9yZWY1O1xuICAgICAgcmV0dXJuIHRoaXMuI3ByZXZpb3VzU3RhdGVzW2tleV0gIT09IHZhbHVlO1xuICAgIH0pO1xuICAgIGlmIChoYXNDaGFuZ2VkKSB7XG4gICAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JzdGF0ZXNjaGFuZ2VkXCIsIHtcbiAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICBkZXRhaWxzOiBPYmplY3QuYXNzaWduKHRoaXMuI3ByZXZpb3VzU3RhdGVzLCBkZXRhaWxzKVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gICNkaXNwYXRjaFVwZGF0ZVVJKGRldGFpbHMpIHtcbiAgICB0aGlzLl9ldmVudEJ1cy5kaXNwYXRjaChcImFubm90YXRpb25lZGl0b3JwYXJhbXNjaGFuZ2VkXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGRldGFpbHNcbiAgICB9KTtcbiAgfVxuICBzZXRFZGl0aW5nU3RhdGUoaXNFZGl0aW5nKSB7XG4gICAgaWYgKGlzRWRpdGluZykge1xuICAgICAgdGhpcy4jYWRkRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNhZGRLZXlib2FyZE1hbmFnZXIoKTtcbiAgICAgIHRoaXMuI2FkZENvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IHRoaXMuI21vZGUgIT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUsXG4gICAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1VuZG8oKSxcbiAgICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiB0aGlzLiNjb21tYW5kTWFuYWdlci5oYXNTb21ldGhpbmdUb1JlZG8oKSxcbiAgICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy4jcmVtb3ZlRm9jdXNNYW5hZ2VyKCk7XG4gICAgICB0aGlzLiNyZW1vdmVLZXlib2FyZE1hbmFnZXIoKTtcbiAgICAgIHRoaXMuI3JlbW92ZUNvcHlQYXN0ZUxpc3RlbmVycygpO1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgICBpc0VkaXRpbmc6IGZhbHNlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QoZmFsc2UpO1xuICAgIH1cbiAgfVxuICByZWdpc3RlckVkaXRvclR5cGVzKHR5cGVzKSB7XG4gICAgaWYgKHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2VkaXRvclR5cGVzID0gdHlwZXM7XG4gICAgZm9yIChjb25zdCBlZGl0b3JUeXBlIG9mIHRoaXMuI2VkaXRvclR5cGVzKSB7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVVJKGVkaXRvclR5cGUuZGVmYXVsdFByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgfVxuICB9XG4gIGdldElkKCkge1xuICAgIHJldHVybiB0aGlzLiNpZE1hbmFnZXIuZ2V0SWQoKTtcbiAgfVxuICBnZXQgY3VycmVudExheWVyKCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHRoaXMuI2N1cnJlbnRQYWdlSW5kZXgpO1xuICB9XG4gIGdldExheWVyKHBhZ2VJbmRleCkge1xuICAgIHJldHVybiB0aGlzLiNhbGxMYXllcnMuZ2V0KHBhZ2VJbmRleCk7XG4gIH1cbiAgZ2V0IGN1cnJlbnRQYWdlSW5kZXgoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2N1cnJlbnRQYWdlSW5kZXg7XG4gIH1cbiAgYWRkTGF5ZXIobGF5ZXIpIHtcbiAgICB0aGlzLiNhbGxMYXllcnMuc2V0KGxheWVyLnBhZ2VJbmRleCwgbGF5ZXIpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIGxheWVyLmVuYWJsZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBsYXllci5kaXNhYmxlKCk7XG4gICAgfVxuICB9XG4gIHJlbW92ZUxheWVyKGxheWVyKSB7XG4gICAgdGhpcy4jYWxsTGF5ZXJzLmRlbGV0ZShsYXllci5wYWdlSW5kZXgpO1xuICB9XG4gIHVwZGF0ZU1vZGUobW9kZSkge1xuICAgIGxldCBlZGl0SWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgaWYgKHRoaXMuI21vZGUgPT09IG1vZGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jbW9kZSA9IG1vZGU7XG4gICAgaWYgKG1vZGUgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLk5PTkUpIHtcbiAgICAgIHRoaXMuc2V0RWRpdGluZ1N0YXRlKGZhbHNlKTtcbiAgICAgIHRoaXMuI2Rpc2FibGVBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgdGhpcy4jZW5hYmxlQWxsKCk7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGZvciAoY29uc3QgbGF5ZXIgb2YgdGhpcy4jYWxsTGF5ZXJzLnZhbHVlcygpKSB7XG4gICAgICBsYXllci51cGRhdGVNb2RlKG1vZGUpO1xuICAgIH1cbiAgICBpZiAoIWVkaXRJZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPT09IGVkaXRJZCkge1xuICAgICAgICB0aGlzLnNldFNlbGVjdGVkKGVkaXRvcik7XG4gICAgICAgIGVkaXRvci5lbnRlckluRWRpdE1vZGUoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHVwZGF0ZVRvb2xiYXIobW9kZSkge1xuICAgIGlmIChtb2RlID09PSB0aGlzLiNtb2RlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuX2V2ZW50QnVzLmRpc3BhdGNoKFwic3dpdGNoYW5ub3RhdGlvbmVkaXRvcm1vZGVcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgbW9kZVxuICAgIH0pO1xuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIGlmICghdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkNSRUFURSkge1xuICAgICAgdGhpcy5jdXJyZW50TGF5ZXIuYWRkTmV3RWRpdG9yKHR5cGUpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMpIHtcbiAgICAgIGVkaXRvci51cGRhdGVQYXJhbXModHlwZSwgdmFsdWUpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvclR5cGUgb2YgdGhpcy4jZWRpdG9yVHlwZXMpIHtcbiAgICAgIGVkaXRvclR5cGUudXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSk7XG4gICAgfVxuICB9XG4gIGVuYWJsZVdhaXRpbmcoKSB7XG4gICAgbGV0IG11c3RXYWl0ID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICBpZiAodGhpcy4jaXNXYWl0aW5nID09PSBtdXN0V2FpdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNpc1dhaXRpbmcgPSBtdXN0V2FpdDtcbiAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgaWYgKG11c3RXYWl0KSB7XG4gICAgICAgIGxheWVyLmRpc2FibGVDbGljaygpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGF5ZXIuZW5hYmxlQ2xpY2soKTtcbiAgICAgIH1cbiAgICAgIGxheWVyLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwid2FpdGluZ1wiLCBtdXN0V2FpdCk7XG4gICAgfVxuICB9XG4gICNlbmFibGVBbGwoKSB7XG4gICAgaWYgKCF0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IHRydWU7XG4gICAgICBmb3IgKGNvbnN0IGxheWVyIG9mIHRoaXMuI2FsbExheWVycy52YWx1ZXMoKSkge1xuICAgICAgICBsYXllci5lbmFibGUoKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgI2Rpc2FibGVBbGwoKSB7XG4gICAgdGhpcy51bnNlbGVjdEFsbCgpO1xuICAgIGlmICh0aGlzLiNpc0VuYWJsZWQpIHtcbiAgICAgIHRoaXMuI2lzRW5hYmxlZCA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBsYXllciBvZiB0aGlzLiNhbGxMYXllcnMudmFsdWVzKCkpIHtcbiAgICAgICAgbGF5ZXIuZGlzYWJsZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBnZXRFZGl0b3JzKHBhZ2VJbmRleCkge1xuICAgIGNvbnN0IGVkaXRvcnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBpZiAoZWRpdG9yLnBhZ2VJbmRleCA9PT0gcGFnZUluZGV4KSB7XG4gICAgICAgIGVkaXRvcnMucHVzaChlZGl0b3IpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZWRpdG9ycztcbiAgfVxuICBnZXRFZGl0b3IoaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYWxsRWRpdG9ycy5nZXQoaWQpO1xuICB9XG4gIGFkZEVkaXRvcihlZGl0b3IpIHtcbiAgICB0aGlzLiNhbGxFZGl0b3JzLnNldChlZGl0b3IuaWQsIGVkaXRvcik7XG4gIH1cbiAgcmVtb3ZlRWRpdG9yKGVkaXRvcikge1xuICAgIHRoaXMuI2FsbEVkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy51bnNlbGVjdChlZGl0b3IpO1xuICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgfHwgIXRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSkge1xuICAgICAgdGhpcy4jYW5ub3RhdGlvblN0b3JhZ2U/LnJlbW92ZShlZGl0b3IuaWQpO1xuICAgIH1cbiAgfVxuICBhZGREZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKSB7XG4gICAgdGhpcy4jZGVsZXRlZEFubm90YXRpb25zRWxlbWVudElkcy5hZGQoZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQpO1xuICAgIGVkaXRvci5kZWxldGVkID0gdHJ1ZTtcbiAgfVxuICBpc0RlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChhbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgcmV0dXJuIHRoaXMuI2RlbGV0ZWRBbm5vdGF0aW9uc0VsZW1lbnRJZHMuaGFzKGFubm90YXRpb25FbGVtZW50SWQpO1xuICB9XG4gIHJlbW92ZURlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpIHtcbiAgICB0aGlzLiNkZWxldGVkQW5ub3RhdGlvbnNFbGVtZW50SWRzLmRlbGV0ZShlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgZWRpdG9yLmRlbGV0ZWQgPSBmYWxzZTtcbiAgfVxuICAjYWRkRWRpdG9yVG9MYXllcihlZGl0b3IpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI2FsbExheWVycy5nZXQoZWRpdG9yLnBhZ2VJbmRleCk7XG4gICAgaWYgKGxheWVyKSB7XG4gICAgICBsYXllci5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5hZGRFZGl0b3IoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGlmICh0aGlzLiNhY3RpdmVFZGl0b3IgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNhY3RpdmVFZGl0b3IgPSBlZGl0b3I7XG4gICAgaWYgKGVkaXRvcikge1xuICAgICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB9XG4gIH1cbiAgdG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKSB7XG4gICAgaWYgKHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5oYXMoZWRpdG9yKSkge1xuICAgICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgICAgfSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICBlZGl0b3Iuc2VsZWN0KCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVVSShlZGl0b3IucHJvcGVydGllc1RvVXBkYXRlKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTZWxlY3RlZEVkaXRvcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHNldFNlbGVjdGVkKGVkaXRvcikge1xuICAgIGZvciAoY29uc3QgZWQgb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBpZiAoZWQgIT09IGVkaXRvcikge1xuICAgICAgICBlZC51bnNlbGVjdCgpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuYWRkKGVkaXRvcik7XG4gICAgZWRpdG9yLnNlbGVjdCgpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlVUkoZWRpdG9yLnByb3BlcnRpZXNUb1VwZGF0ZSk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBpc1NlbGVjdGVkKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuaGFzKGVkaXRvcik7XG4gIH1cbiAgdW5zZWxlY3QoZWRpdG9yKSB7XG4gICAgZWRpdG9yLnVuc2VsZWN0KCk7XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmRlbGV0ZShlZGl0b3IpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NlbGVjdGVkRWRpdG9yOiB0aGlzLmhhc1NlbGVjdGlvblxuICAgIH0pO1xuICB9XG4gIGdldCBoYXNTZWxlY3Rpb24oKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5zaXplICE9PSAwO1xuICB9XG4gIHVuZG8oKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIudW5kbygpO1xuICAgIHRoaXMuI2Rpc3BhdGNoVXBkYXRlU3RhdGVzKHtcbiAgICAgIGhhc1NvbWV0aGluZ1RvVW5kbzogdGhpcy4jY29tbWFuZE1hbmFnZXIuaGFzU29tZXRoaW5nVG9VbmRvKCksXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRydWUsXG4gICAgICBpc0VtcHR5OiB0aGlzLiNpc0VtcHR5KClcbiAgICB9KTtcbiAgfVxuICByZWRvKCkge1xuICAgIHRoaXMuI2NvbW1hbmRNYW5hZ2VyLnJlZG8oKTtcbiAgICB0aGlzLiNkaXNwYXRjaFVwZGF0ZVN0YXRlcyh7XG4gICAgICBoYXNTb21ldGhpbmdUb1VuZG86IHRydWUsXG4gICAgICBoYXNTb21ldGhpbmdUb1JlZG86IHRoaXMuI2NvbW1hbmRNYW5hZ2VyLmhhc1NvbWV0aGluZ1RvUmVkbygpLFxuICAgICAgaXNFbXB0eTogdGhpcy4jaXNFbXB0eSgpXG4gICAgfSk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jY29tbWFuZE1hbmFnZXIuYWRkKHBhcmFtcyk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU29tZXRoaW5nVG9VbmRvOiB0cnVlLFxuICAgICAgaGFzU29tZXRoaW5nVG9SZWRvOiBmYWxzZSxcbiAgICAgIGlzRW1wdHk6IHRoaXMuI2lzRW1wdHkoKVxuICAgIH0pO1xuICB9XG4gICNpc0VtcHR5KCkge1xuICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLnNpemUgPT09IDApIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICBpZiAodGhpcy4jYWxsRWRpdG9ycy5zaXplID09PSAxKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNhbGxFZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIHJldHVybiBlZGl0b3IuaXNFbXB0eSgpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgZGVsZXRlKCkge1xuICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvcnMgPSBbLi4udGhpcy4jc2VsZWN0ZWRFZGl0b3JzXTtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICAgIHRoaXMuI2FkZEVkaXRvclRvTGF5ZXIoZWRpdG9yKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgY29tbWl0T3JSZW1vdmUoKSB7XG4gICAgdGhpcy4jYWN0aXZlRWRpdG9yPy5jb21taXRPclJlbW92ZSgpO1xuICB9XG4gIGhhc1NvbWV0aGluZ1RvQ29udHJvbCgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yIHx8IHRoaXMuaGFzU2VsZWN0aW9uO1xuICB9XG4gICNzZWxlY3RFZGl0b3JzKGVkaXRvcnMpIHtcbiAgICB0aGlzLiNzZWxlY3RlZEVkaXRvcnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiBlZGl0b3JzKSB7XG4gICAgICBpZiAoZWRpdG9yLmlzRW1wdHkoKSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NlbGVjdGVkRWRpdG9ycy5hZGQoZWRpdG9yKTtcbiAgICAgIGVkaXRvci5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IHRydWVcbiAgICB9KTtcbiAgfVxuICBzZWxlY3RBbGwoKSB7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IuY29tbWl0KCk7XG4gICAgfVxuICAgIHRoaXMuI3NlbGVjdEVkaXRvcnModGhpcy4jYWxsRWRpdG9ycy52YWx1ZXMoKSk7XG4gIH1cbiAgdW5zZWxlY3RBbGwoKSB7XG4gICAgaWYgKHRoaXMuI2FjdGl2ZUVkaXRvcikge1xuICAgICAgdGhpcy4jYWN0aXZlRWRpdG9yLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5oYXNTZWxlY3Rpb24pIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzKSB7XG4gICAgICBlZGl0b3IudW5zZWxlY3QoKTtcbiAgICB9XG4gICAgdGhpcy4jc2VsZWN0ZWRFZGl0b3JzLmNsZWFyKCk7XG4gICAgdGhpcy4jZGlzcGF0Y2hVcGRhdGVTdGF0ZXMoe1xuICAgICAgaGFzU2VsZWN0ZWRFZGl0b3I6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgdHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHkpIHtcbiAgICBsZXQgbm9Db21taXQgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGlmICghbm9Db21taXQpIHtcbiAgICAgIHRoaXMuY29tbWl0T3JSZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmhhc1NlbGVjdGlvbikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN0cmFuc2xhdGlvblswXSArPSB4O1xuICAgIHRoaXMuI3RyYW5zbGF0aW9uWzFdICs9IHk7XG4gICAgY29uc3QgW3RvdGFsWCwgdG90YWxZXSA9IHRoaXMuI3RyYW5zbGF0aW9uO1xuICAgIGNvbnN0IGVkaXRvcnMgPSBbLi4udGhpcy4jc2VsZWN0ZWRFZGl0b3JzXTtcbiAgICBjb25zdCBUSU1FX1RPX1dBSVQgPSAxMDAwO1xuICAgIGlmICh0aGlzLiN0cmFuc2xhdGlvblRpbWVvdXRJZCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkKTtcbiAgICB9XG4gICAgdGhpcy4jdHJhbnNsYXRpb25UaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uVGltZW91dElkID0gbnVsbDtcbiAgICAgIHRoaXMuI3RyYW5zbGF0aW9uWzBdID0gdGhpcy4jdHJhbnNsYXRpb25bMV0gPSAwO1xuICAgICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UodG90YWxYLCB0b3RhbFkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIGVkaXRvcnMpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgICAgICAgIGVkaXRvci50cmFuc2xhdGVJblBhZ2UoLXRvdGFsWCwgLXRvdGFsWSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0sIFRJTUVfVE9fV0FJVCk7XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgZWRpdG9ycykge1xuICAgICAgZWRpdG9yLnRyYW5zbGF0ZUluUGFnZSh4LCB5KTtcbiAgICB9XG4gIH1cbiAgc2V0VXBEcmFnU2Vzc2lvbigpIHtcbiAgICBpZiAoIXRoaXMuaGFzU2VsZWN0aW9uKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZGlzYWJsZVVzZXJTZWxlY3QodHJ1ZSk7XG4gICAgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzID0gbmV3IE1hcCgpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3NlbGVjdGVkRWRpdG9ycykge1xuICAgICAgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzLnNldChlZGl0b3IsIHtcbiAgICAgICAgc2F2ZWRYOiBlZGl0b3IueCxcbiAgICAgICAgc2F2ZWRZOiBlZGl0b3IueSxcbiAgICAgICAgc2F2ZWRQYWdlSW5kZXg6IGVkaXRvci5wYWdlSW5kZXgsXG4gICAgICAgIG5ld1g6IDAsXG4gICAgICAgIG5ld1k6IDAsXG4gICAgICAgIG5ld1BhZ2VJbmRleDogLTFcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBlbmREcmFnU2Vzc2lvbigpIHtcbiAgICBpZiAoIXRoaXMuI2RyYWdnaW5nRWRpdG9ycykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLmRpc2FibGVVc2VyU2VsZWN0KGZhbHNlKTtcbiAgICBjb25zdCBtYXAgPSB0aGlzLiNkcmFnZ2luZ0VkaXRvcnM7XG4gICAgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzID0gbnVsbDtcbiAgICBsZXQgbXVzdEJlQWRkZWRJblVuZG9TdGFjayA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgW3tcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSwgdmFsdWVdIG9mIG1hcCkge1xuICAgICAgdmFsdWUubmV3WCA9IHg7XG4gICAgICB2YWx1ZS5uZXdZID0geTtcbiAgICAgIHZhbHVlLm5ld1BhZ2VJbmRleCA9IHBhZ2VJbmRleDtcbiAgICAgIG11c3RCZUFkZGVkSW5VbmRvU3RhY2sgfHw9IHggIT09IHZhbHVlLnNhdmVkWCB8fCB5ICE9PSB2YWx1ZS5zYXZlZFkgfHwgcGFnZUluZGV4ICE9PSB2YWx1ZS5zYXZlZFBhZ2VJbmRleDtcbiAgICB9XG4gICAgaWYgKCFtdXN0QmVBZGRlZEluVW5kb1N0YWNrKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGNvbnN0IG1vdmUgPSAoZWRpdG9yLCB4LCB5LCBwYWdlSW5kZXgpID0+IHtcbiAgICAgIGlmICh0aGlzLiNhbGxFZGl0b3JzLmhhcyhlZGl0b3IuaWQpKSB7XG4gICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuI2FsbExheWVycy5nZXQocGFnZUluZGV4KTtcbiAgICAgICAgaWYgKHBhcmVudCkge1xuICAgICAgICAgIGVkaXRvci5fc2V0UGFyZW50QW5kUG9zaXRpb24ocGFyZW50LCB4LCB5KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IucGFnZUluZGV4ID0gcGFnZUluZGV4O1xuICAgICAgICAgIGVkaXRvci54ID0geDtcbiAgICAgICAgICBlZGl0b3IueSA9IHk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2VkaXRvciwge1xuICAgICAgICAgIG5ld1gsXG4gICAgICAgICAgbmV3WSxcbiAgICAgICAgICBuZXdQYWdlSW5kZXhcbiAgICAgICAgfV0gb2YgbWFwKSB7XG4gICAgICAgICAgbW92ZShlZGl0b3IsIG5ld1gsIG5ld1ksIG5ld1BhZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgW2VkaXRvciwge1xuICAgICAgICAgIHNhdmVkWCxcbiAgICAgICAgICBzYXZlZFksXG4gICAgICAgICAgc2F2ZWRQYWdlSW5kZXhcbiAgICAgICAgfV0gb2YgbWFwKSB7XG4gICAgICAgICAgbW92ZShlZGl0b3IsIHNhdmVkWCwgc2F2ZWRZLCBzYXZlZFBhZ2VJbmRleCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZVxuICAgIH0pO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGRyYWdTZWxlY3RlZEVkaXRvcnModHgsIHR5KSB7XG4gICAgaWYgKCF0aGlzLiNkcmFnZ2luZ0VkaXRvcnMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlZGl0b3Igb2YgdGhpcy4jZHJhZ2dpbmdFZGl0b3JzLmtleXMoKSkge1xuICAgICAgZWRpdG9yLmRyYWcodHgsIHR5KTtcbiAgICB9XG4gIH1cbiAgcmVidWlsZChlZGl0b3IpIHtcbiAgICBpZiAoZWRpdG9yLnBhcmVudCA9PT0gbnVsbCkge1xuICAgICAgY29uc3QgcGFyZW50ID0gdGhpcy5nZXRMYXllcihlZGl0b3IucGFnZUluZGV4KTtcbiAgICAgIGlmIChwYXJlbnQpIHtcbiAgICAgICAgcGFyZW50LmNoYW5nZVBhcmVudChlZGl0b3IpO1xuICAgICAgICBwYXJlbnQuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgICAgICB0aGlzLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgICAgICAgZWRpdG9yLnJlYnVpbGQoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWRpdG9yLnBhcmVudC5hZGRPclJlYnVpbGQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgaXNBY3RpdmUoZWRpdG9yKSB7XG4gICAgcmV0dXJuIHRoaXMuI2FjdGl2ZUVkaXRvciA9PT0gZWRpdG9yO1xuICB9XG4gIGdldEFjdGl2ZSgpIHtcbiAgICByZXR1cm4gdGhpcy4jYWN0aXZlRWRpdG9yO1xuICB9XG4gIGdldE1vZGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI21vZGU7XG4gIH1cbiAgZ2V0IGltYWdlTWFuYWdlcigpIHtcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpbWFnZU1hbmFnZXJcIiwgbmV3IEltYWdlTWFuYWdlcigpKTtcbiAgfVxufVxuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yVUlNYW5hZ2VyID0gQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlcjtcblxuLyoqKi8gfSksXG4vKiAxNjYgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciAkID0gX193X3BkZmpzX3JlcXVpcmVfXygzKTtcbnZhciBERVNDUklQVE9SUyA9IF9fd19wZGZqc19yZXF1aXJlX18oNik7XG52YXIgZ2xvYmFsID0gX193X3BkZmpzX3JlcXVpcmVfXyg0KTtcbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG52YXIgdW5jdXJyeVRoaXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE0KTtcbnZhciBjYWxsID0gX193X3BkZmpzX3JlcXVpcmVfXyg4KTtcbnZhciBpc0NhbGxhYmxlID0gX193X3BkZmpzX3JlcXVpcmVfXygyMSk7XG52YXIgaXNPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwKTtcbnZhciBpc0FycmF5ID0gX193X3BkZmpzX3JlcXVpcmVfXyg5MSk7XG52YXIgaGFzT3duID0gX193X3BkZmpzX3JlcXVpcmVfXygzOSk7XG52YXIgdG9TdHJpbmcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDc3KTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNjQpO1xudmFyIGNyZWF0ZVByb3BlcnR5ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNTkpO1xudmFyIGZhaWxzID0gX193X3BkZmpzX3JlcXVpcmVfXyg3KTtcbnZhciBwYXJzZUpTT05TdHJpbmcgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2Nyk7XG52YXIgTkFUSVZFX1NZTUJPTCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjcpO1xudmFyIEpTT04gPSBnbG9iYWwuSlNPTjtcbnZhciBOdW1iZXIgPSBnbG9iYWwuTnVtYmVyO1xudmFyIFN5bnRheEVycm9yID0gZ2xvYmFsLlN5bnRheEVycm9yO1xudmFyIG5hdGl2ZVBhcnNlID0gSlNPTiAmJiBKU09OLnBhcnNlO1xudmFyIGVudW1lcmFibGVPd25Qcm9wZXJ0aWVzID0gZ2V0QnVpbHRJbignT2JqZWN0JywgJ2tleXMnKTtcbnZhciBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yO1xudmFyIGF0ID0gdW5jdXJyeVRoaXMoJycuY2hhckF0KTtcbnZhciBzbGljZSA9IHVuY3VycnlUaGlzKCcnLnNsaWNlKTtcbnZhciBleGVjID0gdW5jdXJyeVRoaXMoLy4vLmV4ZWMpO1xudmFyIHB1c2ggPSB1bmN1cnJ5VGhpcyhbXS5wdXNoKTtcbnZhciBJU19ESUdJVCA9IC9eXFxkJC87XG52YXIgSVNfTk9OX1pFUk9fRElHSVQgPSAvXlsxLTldJC87XG52YXIgSVNfTlVNQkVSX1NUQVJUID0gL14oPzotfFxcZCkkLztcbnZhciBJU19XSElURVNQQUNFID0gL15bXFx0XFxuXFxyIF0kLztcbnZhciBQUklNSVRJVkUgPSAwO1xudmFyIE9CSkVDVCA9IDE7XG52YXIgJHBhcnNlID0gZnVuY3Rpb24gKHNvdXJjZSwgcmV2aXZlcikge1xuIHNvdXJjZSA9IHRvU3RyaW5nKHNvdXJjZSk7XG4gdmFyIGNvbnRleHQgPSBuZXcgQ29udGV4dChzb3VyY2UsIDAsICcnKTtcbiB2YXIgcm9vdCA9IGNvbnRleHQucGFyc2UoKTtcbiB2YXIgdmFsdWUgPSByb290LnZhbHVlO1xuIHZhciBlbmRJbmRleCA9IGNvbnRleHQuc2tpcChJU19XSElURVNQQUNFLCByb290LmVuZCk7XG4gaWYgKGVuZEluZGV4IDwgc291cmNlLmxlbmd0aCkge1xuICB0aHJvdyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBleHRyYSBjaGFyYWN0ZXI6IFwiJyArIGF0KHNvdXJjZSwgZW5kSW5kZXgpICsgJ1wiIGFmdGVyIHRoZSBwYXJzZWQgZGF0YSBhdDogJyArIGVuZEluZGV4KTtcbiB9XG4gcmV0dXJuIGlzQ2FsbGFibGUocmV2aXZlcikgPyBpbnRlcm5hbGl6ZSh7ICcnOiB2YWx1ZSB9LCAnJywgcmV2aXZlciwgcm9vdCkgOiB2YWx1ZTtcbn07XG52YXIgaW50ZXJuYWxpemUgPSBmdW5jdGlvbiAoaG9sZGVyLCBuYW1lLCByZXZpdmVyLCBub2RlKSB7XG4gdmFyIHZhbCA9IGhvbGRlcltuYW1lXTtcbiB2YXIgdW5tb2RpZmllZCA9IG5vZGUgJiYgdmFsID09PSBub2RlLnZhbHVlO1xuIHZhciBjb250ZXh0ID0gdW5tb2RpZmllZCAmJiB0eXBlb2Ygbm9kZS5zb3VyY2UgPT0gJ3N0cmluZycgPyB7IHNvdXJjZTogbm9kZS5zb3VyY2UgfSA6IHt9O1xuIHZhciBlbGVtZW50UmVjb3Jkc0xlbiwga2V5cywgbGVuLCBpLCBQO1xuIGlmIChpc09iamVjdCh2YWwpKSB7XG4gIHZhciBub2RlSXNBcnJheSA9IGlzQXJyYXkodmFsKTtcbiAgdmFyIG5vZGVzID0gdW5tb2RpZmllZCA/IG5vZGUubm9kZXMgOiBub2RlSXNBcnJheSA/IFtdIDoge307XG4gIGlmIChub2RlSXNBcnJheSkge1xuICAgZWxlbWVudFJlY29yZHNMZW4gPSBub2Rlcy5sZW5ndGg7XG4gICBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZSh2YWwpO1xuICAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgaW50ZXJuYWxpemVQcm9wZXJ0eSh2YWwsIGksIGludGVybmFsaXplKHZhbCwgJycgKyBpLCByZXZpdmVyLCBpIDwgZWxlbWVudFJlY29yZHNMZW4gPyBub2Rlc1tpXSA6IHVuZGVmaW5lZCkpO1xuICAgfVxuICB9IGVsc2Uge1xuICAga2V5cyA9IGVudW1lcmFibGVPd25Qcm9wZXJ0aWVzKHZhbCk7XG4gICBsZW4gPSBsZW5ndGhPZkFycmF5TGlrZShrZXlzKTtcbiAgIGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIFAgPSBrZXlzW2ldO1xuICAgIGludGVybmFsaXplUHJvcGVydHkodmFsLCBQLCBpbnRlcm5hbGl6ZSh2YWwsIFAsIHJldml2ZXIsIGhhc093bihub2RlcywgUCkgPyBub2Rlc1tQXSA6IHVuZGVmaW5lZCkpO1xuICAgfVxuICB9XG4gfVxuIHJldHVybiBjYWxsKHJldml2ZXIsIGhvbGRlciwgbmFtZSwgdmFsLCBjb250ZXh0KTtcbn07XG52YXIgaW50ZXJuYWxpemVQcm9wZXJ0eSA9IGZ1bmN0aW9uIChvYmplY3QsIGtleSwgdmFsdWUpIHtcbiBpZiAoREVTQ1JJUFRPUlMpIHtcbiAgdmFyIGRlc2NyaXB0b3IgPSBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBrZXkpO1xuICBpZiAoZGVzY3JpcHRvciAmJiAhZGVzY3JpcHRvci5jb25maWd1cmFibGUpXG4gICByZXR1cm47XG4gfVxuIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKVxuICBkZWxldGUgb2JqZWN0W2tleV07XG4gZWxzZVxuICBjcmVhdGVQcm9wZXJ0eShvYmplY3QsIGtleSwgdmFsdWUpO1xufTtcbnZhciBOb2RlID0gZnVuY3Rpb24gKHZhbHVlLCBlbmQsIHNvdXJjZSwgbm9kZXMpIHtcbiB0aGlzLnZhbHVlID0gdmFsdWU7XG4gdGhpcy5lbmQgPSBlbmQ7XG4gdGhpcy5zb3VyY2UgPSBzb3VyY2U7XG4gdGhpcy5ub2RlcyA9IG5vZGVzO1xufTtcbnZhciBDb250ZXh0ID0gZnVuY3Rpb24gKHNvdXJjZSwgaW5kZXgpIHtcbiB0aGlzLnNvdXJjZSA9IHNvdXJjZTtcbiB0aGlzLmluZGV4ID0gaW5kZXg7XG59O1xuQ29udGV4dC5wcm90b3R5cGUgPSB7XG4gZm9yazogZnVuY3Rpb24gKG5leHRJbmRleCkge1xuICByZXR1cm4gbmV3IENvbnRleHQodGhpcy5zb3VyY2UsIG5leHRJbmRleCk7XG4gfSxcbiBwYXJzZTogZnVuY3Rpb24gKCkge1xuICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gIHZhciBpID0gdGhpcy5za2lwKElTX1dISVRFU1BBQ0UsIHRoaXMuaW5kZXgpO1xuICB2YXIgZm9yayA9IHRoaXMuZm9yayhpKTtcbiAgdmFyIGNociA9IGF0KHNvdXJjZSwgaSk7XG4gIGlmIChleGVjKElTX05VTUJFUl9TVEFSVCwgY2hyKSlcbiAgIHJldHVybiBmb3JrLm51bWJlcigpO1xuICBzd2l0Y2ggKGNocikge1xuICBjYXNlICd7JzpcbiAgIHJldHVybiBmb3JrLm9iamVjdCgpO1xuICBjYXNlICdbJzpcbiAgIHJldHVybiBmb3JrLmFycmF5KCk7XG4gIGNhc2UgJ1wiJzpcbiAgIHJldHVybiBmb3JrLnN0cmluZygpO1xuICBjYXNlICd0JzpcbiAgIHJldHVybiBmb3JrLmtleXdvcmQodHJ1ZSk7XG4gIGNhc2UgJ2YnOlxuICAgcmV0dXJuIGZvcmsua2V5d29yZChmYWxzZSk7XG4gIGNhc2UgJ24nOlxuICAgcmV0dXJuIGZvcmsua2V5d29yZChudWxsKTtcbiAgfVxuICB0aHJvdyBTeW50YXhFcnJvcignVW5leHBlY3RlZCBjaGFyYWN0ZXI6IFwiJyArIGNociArICdcIiBhdDogJyArIGkpO1xuIH0sXG4gbm9kZTogZnVuY3Rpb24gKHR5cGUsIHZhbHVlLCBzdGFydCwgZW5kLCBub2Rlcykge1xuICByZXR1cm4gbmV3IE5vZGUodmFsdWUsIGVuZCwgdHlwZSA/IG51bGwgOiBzbGljZSh0aGlzLnNvdXJjZSwgc3RhcnQsIGVuZCksIG5vZGVzKTtcbiB9LFxuIG9iamVjdDogZnVuY3Rpb24gKCkge1xuICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gIHZhciBpID0gdGhpcy5pbmRleCArIDE7XG4gIHZhciBleHBlY3RLZXlwYWlyID0gZmFsc2U7XG4gIHZhciBvYmplY3QgPSB7fTtcbiAgdmFyIG5vZGVzID0ge307XG4gIHdoaWxlIChpIDwgc291cmNlLmxlbmd0aCkge1xuICAgaSA9IHRoaXMudW50aWwoW1xuICAgICdcIicsXG4gICAgJ30nXG4gICBdLCBpKTtcbiAgIGlmIChhdChzb3VyY2UsIGkpID09PSAnfScgJiYgIWV4cGVjdEtleXBhaXIpIHtcbiAgICBpKys7XG4gICAgYnJlYWs7XG4gICB9XG4gICB2YXIgcmVzdWx0ID0gdGhpcy5mb3JrKGkpLnN0cmluZygpO1xuICAgdmFyIGtleSA9IHJlc3VsdC52YWx1ZTtcbiAgIGkgPSByZXN1bHQuZW5kO1xuICAgaSA9IHRoaXMudW50aWwoWyc6J10sIGkpICsgMTtcbiAgIGkgPSB0aGlzLnNraXAoSVNfV0hJVEVTUEFDRSwgaSk7XG4gICByZXN1bHQgPSB0aGlzLmZvcmsoaSkucGFyc2UoKTtcbiAgIGNyZWF0ZVByb3BlcnR5KG5vZGVzLCBrZXksIHJlc3VsdCk7XG4gICBjcmVhdGVQcm9wZXJ0eShvYmplY3QsIGtleSwgcmVzdWx0LnZhbHVlKTtcbiAgIGkgPSB0aGlzLnVudGlsKFtcbiAgICAnLCcsXG4gICAgJ30nXG4gICBdLCByZXN1bHQuZW5kKTtcbiAgIHZhciBjaHIgPSBhdChzb3VyY2UsIGkpO1xuICAgaWYgKGNociA9PT0gJywnKSB7XG4gICAgZXhwZWN0S2V5cGFpciA9IHRydWU7XG4gICAgaSsrO1xuICAgfSBlbHNlIGlmIChjaHIgPT09ICd9Jykge1xuICAgIGkrKztcbiAgICBicmVhaztcbiAgIH1cbiAgfVxuICByZXR1cm4gdGhpcy5ub2RlKE9CSkVDVCwgb2JqZWN0LCB0aGlzLmluZGV4LCBpLCBub2Rlcyk7XG4gfSxcbiBhcnJheTogZnVuY3Rpb24gKCkge1xuICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gIHZhciBpID0gdGhpcy5pbmRleCArIDE7XG4gIHZhciBleHBlY3RFbGVtZW50ID0gZmFsc2U7XG4gIHZhciBhcnJheSA9IFtdO1xuICB2YXIgbm9kZXMgPSBbXTtcbiAgd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoKSB7XG4gICBpID0gdGhpcy5za2lwKElTX1dISVRFU1BBQ0UsIGkpO1xuICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09ICddJyAmJiAhZXhwZWN0RWxlbWVudCkge1xuICAgIGkrKztcbiAgICBicmVhaztcbiAgIH1cbiAgIHZhciByZXN1bHQgPSB0aGlzLmZvcmsoaSkucGFyc2UoKTtcbiAgIHB1c2gobm9kZXMsIHJlc3VsdCk7XG4gICBwdXNoKGFycmF5LCByZXN1bHQudmFsdWUpO1xuICAgaSA9IHRoaXMudW50aWwoW1xuICAgICcsJyxcbiAgICAnXSdcbiAgIF0sIHJlc3VsdC5lbmQpO1xuICAgaWYgKGF0KHNvdXJjZSwgaSkgPT09ICcsJykge1xuICAgIGV4cGVjdEVsZW1lbnQgPSB0cnVlO1xuICAgIGkrKztcbiAgIH0gZWxzZSBpZiAoYXQoc291cmNlLCBpKSA9PT0gJ10nKSB7XG4gICAgaSsrO1xuICAgIGJyZWFrO1xuICAgfVxuICB9XG4gIHJldHVybiB0aGlzLm5vZGUoT0JKRUNULCBhcnJheSwgdGhpcy5pbmRleCwgaSwgbm9kZXMpO1xuIH0sXG4gc3RyaW5nOiBmdW5jdGlvbiAoKSB7XG4gIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gIHZhciBwYXJzZWQgPSBwYXJzZUpTT05TdHJpbmcodGhpcy5zb3VyY2UsIHRoaXMuaW5kZXggKyAxKTtcbiAgcmV0dXJuIHRoaXMubm9kZShQUklNSVRJVkUsIHBhcnNlZC52YWx1ZSwgaW5kZXgsIHBhcnNlZC5lbmQpO1xuIH0sXG4gbnVtYmVyOiBmdW5jdGlvbiAoKSB7XG4gIHZhciBzb3VyY2UgPSB0aGlzLnNvdXJjZTtcbiAgdmFyIHN0YXJ0SW5kZXggPSB0aGlzLmluZGV4O1xuICB2YXIgaSA9IHN0YXJ0SW5kZXg7XG4gIGlmIChhdChzb3VyY2UsIGkpID09PSAnLScpXG4gICBpKys7XG4gIGlmIChhdChzb3VyY2UsIGkpID09PSAnMCcpXG4gICBpKys7XG4gIGVsc2UgaWYgKGV4ZWMoSVNfTk9OX1pFUk9fRElHSVQsIGF0KHNvdXJjZSwgaSkpKVxuICAgaSA9IHRoaXMuc2tpcChJU19ESUdJVCwgKytpKTtcbiAgZWxzZVxuICAgdGhyb3cgU3ludGF4RXJyb3IoJ0ZhaWxlZCB0byBwYXJzZSBudW1iZXIgYXQ6ICcgKyBpKTtcbiAgaWYgKGF0KHNvdXJjZSwgaSkgPT09ICcuJylcbiAgIGkgPSB0aGlzLnNraXAoSVNfRElHSVQsICsraSk7XG4gIGlmIChhdChzb3VyY2UsIGkpID09PSAnZScgfHwgYXQoc291cmNlLCBpKSA9PT0gJ0UnKSB7XG4gICBpKys7XG4gICBpZiAoYXQoc291cmNlLCBpKSA9PT0gJysnIHx8IGF0KHNvdXJjZSwgaSkgPT09ICctJylcbiAgICBpKys7XG4gICB2YXIgZXhwb25lbnRTdGFydEluZGV4ID0gaTtcbiAgIGkgPSB0aGlzLnNraXAoSVNfRElHSVQsIGkpO1xuICAgaWYgKGV4cG9uZW50U3RhcnRJbmRleCA9PT0gaSlcbiAgICB0aHJvdyBTeW50YXhFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBudW1iZXIncyBleHBvbmVudCB2YWx1ZSBhdDogXCIgKyBpKTtcbiAgfVxuICByZXR1cm4gdGhpcy5ub2RlKFBSSU1JVElWRSwgTnVtYmVyKHNsaWNlKHNvdXJjZSwgc3RhcnRJbmRleCwgaSkpLCBzdGFydEluZGV4LCBpKTtcbiB9LFxuIGtleXdvcmQ6IGZ1bmN0aW9uICh2YWx1ZSkge1xuICB2YXIga2V5d29yZCA9ICcnICsgdmFsdWU7XG4gIHZhciBpbmRleCA9IHRoaXMuaW5kZXg7XG4gIHZhciBlbmRJbmRleCA9IGluZGV4ICsga2V5d29yZC5sZW5ndGg7XG4gIGlmIChzbGljZSh0aGlzLnNvdXJjZSwgaW5kZXgsIGVuZEluZGV4KSAhPT0ga2V5d29yZClcbiAgIHRocm93IFN5bnRheEVycm9yKCdGYWlsZWQgdG8gcGFyc2UgdmFsdWUgYXQ6ICcgKyBpbmRleCk7XG4gIHJldHVybiB0aGlzLm5vZGUoUFJJTUlUSVZFLCB2YWx1ZSwgaW5kZXgsIGVuZEluZGV4KTtcbiB9LFxuIHNraXA6IGZ1bmN0aW9uIChyZWdleCwgaSkge1xuICB2YXIgc291cmNlID0gdGhpcy5zb3VyY2U7XG4gIGZvciAoOyBpIDwgc291cmNlLmxlbmd0aDsgaSsrKVxuICAgaWYgKCFleGVjKHJlZ2V4LCBhdChzb3VyY2UsIGkpKSlcbiAgICBicmVhaztcbiAgcmV0dXJuIGk7XG4gfSxcbiB1bnRpbDogZnVuY3Rpb24gKGFycmF5LCBpKSB7XG4gIGkgPSB0aGlzLnNraXAoSVNfV0hJVEVTUEFDRSwgaSk7XG4gIHZhciBjaHIgPSBhdCh0aGlzLnNvdXJjZSwgaSk7XG4gIGZvciAodmFyIGogPSAwOyBqIDwgYXJyYXkubGVuZ3RoOyBqKyspXG4gICBpZiAoYXJyYXlbal0gPT09IGNocilcbiAgICByZXR1cm4gaTtcbiAgdGhyb3cgU3ludGF4RXJyb3IoJ1VuZXhwZWN0ZWQgY2hhcmFjdGVyOiBcIicgKyBjaHIgKyAnXCIgYXQ6ICcgKyBpKTtcbiB9XG59O1xudmFyIE5PX1NPVVJDRV9TVVBQT1JUID0gZmFpbHMoZnVuY3Rpb24gKCkge1xuIHZhciB1bnNhZmVJbnQgPSAnOTAwNzE5OTI1NDc0MDk5Myc7XG4gdmFyIHNvdXJjZTtcbiBuYXRpdmVQYXJzZSh1bnNhZmVJbnQsIGZ1bmN0aW9uIChrZXksIHZhbHVlLCBjb250ZXh0KSB7XG4gIHNvdXJjZSA9IGNvbnRleHQuc291cmNlO1xuIH0pO1xuIHJldHVybiBzb3VyY2UgIT09IHVuc2FmZUludDtcbn0pO1xudmFyIFBST1BFUl9CQVNFX1BBUlNFID0gTkFUSVZFX1NZTUJPTCAmJiAhZmFpbHMoZnVuY3Rpb24gKCkge1xuIHJldHVybiAxIC8gbmF0aXZlUGFyc2UoJy0wIFxcdCcpICE9PSAtSW5maW5pdHk7XG59KTtcbiQoe1xuIHRhcmdldDogJ0pTT04nLFxuIHN0YXQ6IHRydWUsXG4gZm9yY2VkOiBOT19TT1VSQ0VfU1VQUE9SVFxufSwge1xuIHBhcnNlOiBmdW5jdGlvbiBwYXJzZSh0ZXh0LCByZXZpdmVyKSB7XG4gIHJldHVybiBQUk9QRVJfQkFTRV9QQVJTRSAmJiAhaXNDYWxsYWJsZShyZXZpdmVyKSA/IG5hdGl2ZVBhcnNlKHRleHQpIDogJHBhcnNlKHRleHQsIHJldml2ZXIpO1xuIH1cbn0pO1xuXG4vKioqLyB9KSxcbi8qIDE2NyAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIGhhc093biA9IF9fd19wZGZqc19yZXF1aXJlX18oMzkpO1xudmFyICRTeW50YXhFcnJvciA9IFN5bnRheEVycm9yO1xudmFyICRwYXJzZUludCA9IHBhcnNlSW50O1xudmFyIGZyb21DaGFyQ29kZSA9IFN0cmluZy5mcm9tQ2hhckNvZGU7XG52YXIgYXQgPSB1bmN1cnJ5VGhpcygnJy5jaGFyQXQpO1xudmFyIHNsaWNlID0gdW5jdXJyeVRoaXMoJycuc2xpY2UpO1xudmFyIGV4ZWMgPSB1bmN1cnJ5VGhpcygvLi8uZXhlYyk7XG52YXIgY29kZVBvaW50cyA9IHtcbiAnXFxcXFwiJzogJ1wiJyxcbiAnXFxcXFxcXFwnOiAnXFxcXCcsXG4gJ1xcXFwvJzogJy8nLFxuICdcXFxcYic6ICdcXGInLFxuICdcXFxcZic6ICdcXGYnLFxuICdcXFxcbic6ICdcXG4nLFxuICdcXFxccic6ICdcXHInLFxuICdcXFxcdCc6ICdcXHQnXG59O1xudmFyIElTXzRfSEVYX0RJR0lUUyA9IC9eW1xcZGEtZl17NH0kL2k7XG52YXIgSVNfQzBfQ09OVFJPTF9DT0RFID0gL15bXFx1MDAwMC1cXHUwMDFGXSQvO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc291cmNlLCBpKSB7XG4gdmFyIHVudGVybWluYXRlZCA9IHRydWU7XG4gdmFyIHZhbHVlID0gJyc7XG4gd2hpbGUgKGkgPCBzb3VyY2UubGVuZ3RoKSB7XG4gIHZhciBjaHIgPSBhdChzb3VyY2UsIGkpO1xuICBpZiAoY2hyID09PSAnXFxcXCcpIHtcbiAgIHZhciB0d29DaGFycyA9IHNsaWNlKHNvdXJjZSwgaSwgaSArIDIpO1xuICAgaWYgKGhhc093bihjb2RlUG9pbnRzLCB0d29DaGFycykpIHtcbiAgICB2YWx1ZSArPSBjb2RlUG9pbnRzW3R3b0NoYXJzXTtcbiAgICBpICs9IDI7XG4gICB9IGVsc2UgaWYgKHR3b0NoYXJzID09PSAnXFxcXHUnKSB7XG4gICAgaSArPSAyO1xuICAgIHZhciBmb3VySGV4RGlnaXRzID0gc2xpY2Uoc291cmNlLCBpLCBpICsgNCk7XG4gICAgaWYgKCFleGVjKElTXzRfSEVYX0RJR0lUUywgZm91ckhleERpZ2l0cykpXG4gICAgIHRocm93ICRTeW50YXhFcnJvcignQmFkIFVuaWNvZGUgZXNjYXBlIGF0OiAnICsgaSk7XG4gICAgdmFsdWUgKz0gZnJvbUNoYXJDb2RlKCRwYXJzZUludChmb3VySGV4RGlnaXRzLCAxNikpO1xuICAgIGkgKz0gNDtcbiAgIH0gZWxzZVxuICAgIHRocm93ICRTeW50YXhFcnJvcignVW5rbm93biBlc2NhcGUgc2VxdWVuY2U6IFwiJyArIHR3b0NoYXJzICsgJ1wiJyk7XG4gIH0gZWxzZSBpZiAoY2hyID09PSAnXCInKSB7XG4gICB1bnRlcm1pbmF0ZWQgPSBmYWxzZTtcbiAgIGkrKztcbiAgIGJyZWFrO1xuICB9IGVsc2Uge1xuICAgaWYgKGV4ZWMoSVNfQzBfQ09OVFJPTF9DT0RFLCBjaHIpKVxuICAgIHRocm93ICRTeW50YXhFcnJvcignQmFkIGNvbnRyb2wgY2hhcmFjdGVyIGluIHN0cmluZyBsaXRlcmFsIGF0OiAnICsgaSk7XG4gICB2YWx1ZSArPSBjaHI7XG4gICBpKys7XG4gIH1cbiB9XG4gaWYgKHVudGVybWluYXRlZClcbiAgdGhyb3cgJFN5bnRheEVycm9yKCdVbnRlcm1pbmF0ZWQgc3RyaW5nIGF0OiAnICsgaSk7XG4gcmV0dXJuIHtcbiAgdmFsdWU6IHZhbHVlLFxuICBlbmQ6IGlcbiB9O1xufTtcblxuLyoqKi8gfSksXG4vKiAxNjggKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuU3RhdFRpbWVyID0gZXhwb3J0cy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb24gPSBleHBvcnRzLlBpeGVsc1BlckluY2ggPSBleHBvcnRzLlBhZ2VWaWV3cG9ydCA9IGV4cG9ydHMuUERGRGF0ZVN0cmluZyA9IGV4cG9ydHMuRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBleHBvcnRzLkRPTVNWR0ZhY3RvcnkgPSBleHBvcnRzLkRPTUZpbHRlckZhY3RvcnkgPSBleHBvcnRzLkRPTUNhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkRPTUNNYXBSZWFkZXJGYWN0b3J5ID0gdm9pZCAwO1xuZXhwb3J0cy5kZXByZWNhdGVkID0gZGVwcmVjYXRlZDtcbmV4cG9ydHMuZ2V0Q29sb3JWYWx1ZXMgPSBnZXRDb2xvclZhbHVlcztcbmV4cG9ydHMuZ2V0Q3VycmVudFRyYW5zZm9ybSA9IGdldEN1cnJlbnRUcmFuc2Zvcm07XG5leHBvcnRzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlID0gZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2U7XG5leHBvcnRzLmdldEZpbGVuYW1lRnJvbVVybCA9IGdldEZpbGVuYW1lRnJvbVVybDtcbmV4cG9ydHMuZ2V0UGRmRmlsZW5hbWVGcm9tVXJsID0gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsO1xuZXhwb3J0cy5nZXRSR0IgPSBnZXRSR0I7XG5leHBvcnRzLmdldFhmYVBhZ2VWaWV3cG9ydCA9IGdldFhmYVBhZ2VWaWV3cG9ydDtcbmV4cG9ydHMuaXNEYXRhU2NoZW1lID0gaXNEYXRhU2NoZW1lO1xuZXhwb3J0cy5pc1BkZkZpbGUgPSBpc1BkZkZpbGU7XG5leHBvcnRzLmlzVmFsaWRGZXRjaFVybCA9IGlzVmFsaWRGZXRjaFVybDtcbmV4cG9ydHMubG9hZFNjcmlwdCA9IGxvYWRTY3JpcHQ7XG5leHBvcnRzLm5vQ29udGV4dE1lbnUgPSBub0NvbnRleHRNZW51O1xuZXhwb3J0cy5zZXRMYXllckRpbWVuc2lvbnMgPSBzZXRMYXllckRpbWVuc2lvbnM7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg5Myk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwOSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExNik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDg5KTtcbl9fd19wZGZqc19yZXF1aXJlX18oODQpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4Nik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDg3KTtcbnZhciBfYmFzZV9mYWN0b3J5ID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjkpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmNvbnN0IFNWR19OUyA9IFwiaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmdcIjtcbmNsYXNzIFBpeGVsc1BlckluY2gge1xuICBzdGF0aWMgQ1NTID0gOTYuMDtcbiAgc3RhdGljIFBERiA9IDcyLjA7XG4gIHN0YXRpYyBQREZfVE9fQ1NTX1VOSVRTID0gdGhpcy5DU1MgLyB0aGlzLlBERjtcbn1cbmV4cG9ydHMuUGl4ZWxzUGVySW5jaCA9IFBpeGVsc1BlckluY2g7XG5jbGFzcyBET01GaWx0ZXJGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlRmlsdGVyRmFjdG9yeSB7XG4gICNfY2FjaGU7XG4gICNfZGVmcztcbiAgI2RvY0lkO1xuICAjZG9jdW1lbnQ7XG4gICNoY21GaWx0ZXI7XG4gICNoY21LZXk7XG4gICNoY21Vcmw7XG4gICNoY21IaWdobGlnaHRGaWx0ZXI7XG4gICNoY21IaWdobGlnaHRLZXk7XG4gICNoY21IaWdobGlnaHRVcmw7XG4gICNpZCA9IDA7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB7XG4gICAgICBkb2NJZCxcbiAgICAgIG93bmVyRG9jdW1lbnQgPSBnbG9iYWxUaGlzLmRvY3VtZW50XG4gICAgfSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLiNkb2NJZCA9IGRvY0lkO1xuICAgIHRoaXMuI2RvY3VtZW50ID0gb3duZXJEb2N1bWVudDtcbiAgfVxuICBnZXQgI2NhY2hlKCkge1xuICAgIHJldHVybiB0aGlzLiNfY2FjaGUgfHw9IG5ldyBNYXAoKTtcbiAgfVxuICBnZXQgI2RlZnMoKSB7XG4gICAgaWYgKCF0aGlzLiNfZGVmcykge1xuICAgICAgY29uc3QgZGl2ID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBkaXY7XG4gICAgICBzdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICAgIHN0eWxlLmNvbnRhaW4gPSBcInN0cmljdFwiO1xuICAgICAgc3R5bGUud2lkdGggPSBzdHlsZS5oZWlnaHQgPSAwO1xuICAgICAgc3R5bGUucG9zaXRpb24gPSBcImFic29sdXRlXCI7XG4gICAgICBzdHlsZS50b3AgPSBzdHlsZS5sZWZ0ID0gMDtcbiAgICAgIHN0eWxlLnpJbmRleCA9IC0xO1xuICAgICAgY29uc3Qgc3ZnID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJzdmdcIik7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwid2lkdGhcIiwgMCk7XG4gICAgICBzdmcuc2V0QXR0cmlidXRlKFwiaGVpZ2h0XCIsIDApO1xuICAgICAgdGhpcy4jX2RlZnMgPSB0aGlzLiNkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCBcImRlZnNcIik7XG4gICAgICBkaXYuYXBwZW5kKHN2Zyk7XG4gICAgICBzdmcuYXBwZW5kKHRoaXMuI19kZWZzKTtcbiAgICAgIHRoaXMuI2RvY3VtZW50LmJvZHkuYXBwZW5kKGRpdik7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNfZGVmcztcbiAgfVxuICBhZGRGaWx0ZXIobWFwcykge1xuICAgIGlmICghbWFwcykge1xuICAgICAgcmV0dXJuIFwibm9uZVwiO1xuICAgIH1cbiAgICBsZXQgdmFsdWUgPSB0aGlzLiNjYWNoZS5nZXQobWFwcyk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICAgIGxldCB0YWJsZVIsIHRhYmxlRywgdGFibGVCLCBrZXk7XG4gICAgaWYgKG1hcHMubGVuZ3RoID09PSAxKSB7XG4gICAgICBjb25zdCBtYXBSID0gbWFwc1swXTtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBidWZmZXJbaV0gPSBtYXBSW2ldIC8gMjU1O1xuICAgICAgfVxuICAgICAga2V5ID0gdGFibGVSID0gdGFibGVHID0gdGFibGVCID0gYnVmZmVyLmpvaW4oXCIsXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBbbWFwUiwgbWFwRywgbWFwQl0gPSBtYXBzO1xuICAgICAgY29uc3QgYnVmZmVyUiA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3QgYnVmZmVyRyA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgY29uc3QgYnVmZmVyQiA9IG5ldyBBcnJheSgyNTYpO1xuICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBidWZmZXJSW2ldID0gbWFwUltpXSAvIDI1NTtcbiAgICAgICAgYnVmZmVyR1tpXSA9IG1hcEdbaV0gLyAyNTU7XG4gICAgICAgIGJ1ZmZlckJbaV0gPSBtYXBCW2ldIC8gMjU1O1xuICAgICAgfVxuICAgICAgdGFibGVSID0gYnVmZmVyUi5qb2luKFwiLFwiKTtcbiAgICAgIHRhYmxlRyA9IGJ1ZmZlckcuam9pbihcIixcIik7XG4gICAgICB0YWJsZUIgPSBidWZmZXJCLmpvaW4oXCIsXCIpO1xuICAgICAga2V5ID0gYCR7dGFibGVSfSR7dGFibGVHfSR7dGFibGVCfWA7XG4gICAgfVxuICAgIHZhbHVlID0gdGhpcy4jY2FjaGUuZ2V0KGtleSk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICB0aGlzLiNjYWNoZS5zZXQobWFwcywgdmFsdWUpO1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBpZCA9IGBnXyR7dGhpcy4jZG9jSWR9X3RyYW5zZmVyX21hcF8ke3RoaXMuI2lkKyt9YDtcbiAgICBjb25zdCB1cmwgPSBgdXJsKCMke2lkfSlgO1xuICAgIHRoaXMuI2NhY2hlLnNldChtYXBzLCB1cmwpO1xuICAgIHRoaXMuI2NhY2hlLnNldChrZXksIHVybCk7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jY3JlYXRlRmlsdGVyKGlkKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24odGFibGVSLCB0YWJsZUcsIHRhYmxlQiwgZmlsdGVyKTtcbiAgICByZXR1cm4gdXJsO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgY29uc3Qga2V5ID0gYCR7ZmdDb2xvcn0tJHtiZ0NvbG9yfWA7XG4gICAgaWYgKHRoaXMuI2hjbUtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtVXJsO1xuICAgIH1cbiAgICB0aGlzLiNoY21LZXkgPSBrZXk7XG4gICAgdGhpcy4jaGNtVXJsID0gXCJub25lXCI7XG4gICAgdGhpcy4jaGNtRmlsdGVyPy5yZW1vdmUoKTtcbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoY21Vcmw7XG4gICAgfVxuICAgIGNvbnN0IGZnUkdCID0gdGhpcy4jZ2V0UkdCKGZnQ29sb3IpO1xuICAgIGZnQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi5mZ1JHQik7XG4gICAgY29uc3QgYmdSR0IgPSB0aGlzLiNnZXRSR0IoYmdDb2xvcik7XG4gICAgYmdDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmJnUkdCKTtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gXCJcIjtcbiAgICBpZiAoZmdDb2xvciA9PT0gXCIjMDAwMDAwXCIgJiYgYmdDb2xvciA9PT0gXCIjZmZmZmZmXCIgfHwgZmdDb2xvciA9PT0gYmdDb2xvcikge1xuICAgICAgcmV0dXJuIHRoaXMuI2hjbVVybDtcbiAgICB9XG4gICAgY29uc3QgbWFwID0gbmV3IEFycmF5KDI1Nik7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPD0gMjU1OyBpKyspIHtcbiAgICAgIGNvbnN0IHggPSBpIC8gMjU1O1xuICAgICAgbWFwW2ldID0geCA8PSAwLjAzOTI4ID8geCAvIDEyLjkyIDogKCh4ICsgMC4wNTUpIC8gMS4wNTUpICoqIDIuNDtcbiAgICB9XG4gICAgY29uc3QgdGFibGUgPSBtYXAuam9pbihcIixcIik7XG4gICAgY29uc3QgaWQgPSBgZ18ke3RoaXMuI2RvY0lkfV9oY21fZmlsdGVyYDtcbiAgICBjb25zdCBmaWx0ZXIgPSB0aGlzLiNoY21IaWdobGlnaHRGaWx0ZXIgPSB0aGlzLiNjcmVhdGVGaWx0ZXIoaWQpO1xuICAgIHRoaXMuI2FkZFRyYW5zZmVyTWFwQ29udmVyc2lvbih0YWJsZSwgdGFibGUsIHRhYmxlLCBmaWx0ZXIpO1xuICAgIHRoaXMuI2FkZEdyYXlDb252ZXJzaW9uKGZpbHRlcik7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoYywgbikgPT4ge1xuICAgICAgY29uc3Qgc3RhcnQgPSBmZ1JHQltjXSAvIDI1NTtcbiAgICAgIGNvbnN0IGVuZCA9IGJnUkdCW2NdIC8gMjU1O1xuICAgICAgY29uc3QgYXJyID0gbmV3IEFycmF5KG4gKyAxKTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBzdGFydCArIGkgLyBuICogKGVuZCAtIHN0YXJ0KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBhcnIuam9pbihcIixcIik7XG4gICAgfTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMoMCwgNSksIGdldFN0ZXBzKDEsIDUpLCBnZXRTdGVwcygyLCA1KSwgZmlsdGVyKTtcbiAgICB0aGlzLiNoY21VcmwgPSBgdXJsKCMke2lkfSlgO1xuICAgIHJldHVybiB0aGlzLiNoY21Vcmw7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0SENNRmlsdGVyKGZnQ29sb3IsIGJnQ29sb3IsIG5ld0ZnQ29sb3IsIG5ld0JnQ29sb3IpIHtcbiAgICBjb25zdCBrZXkgPSBgJHtmZ0NvbG9yfS0ke2JnQ29sb3J9LSR7bmV3RmdDb2xvcn0tJHtuZXdCZ0NvbG9yfWA7XG4gICAgaWYgKHRoaXMuI2hjbUhpZ2hsaWdodEtleSA9PT0ga2V5KSB7XG4gICAgICByZXR1cm4gdGhpcy4jaGNtSGlnaGxpZ2h0VXJsO1xuICAgIH1cbiAgICB0aGlzLiNoY21IaWdobGlnaHRLZXkgPSBrZXk7XG4gICAgdGhpcy4jaGNtSGlnaGxpZ2h0VXJsID0gXCJub25lXCI7XG4gICAgdGhpcy4jaGNtSGlnaGxpZ2h0RmlsdGVyPy5yZW1vdmUoKTtcbiAgICBpZiAoIWZnQ29sb3IgfHwgIWJnQ29sb3IpIHtcbiAgICAgIHJldHVybiB0aGlzLiNoY21IaWdobGlnaHRVcmw7XG4gICAgfVxuICAgIGNvbnN0IFtmZ1JHQiwgYmdSR0JdID0gW2ZnQ29sb3IsIGJnQ29sb3JdLm1hcCh0aGlzLiNnZXRSR0IuYmluZCh0aGlzKSk7XG4gICAgbGV0IGZnR3JheSA9IE1hdGgucm91bmQoMC4yMTI2ICogZmdSR0JbMF0gKyAwLjcxNTIgKiBmZ1JHQlsxXSArIDAuMDcyMiAqIGZnUkdCWzJdKTtcbiAgICBsZXQgYmdHcmF5ID0gTWF0aC5yb3VuZCgwLjIxMjYgKiBiZ1JHQlswXSArIDAuNzE1MiAqIGJnUkdCWzFdICsgMC4wNzIyICogYmdSR0JbMl0pO1xuICAgIGxldCBbbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yXS5tYXAodGhpcy4jZ2V0UkdCLmJpbmQodGhpcykpO1xuICAgIGlmIChiZ0dyYXkgPCBmZ0dyYXkpIHtcbiAgICAgIFtmZ0dyYXksIGJnR3JheSwgbmV3RmdSR0IsIG5ld0JnUkdCXSA9IFtiZ0dyYXksIGZnR3JheSwgbmV3QmdSR0IsIG5ld0ZnUkdCXTtcbiAgICB9XG4gICAgdGhpcy4jZGVmcy5zdHlsZS5jb2xvciA9IFwiXCI7XG4gICAgY29uc3QgZ2V0U3RlcHMgPSAoZmcsIGJnLCBuKSA9PiB7XG4gICAgICBjb25zdCBhcnIgPSBuZXcgQXJyYXkoMjU2KTtcbiAgICAgIGNvbnN0IHN0ZXAgPSAoYmdHcmF5IC0gZmdHcmF5KSAvIG47XG4gICAgICBjb25zdCBuZXdTdGFydCA9IGZnIC8gMjU1O1xuICAgICAgY29uc3QgbmV3U3RlcCA9IChiZyAtIGZnKSAvICgyNTUgKiBuKTtcbiAgICAgIGxldCBwcmV2ID0gMDtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDw9IG47IGkrKykge1xuICAgICAgICBjb25zdCBrID0gTWF0aC5yb3VuZChmZ0dyYXkgKyBpICogc3RlcCk7XG4gICAgICAgIGNvbnN0IHZhbHVlID0gbmV3U3RhcnQgKyBpICogbmV3U3RlcDtcbiAgICAgICAgZm9yIChsZXQgaiA9IHByZXY7IGogPD0gazsgaisrKSB7XG4gICAgICAgICAgYXJyW2pdID0gdmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgcHJldiA9IGsgKyAxO1xuICAgICAgfVxuICAgICAgZm9yIChsZXQgaSA9IHByZXY7IGkgPCAyNTY7IGkrKykge1xuICAgICAgICBhcnJbaV0gPSBhcnJbcHJldiAtIDFdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGFyci5qb2luKFwiLFwiKTtcbiAgICB9O1xuICAgIGNvbnN0IGlkID0gYGdfJHt0aGlzLiNkb2NJZH1faGNtX2hpZ2hsaWdodF9maWx0ZXJgO1xuICAgIGNvbnN0IGZpbHRlciA9IHRoaXMuI2hjbUhpZ2hsaWdodEZpbHRlciA9IHRoaXMuI2NyZWF0ZUZpbHRlcihpZCk7XG4gICAgdGhpcy4jYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKTtcbiAgICB0aGlzLiNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oZ2V0U3RlcHMobmV3RmdSR0JbMF0sIG5ld0JnUkdCWzBdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMV0sIG5ld0JnUkdCWzFdLCA1KSwgZ2V0U3RlcHMobmV3RmdSR0JbMl0sIG5ld0JnUkdCWzJdLCA1KSwgZmlsdGVyKTtcbiAgICB0aGlzLiNoY21IaWdobGlnaHRVcmwgPSBgdXJsKCMke2lkfSlgO1xuICAgIHJldHVybiB0aGlzLiNoY21IaWdobGlnaHRVcmw7XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICBsZXQga2VlcEhDTSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgaWYgKGtlZXBIQ00gJiYgKHRoaXMuI2hjbVVybCB8fCB0aGlzLiNoY21IaWdobGlnaHRVcmwpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNfZGVmcykge1xuICAgICAgdGhpcy4jX2RlZnMucGFyZW50Tm9kZS5wYXJlbnROb2RlLnJlbW92ZSgpO1xuICAgICAgdGhpcy4jX2RlZnMgPSBudWxsO1xuICAgIH1cbiAgICBpZiAodGhpcy4jX2NhY2hlKSB7XG4gICAgICB0aGlzLiNfY2FjaGUuY2xlYXIoKTtcbiAgICAgIHRoaXMuI19jYWNoZSA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuI2lkID0gMDtcbiAgfVxuICAjYWRkR3JheUNvbnZlcnNpb24oZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb2xvck1hdHJpeCA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb2xvck1hdHJpeFwiKTtcbiAgICBmZUNvbG9yTWF0cml4LnNldEF0dHJpYnV0ZShcInR5cGVcIiwgXCJtYXRyaXhcIik7XG4gICAgZmVDb2xvck1hdHJpeC5zZXRBdHRyaWJ1dGUoXCJ2YWx1ZXNcIiwgXCIwLjIxMjYgMC43MTUyIDAuMDcyMiAwIDAgMC4yMTI2IDAuNzE1MiAwLjA3MjIgMCAwIDAuMjEyNiAwLjcxNTIgMC4wNzIyIDAgMCAwIDAgMCAxIDBcIik7XG4gICAgZmlsdGVyLmFwcGVuZChmZUNvbG9yTWF0cml4KTtcbiAgfVxuICAjY3JlYXRlRmlsdGVyKGlkKSB7XG4gICAgY29uc3QgZmlsdGVyID0gdGhpcy4jZG9jdW1lbnQuY3JlYXRlRWxlbWVudE5TKFNWR19OUywgXCJmaWx0ZXJcIik7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZShcImNvbG9yLWludGVycG9sYXRpb24tZmlsdGVyc1wiLCBcInNSR0JcIik7XG4gICAgZmlsdGVyLnNldEF0dHJpYnV0ZShcImlkXCIsIGlkKTtcbiAgICB0aGlzLiNkZWZzLmFwcGVuZChmaWx0ZXIpO1xuICAgIHJldHVybiBmaWx0ZXI7XG4gIH1cbiAgI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBmdW5jLCB0YWJsZSkge1xuICAgIGNvbnN0IGZlRnVuYyA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIGZ1bmMpO1xuICAgIGZlRnVuYy5zZXRBdHRyaWJ1dGUoXCJ0eXBlXCIsIFwiZGlzY3JldGVcIik7XG4gICAgZmVGdW5jLnNldEF0dHJpYnV0ZShcInRhYmxlVmFsdWVzXCIsIHRhYmxlKTtcbiAgICBmZUNvbXBvbmVudFRyYW5zZmVyLmFwcGVuZChmZUZ1bmMpO1xuICB9XG4gICNhZGRUcmFuc2Zlck1hcENvbnZlcnNpb24oclRhYmxlLCBnVGFibGUsIGJUYWJsZSwgZmlsdGVyKSB7XG4gICAgY29uc3QgZmVDb21wb25lbnRUcmFuc2ZlciA9IHRoaXMuI2RvY3VtZW50LmNyZWF0ZUVsZW1lbnROUyhTVkdfTlMsIFwiZmVDb21wb25lbnRUcmFuc2ZlclwiKTtcbiAgICBmaWx0ZXIuYXBwZW5kKGZlQ29tcG9uZW50VHJhbnNmZXIpO1xuICAgIHRoaXMuI2FwcGVuZEZlRnVuYyhmZUNvbXBvbmVudFRyYW5zZmVyLCBcImZlRnVuY1JcIiwgclRhYmxlKTtcbiAgICB0aGlzLiNhcHBlbmRGZUZ1bmMoZmVDb21wb25lbnRUcmFuc2ZlciwgXCJmZUZ1bmNHXCIsIGdUYWJsZSk7XG4gICAgdGhpcy4jYXBwZW5kRmVGdW5jKGZlQ29tcG9uZW50VHJhbnNmZXIsIFwiZmVGdW5jQlwiLCBiVGFibGUpO1xuICB9XG4gICNnZXRSR0IoY29sb3IpIHtcbiAgICB0aGlzLiNkZWZzLnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgcmV0dXJuIGdldFJHQihnZXRDb21wdXRlZFN0eWxlKHRoaXMuI2RlZnMpLmdldFByb3BlcnR5VmFsdWUoXCJjb2xvclwiKSk7XG4gIH1cbn1cbmV4cG9ydHMuRE9NRmlsdGVyRmFjdG9yeSA9IERPTUZpbHRlckZhY3Rvcnk7XG5jbGFzcyBET01DYW52YXNGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGxldCB7XG4gICAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudFxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fZG9jdW1lbnQgPSBvd25lckRvY3VtZW50O1xuICB9XG4gIF9jcmVhdGVDYW52YXMod2lkdGgsIGhlaWdodCkge1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gd2lkdGg7XG4gICAgY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgICByZXR1cm4gY2FudmFzO1xuICB9XG59XG5leHBvcnRzLkRPTUNhbnZhc0ZhY3RvcnkgPSBET01DYW52YXNGYWN0b3J5O1xuYXN5bmMgZnVuY3Rpb24gZmV0Y2hEYXRhKHVybCkge1xuICBsZXQgYXNUeXBlZEFycmF5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgaWYgKGlzVmFsaWRGZXRjaFVybCh1cmwsIGRvY3VtZW50LmJhc2VVUkkpKSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihyZXNwb25zZS5zdGF0dXNUZXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGFzVHlwZWRBcnJheSA/IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpIDogKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKGF3YWl0IHJlc3BvbnNlLnRleHQoKSk7XG4gIH1cbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgcmVxdWVzdC5vcGVuKFwiR0VUXCIsIHVybCwgdHJ1ZSk7XG4gICAgaWYgKGFzVHlwZWRBcnJheSkge1xuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBcImFycmF5YnVmZmVyXCI7XG4gICAgfVxuICAgIHJlcXVlc3Qub25yZWFkeXN0YXRlY2hhbmdlID0gKCkgPT4ge1xuICAgICAgaWYgKHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gWE1MSHR0cFJlcXVlc3QuRE9ORSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAocmVxdWVzdC5zdGF0dXMgPT09IDIwMCB8fCByZXF1ZXN0LnN0YXR1cyA9PT0gMCkge1xuICAgICAgICBsZXQgZGF0YTtcbiAgICAgICAgaWYgKGFzVHlwZWRBcnJheSAmJiByZXF1ZXN0LnJlc3BvbnNlKSB7XG4gICAgICAgICAgZGF0YSA9IG5ldyBVaW50OEFycmF5KHJlcXVlc3QucmVzcG9uc2UpO1xuICAgICAgICB9IGVsc2UgaWYgKCFhc1R5cGVkQXJyYXkgJiYgcmVxdWVzdC5yZXNwb25zZVRleHQpIHtcbiAgICAgICAgICBkYXRhID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHJlcXVlc3QucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZGF0YSkge1xuICAgICAgICAgIHJlc29sdmUoZGF0YSk7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZWplY3QobmV3IEVycm9yKHJlcXVlc3Quc3RhdHVzVGV4dCkpO1xuICAgIH07XG4gICAgcmVxdWVzdC5zZW5kKG51bGwpO1xuICB9KTtcbn1cbmNsYXNzIERPTUNNYXBSZWFkZXJGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlQ01hcFJlYWRlckZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgcmV0dXJuIGZldGNoRGF0YSh1cmwsIHRoaXMuaXNDb21wcmVzc2VkKS50aGVuKGRhdGEgPT4ge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgY01hcERhdGE6IGRhdGEsXG4gICAgICAgIGNvbXByZXNzaW9uVHlwZVxuICAgICAgfTtcbiAgICB9KTtcbiAgfVxufVxuZXhwb3J0cy5ET01DTWFwUmVhZGVyRmFjdG9yeSA9IERPTUNNYXBSZWFkZXJGYWN0b3J5O1xuY2xhc3MgRE9NU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSB7XG4gIF9mZXRjaERhdGEodXJsKSB7XG4gICAgcmV0dXJuIGZldGNoRGF0YSh1cmwsIHRydWUpO1xuICB9XG59XG5leHBvcnRzLkRPTVN0YW5kYXJkRm9udERhdGFGYWN0b3J5ID0gRE9NU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5jbGFzcyBET01TVkdGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlU1ZHRmFjdG9yeSB7XG4gIF9jcmVhdGVTVkcodHlwZSkge1xuICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoU1ZHX05TLCB0eXBlKTtcbiAgfVxufVxuZXhwb3J0cy5ET01TVkdGYWN0b3J5ID0gRE9NU1ZHRmFjdG9yeTtcbmNsYXNzIFBhZ2VWaWV3cG9ydCB7XG4gIGNvbnN0cnVjdG9yKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgdmlld0JveCxcbiAgICAgIHNjYWxlLFxuICAgICAgcm90YXRpb24sXG4gICAgICBvZmZzZXRYID0gMCxcbiAgICAgIG9mZnNldFkgPSAwLFxuICAgICAgZG9udEZsaXAgPSBmYWxzZVxuICAgIH0gPSBfcmVmO1xuICAgIHRoaXMudmlld0JveCA9IHZpZXdCb3g7XG4gICAgdGhpcy5zY2FsZSA9IHNjYWxlO1xuICAgIHRoaXMucm90YXRpb24gPSByb3RhdGlvbjtcbiAgICB0aGlzLm9mZnNldFggPSBvZmZzZXRYO1xuICAgIHRoaXMub2Zmc2V0WSA9IG9mZnNldFk7XG4gICAgY29uc3QgY2VudGVyWCA9ICh2aWV3Qm94WzJdICsgdmlld0JveFswXSkgLyAyO1xuICAgIGNvbnN0IGNlbnRlclkgPSAodmlld0JveFszXSArIHZpZXdCb3hbMV0pIC8gMjtcbiAgICBsZXQgcm90YXRlQSwgcm90YXRlQiwgcm90YXRlQywgcm90YXRlRDtcbiAgICByb3RhdGlvbiAlPSAzNjA7XG4gICAgaWYgKHJvdGF0aW9uIDwgMCkge1xuICAgICAgcm90YXRpb24gKz0gMzYwO1xuICAgIH1cbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDE4MDpcbiAgICAgICAgcm90YXRlQSA9IC0xO1xuICAgICAgICByb3RhdGVCID0gMDtcbiAgICAgICAgcm90YXRlQyA9IDA7XG4gICAgICAgIHJvdGF0ZUQgPSAxO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJvdGF0ZUEgPSAwO1xuICAgICAgICByb3RhdGVCID0gMTtcbiAgICAgICAgcm90YXRlQyA9IDE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICByb3RhdGVBID0gMDtcbiAgICAgICAgcm90YXRlQiA9IC0xO1xuICAgICAgICByb3RhdGVDID0gLTE7XG4gICAgICAgIHJvdGF0ZUQgPSAwO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMDpcbiAgICAgICAgcm90YXRlQSA9IDE7XG4gICAgICAgIHJvdGF0ZUIgPSAwO1xuICAgICAgICByb3RhdGVDID0gMDtcbiAgICAgICAgcm90YXRlRCA9IC0xO1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIlBhZ2VWaWV3cG9ydDogSW52YWxpZCByb3RhdGlvbiwgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDkwIGRlZ3JlZXMuXCIpO1xuICAgIH1cbiAgICBpZiAoZG9udEZsaXApIHtcbiAgICAgIHJvdGF0ZUMgPSAtcm90YXRlQztcbiAgICAgIHJvdGF0ZUQgPSAtcm90YXRlRDtcbiAgICB9XG4gICAgbGV0IG9mZnNldENhbnZhc1gsIG9mZnNldENhbnZhc1k7XG4gICAgbGV0IHdpZHRoLCBoZWlnaHQ7XG4gICAgaWYgKHJvdGF0ZUEgPT09IDApIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJZIC0gdmlld0JveFsxXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWCAtIHZpZXdCb3hbMF0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9mZnNldENhbnZhc1ggPSBNYXRoLmFicyhjZW50ZXJYIC0gdmlld0JveFswXSkgKiBzY2FsZSArIG9mZnNldFg7XG4gICAgICBvZmZzZXRDYW52YXNZID0gTWF0aC5hYnMoY2VudGVyWSAtIHZpZXdCb3hbMV0pICogc2NhbGUgKyBvZmZzZXRZO1xuICAgICAgd2lkdGggPSAodmlld0JveFsyXSAtIHZpZXdCb3hbMF0pICogc2NhbGU7XG4gICAgICBoZWlnaHQgPSAodmlld0JveFszXSAtIHZpZXdCb3hbMV0pICogc2NhbGU7XG4gICAgfVxuICAgIHRoaXMudHJhbnNmb3JtID0gW3JvdGF0ZUEgKiBzY2FsZSwgcm90YXRlQiAqIHNjYWxlLCByb3RhdGVDICogc2NhbGUsIHJvdGF0ZUQgKiBzY2FsZSwgb2Zmc2V0Q2FudmFzWCAtIHJvdGF0ZUEgKiBzY2FsZSAqIGNlbnRlclggLSByb3RhdGVDICogc2NhbGUgKiBjZW50ZXJZLCBvZmZzZXRDYW52YXNZIC0gcm90YXRlQiAqIHNjYWxlICogY2VudGVyWCAtIHJvdGF0ZUQgKiBzY2FsZSAqIGNlbnRlclldO1xuICAgIHRoaXMud2lkdGggPSB3aWR0aDtcbiAgICB0aGlzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBnZXQgcmF3RGltcygpIHtcbiAgICBjb25zdCB7XG4gICAgICB2aWV3Qm94XG4gICAgfSA9IHRoaXM7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwicmF3RGltc1wiLCB7XG4gICAgICBwYWdlV2lkdGg6IHZpZXdCb3hbMl0gLSB2aWV3Qm94WzBdLFxuICAgICAgcGFnZUhlaWdodDogdmlld0JveFszXSAtIHZpZXdCb3hbMV0sXG4gICAgICBwYWdlWDogdmlld0JveFswXSxcbiAgICAgIHBhZ2VZOiB2aWV3Qm94WzFdXG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgbGV0IHtcbiAgICAgIHNjYWxlID0gdGhpcy5zY2FsZSxcbiAgICAgIHJvdGF0aW9uID0gdGhpcy5yb3RhdGlvbixcbiAgICAgIG9mZnNldFggPSB0aGlzLm9mZnNldFgsXG4gICAgICBvZmZzZXRZID0gdGhpcy5vZmZzZXRZLFxuICAgICAgZG9udEZsaXAgPSBmYWxzZVxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgIHJldHVybiBuZXcgUGFnZVZpZXdwb3J0KHtcbiAgICAgIHZpZXdCb3g6IHRoaXMudmlld0JveC5zbGljZSgpLFxuICAgICAgc2NhbGUsXG4gICAgICByb3RhdGlvbixcbiAgICAgIG9mZnNldFgsXG4gICAgICBvZmZzZXRZLFxuICAgICAgZG9udEZsaXBcbiAgICB9KTtcbiAgfVxuICBjb252ZXJ0VG9WaWV3cG9ydFBvaW50KHgsIHkpIHtcbiAgICByZXR1cm4gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRoaXMudHJhbnNmb3JtKTtcbiAgfVxuICBjb252ZXJ0VG9WaWV3cG9ydFJlY3RhbmdsZShyZWN0KSB7XG4gICAgY29uc3QgdG9wTGVmdCA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oW3JlY3RbMF0sIHJlY3RbMV1dLCB0aGlzLnRyYW5zZm9ybSk7XG4gICAgY29uc3QgYm90dG9tUmlnaHQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtyZWN0WzJdLCByZWN0WzNdXSwgdGhpcy50cmFuc2Zvcm0pO1xuICAgIHJldHVybiBbdG9wTGVmdFswXSwgdG9wTGVmdFsxXSwgYm90dG9tUmlnaHRbMF0sIGJvdHRvbVJpZ2h0WzFdXTtcbiAgfVxuICBjb252ZXJ0VG9QZGZQb2ludCh4LCB5KSB7XG4gICAgcmV0dXJuIF91dGlsLlV0aWwuYXBwbHlJbnZlcnNlVHJhbnNmb3JtKFt4LCB5XSwgdGhpcy50cmFuc2Zvcm0pO1xuICB9XG59XG5leHBvcnRzLlBhZ2VWaWV3cG9ydCA9IFBhZ2VWaWV3cG9ydDtcbmNsYXNzIFJlbmRlcmluZ0NhbmNlbGxlZEV4Y2VwdGlvbiBleHRlbmRzIF91dGlsLkJhc2VFeGNlcHRpb24ge1xuICBjb25zdHJ1Y3Rvcihtc2cpIHtcbiAgICBsZXQgZXh0cmFEZWxheSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogMDtcbiAgICBzdXBlcihtc2csIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIpO1xuICAgIHRoaXMuZXh0cmFEZWxheSA9IGV4dHJhRGVsYXk7XG4gIH1cbn1cbmV4cG9ydHMuUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uID0gUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uO1xuZnVuY3Rpb24gaXNEYXRhU2NoZW1lKHVybCkge1xuICBjb25zdCBpaSA9IHVybC5sZW5ndGg7XG4gIGxldCBpID0gMDtcbiAgd2hpbGUgKGkgPCBpaSAmJiB1cmxbaV0udHJpbSgpID09PSBcIlwiKSB7XG4gICAgaSsrO1xuICB9XG4gIHJldHVybiB1cmwuc3Vic3RyaW5nKGksIGkgKyA1KS50b0xvd2VyQ2FzZSgpID09PSBcImRhdGE6XCI7XG59XG5mdW5jdGlvbiBpc1BkZkZpbGUoZmlsZW5hbWUpIHtcbiAgcmV0dXJuIHR5cGVvZiBmaWxlbmFtZSA9PT0gXCJzdHJpbmdcIiAmJiAvXFwucGRmJC9pLnRlc3QoZmlsZW5hbWUpO1xufVxuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tVXJsKHVybCkge1xuICBsZXQgb25seVN0cmlwUGF0aCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG4gIGlmICghb25seVN0cmlwUGF0aCkge1xuICAgIFt1cmxdID0gdXJsLnNwbGl0KC9bIz9dLywgMSk7XG4gIH1cbiAgcmV0dXJuIHVybC5zdWJzdHJpbmcodXJsLmxhc3RJbmRleE9mKFwiL1wiKSArIDEpO1xufVxuZnVuY3Rpb24gZ2V0UGRmRmlsZW5hbWVGcm9tVXJsKHVybCkge1xuICBsZXQgZGVmYXVsdEZpbGVuYW1lID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBcImRvY3VtZW50LnBkZlwiO1xuICBpZiAodHlwZW9mIHVybCAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgaWYgKGlzRGF0YVNjaGVtZSh1cmwpKSB7XG4gICAgKDAsIF91dGlsLndhcm4pKCdnZXRQZGZGaWxlbmFtZUZyb21Vcmw6IGlnbm9yZSBcImRhdGE6XCItVVJMIGZvciBwZXJmb3JtYW5jZSByZWFzb25zLicpO1xuICAgIHJldHVybiBkZWZhdWx0RmlsZW5hbWU7XG4gIH1cbiAgY29uc3QgcmVVUkkgPSAvXig/Oig/OlteOl0rOik/XFwvXFwvW14vXSspPyhbXj8jXSopKFxcP1teI10qKT8oIy4qKT8kLztcbiAgY29uc3QgcmVGaWxlbmFtZSA9IC9bXi8/Iz1dK1xcLnBkZlxcYig/IS4qXFwucGRmXFxiKS9pO1xuICBjb25zdCBzcGxpdFVSSSA9IHJlVVJJLmV4ZWModXJsKTtcbiAgbGV0IHN1Z2dlc3RlZEZpbGVuYW1lID0gcmVGaWxlbmFtZS5leGVjKHNwbGl0VVJJWzFdKSB8fCByZUZpbGVuYW1lLmV4ZWMoc3BsaXRVUklbMl0pIHx8IHJlRmlsZW5hbWUuZXhlYyhzcGxpdFVSSVszXSk7XG4gIGlmIChzdWdnZXN0ZWRGaWxlbmFtZSkge1xuICAgIHN1Z2dlc3RlZEZpbGVuYW1lID0gc3VnZ2VzdGVkRmlsZW5hbWVbMF07XG4gICAgaWYgKHN1Z2dlc3RlZEZpbGVuYW1lLmluY2x1ZGVzKFwiJVwiKSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgc3VnZ2VzdGVkRmlsZW5hbWUgPSByZUZpbGVuYW1lLmV4ZWMoZGVjb2RlVVJJQ29tcG9uZW50KHN1Z2dlc3RlZEZpbGVuYW1lKSlbMF07XG4gICAgICB9IGNhdGNoIHt9XG4gICAgfVxuICB9XG4gIHJldHVybiBzdWdnZXN0ZWRGaWxlbmFtZSB8fCBkZWZhdWx0RmlsZW5hbWU7XG59XG5jbGFzcyBTdGF0VGltZXIge1xuICBzdGFydGVkID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdGltZXMgPSBbXTtcbiAgdGltZShuYW1lKSB7XG4gICAgaWYgKG5hbWUgaW4gdGhpcy5zdGFydGVkKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYFRpbWVyIGlzIGFscmVhZHkgcnVubmluZyBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnN0YXJ0ZWRbbmFtZV0gPSBEYXRlLm5vdygpO1xuICB9XG4gIHRpbWVFbmQobmFtZSkge1xuICAgIGlmICghKG5hbWUgaW4gdGhpcy5zdGFydGVkKSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBUaW1lciBoYXMgbm90IGJlZW4gc3RhcnRlZCBmb3IgJHtuYW1lfWApO1xuICAgIH1cbiAgICB0aGlzLnRpbWVzLnB1c2goe1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0OiB0aGlzLnN0YXJ0ZWRbbmFtZV0sXG4gICAgICBlbmQ6IERhdGUubm93KClcbiAgICB9KTtcbiAgICBkZWxldGUgdGhpcy5zdGFydGVkW25hbWVdO1xuICB9XG4gIHRvU3RyaW5nKCkge1xuICAgIGNvbnN0IG91dEJ1ZiA9IFtdO1xuICAgIGxldCBsb25nZXN0ID0gMDtcbiAgICBmb3IgKGNvbnN0IHtcbiAgICAgIG5hbWVcbiAgICB9IG9mIHRoaXMudGltZXMpIHtcbiAgICAgIGxvbmdlc3QgPSBNYXRoLm1heChuYW1lLmxlbmd0aCwgbG9uZ2VzdCk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qge1xuICAgICAgbmFtZSxcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kXG4gICAgfSBvZiB0aGlzLnRpbWVzKSB7XG4gICAgICBvdXRCdWYucHVzaChgJHtuYW1lLnBhZEVuZChsb25nZXN0KX0gJHtlbmQgLSBzdGFydH1tc1xcbmApO1xuICAgIH1cbiAgICByZXR1cm4gb3V0QnVmLmpvaW4oXCJcIik7XG4gIH1cbn1cbmV4cG9ydHMuU3RhdFRpbWVyID0gU3RhdFRpbWVyO1xuZnVuY3Rpb24gaXNWYWxpZEZldGNoVXJsKHVybCwgYmFzZVVybCkge1xuICB0cnkge1xuICAgIGNvbnN0IHtcbiAgICAgIHByb3RvY29sXG4gICAgfSA9IGJhc2VVcmwgPyBuZXcgVVJMKHVybCwgYmFzZVVybCkgOiBuZXcgVVJMKHVybCk7XG4gICAgcmV0dXJuIHByb3RvY29sID09PSBcImh0dHA6XCIgfHwgcHJvdG9jb2wgPT09IFwiaHR0cHM6XCI7XG4gIH0gY2F0Y2gge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuZnVuY3Rpb24gbm9Db250ZXh0TWVudShlKSB7XG4gIGUucHJldmVudERlZmF1bHQoKTtcbn1cbmZ1bmN0aW9uIGxvYWRTY3JpcHQoc3JjKSB7XG4gIGxldCByZW1vdmVTY3JpcHRFbGVtZW50ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICBjb25zdCBzY3JpcHQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpO1xuICAgIHNjcmlwdC5zcmMgPSBzcmM7XG4gICAgc2NyaXB0Lm9ubG9hZCA9IGZ1bmN0aW9uIChldnQpIHtcbiAgICAgIGlmIChyZW1vdmVTY3JpcHRFbGVtZW50KSB7XG4gICAgICAgIHNjcmlwdC5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICAgIHJlc29sdmUoZXZ0KTtcbiAgICB9O1xuICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgcmVqZWN0KG5ldyBFcnJvcihgQ2Fubm90IGxvYWQgc2NyaXB0IGF0OiAke3NjcmlwdC5zcmN9YCkpO1xuICAgIH07XG4gICAgKGRvY3VtZW50LmhlYWQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50KS5hcHBlbmQoc2NyaXB0KTtcbiAgfSk7XG59XG5mdW5jdGlvbiBkZXByZWNhdGVkKGRldGFpbHMpIHtcbiAgY29uc29sZS5sb2coXCJEZXByZWNhdGVkIEFQSSB1c2FnZTogXCIgKyBkZXRhaWxzKTtcbn1cbmxldCBwZGZEYXRlU3RyaW5nUmVnZXg7XG5jbGFzcyBQREZEYXRlU3RyaW5nIHtcbiAgc3RhdGljIHRvRGF0ZU9iamVjdChpbnB1dCkge1xuICAgIGlmICghaW5wdXQgfHwgdHlwZW9mIGlucHV0ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgcGRmRGF0ZVN0cmluZ1JlZ2V4IHx8PSBuZXcgUmVnRXhwKFwiXkQ6XCIgKyBcIihcXFxcZHs0fSlcIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFxcXFxkezJ9KT9cIiArIFwiKFtafCt8LV0pP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiICsgXCIoXFxcXGR7Mn0pP1wiICsgXCInP1wiKTtcbiAgICBjb25zdCBtYXRjaGVzID0gcGRmRGF0ZVN0cmluZ1JlZ2V4LmV4ZWMoaW5wdXQpO1xuICAgIGlmICghbWF0Y2hlcykge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHllYXIgPSBwYXJzZUludChtYXRjaGVzWzFdLCAxMCk7XG4gICAgbGV0IG1vbnRoID0gcGFyc2VJbnQobWF0Y2hlc1syXSwgMTApO1xuICAgIG1vbnRoID0gbW9udGggPj0gMSAmJiBtb250aCA8PSAxMiA/IG1vbnRoIC0gMSA6IDA7XG4gICAgbGV0IGRheSA9IHBhcnNlSW50KG1hdGNoZXNbM10sIDEwKTtcbiAgICBkYXkgPSBkYXkgPj0gMSAmJiBkYXkgPD0gMzEgPyBkYXkgOiAxO1xuICAgIGxldCBob3VyID0gcGFyc2VJbnQobWF0Y2hlc1s0XSwgMTApO1xuICAgIGhvdXIgPSBob3VyID49IDAgJiYgaG91ciA8PSAyMyA/IGhvdXIgOiAwO1xuICAgIGxldCBtaW51dGUgPSBwYXJzZUludChtYXRjaGVzWzVdLCAxMCk7XG4gICAgbWludXRlID0gbWludXRlID49IDAgJiYgbWludXRlIDw9IDU5ID8gbWludXRlIDogMDtcbiAgICBsZXQgc2Vjb25kID0gcGFyc2VJbnQobWF0Y2hlc1s2XSwgMTApO1xuICAgIHNlY29uZCA9IHNlY29uZCA+PSAwICYmIHNlY29uZCA8PSA1OSA/IHNlY29uZCA6IDA7XG4gICAgY29uc3QgdW5pdmVyc2FsVGltZVJlbGF0aW9uID0gbWF0Y2hlc1s3XSB8fCBcIlpcIjtcbiAgICBsZXQgb2Zmc2V0SG91ciA9IHBhcnNlSW50KG1hdGNoZXNbOF0sIDEwKTtcbiAgICBvZmZzZXRIb3VyID0gb2Zmc2V0SG91ciA+PSAwICYmIG9mZnNldEhvdXIgPD0gMjMgPyBvZmZzZXRIb3VyIDogMDtcbiAgICBsZXQgb2Zmc2V0TWludXRlID0gcGFyc2VJbnQobWF0Y2hlc1s5XSwgMTApIHx8IDA7XG4gICAgb2Zmc2V0TWludXRlID0gb2Zmc2V0TWludXRlID49IDAgJiYgb2Zmc2V0TWludXRlIDw9IDU5ID8gb2Zmc2V0TWludXRlIDogMDtcbiAgICBpZiAodW5pdmVyc2FsVGltZVJlbGF0aW9uID09PSBcIi1cIikge1xuICAgICAgaG91ciArPSBvZmZzZXRIb3VyO1xuICAgICAgbWludXRlICs9IG9mZnNldE1pbnV0ZTtcbiAgICB9IGVsc2UgaWYgKHVuaXZlcnNhbFRpbWVSZWxhdGlvbiA9PT0gXCIrXCIpIHtcbiAgICAgIGhvdXIgLT0gb2Zmc2V0SG91cjtcbiAgICAgIG1pbnV0ZSAtPSBvZmZzZXRNaW51dGU7XG4gICAgfVxuICAgIHJldHVybiBuZXcgRGF0ZShEYXRlLlVUQyh5ZWFyLCBtb250aCwgZGF5LCBob3VyLCBtaW51dGUsIHNlY29uZCkpO1xuICB9XG59XG5leHBvcnRzLlBERkRhdGVTdHJpbmcgPSBQREZEYXRlU3RyaW5nO1xuZnVuY3Rpb24gZ2V0WGZhUGFnZVZpZXdwb3J0KHhmYVBhZ2UsIF9yZWYyKSB7XG4gIGxldCB7XG4gICAgc2NhbGUgPSAxLFxuICAgIHJvdGF0aW9uID0gMFxuICB9ID0gX3JlZjI7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IHhmYVBhZ2UuYXR0cmlidXRlcy5zdHlsZTtcbiAgY29uc3Qgdmlld0JveCA9IFswLCAwLCBwYXJzZUludCh3aWR0aCksIHBhcnNlSW50KGhlaWdodCldO1xuICByZXR1cm4gbmV3IFBhZ2VWaWV3cG9ydCh7XG4gICAgdmlld0JveCxcbiAgICBzY2FsZSxcbiAgICByb3RhdGlvblxuICB9KTtcbn1cbmZ1bmN0aW9uIGdldFJHQihjb2xvcikge1xuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcIiNcIikpIHtcbiAgICBjb25zdCBjb2xvclJHQiA9IHBhcnNlSW50KGNvbG9yLnNsaWNlKDEpLCAxNik7XG4gICAgcmV0dXJuIFsoY29sb3JSR0IgJiAweGZmMDAwMCkgPj4gMTYsIChjb2xvclJHQiAmIDB4MDBmZjAwKSA+PiA4LCBjb2xvclJHQiAmIDB4MDAwMGZmXTtcbiAgfVxuICBpZiAoY29sb3Iuc3RhcnRzV2l0aChcInJnYihcIikpIHtcbiAgICByZXR1cm4gY29sb3Iuc2xpY2UoNCwgLTEpLnNwbGl0KFwiLFwiKS5tYXAoeCA9PiBwYXJzZUludCh4KSk7XG4gIH1cbiAgaWYgKGNvbG9yLnN0YXJ0c1dpdGgoXCJyZ2JhKFwiKSkge1xuICAgIHJldHVybiBjb2xvci5zbGljZSg1LCAtMSkuc3BsaXQoXCIsXCIpLm1hcCh4ID0+IHBhcnNlSW50KHgpKS5zbGljZSgwLCAzKTtcbiAgfVxuICAoMCwgX3V0aWwud2FybikoYE5vdCBhIHZhbGlkIGNvbG9yIGZvcm1hdDogXCIke2NvbG9yfVwiYCk7XG4gIHJldHVybiBbMCwgMCwgMF07XG59XG5mdW5jdGlvbiBnZXRDb2xvclZhbHVlcyhjb2xvcnMpIHtcbiAgY29uc3Qgc3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICBzcGFuLnN0eWxlLnZpc2liaWxpdHkgPSBcImhpZGRlblwiO1xuICBkb2N1bWVudC5ib2R5LmFwcGVuZChzcGFuKTtcbiAgZm9yIChjb25zdCBuYW1lIG9mIGNvbG9ycy5rZXlzKCkpIHtcbiAgICBzcGFuLnN0eWxlLmNvbG9yID0gbmFtZTtcbiAgICBjb25zdCBjb21wdXRlZENvbG9yID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoc3BhbikuY29sb3I7XG4gICAgY29sb3JzLnNldChuYW1lLCBnZXRSR0IoY29tcHV0ZWRDb2xvcikpO1xuICB9XG4gIHNwYW4ucmVtb3ZlKCk7XG59XG5mdW5jdGlvbiBnZXRDdXJyZW50VHJhbnNmb3JtKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgcmV0dXJuIFthLCBiLCBjLCBkLCBlLCBmXTtcbn1cbmZ1bmN0aW9uIGdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKGN0eCkge1xuICBjb25zdCB7XG4gICAgYSxcbiAgICBiLFxuICAgIGMsXG4gICAgZCxcbiAgICBlLFxuICAgIGZcbiAgfSA9IGN0eC5nZXRUcmFuc2Zvcm0oKS5pbnZlcnRTZWxmKCk7XG4gIHJldHVybiBbYSwgYiwgYywgZCwgZSwgZl07XG59XG5mdW5jdGlvbiBzZXRMYXllckRpbWVuc2lvbnMoZGl2LCB2aWV3cG9ydCkge1xuICBsZXQgbXVzdEZsaXAgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICBsZXQgbXVzdFJvdGF0ZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAzICYmIGFyZ3VtZW50c1szXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzNdIDogdHJ1ZTtcbiAgaWYgKHZpZXdwb3J0IGluc3RhbmNlb2YgUGFnZVZpZXdwb3J0KSB7XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IGRpdjtcbiAgICBjb25zdCB1c2VSb3VuZCA9IF91dGlsLkZlYXR1cmVUZXN0LmlzQ1NTUm91bmRTdXBwb3J0ZWQ7XG4gICAgY29uc3QgdyA9IGB2YXIoLS1zY2FsZS1mYWN0b3IpICogJHtwYWdlV2lkdGh9cHhgLFxuICAgICAgaCA9IGB2YXIoLS1zY2FsZS1mYWN0b3IpICogJHtwYWdlSGVpZ2h0fXB4YDtcbiAgICBjb25zdCB3aWR0aFN0ciA9IHVzZVJvdW5kID8gYHJvdW5kKCR7d30sIDFweClgIDogYGNhbGMoJHt3fSlgLFxuICAgICAgaGVpZ2h0U3RyID0gdXNlUm91bmQgPyBgcm91bmQoJHtofSwgMXB4KWAgOiBgY2FsYygke2h9KWA7XG4gICAgaWYgKCFtdXN0RmxpcCB8fCB2aWV3cG9ydC5yb3RhdGlvbiAlIDE4MCA9PT0gMCkge1xuICAgICAgc3R5bGUud2lkdGggPSB3aWR0aFN0cjtcbiAgICAgIHN0eWxlLmhlaWdodCA9IGhlaWdodFN0cjtcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGUud2lkdGggPSBoZWlnaHRTdHI7XG4gICAgICBzdHlsZS5oZWlnaHQgPSB3aWR0aFN0cjtcbiAgICB9XG4gIH1cbiAgaWYgKG11c3RSb3RhdGUpIHtcbiAgICBkaXYuc2V0QXR0cmlidXRlKFwiZGF0YS1tYWluLXJvdGF0aW9uXCIsIHZpZXdwb3J0LnJvdGF0aW9uKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDE2OSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBleHBvcnRzLkJhc2VTVkdGYWN0b3J5ID0gZXhwb3J0cy5CYXNlRmlsdGVyRmFjdG9yeSA9IGV4cG9ydHMuQmFzZUNhbnZhc0ZhY3RvcnkgPSBleHBvcnRzLkJhc2VDTWFwUmVhZGVyRmFjdG9yeSA9IHZvaWQgMDtcbl9fd19wZGZqc19yZXF1aXJlX18oMik7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY2xhc3MgQmFzZUZpbHRlckZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUZpbHRlckZhY3RvcnkpIHtcbiAgICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJDYW5ub3QgaW5pdGlhbGl6ZSBCYXNlRmlsdGVyRmFjdG9yeS5cIik7XG4gICAgfVxuICB9XG4gIGFkZEZpbHRlcihtYXBzKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGFkZEhpZ2hsaWdodEhDTUZpbHRlcihmZ0NvbG9yLCBiZ0NvbG9yLCBuZXdGZ0NvbG9yLCBuZXdCZ0NvbG9yKSB7XG4gICAgcmV0dXJuIFwibm9uZVwiO1xuICB9XG4gIGRlc3Ryb3koKSB7XG4gICAgbGV0IGtlZXBIQ00gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICB9XG59XG5leHBvcnRzLkJhc2VGaWx0ZXJGYWN0b3J5ID0gQmFzZUZpbHRlckZhY3Rvcnk7XG5jbGFzcyBCYXNlQ2FudmFzRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlQ2FudmFzRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VDYW52YXNGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBpZiAod2lkdGggPD0gMCB8fCBoZWlnaHQgPD0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBjYW52YXMgc2l6ZVwiKTtcbiAgICB9XG4gICAgY29uc3QgY2FudmFzID0gdGhpcy5fY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBjb250ZXh0OiBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpXG4gICAgfTtcbiAgfVxuICByZXNldChjYW52YXNBbmRDb250ZXh0LCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgaWYgKCFjYW52YXNBbmRDb250ZXh0LmNhbnZhcykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FudmFzIGlzIG5vdCBzcGVjaWZpZWRcIik7XG4gICAgfVxuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGNhbnZhcyBzaXplXCIpO1xuICAgIH1cbiAgICBjYW52YXNBbmRDb250ZXh0LmNhbnZhcy53aWR0aCA9IHdpZHRoO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IGhlaWdodDtcbiAgfVxuICBkZXN0cm95KGNhbnZhc0FuZENvbnRleHQpIHtcbiAgICBpZiAoIWNhbnZhc0FuZENvbnRleHQuY2FudmFzKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDYW52YXMgaXMgbm90IHNwZWNpZmllZFwiKTtcbiAgICB9XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMud2lkdGggPSAwO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY2FudmFzLmhlaWdodCA9IDA7XG4gICAgY2FudmFzQW5kQ29udGV4dC5jYW52YXMgPSBudWxsO1xuICAgIGNhbnZhc0FuZENvbnRleHQuY29udGV4dCA9IG51bGw7XG4gIH1cbiAgX2NyZWF0ZUNhbnZhcyh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2NyZWF0ZUNhbnZhc2AgY2FsbGVkLlwiKTtcbiAgfVxufVxuZXhwb3J0cy5CYXNlQ2FudmFzRmFjdG9yeSA9IEJhc2VDYW52YXNGYWN0b3J5O1xuY2xhc3MgQmFzZUNNYXBSZWFkZXJGYWN0b3J5IHtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBiYXNlVXJsID0gbnVsbCxcbiAgICAgIGlzQ29tcHJlc3NlZCA9IHRydWVcbiAgICB9ID0gX3JlZjtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZUNNYXBSZWFkZXJGYWN0b3J5KSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZUNNYXBSZWFkZXJGYWN0b3J5LlwiKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgICB0aGlzLmlzQ29tcHJlc3NlZCA9IGlzQ29tcHJlc3NlZDtcbiAgfVxuICBhc3luYyBmZXRjaChfcmVmMikge1xuICAgIGxldCB7XG4gICAgICBuYW1lXG4gICAgfSA9IF9yZWYyO1xuICAgIGlmICghdGhpcy5iYXNlVXJsKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RoZSBDTWFwIFwiYmFzZVVybFwiIHBhcmFtZXRlciBtdXN0IGJlIHNwZWNpZmllZCwgZW5zdXJlIHRoYXQgJyArICd0aGUgXCJjTWFwVXJsXCIgYW5kIFwiY01hcFBhY2tlZFwiIEFQSSBwYXJhbWV0ZXJzIGFyZSBwcm92aWRlZC4nKTtcbiAgICB9XG4gICAgaWYgKCFuYW1lKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJDTWFwIG5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSB0aGlzLmJhc2VVcmwgKyBuYW1lICsgKHRoaXMuaXNDb21wcmVzc2VkID8gXCIuYmNtYXBcIiA6IFwiXCIpO1xuICAgIGNvbnN0IGNvbXByZXNzaW9uVHlwZSA9IHRoaXMuaXNDb21wcmVzc2VkID8gX3V0aWwuQ01hcENvbXByZXNzaW9uVHlwZS5CSU5BUlkgOiBfdXRpbC5DTWFwQ29tcHJlc3Npb25UeXBlLk5PTkU7XG4gICAgcmV0dXJuIHRoaXMuX2ZldGNoRGF0YSh1cmwsIGNvbXByZXNzaW9uVHlwZSkuY2F0Y2gocmVhc29uID0+IHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5hYmxlIHRvIGxvYWQgJHt0aGlzLmlzQ29tcHJlc3NlZCA/IFwiYmluYXJ5IFwiIDogXCJcIn1DTWFwIGF0OiAke3VybH1gKTtcbiAgICB9KTtcbiAgfVxuICBfZmV0Y2hEYXRhKHVybCwgY29tcHJlc3Npb25UeXBlKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoRGF0YWAgY2FsbGVkLlwiKTtcbiAgfVxufVxuZXhwb3J0cy5CYXNlQ01hcFJlYWRlckZhY3RvcnkgPSBCYXNlQ01hcFJlYWRlckZhY3Rvcnk7XG5jbGFzcyBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBjb25zdHJ1Y3RvcihfcmVmMykge1xuICAgIGxldCB7XG4gICAgICBiYXNlVXJsID0gbnVsbFxuICAgIH0gPSBfcmVmMztcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5KSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5LlwiKTtcbiAgICB9XG4gICAgdGhpcy5iYXNlVXJsID0gYmFzZVVybDtcbiAgfVxuICBhc3luYyBmZXRjaChfcmVmNCkge1xuICAgIGxldCB7XG4gICAgICBmaWxlbmFtZVxuICAgIH0gPSBfcmVmNDtcbiAgICBpZiAoIXRoaXMuYmFzZVVybCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdUaGUgc3RhbmRhcmQgZm9udCBcImJhc2VVcmxcIiBwYXJhbWV0ZXIgbXVzdCBiZSBzcGVjaWZpZWQsIGVuc3VyZSB0aGF0ICcgKyAndGhlIFwic3RhbmRhcmRGb250RGF0YVVybFwiIEFQSSBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuJyk7XG4gICAgfVxuICAgIGlmICghZmlsZW5hbWUpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkZvbnQgZmlsZW5hbWUgbXVzdCBiZSBzcGVjaWZpZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBgJHt0aGlzLmJhc2VVcmx9JHtmaWxlbmFtZX1gO1xuICAgIHJldHVybiB0aGlzLl9mZXRjaERhdGEodXJsKS5jYXRjaChyZWFzb24gPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmFibGUgdG8gbG9hZCBmb250IGRhdGEgYXQ6ICR7dXJsfWApO1xuICAgIH0pO1xuICB9XG4gIF9mZXRjaERhdGEodXJsKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgX2ZldGNoRGF0YWAgY2FsbGVkLlwiKTtcbiAgfVxufVxuZXhwb3J0cy5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBCYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5jbGFzcyBCYXNlU1ZHRmFjdG9yeSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIGlmICh0aGlzLmNvbnN0cnVjdG9yID09PSBCYXNlU1ZHRmFjdG9yeSkge1xuICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkNhbm5vdCBpbml0aWFsaXplIEJhc2VTVkdGYWN0b3J5LlwiKTtcbiAgICB9XG4gIH1cbiAgY3JlYXRlKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBsZXQgc2tpcERpbWVuc2lvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICAgIGlmICh3aWR0aCA8PSAwIHx8IGhlaWdodCA8PSAwKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIFNWRyBkaW1lbnNpb25zXCIpO1xuICAgIH1cbiAgICBjb25zdCBzdmcgPSB0aGlzLl9jcmVhdGVTVkcoXCJzdmc6c3ZnXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2ZXJzaW9uXCIsIFwiMS4xXCIpO1xuICAgIGlmICghc2tpcERpbWVuc2lvbnMpIHtcbiAgICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCBgJHt3aWR0aH1weGApO1xuICAgICAgc3ZnLnNldEF0dHJpYnV0ZShcImhlaWdodFwiLCBgJHtoZWlnaHR9cHhgKTtcbiAgICB9XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcInByZXNlcnZlQXNwZWN0UmF0aW9cIiwgXCJub25lXCIpO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJ2aWV3Qm94XCIsIGAwIDAgJHt3aWR0aH0gJHtoZWlnaHR9YCk7XG4gICAgcmV0dXJuIHN2ZztcbiAgfVxuICBjcmVhdGVFbGVtZW50KHR5cGUpIHtcbiAgICBpZiAodHlwZW9mIHR5cGUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgU1ZHIGVsZW1lbnQgdHlwZVwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVNWRyh0eXBlKTtcbiAgfVxuICBfY3JlYXRlU1ZHKHR5cGUpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBfY3JlYXRlU1ZHYCBjYWxsZWQuXCIpO1xuICB9XG59XG5leHBvcnRzLkJhc2VTVkdGYWN0b3J5ID0gQmFzZVNWR0ZhY3Rvcnk7XG5cbi8qKiovIH0pLFxuLyogMTcwICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk11cm11ckhhc2gzXzY0ID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXyg5Myk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwOSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExNik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbmNvbnN0IFNFRUQgPSAweGMzZDJlMWYwO1xuY29uc3QgTUFTS19ISUdIID0gMHhmZmZmMDAwMDtcbmNvbnN0IE1BU0tfTE9XID0gMHhmZmZmO1xuY2xhc3MgTXVybXVySGFzaDNfNjQge1xuICBjb25zdHJ1Y3RvcihzZWVkKSB7XG4gICAgdGhpcy5oMSA9IHNlZWQgPyBzZWVkICYgMHhmZmZmZmZmZiA6IFNFRUQ7XG4gICAgdGhpcy5oMiA9IHNlZWQgPyBzZWVkICYgMHhmZmZmZmZmZiA6IFNFRUQ7XG4gIH1cbiAgdXBkYXRlKGlucHV0KSB7XG4gICAgbGV0IGRhdGEsIGxlbmd0aDtcbiAgICBpZiAodHlwZW9mIGlucHV0ID09PSBcInN0cmluZ1wiKSB7XG4gICAgICBkYXRhID0gbmV3IFVpbnQ4QXJyYXkoaW5wdXQubGVuZ3RoICogMik7XG4gICAgICBsZW5ndGggPSAwO1xuICAgICAgZm9yIChsZXQgaSA9IDAsIGlpID0gaW5wdXQubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgICBjb25zdCBjb2RlID0gaW5wdXQuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGUgPD0gMHhmZikge1xuICAgICAgICAgIGRhdGFbbGVuZ3RoKytdID0gY29kZTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBkYXRhW2xlbmd0aCsrXSA9IGNvZGUgPj4+IDg7XG4gICAgICAgICAgZGF0YVtsZW5ndGgrK10gPSBjb2RlICYgMHhmZjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoKDAsIF91dGlsLmlzQXJyYXlCdWZmZXIpKGlucHV0KSkge1xuICAgICAgZGF0YSA9IGlucHV0LnNsaWNlKCk7XG4gICAgICBsZW5ndGggPSBkYXRhLmJ5dGVMZW5ndGg7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIldyb25nIGRhdGEgZm9ybWF0IGluIE11cm11ckhhc2gzXzY0X3VwZGF0ZS4gXCIgKyBcIklucHV0IG11c3QgYmUgYSBzdHJpbmcgb3IgYXJyYXkuXCIpO1xuICAgIH1cbiAgICBjb25zdCBibG9ja0NvdW50cyA9IGxlbmd0aCA+PiAyO1xuICAgIGNvbnN0IHRhaWxMZW5ndGggPSBsZW5ndGggLSBibG9ja0NvdW50cyAqIDQ7XG4gICAgY29uc3QgZGF0YVVpbnQzMiA9IG5ldyBVaW50MzJBcnJheShkYXRhLmJ1ZmZlciwgMCwgYmxvY2tDb3VudHMpO1xuICAgIGxldCBrMSA9IDAsXG4gICAgICBrMiA9IDA7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBjb25zdCBDMSA9IDB4Y2M5ZTJkNTEsXG4gICAgICBDMiA9IDB4MWI4NzM1OTM7XG4gICAgY29uc3QgQzFfTE9XID0gQzEgJiBNQVNLX0xPVyxcbiAgICAgIEMyX0xPVyA9IEMyICYgTUFTS19MT1c7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBibG9ja0NvdW50czsgaSsrKSB7XG4gICAgICBpZiAoaSAmIDEpIHtcbiAgICAgICAgazEgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMSBePSBrMTtcbiAgICAgICAgaDEgPSBoMSA8PCAxMyB8IGgxID4+PiAxOTtcbiAgICAgICAgaDEgPSBoMSAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgazIgPSBkYXRhVWludDMyW2ldO1xuICAgICAgICBrMiA9IGsyICogQzEgJiBNQVNLX0hJR0ggfCBrMiAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMiA9IGsyIDw8IDE1IHwgazIgPj4+IDE3O1xuICAgICAgICBrMiA9IGsyICogQzIgJiBNQVNLX0hJR0ggfCBrMiAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBoMiBePSBrMjtcbiAgICAgICAgaDIgPSBoMiA8PCAxMyB8IGgyID4+PiAxOTtcbiAgICAgICAgaDIgPSBoMiAqIDUgKyAweGU2NTQ2YjY0O1xuICAgICAgfVxuICAgIH1cbiAgICBrMSA9IDA7XG4gICAgc3dpdGNoICh0YWlsTGVuZ3RoKSB7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMl0gPDwgMTY7XG4gICAgICBjYXNlIDI6XG4gICAgICAgIGsxIF49IGRhdGFbYmxvY2tDb3VudHMgKiA0ICsgMV0gPDwgODtcbiAgICAgIGNhc2UgMTpcbiAgICAgICAgazEgXj0gZGF0YVtibG9ja0NvdW50cyAqIDRdO1xuICAgICAgICBrMSA9IGsxICogQzEgJiBNQVNLX0hJR0ggfCBrMSAqIEMxX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBrMSA9IGsxIDw8IDE1IHwgazEgPj4+IDE3O1xuICAgICAgICBrMSA9IGsxICogQzIgJiBNQVNLX0hJR0ggfCBrMSAqIEMyX0xPVyAmIE1BU0tfTE9XO1xuICAgICAgICBpZiAoYmxvY2tDb3VudHMgJiAxKSB7XG4gICAgICAgICAgaDEgXj0gazE7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaDIgXj0gazE7XG4gICAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5oMSA9IGgxO1xuICAgIHRoaXMuaDIgPSBoMjtcbiAgfVxuICBoZXhkaWdlc3QoKSB7XG4gICAgbGV0IGgxID0gdGhpcy5oMSxcbiAgICAgIGgyID0gdGhpcy5oMjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHhlZDU1OGNjZCAmIE1BU0tfSElHSCB8IGgxICogMHg4Y2NkICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4ZmY1MWFmZDcgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YWZkN2VkNTUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICBoMSA9IGgxICogMHgxYTg1ZWM1MyAmIE1BU0tfSElHSCB8IGgxICogMHhlYzUzICYgTUFTS19MT1c7XG4gICAgaDIgPSBoMiAqIDB4YzRjZWI5ZmUgJiBNQVNLX0hJR0ggfCAoKGgyIDw8IDE2IHwgaDEgPj4+IDE2KSAqIDB4YjlmZTFhODUgJiBNQVNLX0hJR0gpID4+PiAxNjtcbiAgICBoMSBePSBoMiA+Pj4gMTtcbiAgICByZXR1cm4gKGgxID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpICsgKGgyID4+PiAwKS50b1N0cmluZygxNikucGFkU3RhcnQoOCwgXCIwXCIpO1xuICB9XG59XG5leHBvcnRzLk11cm11ckhhc2gzXzY0ID0gTXVybXVySGFzaDNfNjQ7XG5cbi8qKiovIH0pLFxuLyogMTcxICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkZvbnRMb2FkZXIgPSBleHBvcnRzLkZvbnRGYWNlT2JqZWN0ID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMjUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMzYpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMzgpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDEpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDcpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDE0OSk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY2xhc3MgRm9udExvYWRlciB7XG4gICNzeXN0ZW1Gb250cyA9IG5ldyBTZXQoKTtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICBvd25lckRvY3VtZW50ID0gZ2xvYmFsVGhpcy5kb2N1bWVudCxcbiAgICAgIHN0eWxlRWxlbWVudCA9IG51bGxcbiAgICB9ID0gX3JlZjtcbiAgICB0aGlzLl9kb2N1bWVudCA9IG93bmVyRG9jdW1lbnQ7XG4gICAgdGhpcy5uYXRpdmVGb250RmFjZXMgPSBuZXcgU2V0KCk7XG4gICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIHRoaXMubG9hZGluZ1JlcXVlc3RzID0gW107XG4gICAgdGhpcy5sb2FkVGVzdEZvbnRJZCA9IDA7XG4gIH1cbiAgYWRkTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5hZGQobmF0aXZlRm9udEZhY2UpO1xuICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmFkZChuYXRpdmVGb250RmFjZSk7XG4gIH1cbiAgcmVtb3ZlTmF0aXZlRm9udEZhY2UobmF0aXZlRm9udEZhY2UpIHtcbiAgICB0aGlzLm5hdGl2ZUZvbnRGYWNlcy5kZWxldGUobmF0aXZlRm9udEZhY2UpO1xuICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gIH1cbiAgaW5zZXJ0UnVsZShydWxlKSB7XG4gICAgaWYgKCF0aGlzLnN0eWxlRWxlbWVudCkge1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG4gICAgICB0aGlzLl9kb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJoZWFkXCIpWzBdLmFwcGVuZCh0aGlzLnN0eWxlRWxlbWVudCk7XG4gICAgfVxuICAgIGNvbnN0IHN0eWxlU2hlZXQgPSB0aGlzLnN0eWxlRWxlbWVudC5zaGVldDtcbiAgICBzdHlsZVNoZWV0Lmluc2VydFJ1bGUocnVsZSwgc3R5bGVTaGVldC5jc3NSdWxlcy5sZW5ndGgpO1xuICB9XG4gIGNsZWFyKCkge1xuICAgIGZvciAoY29uc3QgbmF0aXZlRm9udEZhY2Ugb2YgdGhpcy5uYXRpdmVGb250RmFjZXMpIHtcbiAgICAgIHRoaXMuX2RvY3VtZW50LmZvbnRzLmRlbGV0ZShuYXRpdmVGb250RmFjZSk7XG4gICAgfVxuICAgIHRoaXMubmF0aXZlRm9udEZhY2VzLmNsZWFyKCk7XG4gICAgdGhpcy4jc3lzdGVtRm9udHMuY2xlYXIoKTtcbiAgICBpZiAodGhpcy5zdHlsZUVsZW1lbnQpIHtcbiAgICAgIHRoaXMuc3R5bGVFbGVtZW50LnJlbW92ZSgpO1xuICAgICAgdGhpcy5zdHlsZUVsZW1lbnQgPSBudWxsO1xuICAgIH1cbiAgfVxuICBhc3luYyBsb2FkU3lzdGVtRm9udChpbmZvKSB7XG4gICAgaWYgKCFpbmZvIHx8IHRoaXMuI3N5c3RlbUZvbnRzLmhhcyhpbmZvLmxvYWRlZE5hbWUpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLmRpc2FibGVGb250RmFjZSwgXCJsb2FkU3lzdGVtRm9udCBzaG91bGRuJ3QgYmUgY2FsbGVkIHdoZW4gYGRpc2FibGVGb250RmFjZWAgaXMgc2V0LlwiKTtcbiAgICBpZiAodGhpcy5pc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGxvYWRlZE5hbWUsXG4gICAgICAgIHNyYyxcbiAgICAgICAgc3R5bGVcbiAgICAgIH0gPSBpbmZvO1xuICAgICAgY29uc3QgZm9udEZhY2UgPSBuZXcgRm9udEZhY2UobG9hZGVkTmFtZSwgc3JjLCBzdHlsZSk7XG4gICAgICB0aGlzLmFkZE5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIHRyeSB7XG4gICAgICAgIGF3YWl0IGZvbnRGYWNlLmxvYWQoKTtcbiAgICAgICAgdGhpcy4jc3lzdGVtRm9udHMuYWRkKGxvYWRlZE5hbWUpO1xuICAgICAgfSBjYXRjaCB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgQ2Fubm90IGxvYWQgc3lzdGVtIGZvbnQ6ICR7aW5mby5iYXNlRm9udE5hbWV9LCBpbnN0YWxsaW5nIGl0IGNvdWxkIGhlbHAgdG8gaW1wcm92ZSBQREYgcmVuZGVyaW5nLmApO1xuICAgICAgICB0aGlzLnJlbW92ZU5hdGl2ZUZvbnRGYWNlKGZvbnRGYWNlKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIk5vdCBpbXBsZW1lbnRlZDogbG9hZFN5c3RlbUZvbnQgd2l0aG91dCB0aGUgRm9udCBMb2FkaW5nIEFQSS5cIik7XG4gIH1cbiAgYXN5bmMgYmluZChmb250KSB7XG4gICAgaWYgKGZvbnQuYXR0YWNoZWQgfHwgZm9udC5taXNzaW5nRmlsZSAmJiAhZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb250LmF0dGFjaGVkID0gdHJ1ZTtcbiAgICBpZiAoZm9udC5zeXN0ZW1Gb250SW5mbykge1xuICAgICAgYXdhaXQgdGhpcy5sb2FkU3lzdGVtRm9udChmb250LnN5c3RlbUZvbnRJbmZvKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZCkge1xuICAgICAgY29uc3QgbmF0aXZlRm9udEZhY2UgPSBmb250LmNyZWF0ZU5hdGl2ZUZvbnRGYWNlKCk7XG4gICAgICBpZiAobmF0aXZlRm9udEZhY2UpIHtcbiAgICAgICAgdGhpcy5hZGROYXRpdmVGb250RmFjZShuYXRpdmVGb250RmFjZSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgYXdhaXQgbmF0aXZlRm9udEZhY2UubG9hZGVkO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgRmFpbGVkIHRvIGxvYWQgZm9udCAnJHtuYXRpdmVGb250RmFjZS5mYW1pbHl9JzogJyR7ZXh9Jy5gKTtcbiAgICAgICAgICBmb250LmRpc2FibGVGb250RmFjZSA9IHRydWU7XG4gICAgICAgICAgdGhyb3cgZXg7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgcnVsZSA9IGZvbnQuY3JlYXRlRm9udEZhY2VSdWxlKCk7XG4gICAgaWYgKHJ1bGUpIHtcbiAgICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICAgIGlmICh0aGlzLmlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5fcXVldWVMb2FkaW5nQ2FsbGJhY2socmVzb2x2ZSk7XG4gICAgICAgIHRoaXMuX3ByZXBhcmVGb250TG9hZEV2ZW50KGZvbnQsIHJlcXVlc3QpO1xuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRMb2FkaW5nQVBJU3VwcG9ydGVkKCkge1xuICAgIGNvbnN0IGhhc0ZvbnRzID0gISF0aGlzLl9kb2N1bWVudD8uZm9udHM7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNGb250TG9hZGluZ0FQSVN1cHBvcnRlZFwiLCBoYXNGb250cyk7XG4gIH1cbiAgZ2V0IGlzU3luY0ZvbnRMb2FkaW5nU3VwcG9ydGVkKCkge1xuICAgIGxldCBzdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICBpZiAoX3V0aWwuaXNOb2RlSlMpIHtcbiAgICAgIHN1cHBvcnRlZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSBcInVuZGVmaW5lZFwiICYmIC9Nb3ppbGxhXFwvNS4wLio/cnY6XFxkKy4qPyBHZWNrby8udGVzdChuYXZpZ2F0b3IudXNlckFnZW50KSkge1xuICAgICAgc3VwcG9ydGVkID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwiaXNTeW5jRm9udExvYWRpbmdTdXBwb3J0ZWRcIiwgc3VwcG9ydGVkKTtcbiAgfVxuICBfcXVldWVMb2FkaW5nQ2FsbGJhY2soY2FsbGJhY2spIHtcbiAgICBmdW5jdGlvbiBjb21wbGV0ZVJlcXVlc3QoKSB7XG4gICAgICAoMCwgX3V0aWwuYXNzZXJ0KSghcmVxdWVzdC5kb25lLCBcImNvbXBsZXRlUmVxdWVzdCgpIGNhbm5vdCBiZSBjYWxsZWQgdHdpY2UuXCIpO1xuICAgICAgcmVxdWVzdC5kb25lID0gdHJ1ZTtcbiAgICAgIHdoaWxlIChsb2FkaW5nUmVxdWVzdHMubGVuZ3RoID4gMCAmJiBsb2FkaW5nUmVxdWVzdHNbMF0uZG9uZSkge1xuICAgICAgICBjb25zdCBvdGhlclJlcXVlc3QgPSBsb2FkaW5nUmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgc2V0VGltZW91dChvdGhlclJlcXVlc3QuY2FsbGJhY2ssIDApO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBsb2FkaW5nUmVxdWVzdHNcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCByZXF1ZXN0ID0ge1xuICAgICAgZG9uZTogZmFsc2UsXG4gICAgICBjb21wbGV0ZTogY29tcGxldGVSZXF1ZXN0LFxuICAgICAgY2FsbGJhY2tcbiAgICB9O1xuICAgIGxvYWRpbmdSZXF1ZXN0cy5wdXNoKHJlcXVlc3QpO1xuICAgIHJldHVybiByZXF1ZXN0O1xuICB9XG4gIGdldCBfbG9hZFRlc3RGb250KCkge1xuICAgIGNvbnN0IHRlc3RGb250ID0gYXRvYihcIlQxUlVUd0FMQUlBQUF3QXdRMFpHSURIdFpnNEFBQU9ZQUFBQWdVWkdWRTFsa3pad0FBQUVIQUFBQUJ4SFJFVkdBQlFBXCIgKyBcIkZRQUFCRGdBQUFBZVQxTXZNbFlOWXdrQUFBRWdBQUFBWUdOdFlYQUJEUUxVQUFBQ05BQUFBVUpvWldGay94VkZEUUFBXCIgKyBcIkFMd0FBQUEyYUdobFlRZGtBK29BQUFEMEFBQUFKR2h0ZEhnRDZBQUFBQUFFV0FBQUFBWnRZWGh3QUFKUUFBQUFBUmdBXCIgKyBcIkFBQUdibUZ0WlZqbWRINEFBQUdBQUFBQXNYQnZjM1QvaGdBekFBQURlQUFBQUNBQUFRQUFBQUVBQUxaUkZzUmZEenoxXCIgKyBcIkFBc0Q2QUFBQUFET0JPVExBQUFBQU00S0hEd0FBQUFBQStnRElRQUFBQWdBQWdBQUFBQUFBQUFCQUFBRElRQUFBRm9EXCIgKyBcIjZBQUFBQUFENkFBQkFBQUFBQUFBQUFBQUFBQUFBQUFBQVFBQVVBQUFBZ0FBQUFRRDZBSDBBQVVBQUFLS0Fyd0FBQUNNXCIgKyBcIkFvb0N2QUFBQWVBQU1RRUNBQUFDQUFZSkFBQUFBQUFBQUFBQUFRQUFBQUFBQUFBQUFBQUFBRkJtUldRQXdBQXVBQzREXCIgKyBcIklQODRBRm9ESVFBQUFBQUFBUUFBQUFBQUFBQUFBQ0FBSUFBQkFBQUFEZ0N1QUFFQUFBQUFBQUFBQVFBQUFBRUFBQUFBXCIgKyBcIkFBRUFBUUFBQUFFQUFBQUFBQUlBQVFBQUFBRUFBQUFBQUFNQUFRQUFBQUVBQUFBQUFBUUFBUUFBQUFFQUFBQUFBQVVBXCIgKyBcIkFRQUFBQUVBQUFBQUFBWUFBUUFBQUFNQUFRUUpBQUFBQWdBQkFBTUFBUVFKQUFFQUFnQUJBQU1BQVFRSkFBSUFBZ0FCXCIgKyBcIkFBTUFBUVFKQUFNQUFnQUJBQU1BQVFRSkFBUUFBZ0FCQUFNQUFRUUpBQVVBQWdBQkFBTUFBUVFKQUFZQUFnQUJXQUJZXCIgKyBcIkFBQUFBQUFBQXdBQUFBTUFBQUFjQUFFQUFBQUFBRHdBQXdBQkFBQUFIQUFFQUNBQUFBQUVBQVFBQVFBQUFDNy8vd0FBXCIgKyBcIkFDNy8vLy9UQUFFQUFBQUFBQUFCQmdBQUFRQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUVBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQUFBQU1BQUFBQUFBRC9nd0F5QUFBQUFRQUFBQUFBQUFBQUFBQUFBQUFBXCIgKyBcIkFBQUJBQVFFQUFFQkFRSllBQUVCQVNINER3RDRHd0hFQXZnY0EvZ1hCSXdNQVl1TCtuejV0UVhrRDVqM0NCTG5FUUFDXCIgKyBcIkFRRUJJVmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWVdGaFlXRmhZV0ZoWUFBQUJBUUFBRHdBQ0FRRUVFL3QzXCIgKyBcIkRvdjZmQUg2ZkFUK2ZQcDgrbndIRG9zTUN2bTFDdm0xREF6NmZCUUFBQUFBQUFBQkFBQUFBTW1KYnpFQUFBQUF6Z1RqXCIgKyBcIkZRQUFBQURPQk9RcEFBRUFBQUFBQUFBQURBQVVBQVFBQUFBQkFBQUFBZ0FCQUFBQUFBQUFBQUFENkFBQUFBQUFBQT09XCIpO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9sb2FkVGVzdEZvbnRcIiwgdGVzdEZvbnQpO1xuICB9XG4gIF9wcmVwYXJlRm9udExvYWRFdmVudChmb250LCByZXF1ZXN0KSB7XG4gICAgZnVuY3Rpb24gaW50MzIoZGF0YSwgb2Zmc2V0KSB7XG4gICAgICByZXR1cm4gZGF0YS5jaGFyQ29kZUF0KG9mZnNldCkgPDwgMjQgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMSkgPDwgMTYgfCBkYXRhLmNoYXJDb2RlQXQob2Zmc2V0ICsgMikgPDwgOCB8IGRhdGEuY2hhckNvZGVBdChvZmZzZXQgKyAzKSAmIDB4ZmY7XG4gICAgfVxuICAgIGZ1bmN0aW9uIHNwbGljZVN0cmluZyhzLCBvZmZzZXQsIHJlbW92ZSwgaW5zZXJ0KSB7XG4gICAgICBjb25zdCBjaHVuazEgPSBzLnN1YnN0cmluZygwLCBvZmZzZXQpO1xuICAgICAgY29uc3QgY2h1bmsyID0gcy5zdWJzdHJpbmcob2Zmc2V0ICsgcmVtb3ZlKTtcbiAgICAgIHJldHVybiBjaHVuazEgKyBpbnNlcnQgKyBjaHVuazI7XG4gICAgfVxuICAgIGxldCBpLCBpaTtcbiAgICBjb25zdCBjYW52YXMgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgIGNhbnZhcy53aWR0aCA9IDE7XG4gICAgY2FudmFzLmhlaWdodCA9IDE7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBsZXQgY2FsbGVkID0gMDtcbiAgICBmdW5jdGlvbiBpc0ZvbnRSZWFkeShuYW1lLCBjYWxsYmFjaykge1xuICAgICAgaWYgKCsrY2FsbGVkID4gMzApIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKFwiTG9hZCB0ZXN0IGZvbnQgbmV2ZXIgbG9hZGVkLlwiKTtcbiAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY3R4LmZvbnQgPSBcIjMwcHggXCIgKyBuYW1lO1xuICAgICAgY3R4LmZpbGxUZXh0KFwiLlwiLCAwLCAyMCk7XG4gICAgICBjb25zdCBpbWFnZURhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEsIDEpO1xuICAgICAgaWYgKGltYWdlRGF0YS5kYXRhWzNdID4gMCkge1xuICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZXRUaW1lb3V0KGlzRm9udFJlYWR5LmJpbmQobnVsbCwgbmFtZSwgY2FsbGJhY2spKTtcbiAgICB9XG4gICAgY29uc3QgbG9hZFRlc3RGb250SWQgPSBgbHQke0RhdGUubm93KCl9JHt0aGlzLmxvYWRUZXN0Rm9udElkKyt9YDtcbiAgICBsZXQgZGF0YSA9IHRoaXMuX2xvYWRUZXN0Rm9udDtcbiAgICBjb25zdCBDT01NRU5UX09GRlNFVCA9IDk3NjtcbiAgICBkYXRhID0gc3BsaWNlU3RyaW5nKGRhdGEsIENPTU1FTlRfT0ZGU0VULCBsb2FkVGVzdEZvbnRJZC5sZW5ndGgsIGxvYWRUZXN0Rm9udElkKTtcbiAgICBjb25zdCBDRkZfQ0hFQ0tTVU1fT0ZGU0VUID0gMTY7XG4gICAgY29uc3QgWFhYWF9WQUxVRSA9IDB4NTg1ODU4NTg7XG4gICAgbGV0IGNoZWNrc3VtID0gaW50MzIoZGF0YSwgQ0ZGX0NIRUNLU1VNX09GRlNFVCk7XG4gICAgZm9yIChpID0gMCwgaWkgPSBsb2FkVGVzdEZvbnRJZC5sZW5ndGggLSAzOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCwgaSkgfCAwO1xuICAgIH1cbiAgICBpZiAoaSA8IGxvYWRUZXN0Rm9udElkLmxlbmd0aCkge1xuICAgICAgY2hlY2tzdW0gPSBjaGVja3N1bSAtIFhYWFhfVkFMVUUgKyBpbnQzMihsb2FkVGVzdEZvbnRJZCArIFwiWFhYXCIsIGkpIHwgMDtcbiAgICB9XG4gICAgZGF0YSA9IHNwbGljZVN0cmluZyhkYXRhLCBDRkZfQ0hFQ0tTVU1fT0ZGU0VULCA0LCAoMCwgX3V0aWwuc3RyaW5nMzIpKGNoZWNrc3VtKSk7XG4gICAgY29uc3QgdXJsID0gYHVybChkYXRhOmZvbnQvb3BlbnR5cGU7YmFzZTY0LCR7YnRvYShkYXRhKX0pO2A7XG4gICAgY29uc3QgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7bG9hZFRlc3RGb250SWR9XCI7c3JjOiR7dXJsfX1gO1xuICAgIHRoaXMuaW5zZXJ0UnVsZShydWxlKTtcbiAgICBjb25zdCBkaXYgPSB0aGlzLl9kb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIGRpdi5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBkaXYuc3R5bGUud2lkdGggPSBkaXYuc3R5bGUuaGVpZ2h0ID0gXCIxMHB4XCI7XG4gICAgZGl2LnN0eWxlLnBvc2l0aW9uID0gXCJhYnNvbHV0ZVwiO1xuICAgIGRpdi5zdHlsZS50b3AgPSBkaXYuc3R5bGUubGVmdCA9IFwiMHB4XCI7XG4gICAgZm9yIChjb25zdCBuYW1lIG9mIFtmb250LmxvYWRlZE5hbWUsIGxvYWRUZXN0Rm9udElkXSkge1xuICAgICAgY29uc3Qgc3BhbiA9IHRoaXMuX2RvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgc3Bhbi50ZXh0Q29udGVudCA9IFwiSGlcIjtcbiAgICAgIHNwYW4uc3R5bGUuZm9udEZhbWlseSA9IG5hbWU7XG4gICAgICBkaXYuYXBwZW5kKHNwYW4pO1xuICAgIH1cbiAgICB0aGlzLl9kb2N1bWVudC5ib2R5LmFwcGVuZChkaXYpO1xuICAgIGlzRm9udFJlYWR5KGxvYWRUZXN0Rm9udElkLCAoKSA9PiB7XG4gICAgICBkaXYucmVtb3ZlKCk7XG4gICAgICByZXF1ZXN0LmNvbXBsZXRlKCk7XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydHMuRm9udExvYWRlciA9IEZvbnRMb2FkZXI7XG5jbGFzcyBGb250RmFjZU9iamVjdCB7XG4gIGNvbnN0cnVjdG9yKHRyYW5zbGF0ZWREYXRhLCBfcmVmMikge1xuICAgIGxldCB7XG4gICAgICBpc0V2YWxTdXBwb3J0ZWQgPSB0cnVlLFxuICAgICAgZGlzYWJsZUZvbnRGYWNlID0gZmFsc2UsXG4gICAgICBpZ25vcmVFcnJvcnMgPSBmYWxzZSxcbiAgICAgIGluc3BlY3RGb250ID0gbnVsbFxuICAgIH0gPSBfcmVmMjtcbiAgICB0aGlzLmNvbXBpbGVkR2x5cGhzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICBmb3IgKGNvbnN0IGkgaW4gdHJhbnNsYXRlZERhdGEpIHtcbiAgICAgIHRoaXNbaV0gPSB0cmFuc2xhdGVkRGF0YVtpXTtcbiAgICB9XG4gICAgdGhpcy5pc0V2YWxTdXBwb3J0ZWQgPSBpc0V2YWxTdXBwb3J0ZWQgIT09IGZhbHNlO1xuICAgIHRoaXMuZGlzYWJsZUZvbnRGYWNlID0gZGlzYWJsZUZvbnRGYWNlID09PSB0cnVlO1xuICAgIHRoaXMuaWdub3JlRXJyb3JzID0gaWdub3JlRXJyb3JzID09PSB0cnVlO1xuICAgIHRoaXMuX2luc3BlY3RGb250ID0gaW5zcGVjdEZvbnQ7XG4gIH1cbiAgY3JlYXRlTmF0aXZlRm9udEZhY2UoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEgfHwgdGhpcy5kaXNhYmxlRm9udEZhY2UpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBsZXQgbmF0aXZlRm9udEZhY2U7XG4gICAgaWYgKCF0aGlzLmNzc0ZvbnRJbmZvKSB7XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmxvYWRlZE5hbWUsIHRoaXMuZGF0YSwge30pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBjc3MgPSB7XG4gICAgICAgIHdlaWdodDogdGhpcy5jc3NGb250SW5mby5mb250V2VpZ2h0XG4gICAgICB9O1xuICAgICAgaWYgKHRoaXMuY3NzRm9udEluZm8uaXRhbGljQW5nbGUpIHtcbiAgICAgICAgY3NzLnN0eWxlID0gYG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZ2A7XG4gICAgICB9XG4gICAgICBuYXRpdmVGb250RmFjZSA9IG5ldyBGb250RmFjZSh0aGlzLmNzc0ZvbnRJbmZvLmZvbnRGYW1pbHksIHRoaXMuZGF0YSwgY3NzKTtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzKTtcbiAgICByZXR1cm4gbmF0aXZlRm9udEZhY2U7XG4gIH1cbiAgY3JlYXRlRm9udEZhY2VSdWxlKCkge1xuICAgIGlmICghdGhpcy5kYXRhIHx8IHRoaXMuZGlzYWJsZUZvbnRGYWNlKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZGF0YSA9ICgwLCBfdXRpbC5ieXRlc1RvU3RyaW5nKSh0aGlzLmRhdGEpO1xuICAgIGNvbnN0IHVybCA9IGB1cmwoZGF0YToke3RoaXMubWltZXR5cGV9O2Jhc2U2NCwke2J0b2EoZGF0YSl9KTtgO1xuICAgIGxldCBydWxlO1xuICAgIGlmICghdGhpcy5jc3NGb250SW5mbykge1xuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5sb2FkZWROYW1lfVwiO3NyYzoke3VybH19YDtcbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGNzcyA9IGBmb250LXdlaWdodDogJHt0aGlzLmNzc0ZvbnRJbmZvLmZvbnRXZWlnaHR9O2A7XG4gICAgICBpZiAodGhpcy5jc3NGb250SW5mby5pdGFsaWNBbmdsZSkge1xuICAgICAgICBjc3MgKz0gYGZvbnQtc3R5bGU6IG9ibGlxdWUgJHt0aGlzLmNzc0ZvbnRJbmZvLml0YWxpY0FuZ2xlfWRlZztgO1xuICAgICAgfVxuICAgICAgcnVsZSA9IGBAZm9udC1mYWNlIHtmb250LWZhbWlseTpcIiR7dGhpcy5jc3NGb250SW5mby5mb250RmFtaWx5fVwiOyR7Y3NzfXNyYzoke3VybH19YDtcbiAgICB9XG4gICAgdGhpcy5faW5zcGVjdEZvbnQ/Lih0aGlzLCB1cmwpO1xuICAgIHJldHVybiBydWxlO1xuICB9XG4gIGdldFBhdGhHZW5lcmF0b3Iob2JqcywgY2hhcmFjdGVyKSB7XG4gICAgaWYgKHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdO1xuICAgIH1cbiAgICBsZXQgY21kcztcbiAgICB0cnkge1xuICAgICAgY21kcyA9IG9ianMuZ2V0KHRoaXMubG9hZGVkTmFtZSArIFwiX3BhdGhfXCIgKyBjaGFyYWN0ZXIpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBpZiAoIXRoaXMuaWdub3JlRXJyb3JzKSB7XG4gICAgICAgIHRocm93IGV4O1xuICAgICAgfVxuICAgICAgKDAsIF91dGlsLndhcm4pKGBnZXRQYXRoR2VuZXJhdG9yIC0gaWdub3JpbmcgY2hhcmFjdGVyOiBcIiR7ZXh9XCIuYCk7XG4gICAgICByZXR1cm4gdGhpcy5jb21waWxlZEdseXBoc1tjaGFyYWN0ZXJdID0gZnVuY3Rpb24gKGMsIHNpemUpIHt9O1xuICAgIH1cbiAgICBpZiAodGhpcy5pc0V2YWxTdXBwb3J0ZWQgJiYgX3V0aWwuRmVhdHVyZVRlc3QuaXNFdmFsU3VwcG9ydGVkKSB7XG4gICAgICBjb25zdCBqc0J1ZiA9IFtdO1xuICAgICAgZm9yIChjb25zdCBjdXJyZW50IG9mIGNtZHMpIHtcbiAgICAgICAgY29uc3QgYXJncyA9IGN1cnJlbnQuYXJncyAhPT0gdW5kZWZpbmVkID8gY3VycmVudC5hcmdzLmpvaW4oXCIsXCIpIDogXCJcIjtcbiAgICAgICAganNCdWYucHVzaChcImMuXCIsIGN1cnJlbnQuY21kLCBcIihcIiwgYXJncywgXCIpO1xcblwiKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0aGlzLmNvbXBpbGVkR2x5cGhzW2NoYXJhY3Rlcl0gPSBuZXcgRnVuY3Rpb24oXCJjXCIsIFwic2l6ZVwiLCBqc0J1Zi5qb2luKFwiXCIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29tcGlsZWRHbHlwaHNbY2hhcmFjdGVyXSA9IGZ1bmN0aW9uIChjLCBzaXplKSB7XG4gICAgICBmb3IgKGNvbnN0IGN1cnJlbnQgb2YgY21kcykge1xuICAgICAgICBpZiAoY3VycmVudC5jbWQgPT09IFwic2NhbGVcIikge1xuICAgICAgICAgIGN1cnJlbnQuYXJncyA9IFtzaXplLCAtc2l6ZV07XG4gICAgICAgIH1cbiAgICAgICAgY1tjdXJyZW50LmNtZF0uYXBwbHkoYywgY3VycmVudC5hcmdzKTtcbiAgICAgIH1cbiAgICB9O1xuICB9XG59XG5leHBvcnRzLkZvbnRGYWNlT2JqZWN0ID0gRm9udEZhY2VPYmplY3Q7XG5cbi8qKiovIH0pLFxuLyogMTcyICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk5vZGVTdGFuZGFyZEZvbnREYXRhRmFjdG9yeSA9IGV4cG9ydHMuTm9kZUZpbHRlckZhY3RvcnkgPSBleHBvcnRzLk5vZGVDYW52YXNGYWN0b3J5ID0gZXhwb3J0cy5Ob2RlQ01hcFJlYWRlckZhY3RvcnkgPSB2b2lkIDA7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg5Myk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwOSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExNik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyMyk7XG52YXIgX2Jhc2VfZmFjdG9yeSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTY5KTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG47XG57XG4gIChmdW5jdGlvbiBjaGVja0RPTU1hdHJpeCgpIHtcbiAgICBpZiAoZ2xvYmFsVGhpcy5ET01NYXRyaXggfHwgIV91dGlsLmlzTm9kZUpTKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBnbG9iYWxUaGlzLkRPTU1hdHJpeCA9IHJlcXVpcmUoXCJjYW52YXNcIikuRE9NTWF0cml4O1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYENhbm5vdCBwb2x5ZmlsbCBcXGBET01NYXRyaXhcXGAsIHJlbmRlcmluZyBtYXkgYmUgYnJva2VuOiBcIiR7ZXh9XCIuYCk7XG4gICAgfVxuICB9KSgpO1xuICAoZnVuY3Rpb24gY2hlY2tQYXRoMkQoKSB7XG4gICAgaWYgKGdsb2JhbFRoaXMuUGF0aDJEIHx8ICFfdXRpbC5pc05vZGVKUykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBDYW52YXNSZW5kZXJpbmdDb250ZXh0MkRcbiAgICAgIH0gPSByZXF1aXJlKFwiY2FudmFzXCIpO1xuICAgICAgY29uc3Qge1xuICAgICAgICBwb2x5ZmlsbFBhdGgyRFxuICAgICAgfSA9IHJlcXVpcmUoXCJwYXRoMmQtcG9seWZpbGxcIik7XG4gICAgICBnbG9iYWxUaGlzLkNhbnZhc1JlbmRlcmluZ0NvbnRleHQyRCA9IENhbnZhc1JlbmRlcmluZ0NvbnRleHQyRDtcbiAgICAgIHBvbHlmaWxsUGF0aDJEKGdsb2JhbFRoaXMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYENhbm5vdCBwb2x5ZmlsbCBcXGBQYXRoMkRcXGAsIHJlbmRlcmluZyBtYXkgYmUgYnJva2VuOiBcIiR7ZXh9XCIuYCk7XG4gICAgfVxuICB9KSgpO1xufVxuY29uc3QgZmV0Y2hEYXRhID0gZnVuY3Rpb24gKHVybCkge1xuICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgIGNvbnN0IGZzID0gcmVxdWlyZShcImZzXCIpO1xuICAgIGZzLnJlYWRGaWxlKHVybCwgKGVycm9yLCBkYXRhKSA9PiB7XG4gICAgICBpZiAoZXJyb3IgfHwgIWRhdGEpIHtcbiAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihlcnJvcikpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNvbHZlKG5ldyBVaW50OEFycmF5KGRhdGEpKTtcbiAgICB9KTtcbiAgfSk7XG59O1xuY2xhc3MgTm9kZUZpbHRlckZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VGaWx0ZXJGYWN0b3J5IHt9XG5leHBvcnRzLk5vZGVGaWx0ZXJGYWN0b3J5ID0gTm9kZUZpbHRlckZhY3Rvcnk7XG5jbGFzcyBOb2RlQ2FudmFzRmFjdG9yeSBleHRlbmRzIF9iYXNlX2ZhY3RvcnkuQmFzZUNhbnZhc0ZhY3Rvcnkge1xuICBfY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBDYW52YXMgPSByZXF1aXJlKFwiY2FudmFzXCIpO1xuICAgIHJldHVybiBDYW52YXMuY3JlYXRlQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICB9XG59XG5leHBvcnRzLk5vZGVDYW52YXNGYWN0b3J5ID0gTm9kZUNhbnZhc0ZhY3Rvcnk7XG5jbGFzcyBOb2RlQ01hcFJlYWRlckZhY3RvcnkgZXh0ZW5kcyBfYmFzZV9mYWN0b3J5LkJhc2VDTWFwUmVhZGVyRmFjdG9yeSB7XG4gIF9mZXRjaERhdGEodXJsLCBjb21wcmVzc2lvblR5cGUpIHtcbiAgICByZXR1cm4gZmV0Y2hEYXRhKHVybCkudGhlbihkYXRhID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGNNYXBEYXRhOiBkYXRhLFxuICAgICAgICBjb21wcmVzc2lvblR5cGVcbiAgICAgIH07XG4gICAgfSk7XG4gIH1cbn1cbmV4cG9ydHMuTm9kZUNNYXBSZWFkZXJGYWN0b3J5ID0gTm9kZUNNYXBSZWFkZXJGYWN0b3J5O1xuY2xhc3MgTm9kZVN0YW5kYXJkRm9udERhdGFGYWN0b3J5IGV4dGVuZHMgX2Jhc2VfZmFjdG9yeS5CYXNlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnkge1xuICBfZmV0Y2hEYXRhKHVybCkge1xuICAgIHJldHVybiBmZXRjaERhdGEodXJsKTtcbiAgfVxufVxuZXhwb3J0cy5Ob2RlU3RhbmRhcmRGb250RGF0YUZhY3RvcnkgPSBOb2RlU3RhbmRhcmRGb250RGF0YUZhY3Rvcnk7XG5cbi8qKiovIH0pLFxuLyogMTczICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkNhbnZhc0dyYXBoaWNzID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXygyKTtcbl9fd19wZGZqc19yZXF1aXJlX18oOTMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDEpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDIpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDcpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDkpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMTMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMTYpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMjMpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjgpO1xudmFyIF9wYXR0ZXJuX2hlbHBlciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTc0KTtcbnZhciBfaW1hZ2VfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3NSk7XG5jb25zdCBNSU5fRk9OVF9TSVpFID0gMTY7XG5jb25zdCBNQVhfRk9OVF9TSVpFID0gMTAwO1xuY29uc3QgTUFYX0dST1VQX1NJWkUgPSA0MDk2O1xuY29uc3QgRVhFQ1VUSU9OX1RJTUUgPSAxNTtcbmNvbnN0IEVYRUNVVElPTl9TVEVQUyA9IDEwO1xuY29uc3QgTUFYX1NJWkVfVE9fQ09NUElMRSA9IDEwMDA7XG5jb25zdCBGVUxMX0NIVU5LX0hFSUdIVCA9IDE2O1xuZnVuY3Rpb24gbWlycm9yQ29udGV4dE9wZXJhdGlvbnMoY3R4LCBkZXN0Q3R4KSB7XG4gIGlmIChjdHguX3JlbW92ZU1pcnJvcmluZykge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkNvbnRleHQgaXMgYWxyZWFkeSBmb3J3YXJkaW5nIG9wZXJhdGlvbnMuXCIpO1xuICB9XG4gIGN0eC5fX29yaWdpbmFsU2F2ZSA9IGN0eC5zYXZlO1xuICBjdHguX19vcmlnaW5hbFJlc3RvcmUgPSBjdHgucmVzdG9yZTtcbiAgY3R4Ll9fb3JpZ2luYWxSb3RhdGUgPSBjdHgucm90YXRlO1xuICBjdHguX19vcmlnaW5hbFNjYWxlID0gY3R4LnNjYWxlO1xuICBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZSA9IGN0eC50cmFuc2xhdGU7XG4gIGN0eC5fX29yaWdpbmFsVHJhbnNmb3JtID0gY3R4LnRyYW5zZm9ybTtcbiAgY3R4Ll9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0gPSBjdHguc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbFJlc2V0VHJhbnNmb3JtID0gY3R4LnJlc2V0VHJhbnNmb3JtO1xuICBjdHguX19vcmlnaW5hbENsaXAgPSBjdHguY2xpcDtcbiAgY3R4Ll9fb3JpZ2luYWxNb3ZlVG8gPSBjdHgubW92ZVRvO1xuICBjdHguX19vcmlnaW5hbExpbmVUbyA9IGN0eC5saW5lVG87XG4gIGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyA9IGN0eC5iZXppZXJDdXJ2ZVRvO1xuICBjdHguX19vcmlnaW5hbFJlY3QgPSBjdHgucmVjdDtcbiAgY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGggPSBjdHguY2xvc2VQYXRoO1xuICBjdHguX19vcmlnaW5hbEJlZ2luUGF0aCA9IGN0eC5iZWdpblBhdGg7XG4gIGN0eC5fcmVtb3ZlTWlycm9yaW5nID0gKCkgPT4ge1xuICAgIGN0eC5zYXZlID0gY3R4Ll9fb3JpZ2luYWxTYXZlO1xuICAgIGN0eC5yZXN0b3JlID0gY3R4Ll9fb3JpZ2luYWxSZXN0b3JlO1xuICAgIGN0eC5yb3RhdGUgPSBjdHguX19vcmlnaW5hbFJvdGF0ZTtcbiAgICBjdHguc2NhbGUgPSBjdHguX19vcmlnaW5hbFNjYWxlO1xuICAgIGN0eC50cmFuc2xhdGUgPSBjdHguX19vcmlnaW5hbFRyYW5zbGF0ZTtcbiAgICBjdHgudHJhbnNmb3JtID0gY3R4Ll9fb3JpZ2luYWxUcmFuc2Zvcm07XG4gICAgY3R4LnNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsU2V0VHJhbnNmb3JtO1xuICAgIGN0eC5yZXNldFRyYW5zZm9ybSA9IGN0eC5fX29yaWdpbmFsUmVzZXRUcmFuc2Zvcm07XG4gICAgY3R4LmNsaXAgPSBjdHguX19vcmlnaW5hbENsaXA7XG4gICAgY3R4Lm1vdmVUbyA9IGN0eC5fX29yaWdpbmFsTW92ZVRvO1xuICAgIGN0eC5saW5lVG8gPSBjdHguX19vcmlnaW5hbExpbmVUbztcbiAgICBjdHguYmV6aWVyQ3VydmVUbyA9IGN0eC5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbztcbiAgICBjdHgucmVjdCA9IGN0eC5fX29yaWdpbmFsUmVjdDtcbiAgICBjdHguY2xvc2VQYXRoID0gY3R4Ll9fb3JpZ2luYWxDbG9zZVBhdGg7XG4gICAgY3R4LmJlZ2luUGF0aCA9IGN0eC5fX29yaWdpbmFsQmVnaW5QYXRoO1xuICAgIGRlbGV0ZSBjdHguX3JlbW92ZU1pcnJvcmluZztcbiAgfTtcbiAgY3R4LnNhdmUgPSBmdW5jdGlvbiBjdHhTYXZlKCkge1xuICAgIGRlc3RDdHguc2F2ZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFNhdmUoKTtcbiAgfTtcbiAgY3R4LnJlc3RvcmUgPSBmdW5jdGlvbiBjdHhSZXN0b3JlKCkge1xuICAgIGRlc3RDdHgucmVzdG9yZSgpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJlc3RvcmUoKTtcbiAgfTtcbiAgY3R4LnRyYW5zbGF0ZSA9IGZ1bmN0aW9uIGN0eFRyYW5zbGF0ZSh4LCB5KSB7XG4gICAgZGVzdEN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNsYXRlKHgsIHkpO1xuICB9O1xuICBjdHguc2NhbGUgPSBmdW5jdGlvbiBjdHhTY2FsZSh4LCB5KSB7XG4gICAgZGVzdEN0eC5zY2FsZSh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTY2FsZSh4LCB5KTtcbiAgfTtcbiAgY3R4LnRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgZGVzdEN0eC50cmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gICAgdGhpcy5fX29yaWdpbmFsVHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICB9O1xuICBjdHguc2V0VHJhbnNmb3JtID0gZnVuY3Rpb24gY3R4U2V0VHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpIHtcbiAgICBkZXN0Q3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxTZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgZSwgZik7XG4gIH07XG4gIGN0eC5yZXNldFRyYW5zZm9ybSA9IGZ1bmN0aW9uIGN0eFJlc2V0VHJhbnNmb3JtKCkge1xuICAgIGRlc3RDdHgucmVzZXRUcmFuc2Zvcm0oKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZXNldFRyYW5zZm9ybSgpO1xuICB9O1xuICBjdHgucm90YXRlID0gZnVuY3Rpb24gY3R4Um90YXRlKGFuZ2xlKSB7XG4gICAgZGVzdEN0eC5yb3RhdGUoYW5nbGUpO1xuICAgIHRoaXMuX19vcmlnaW5hbFJvdGF0ZShhbmdsZSk7XG4gIH07XG4gIGN0eC5jbGlwID0gZnVuY3Rpb24gY3R4Um90YXRlKHJ1bGUpIHtcbiAgICBkZXN0Q3R4LmNsaXAocnVsZSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xpcChydWxlKTtcbiAgfTtcbiAgY3R4Lm1vdmVUbyA9IGZ1bmN0aW9uICh4LCB5KSB7XG4gICAgZGVzdEN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsTW92ZVRvKHgsIHkpO1xuICB9O1xuICBjdHgubGluZVRvID0gZnVuY3Rpb24gKHgsIHkpIHtcbiAgICBkZXN0Q3R4LmxpbmVUbyh4LCB5KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxMaW5lVG8oeCwgeSk7XG4gIH07XG4gIGN0eC5iZXppZXJDdXJ2ZVRvID0gZnVuY3Rpb24gKGNwMXgsIGNwMXksIGNwMngsIGNwMnksIHgsIHkpIHtcbiAgICBkZXN0Q3R4LmJlemllckN1cnZlVG8oY3AxeCwgY3AxeSwgY3AyeCwgY3AyeSwgeCwgeSk7XG4gICAgdGhpcy5fX29yaWdpbmFsQmV6aWVyQ3VydmVUbyhjcDF4LCBjcDF5LCBjcDJ4LCBjcDJ5LCB4LCB5KTtcbiAgfTtcbiAgY3R4LnJlY3QgPSBmdW5jdGlvbiAoeCwgeSwgd2lkdGgsIGhlaWdodCkge1xuICAgIGRlc3RDdHgucmVjdCh4LCB5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLl9fb3JpZ2luYWxSZWN0KHgsIHksIHdpZHRoLCBoZWlnaHQpO1xuICB9O1xuICBjdHguY2xvc2VQYXRoID0gZnVuY3Rpb24gKCkge1xuICAgIGRlc3RDdHguY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5fX29yaWdpbmFsQ2xvc2VQYXRoKCk7XG4gIH07XG4gIGN0eC5iZWdpblBhdGggPSBmdW5jdGlvbiAoKSB7XG4gICAgZGVzdEN0eC5iZWdpblBhdGgoKTtcbiAgICB0aGlzLl9fb3JpZ2luYWxCZWdpblBhdGgoKTtcbiAgfTtcbn1cbmNsYXNzIENhY2hlZENhbnZhc2VzIHtcbiAgY29uc3RydWN0b3IoY2FudmFzRmFjdG9yeSkge1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5jYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgZ2V0Q2FudmFzKGlkLCB3aWR0aCwgaGVpZ2h0KSB7XG4gICAgbGV0IGNhbnZhc0VudHJ5O1xuICAgIGlmICh0aGlzLmNhY2hlW2lkXSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjYW52YXNFbnRyeSA9IHRoaXMuY2FjaGVbaWRdO1xuICAgICAgdGhpcy5jYW52YXNGYWN0b3J5LnJlc2V0KGNhbnZhc0VudHJ5LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FudmFzRW50cnkgPSB0aGlzLmNhbnZhc0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jYWNoZVtpZF0gPSBjYW52YXNFbnRyeTtcbiAgICB9XG4gICAgcmV0dXJuIGNhbnZhc0VudHJ5O1xuICB9XG4gIGRlbGV0ZShpZCkge1xuICAgIGRlbGV0ZSB0aGlzLmNhY2hlW2lkXTtcbiAgfVxuICBjbGVhcigpIHtcbiAgICBmb3IgKGNvbnN0IGlkIGluIHRoaXMuY2FjaGUpIHtcbiAgICAgIGNvbnN0IGNhbnZhc0VudHJ5ID0gdGhpcy5jYWNoZVtpZF07XG4gICAgICB0aGlzLmNhbnZhc0ZhY3RvcnkuZGVzdHJveShjYW52YXNFbnRyeSk7XG4gICAgICBkZWxldGUgdGhpcy5jYWNoZVtpZF07XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIGRlc3RYLCBkZXN0WSwgZGVzdFcsIGRlc3RIKSB7XG4gIGNvbnN0IFthLCBiLCBjLCBkLCB0eCwgdHldID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN0eCk7XG4gIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICBjb25zdCB0bFggPSBkZXN0WCAqIGEgKyB0eDtcbiAgICBjb25zdCByVGxYID0gTWF0aC5yb3VuZCh0bFgpO1xuICAgIGNvbnN0IHRsWSA9IGRlc3RZICogZCArIHR5O1xuICAgIGNvbnN0IHJUbFkgPSBNYXRoLnJvdW5kKHRsWSk7XG4gICAgY29uc3QgYnJYID0gKGRlc3RYICsgZGVzdFcpICogYSArIHR4O1xuICAgIGNvbnN0IHJXaWR0aCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJYKSAtIHJUbFgpIHx8IDE7XG4gICAgY29uc3QgYnJZID0gKGRlc3RZICsgZGVzdEgpICogZCArIHR5O1xuICAgIGNvbnN0IHJIZWlnaHQgPSBNYXRoLmFicyhNYXRoLnJvdW5kKGJyWSkgLSByVGxZKSB8fCAxO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oTWF0aC5zaWduKGEpLCAwLCAwLCBNYXRoLnNpZ24oZCksIHJUbFgsIHJUbFkpO1xuICAgIGN0eC5kcmF3SW1hZ2Uoc3JjSW1nLCBzcmNYLCBzcmNZLCBzcmNXLCBzcmNILCAwLCAwLCByV2lkdGgsIHJIZWlnaHQpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oYSwgYiwgYywgZCwgdHgsIHR5KTtcbiAgICByZXR1cm4gW3JXaWR0aCwgckhlaWdodF07XG4gIH1cbiAgaWYgKGEgPT09IDAgJiYgZCA9PT0gMCkge1xuICAgIGNvbnN0IHRsWCA9IGRlc3RZICogYyArIHR4O1xuICAgIGNvbnN0IHJUbFggPSBNYXRoLnJvdW5kKHRsWCk7XG4gICAgY29uc3QgdGxZID0gZGVzdFggKiBiICsgdHk7XG4gICAgY29uc3QgclRsWSA9IE1hdGgucm91bmQodGxZKTtcbiAgICBjb25zdCBiclggPSAoZGVzdFkgKyBkZXN0SCkgKiBjICsgdHg7XG4gICAgY29uc3QgcldpZHRoID0gTWF0aC5hYnMoTWF0aC5yb3VuZChiclgpIC0gclRsWCkgfHwgMTtcbiAgICBjb25zdCBiclkgPSAoZGVzdFggKyBkZXN0VykgKiBiICsgdHk7XG4gICAgY29uc3QgckhlaWdodCA9IE1hdGguYWJzKE1hdGgucm91bmQoYnJZKSAtIHJUbFkpIHx8IDE7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgwLCBNYXRoLnNpZ24oYiksIE1hdGguc2lnbihjKSwgMCwgclRsWCwgclRsWSk7XG4gICAgY3R4LmRyYXdJbWFnZShzcmNJbWcsIHNyY1gsIHNyY1ksIHNyY1csIHNyY0gsIDAsIDAsIHJIZWlnaHQsIHJXaWR0aCk7XG4gICAgY3R4LnNldFRyYW5zZm9ybShhLCBiLCBjLCBkLCB0eCwgdHkpO1xuICAgIHJldHVybiBbckhlaWdodCwgcldpZHRoXTtcbiAgfVxuICBjdHguZHJhd0ltYWdlKHNyY0ltZywgc3JjWCwgc3JjWSwgc3JjVywgc3JjSCwgZGVzdFgsIGRlc3RZLCBkZXN0VywgZGVzdEgpO1xuICBjb25zdCBzY2FsZVggPSBNYXRoLmh5cG90KGEsIGIpO1xuICBjb25zdCBzY2FsZVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICByZXR1cm4gW3NjYWxlWCAqIGRlc3RXLCBzY2FsZVkgKiBkZXN0SF07XG59XG5mdW5jdGlvbiBjb21waWxlVHlwZTNHbHlwaChpbWdEYXRhKSB7XG4gIGNvbnN0IHtcbiAgICB3aWR0aCxcbiAgICBoZWlnaHRcbiAgfSA9IGltZ0RhdGE7XG4gIGlmICh3aWR0aCA+IE1BWF9TSVpFX1RPX0NPTVBJTEUgfHwgaGVpZ2h0ID4gTUFYX1NJWkVfVE9fQ09NUElMRSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IFBPSU5UX1RPX1BST0NFU1NfTElNSVQgPSAxMDAwO1xuICBjb25zdCBQT0lOVF9UWVBFUyA9IG5ldyBVaW50OEFycmF5KFswLCAyLCA0LCAwLCAxLCAwLCA1LCA0LCA4LCAxMCwgMCwgOCwgMCwgMiwgMSwgMF0pO1xuICBjb25zdCB3aWR0aDEgPSB3aWR0aCArIDE7XG4gIGxldCBwb2ludHMgPSBuZXcgVWludDhBcnJheSh3aWR0aDEgKiAoaGVpZ2h0ICsgMSkpO1xuICBsZXQgaSwgaiwgajA7XG4gIGNvbnN0IGxpbmVTaXplID0gd2lkdGggKyA3ICYgfjc7XG4gIGxldCBkYXRhID0gbmV3IFVpbnQ4QXJyYXkobGluZVNpemUgKiBoZWlnaHQpLFxuICAgIHBvcyA9IDA7XG4gIGZvciAoY29uc3QgZWxlbSBvZiBpbWdEYXRhLmRhdGEpIHtcbiAgICBsZXQgbWFzayA9IDEyODtcbiAgICB3aGlsZSAobWFzayA+IDApIHtcbiAgICAgIGRhdGFbcG9zKytdID0gZWxlbSAmIG1hc2sgPyAwIDogMjU1O1xuICAgICAgbWFzayA+Pj0gMTtcbiAgICB9XG4gIH1cbiAgbGV0IGNvdW50ID0gMDtcbiAgcG9zID0gMDtcbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1swXSA9IDE7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqXSA9IGRhdGFbcG9zXSA/IDIgOiAxO1xuICAgICAgKytjb3VudDtcbiAgICB9XG4gICAgcG9zKys7XG4gIH1cbiAgaWYgKGRhdGFbcG9zXSAhPT0gMCkge1xuICAgIHBvaW50c1tqXSA9IDI7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGkgPSAxOyBpIDwgaGVpZ2h0OyBpKyspIHtcbiAgICBwb3MgPSBpICogbGluZVNpemU7XG4gICAgajAgPSBpICogd2lkdGgxO1xuICAgIGlmIChkYXRhW3BvcyAtIGxpbmVTaXplXSAhPT0gZGF0YVtwb3NdKSB7XG4gICAgICBwb2ludHNbajBdID0gZGF0YVtwb3NdID8gMSA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBsZXQgc3VtID0gKGRhdGFbcG9zXSA/IDQgOiAwKSArIChkYXRhW3BvcyAtIGxpbmVTaXplXSA/IDggOiAwKTtcbiAgICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgICAgc3VtID0gKHN1bSA+PiAyKSArIChkYXRhW3BvcyArIDFdID8gNCA6IDApICsgKGRhdGFbcG9zIC0gbGluZVNpemUgKyAxXSA/IDggOiAwKTtcbiAgICAgIGlmIChQT0lOVF9UWVBFU1tzdW1dKSB7XG4gICAgICAgIHBvaW50c1tqMCArIGpdID0gUE9JTlRfVFlQRVNbc3VtXTtcbiAgICAgICAgKytjb3VudDtcbiAgICAgIH1cbiAgICAgIHBvcysrO1xuICAgIH1cbiAgICBpZiAoZGF0YVtwb3MgLSBsaW5lU2l6ZV0gIT09IGRhdGFbcG9zXSkge1xuICAgICAgcG9pbnRzW2owICsgal0gPSBkYXRhW3Bvc10gPyAyIDogNDtcbiAgICAgICsrY291bnQ7XG4gICAgfVxuICAgIGlmIChjb3VudCA+IFBPSU5UX1RPX1BST0NFU1NfTElNSVQpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgfVxuICBwb3MgPSBsaW5lU2l6ZSAqIChoZWlnaHQgLSAxKTtcbiAgajAgPSBpICogd2lkdGgxO1xuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owXSA9IDg7XG4gICAgKytjb3VudDtcbiAgfVxuICBmb3IgKGogPSAxOyBqIDwgd2lkdGg7IGorKykge1xuICAgIGlmIChkYXRhW3Bvc10gIT09IGRhdGFbcG9zICsgMV0pIHtcbiAgICAgIHBvaW50c1tqMCArIGpdID0gZGF0YVtwb3NdID8gNCA6IDg7XG4gICAgICArK2NvdW50O1xuICAgIH1cbiAgICBwb3MrKztcbiAgfVxuICBpZiAoZGF0YVtwb3NdICE9PSAwKSB7XG4gICAgcG9pbnRzW2owICsgal0gPSA0O1xuICAgICsrY291bnQ7XG4gIH1cbiAgaWYgKGNvdW50ID4gUE9JTlRfVE9fUFJPQ0VTU19MSU1JVCkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG4gIGNvbnN0IHN0ZXBzID0gbmV3IEludDMyQXJyYXkoWzAsIHdpZHRoMSwgLTEsIDAsIC13aWR0aDEsIDAsIDAsIDAsIDFdKTtcbiAgY29uc3QgcGF0aCA9IG5ldyBQYXRoMkQoKTtcbiAgZm9yIChpID0gMDsgY291bnQgJiYgaSA8PSBoZWlnaHQ7IGkrKykge1xuICAgIGxldCBwID0gaSAqIHdpZHRoMTtcbiAgICBjb25zdCBlbmQgPSBwICsgd2lkdGg7XG4gICAgd2hpbGUgKHAgPCBlbmQgJiYgIXBvaW50c1twXSkge1xuICAgICAgcCsrO1xuICAgIH1cbiAgICBpZiAocCA9PT0gZW5kKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgcGF0aC5tb3ZlVG8ocCAlIHdpZHRoMSwgaSk7XG4gICAgY29uc3QgcDAgPSBwO1xuICAgIGxldCB0eXBlID0gcG9pbnRzW3BdO1xuICAgIGRvIHtcbiAgICAgIGNvbnN0IHN0ZXAgPSBzdGVwc1t0eXBlXTtcbiAgICAgIGRvIHtcbiAgICAgICAgcCArPSBzdGVwO1xuICAgICAgfSB3aGlsZSAoIXBvaW50c1twXSk7XG4gICAgICBjb25zdCBwcCA9IHBvaW50c1twXTtcbiAgICAgIGlmIChwcCAhPT0gNSAmJiBwcCAhPT0gMTApIHtcbiAgICAgICAgdHlwZSA9IHBwO1xuICAgICAgICBwb2ludHNbcF0gPSAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdHlwZSA9IHBwICYgMHgzMyAqIHR5cGUgPj4gNDtcbiAgICAgICAgcG9pbnRzW3BdICY9IHR5cGUgPj4gMiB8IHR5cGUgPDwgMjtcbiAgICAgIH1cbiAgICAgIHBhdGgubGluZVRvKHAgJSB3aWR0aDEsIHAgLyB3aWR0aDEgfCAwKTtcbiAgICAgIGlmICghcG9pbnRzW3BdKSB7XG4gICAgICAgIC0tY291bnQ7XG4gICAgICB9XG4gICAgfSB3aGlsZSAocDAgIT09IHApO1xuICAgIC0taTtcbiAgfVxuICBkYXRhID0gbnVsbDtcbiAgcG9pbnRzID0gbnVsbDtcbiAgY29uc3QgZHJhd091dGxpbmUgPSBmdW5jdGlvbiAoYykge1xuICAgIGMuc2F2ZSgpO1xuICAgIGMuc2NhbGUoMSAvIHdpZHRoLCAtMSAvIGhlaWdodCk7XG4gICAgYy50cmFuc2xhdGUoMCwgLWhlaWdodCk7XG4gICAgYy5maWxsKHBhdGgpO1xuICAgIGMuYmVnaW5QYXRoKCk7XG4gICAgYy5yZXN0b3JlKCk7XG4gIH07XG4gIHJldHVybiBkcmF3T3V0bGluZTtcbn1cbmNsYXNzIENhbnZhc0V4dHJhU3RhdGUge1xuICBjb25zdHJ1Y3Rvcih3aWR0aCwgaGVpZ2h0KSB7XG4gICAgdGhpcy5hbHBoYUlzU2hhcGUgPSBmYWxzZTtcbiAgICB0aGlzLmZvbnRTaXplID0gMDtcbiAgICB0aGlzLmZvbnRTaXplU2NhbGUgPSAxO1xuICAgIHRoaXMudGV4dE1hdHJpeCA9IF91dGlsLklERU5USVRZX01BVFJJWDtcbiAgICB0aGlzLnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5mb250TWF0cml4ID0gX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5sZWFkaW5nID0gMDtcbiAgICB0aGlzLnggPSAwO1xuICAgIHRoaXMueSA9IDA7XG4gICAgdGhpcy5saW5lWCA9IDA7XG4gICAgdGhpcy5saW5lWSA9IDA7XG4gICAgdGhpcy5jaGFyU3BhY2luZyA9IDA7XG4gICAgdGhpcy53b3JkU3BhY2luZyA9IDA7XG4gICAgdGhpcy50ZXh0SFNjYWxlID0gMTtcbiAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTDtcbiAgICB0aGlzLnRleHRSaXNlID0gMDtcbiAgICB0aGlzLmZpbGxDb2xvciA9IFwiIzAwMDAwMFwiO1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLnBhdHRlcm5GaWxsID0gZmFsc2U7XG4gICAgdGhpcy5maWxsQWxwaGEgPSAxO1xuICAgIHRoaXMuc3Ryb2tlQWxwaGEgPSAxO1xuICAgIHRoaXMubGluZVdpZHRoID0gMTtcbiAgICB0aGlzLmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnRyYW5zZmVyTWFwcyA9IFwibm9uZVwiO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChbMCwgMCwgd2lkdGgsIGhlaWdodF0pO1xuICB9XG4gIGNsb25lKCkge1xuICAgIGNvbnN0IGNsb25lID0gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgICBjbG9uZS5jbGlwQm94ID0gdGhpcy5jbGlwQm94LnNsaWNlKCk7XG4gICAgcmV0dXJuIGNsb25lO1xuICB9XG4gIHNldEN1cnJlbnRQb2ludCh4LCB5KSB7XG4gICAgdGhpcy54ID0geDtcbiAgICB0aGlzLnkgPSB5O1xuICB9XG4gIHVwZGF0ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4LCB5KSB7XG4gICAgW3gsIHldID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbeCwgeV0sIHRyYW5zZm9ybSk7XG4gICAgdGhpcy5taW5YID0gTWF0aC5taW4odGhpcy5taW5YLCB4KTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHkpO1xuICAgIHRoaXMubWF4WCA9IE1hdGgubWF4KHRoaXMubWF4WCwgeCk7XG4gICAgdGhpcy5tYXhZID0gTWF0aC5tYXgodGhpcy5tYXhZLCB5KTtcbiAgfVxuICB1cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgcmVjdCkge1xuICAgIGNvbnN0IHAxID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LCB0cmFuc2Zvcm0pO1xuICAgIGNvbnN0IHAyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShyZWN0LnNsaWNlKDIpLCB0cmFuc2Zvcm0pO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgcDFbMF0sIHAyWzBdKTtcbiAgICB0aGlzLm1pblkgPSBNYXRoLm1pbih0aGlzLm1pblksIHAxWzFdLCBwMlsxXSk7XG4gICAgdGhpcy5tYXhYID0gTWF0aC5tYXgodGhpcy5tYXhYLCBwMVswXSwgcDJbMF0pO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgcDFbMV0sIHAyWzFdKTtcbiAgfVxuICB1cGRhdGVTY2FsaW5nUGF0aE1pbk1heCh0cmFuc2Zvcm0sIG1pbk1heCkge1xuICAgIF91dGlsLlV0aWwuc2NhbGVNaW5NYXgodHJhbnNmb3JtLCBtaW5NYXgpO1xuICAgIHRoaXMubWluWCA9IE1hdGgubWluKHRoaXMubWluWCwgbWluTWF4WzBdKTtcbiAgICB0aGlzLm1heFggPSBNYXRoLm1heCh0aGlzLm1heFgsIG1pbk1heFsxXSk7XG4gICAgdGhpcy5taW5ZID0gTWF0aC5taW4odGhpcy5taW5ZLCBtaW5NYXhbMl0pO1xuICAgIHRoaXMubWF4WSA9IE1hdGgubWF4KHRoaXMubWF4WSwgbWluTWF4WzNdKTtcbiAgfVxuICB1cGRhdGVDdXJ2ZVBhdGhNaW5NYXgodHJhbnNmb3JtLCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyLCB4MywgeTMsIG1pbk1heCkge1xuICAgIGNvbnN0IGJveCA9IF91dGlsLlV0aWwuYmV6aWVyQm91bmRpbmdCb3goeDAsIHkwLCB4MSwgeTEsIHgyLCB5MiwgeDMsIHkzKTtcbiAgICBpZiAobWluTWF4KSB7XG4gICAgICBtaW5NYXhbMF0gPSBNYXRoLm1pbihtaW5NYXhbMF0sIGJveFswXSwgYm94WzJdKTtcbiAgICAgIG1pbk1heFsxXSA9IE1hdGgubWF4KG1pbk1heFsxXSwgYm94WzBdLCBib3hbMl0pO1xuICAgICAgbWluTWF4WzJdID0gTWF0aC5taW4obWluTWF4WzJdLCBib3hbMV0sIGJveFszXSk7XG4gICAgICBtaW5NYXhbM10gPSBNYXRoLm1heChtaW5NYXhbM10sIGJveFsxXSwgYm94WzNdKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVSZWN0TWluTWF4KHRyYW5zZm9ybSwgYm94KTtcbiAgfVxuICBnZXRQYXRoQm91bmRpbmdCb3goKSB7XG4gICAgbGV0IHBhdGhUeXBlID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTDtcbiAgICBsZXQgdHJhbnNmb3JtID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIGNvbnN0IGJveCA9IFt0aGlzLm1pblgsIHRoaXMubWluWSwgdGhpcy5tYXhYLCB0aGlzLm1heFldO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLlNUUk9LRSkge1xuICAgICAgaWYgKCF0cmFuc2Zvcm0pIHtcbiAgICAgICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlN0cm9rZSBib3VuZGluZyBib3ggbXVzdCBpbmNsdWRlIHRyYW5zZm9ybS5cIik7XG4gICAgICB9XG4gICAgICBjb25zdCBzY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodHJhbnNmb3JtKTtcbiAgICAgIGNvbnN0IHhTdHJva2VQYWQgPSBzY2FsZVswXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGNvbnN0IHlTdHJva2VQYWQgPSBzY2FsZVsxXSAqIHRoaXMubGluZVdpZHRoIC8gMjtcbiAgICAgIGJveFswXSAtPSB4U3Ryb2tlUGFkO1xuICAgICAgYm94WzFdIC09IHlTdHJva2VQYWQ7XG4gICAgICBib3hbMl0gKz0geFN0cm9rZVBhZDtcbiAgICAgIGJveFszXSArPSB5U3Ryb2tlUGFkO1xuICAgIH1cbiAgICByZXR1cm4gYm94O1xuICB9XG4gIHVwZGF0ZUNsaXBGcm9tUGF0aCgpIHtcbiAgICBjb25zdCBpbnRlcnNlY3QgPSBfdXRpbC5VdGlsLmludGVyc2VjdCh0aGlzLmNsaXBCb3gsIHRoaXMuZ2V0UGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChpbnRlcnNlY3QgfHwgWzAsIDAsIDAsIDBdKTtcbiAgfVxuICBpc0VtcHR5Q2xpcCgpIHtcbiAgICByZXR1cm4gdGhpcy5taW5YID09PSBJbmZpbml0eTtcbiAgfVxuICBzdGFydE5ld1BhdGhBbmRDbGlwQm94KGJveCkge1xuICAgIHRoaXMuY2xpcEJveCA9IGJveDtcbiAgICB0aGlzLm1pblggPSBJbmZpbml0eTtcbiAgICB0aGlzLm1pblkgPSBJbmZpbml0eTtcbiAgICB0aGlzLm1heFggPSAwO1xuICAgIHRoaXMubWF4WSA9IDA7XG4gIH1cbiAgZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpIHtcbiAgICBsZXQgcGF0aFR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMO1xuICAgIGxldCB0cmFuc2Zvcm0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgcmV0dXJuIF91dGlsLlV0aWwuaW50ZXJzZWN0KHRoaXMuY2xpcEJveCwgdGhpcy5nZXRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsIHRyYW5zZm9ybSkpO1xuICB9XG59XG5mdW5jdGlvbiBwdXRCaW5hcnlJbWFnZURhdGEoY3R4LCBpbWdEYXRhKSB7XG4gIGlmICh0eXBlb2YgSW1hZ2VEYXRhICE9PSBcInVuZGVmaW5lZFwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBJbWFnZURhdGEpIHtcbiAgICBjdHgucHV0SW1hZ2VEYXRhKGltZ0RhdGEsIDAsIDApO1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodCxcbiAgICB3aWR0aCA9IGltZ0RhdGEud2lkdGg7XG4gIGNvbnN0IHBhcnRpYWxDaHVua0hlaWdodCA9IGhlaWdodCAlIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCBmdWxsQ2h1bmtzID0gKGhlaWdodCAtIHBhcnRpYWxDaHVua0hlaWdodCkgLyBGVUxMX0NIVU5LX0hFSUdIVDtcbiAgY29uc3QgdG90YWxDaHVua3MgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQgPT09IDAgPyBmdWxsQ2h1bmtzIDogZnVsbENodW5rcyArIDE7XG4gIGNvbnN0IGNodW5rSW1nRGF0YSA9IGN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgbGV0IHNyY1BvcyA9IDAsXG4gICAgZGVzdFBvcztcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGxldCBpLCBqLCB0aGlzQ2h1bmtIZWlnaHQsIGVsZW1zSW5UaGlzQ2h1bms7XG4gIGlmIChpbWdEYXRhLmtpbmQgPT09IF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUCkge1xuICAgIGNvbnN0IHNyY0xlbmd0aCA9IHNyYy5ieXRlTGVuZ3RoO1xuICAgIGNvbnN0IGRlc3QzMiA9IG5ldyBVaW50MzJBcnJheShkZXN0LmJ1ZmZlciwgMCwgZGVzdC5ieXRlTGVuZ3RoID4+IDIpO1xuICAgIGNvbnN0IGRlc3QzMkRhdGFMZW5ndGggPSBkZXN0MzIubGVuZ3RoO1xuICAgIGNvbnN0IGZ1bGxTcmNEaWZmID0gd2lkdGggKyA3ID4+IDM7XG4gICAgY29uc3Qgd2hpdGUgPSAweGZmZmZmZmZmO1xuICAgIGNvbnN0IGJsYWNrID0gX3V0aWwuRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgdGhpc0NodW5rSGVpZ2h0ID0gaSA8IGZ1bGxDaHVua3MgPyBGVUxMX0NIVU5LX0hFSUdIVCA6IHBhcnRpYWxDaHVua0hlaWdodDtcbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gMDsgaiA8IHRoaXNDaHVua0hlaWdodDsgaisrKSB7XG4gICAgICAgIGNvbnN0IHNyY0RpZmYgPSBzcmNMZW5ndGggLSBzcmNQb3M7XG4gICAgICAgIGxldCBrID0gMDtcbiAgICAgICAgY29uc3Qga0VuZCA9IHNyY0RpZmYgPiBmdWxsU3JjRGlmZiA/IHdpZHRoIDogc3JjRGlmZiAqIDggLSA3O1xuICAgICAgICBjb25zdCBrRW5kVW5yb2xsZWQgPSBrRW5kICYgfjc7XG4gICAgICAgIGxldCBtYXNrID0gMDtcbiAgICAgICAgbGV0IHNyY0J5dGUgPSAwO1xuICAgICAgICBmb3IgKDsgayA8IGtFbmRVbnJvbGxlZDsgayArPSA4KSB7XG4gICAgICAgICAgc3JjQnl0ZSA9IHNyY1tzcmNQb3MrK107XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMTI4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA2NCA/IHdoaXRlIDogYmxhY2s7XG4gICAgICAgICAgZGVzdDMyW2Rlc3RQb3MrK10gPSBzcmNCeXRlICYgMzIgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIDE2ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA4ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiA0ID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAyID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IHNyY0J5dGUgJiAxID8gd2hpdGUgOiBibGFjaztcbiAgICAgICAgfVxuICAgICAgICBmb3IgKDsgayA8IGtFbmQ7IGsrKykge1xuICAgICAgICAgIGlmIChtYXNrID09PSAwKSB7XG4gICAgICAgICAgICBzcmNCeXRlID0gc3JjW3NyY1BvcysrXTtcbiAgICAgICAgICAgIG1hc2sgPSAxMjg7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlc3QzMltkZXN0UG9zKytdID0gc3JjQnl0ZSAmIG1hc2sgPyB3aGl0ZSA6IGJsYWNrO1xuICAgICAgICAgIG1hc2sgPj49IDE7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIHdoaWxlIChkZXN0UG9zIDwgZGVzdDMyRGF0YUxlbmd0aCkge1xuICAgICAgICBkZXN0MzJbZGVzdFBvcysrXSA9IDA7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaW1nRGF0YS5raW5kID09PSBfdXRpbC5JbWFnZUtpbmQuUkdCQV8zMkJQUCkge1xuICAgIGogPSAwO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIEZVTExfQ0hVTktfSEVJR0hUICogNDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZnVsbENodW5rczsgaSsrKSB7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBzcmNQb3MgKz0gZWxlbXNJblRoaXNDaHVuaztcbiAgICAgIGN0eC5wdXRJbWFnZURhdGEoY2h1bmtJbWdEYXRhLCAwLCBqKTtcbiAgICAgIGogKz0gRlVMTF9DSFVOS19IRUlHSFQ7XG4gICAgfVxuICAgIGlmIChpIDwgdG90YWxDaHVua3MpIHtcbiAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHBhcnRpYWxDaHVua0hlaWdodCAqIDQ7XG4gICAgICBkZXN0LnNldChzcmMuc3ViYXJyYXkoc3JjUG9zLCBzcmNQb3MgKyBlbGVtc0luVGhpc0NodW5rKSk7XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaik7XG4gICAgfVxuICB9IGVsc2UgaWYgKGltZ0RhdGEua2luZCA9PT0gX3V0aWwuSW1hZ2VLaW5kLlJHQl8yNEJQUCkge1xuICAgIHRoaXNDaHVua0hlaWdodCA9IEZVTExfQ0hVTktfSEVJR0hUO1xuICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICBmb3IgKGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgICAgaWYgKGkgPj0gZnVsbENodW5rcykge1xuICAgICAgICB0aGlzQ2h1bmtIZWlnaHQgPSBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgICAgIGVsZW1zSW5UaGlzQ2h1bmsgPSB3aWR0aCAqIHRoaXNDaHVua0hlaWdodDtcbiAgICAgIH1cbiAgICAgIGRlc3RQb3MgPSAwO1xuICAgICAgZm9yIChqID0gZWxlbXNJblRoaXNDaHVuazsgai0tOykge1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSBzcmNbc3JjUG9zKytdO1xuICAgICAgICBkZXN0W2Rlc3RQb3MrK10gPSAyNTU7XG4gICAgICB9XG4gICAgICBjdHgucHV0SW1hZ2VEYXRhKGNodW5rSW1nRGF0YSwgMCwgaSAqIEZVTExfQ0hVTktfSEVJR0hUKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBiYWQgaW1hZ2Uga2luZDogJHtpbWdEYXRhLmtpbmR9YCk7XG4gIH1cbn1cbmZ1bmN0aW9uIHB1dEJpbmFyeUltYWdlTWFzayhjdHgsIGltZ0RhdGEpIHtcbiAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgY3R4LmRyYXdJbWFnZShpbWdEYXRhLmJpdG1hcCwgMCwgMCk7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0LFxuICAgIHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgY29uc3QgcGFydGlhbENodW5rSGVpZ2h0ID0gaGVpZ2h0ICUgRlVMTF9DSFVOS19IRUlHSFQ7XG4gIGNvbnN0IGZ1bGxDaHVua3MgPSAoaGVpZ2h0IC0gcGFydGlhbENodW5rSGVpZ2h0KSAvIEZVTExfQ0hVTktfSEVJR0hUO1xuICBjb25zdCB0b3RhbENodW5rcyA9IHBhcnRpYWxDaHVua0hlaWdodCA9PT0gMCA/IGZ1bGxDaHVua3MgOiBmdWxsQ2h1bmtzICsgMTtcbiAgY29uc3QgY2h1bmtJbWdEYXRhID0gY3R4LmNyZWF0ZUltYWdlRGF0YSh3aWR0aCwgRlVMTF9DSFVOS19IRUlHSFQpO1xuICBsZXQgc3JjUG9zID0gMDtcbiAgY29uc3Qgc3JjID0gaW1nRGF0YS5kYXRhO1xuICBjb25zdCBkZXN0ID0gY2h1bmtJbWdEYXRhLmRhdGE7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgdG90YWxDaHVua3M7IGkrKykge1xuICAgIGNvbnN0IHRoaXNDaHVua0hlaWdodCA9IGkgPCBmdWxsQ2h1bmtzID8gRlVMTF9DSFVOS19IRUlHSFQgOiBwYXJ0aWFsQ2h1bmtIZWlnaHQ7XG4gICAgKHtcbiAgICAgIHNyY1Bvc1xuICAgIH0gPSAoMCwgX2ltYWdlX3V0aWxzLmNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKSh7XG4gICAgICBzcmMsXG4gICAgICBzcmNQb3MsXG4gICAgICBkZXN0LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQ6IHRoaXNDaHVua0hlaWdodCxcbiAgICAgIG5vbkJsYWNrQ29sb3I6IDBcbiAgICB9KSk7XG4gICAgY3R4LnB1dEltYWdlRGF0YShjaHVua0ltZ0RhdGEsIDAsIGkgKiBGVUxMX0NIVU5LX0hFSUdIVCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGNvcHlDdHhTdGF0ZShzb3VyY2VDdHgsIGRlc3RDdHgpIHtcbiAgY29uc3QgcHJvcGVydGllcyA9IFtcInN0cm9rZVN0eWxlXCIsIFwiZmlsbFN0eWxlXCIsIFwiZmlsbFJ1bGVcIiwgXCJnbG9iYWxBbHBoYVwiLCBcImxpbmVXaWR0aFwiLCBcImxpbmVDYXBcIiwgXCJsaW5lSm9pblwiLCBcIm1pdGVyTGltaXRcIiwgXCJnbG9iYWxDb21wb3NpdGVPcGVyYXRpb25cIiwgXCJmb250XCIsIFwiZmlsdGVyXCJdO1xuICBmb3IgKGNvbnN0IHByb3BlcnR5IG9mIHByb3BlcnRpZXMpIHtcbiAgICBpZiAoc291cmNlQ3R4W3Byb3BlcnR5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBkZXN0Q3R4W3Byb3BlcnR5XSA9IHNvdXJjZUN0eFtwcm9wZXJ0eV07XG4gICAgfVxuICB9XG4gIGlmIChzb3VyY2VDdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGRlc3RDdHguc2V0TGluZURhc2goc291cmNlQ3R4LmdldExpbmVEYXNoKCkpO1xuICAgIGRlc3RDdHgubGluZURhc2hPZmZzZXQgPSBzb3VyY2VDdHgubGluZURhc2hPZmZzZXQ7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlc2V0Q3R4VG9EZWZhdWx0KGN0eCkge1xuICBjdHguc3Ryb2tlU3R5bGUgPSBjdHguZmlsbFN0eWxlID0gXCIjMDAwMDAwXCI7XG4gIGN0eC5maWxsUnVsZSA9IFwibm9uemVyb1wiO1xuICBjdHguZ2xvYmFsQWxwaGEgPSAxO1xuICBjdHgubGluZVdpZHRoID0gMTtcbiAgY3R4LmxpbmVDYXAgPSBcImJ1dHRcIjtcbiAgY3R4LmxpbmVKb2luID0gXCJtaXRlclwiO1xuICBjdHgubWl0ZXJMaW1pdCA9IDEwO1xuICBjdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gXCJzb3VyY2Utb3ZlclwiO1xuICBjdHguZm9udCA9IFwiMTBweCBzYW5zLXNlcmlmXCI7XG4gIGlmIChjdHguc2V0TGluZURhc2ggIT09IHVuZGVmaW5lZCkge1xuICAgIGN0eC5zZXRMaW5lRGFzaChbXSk7XG4gICAgY3R4LmxpbmVEYXNoT2Zmc2V0ID0gMDtcbiAgfVxuICBpZiAoIV91dGlsLmlzTm9kZUpTKSB7XG4gICAgY29uc3Qge1xuICAgICAgZmlsdGVyXG4gICAgfSA9IGN0eDtcbiAgICBpZiAoZmlsdGVyICE9PSBcIm5vbmVcIiAmJiBmaWx0ZXIgIT09IFwiXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gIH1cbn1cbmZ1bmN0aW9uIGNvbXBvc2VTTWFza0JhY2tkcm9wKGJ5dGVzLCByMCwgZzAsIGIwKSB7XG4gIGNvbnN0IGxlbmd0aCA9IGJ5dGVzLmxlbmd0aDtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IGFscGhhID0gYnl0ZXNbaV07XG4gICAgaWYgKGFscGhhID09PSAwKSB7XG4gICAgICBieXRlc1tpIC0gM10gPSByMDtcbiAgICAgIGJ5dGVzW2kgLSAyXSA9IGcwO1xuICAgICAgYnl0ZXNbaSAtIDFdID0gYjA7XG4gICAgfSBlbHNlIGlmIChhbHBoYSA8IDI1NSkge1xuICAgICAgY29uc3QgYWxwaGFfID0gMjU1IC0gYWxwaGE7XG4gICAgICBieXRlc1tpIC0gM10gPSBieXRlc1tpIC0gM10gKiBhbHBoYSArIHIwICogYWxwaGFfID4+IDg7XG4gICAgICBieXRlc1tpIC0gMl0gPSBieXRlc1tpIC0gMl0gKiBhbHBoYSArIGcwICogYWxwaGFfID4+IDg7XG4gICAgICBieXRlc1tpIC0gMV0gPSBieXRlc1tpIC0gMV0gKiBhbHBoYSArIGIwICogYWxwaGFfID4+IDg7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU01hc2tBbHBoYShtYXNrRGF0YSwgbGF5ZXJEYXRhLCB0cmFuc2Zlck1hcCkge1xuICBjb25zdCBsZW5ndGggPSBtYXNrRGF0YS5sZW5ndGg7XG4gIGNvbnN0IHNjYWxlID0gMSAvIDI1NTtcbiAgZm9yIChsZXQgaSA9IDM7IGkgPCBsZW5ndGg7IGkgKz0gNCkge1xuICAgIGNvbnN0IGFscGhhID0gdHJhbnNmZXJNYXAgPyB0cmFuc2Zlck1hcFttYXNrRGF0YVtpXV0gOiBtYXNrRGF0YVtpXTtcbiAgICBsYXllckRhdGFbaV0gPSBsYXllckRhdGFbaV0gKiBhbHBoYSAqIHNjYWxlIHwgMDtcbiAgfVxufVxuZnVuY3Rpb24gY29tcG9zZVNNYXNrTHVtaW5vc2l0eShtYXNrRGF0YSwgbGF5ZXJEYXRhLCB0cmFuc2Zlck1hcCkge1xuICBjb25zdCBsZW5ndGggPSBtYXNrRGF0YS5sZW5ndGg7XG4gIGZvciAobGV0IGkgPSAzOyBpIDwgbGVuZ3RoOyBpICs9IDQpIHtcbiAgICBjb25zdCB5ID0gbWFza0RhdGFbaSAtIDNdICogNzcgKyBtYXNrRGF0YVtpIC0gMl0gKiAxNTIgKyBtYXNrRGF0YVtpIC0gMV0gKiAyODtcbiAgICBsYXllckRhdGFbaV0gPSB0cmFuc2Zlck1hcCA/IGxheWVyRGF0YVtpXSAqIHRyYW5zZmVyTWFwW3kgPj4gOF0gPj4gOCA6IGxheWVyRGF0YVtpXSAqIHkgPj4gMTY7XG4gIH1cbn1cbmZ1bmN0aW9uIGdlbmVyaWNDb21wb3NlU01hc2sobWFza0N0eCwgbGF5ZXJDdHgsIHdpZHRoLCBoZWlnaHQsIHN1YnR5cGUsIGJhY2tkcm9wLCB0cmFuc2Zlck1hcCwgbGF5ZXJPZmZzZXRYLCBsYXllck9mZnNldFksIG1hc2tPZmZzZXRYLCBtYXNrT2Zmc2V0WSkge1xuICBjb25zdCBoYXNCYWNrZHJvcCA9ICEhYmFja2Ryb3A7XG4gIGNvbnN0IHIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFswXSA6IDA7XG4gIGNvbnN0IGcwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsxXSA6IDA7XG4gIGNvbnN0IGIwID0gaGFzQmFja2Ryb3AgPyBiYWNrZHJvcFsyXSA6IDA7XG4gIGNvbnN0IGNvbXBvc2VGbiA9IHN1YnR5cGUgPT09IFwiTHVtaW5vc2l0eVwiID8gY29tcG9zZVNNYXNrTHVtaW5vc2l0eSA6IGNvbXBvc2VTTWFza0FscGhhO1xuICBjb25zdCBQSVhFTFNfVE9fUFJPQ0VTUyA9IDEwNDg1NzY7XG4gIGNvbnN0IGNodW5rU2l6ZSA9IE1hdGgubWluKGhlaWdodCwgTWF0aC5jZWlsKFBJWEVMU19UT19QUk9DRVNTIC8gd2lkdGgpKTtcbiAgZm9yIChsZXQgcm93ID0gMDsgcm93IDwgaGVpZ2h0OyByb3cgKz0gY2h1bmtTaXplKSB7XG4gICAgY29uc3QgY2h1bmtIZWlnaHQgPSBNYXRoLm1pbihjaHVua1NpemUsIGhlaWdodCAtIHJvdyk7XG4gICAgY29uc3QgbWFza0RhdGEgPSBtYXNrQ3R4LmdldEltYWdlRGF0YShsYXllck9mZnNldFggLSBtYXNrT2Zmc2V0WCwgcm93ICsgKGxheWVyT2Zmc2V0WSAtIG1hc2tPZmZzZXRZKSwgd2lkdGgsIGNodW5rSGVpZ2h0KTtcbiAgICBjb25zdCBsYXllckRhdGEgPSBsYXllckN0eC5nZXRJbWFnZURhdGEobGF5ZXJPZmZzZXRYLCByb3cgKyBsYXllck9mZnNldFksIHdpZHRoLCBjaHVua0hlaWdodCk7XG4gICAgaWYgKGhhc0JhY2tkcm9wKSB7XG4gICAgICBjb21wb3NlU01hc2tCYWNrZHJvcChtYXNrRGF0YS5kYXRhLCByMCwgZzAsIGIwKTtcbiAgICB9XG4gICAgY29tcG9zZUZuKG1hc2tEYXRhLmRhdGEsIGxheWVyRGF0YS5kYXRhLCB0cmFuc2Zlck1hcCk7XG4gICAgbGF5ZXJDdHgucHV0SW1hZ2VEYXRhKGxheWVyRGF0YSwgbGF5ZXJPZmZzZXRYLCByb3cgKyBsYXllck9mZnNldFkpO1xuICB9XG59XG5mdW5jdGlvbiBjb21wb3NlU01hc2soY3R4LCBzbWFzaywgbGF5ZXJDdHgsIGxheWVyQm94KSB7XG4gIGNvbnN0IGxheWVyT2Zmc2V0WCA9IGxheWVyQm94WzBdO1xuICBjb25zdCBsYXllck9mZnNldFkgPSBsYXllckJveFsxXTtcbiAgY29uc3QgbGF5ZXJXaWR0aCA9IGxheWVyQm94WzJdIC0gbGF5ZXJPZmZzZXRYO1xuICBjb25zdCBsYXllckhlaWdodCA9IGxheWVyQm94WzNdIC0gbGF5ZXJPZmZzZXRZO1xuICBpZiAobGF5ZXJXaWR0aCA9PT0gMCB8fCBsYXllckhlaWdodCA9PT0gMCkge1xuICAgIHJldHVybjtcbiAgfVxuICBnZW5lcmljQ29tcG9zZVNNYXNrKHNtYXNrLmNvbnRleHQsIGxheWVyQ3R4LCBsYXllcldpZHRoLCBsYXllckhlaWdodCwgc21hc2suc3VidHlwZSwgc21hc2suYmFja2Ryb3AsIHNtYXNrLnRyYW5zZmVyTWFwLCBsYXllck9mZnNldFgsIGxheWVyT2Zmc2V0WSwgc21hc2sub2Zmc2V0WCwgc21hc2sub2Zmc2V0WSk7XG4gIGN0eC5zYXZlKCk7XG4gIGN0eC5nbG9iYWxBbHBoYSA9IDE7XG4gIGN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1vdmVyXCI7XG4gIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gIGN0eC5kcmF3SW1hZ2UobGF5ZXJDdHguY2FudmFzLCAwLCAwKTtcbiAgY3R4LnJlc3RvcmUoKTtcbn1cbmZ1bmN0aW9uIGdldEltYWdlU21vb3RoaW5nRW5hYmxlZCh0cmFuc2Zvcm0sIGludGVycG9sYXRlKSB7XG4gIGNvbnN0IHNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0cmFuc2Zvcm0pO1xuICBzY2FsZVswXSA9IE1hdGguZnJvdW5kKHNjYWxlWzBdKTtcbiAgc2NhbGVbMV0gPSBNYXRoLmZyb3VuZChzY2FsZVsxXSk7XG4gIGNvbnN0IGFjdHVhbFNjYWxlID0gTWF0aC5mcm91bmQoKGdsb2JhbFRoaXMuZGV2aWNlUGl4ZWxSYXRpbyB8fCAxKSAqIF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gIGlmIChpbnRlcnBvbGF0ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIGludGVycG9sYXRlO1xuICB9IGVsc2UgaWYgKHNjYWxlWzBdIDw9IGFjdHVhbFNjYWxlIHx8IHNjYWxlWzFdIDw9IGFjdHVhbFNjYWxlKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufVxuY29uc3QgTElORV9DQVBfU1RZTEVTID0gW1wiYnV0dFwiLCBcInJvdW5kXCIsIFwic3F1YXJlXCJdO1xuY29uc3QgTElORV9KT0lOX1NUWUxFUyA9IFtcIm1pdGVyXCIsIFwicm91bmRcIiwgXCJiZXZlbFwiXTtcbmNvbnN0IE5PUk1BTF9DTElQID0ge307XG5jb25zdCBFT19DTElQID0ge307XG5jbGFzcyBDYW52YXNHcmFwaGljcyB7XG4gIGNvbnN0cnVjdG9yKGNhbnZhc0N0eCwgY29tbW9uT2Jqcywgb2JqcywgY2FudmFzRmFjdG9yeSwgZmlsdGVyRmFjdG9yeSwgX3JlZiwgYW5ub3RhdGlvbkNhbnZhc01hcCwgcGFnZUNvbG9ycykge1xuICAgIGxldCB7XG4gICAgICBvcHRpb25hbENvbnRlbnRDb25maWcsXG4gICAgICBtYXJrZWRDb250ZW50U3RhY2sgPSBudWxsXG4gICAgfSA9IF9yZWY7XG4gICAgdGhpcy5jdHggPSBjYW52YXNDdHg7XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnN0YXRlU3RhY2sgPSBbXTtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLnJlcyA9IG51bGw7XG4gICAgdGhpcy54b2JqcyA9IG51bGw7XG4gICAgdGhpcy5jb21tb25PYmpzID0gY29tbW9uT2JqcztcbiAgICB0aGlzLm9ianMgPSBvYmpzO1xuICAgIHRoaXMuY2FudmFzRmFjdG9yeSA9IGNhbnZhc0ZhY3Rvcnk7XG4gICAgdGhpcy5maWx0ZXJGYWN0b3J5ID0gZmlsdGVyRmFjdG9yeTtcbiAgICB0aGlzLmdyb3VwU3RhY2sgPSBbXTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gICAgdGhpcy5iYXNlVHJhbnNmb3JtID0gbnVsbDtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZ3JvdXBMZXZlbCA9IDA7XG4gICAgdGhpcy5zbWFza1N0YWNrID0gW107XG4gICAgdGhpcy5zbWFza0NvdW50ZXIgPSAwO1xuICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gICAgdGhpcy5jb250ZW50VmlzaWJsZSA9IHRydWU7XG4gICAgdGhpcy5tYXJrZWRDb250ZW50U3RhY2sgPSBtYXJrZWRDb250ZW50U3RhY2sgfHwgW107XG4gICAgdGhpcy5vcHRpb25hbENvbnRlbnRDb25maWcgPSBvcHRpb25hbENvbnRlbnRDb25maWc7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcyA9IG5ldyBDYWNoZWRDYW52YXNlcyh0aGlzLmNhbnZhc0ZhY3RvcnkpO1xuICAgIHRoaXMuY2FjaGVkUGF0dGVybnMgPSBuZXcgTWFwKCk7XG4gICAgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwID0gYW5ub3RhdGlvbkNhbnZhc01hcDtcbiAgICB0aGlzLnZpZXdwb3J0U2NhbGUgPSAxO1xuICAgIHRoaXMub3V0cHV0U2NhbGVYID0gMTtcbiAgICB0aGlzLm91dHB1dFNjYWxlWSA9IDE7XG4gICAgdGhpcy5wYWdlQ29sb3JzID0gcGFnZUNvbG9ycztcbiAgICB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nID0gWy0xLCAwXTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgICB0aGlzLl9jYWNoZWRCaXRtYXBzTWFwID0gbmV3IE1hcCgpO1xuICB9XG4gIGdldE9iamVjdChkYXRhKSB7XG4gICAgbGV0IGZhbGxiYWNrID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgcmV0dXJuIGRhdGEuc3RhcnRzV2l0aChcImdfXCIpID8gdGhpcy5jb21tb25PYmpzLmdldChkYXRhKSA6IHRoaXMub2Jqcy5nZXQoZGF0YSk7XG4gICAgfVxuICAgIHJldHVybiBmYWxsYmFjaztcbiAgfVxuICBiZWdpbkRyYXdpbmcoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgdHJhbnNmb3JtLFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0cmFuc3BhcmVuY3kgPSBmYWxzZSxcbiAgICAgIGJhY2tncm91bmQgPSBudWxsXG4gICAgfSA9IF9yZWYyO1xuICAgIGNvbnN0IHdpZHRoID0gdGhpcy5jdHguY2FudmFzLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3Qgc2F2ZWRGaWxsU3R5bGUgPSB0aGlzLmN0eC5maWxsU3R5bGU7XG4gICAgdGhpcy5jdHguZmlsbFN0eWxlID0gYmFja2dyb3VuZCB8fCBcIiNmZmZmZmZcIjtcbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmN0eC5maWxsU3R5bGUgPSBzYXZlZEZpbGxTdHlsZTtcbiAgICBpZiAodHJhbnNwYXJlbmN5KSB7XG4gICAgICBjb25zdCB0cmFuc3BhcmVudENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwidHJhbnNwYXJlbnRcIiwgd2lkdGgsIGhlaWdodCk7XG4gICAgICB0aGlzLmNvbXBvc2l0ZUN0eCA9IHRoaXMuY3R4O1xuICAgICAgdGhpcy50cmFuc3BhcmVudENhbnZhcyA9IHRyYW5zcGFyZW50Q2FudmFzLmNhbnZhcztcbiAgICAgIHRoaXMuY3R4ID0gdHJhbnNwYXJlbnRDYW52YXMuY29udGV4dDtcbiAgICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi4oMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jb21wb3NpdGVDdHgpKTtcbiAgICB9XG4gICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICBpZiAodHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC50cmFuc2Zvcm0oLi4udHJhbnNmb3JtKTtcbiAgICAgIHRoaXMub3V0cHV0U2NhbGVYID0gdHJhbnNmb3JtWzBdO1xuICAgICAgdGhpcy5vdXRwdXRTY2FsZVkgPSB0cmFuc2Zvcm1bMF07XG4gICAgfVxuICAgIHRoaXMuY3R4LnRyYW5zZm9ybSguLi52aWV3cG9ydC50cmFuc2Zvcm0pO1xuICAgIHRoaXMudmlld3BvcnRTY2FsZSA9IHZpZXdwb3J0LnNjYWxlO1xuICAgIHRoaXMuYmFzZVRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKSh0aGlzLmN0eCk7XG4gIH1cbiAgZXhlY3V0ZU9wZXJhdG9yTGlzdChvcGVyYXRvckxpc3QsIGV4ZWN1dGlvblN0YXJ0SWR4LCBjb250aW51ZUNhbGxiYWNrLCBzdGVwcGVyKSB7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgbGV0IGkgPSBleGVjdXRpb25TdGFydElkeCB8fCAwO1xuICAgIGNvbnN0IGFyZ3NBcnJheUxlbiA9IGFyZ3NBcnJheS5sZW5ndGg7XG4gICAgaWYgKGFyZ3NBcnJheUxlbiA9PT0gaSkge1xuICAgICAgcmV0dXJuIGk7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rT3BlcmF0aW9ucyA9IGFyZ3NBcnJheUxlbiAtIGkgPiBFWEVDVVRJT05fU1RFUFMgJiYgdHlwZW9mIGNvbnRpbnVlQ2FsbGJhY2sgPT09IFwiZnVuY3Rpb25cIjtcbiAgICBjb25zdCBlbmRUaW1lID0gY2h1bmtPcGVyYXRpb25zID8gRGF0ZS5ub3coKSArIEVYRUNVVElPTl9USU1FIDogMDtcbiAgICBsZXQgc3RlcHMgPSAwO1xuICAgIGNvbnN0IGNvbW1vbk9ianMgPSB0aGlzLmNvbW1vbk9ianM7XG4gICAgY29uc3Qgb2JqcyA9IHRoaXMub2JqcztcbiAgICBsZXQgZm5JZDtcbiAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgaWYgKHN0ZXBwZXIgIT09IHVuZGVmaW5lZCAmJiBpID09PSBzdGVwcGVyLm5leHRCcmVha1BvaW50KSB7XG4gICAgICAgIHN0ZXBwZXIuYnJlYWtJdChpLCBjb250aW51ZUNhbGxiYWNrKTtcbiAgICAgICAgcmV0dXJuIGk7XG4gICAgICB9XG4gICAgICBmbklkID0gZm5BcnJheVtpXTtcbiAgICAgIGlmIChmbklkICE9PSBfdXRpbC5PUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICB0aGlzW2ZuSWRdLmFwcGx5KHRoaXMsIGFyZ3NBcnJheVtpXSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmb3IgKGNvbnN0IGRlcE9iaklkIG9mIGFyZ3NBcnJheVtpXSkge1xuICAgICAgICAgIGNvbnN0IG9ianNQb29sID0gZGVwT2JqSWQuc3RhcnRzV2l0aChcImdfXCIpID8gY29tbW9uT2JqcyA6IG9ianM7XG4gICAgICAgICAgaWYgKCFvYmpzUG9vbC5oYXMoZGVwT2JqSWQpKSB7XG4gICAgICAgICAgICBvYmpzUG9vbC5nZXQoZGVwT2JqSWQsIGNvbnRpbnVlQ2FsbGJhY2spO1xuICAgICAgICAgICAgcmV0dXJuIGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpKys7XG4gICAgICBpZiAoaSA9PT0gYXJnc0FycmF5TGVuKSB7XG4gICAgICAgIHJldHVybiBpO1xuICAgICAgfVxuICAgICAgaWYgKGNodW5rT3BlcmF0aW9ucyAmJiArK3N0ZXBzID4gRVhFQ1VUSU9OX1NURVBTKSB7XG4gICAgICAgIGlmIChEYXRlLm5vdygpID4gZW5kVGltZSkge1xuICAgICAgICAgIGNvbnRpbnVlQ2FsbGJhY2soKTtcbiAgICAgICAgICByZXR1cm4gaTtcbiAgICAgICAgfVxuICAgICAgICBzdGVwcyA9IDA7XG4gICAgICB9XG4gICAgfVxuICB9XG4gICNyZXN0b3JlSW5pdGlhbFN0YXRlKCkge1xuICAgIHdoaWxlICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoIHx8IHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgaWYgKHRoaXMudHJhbnNwYXJlbnRDYW52YXMpIHtcbiAgICAgIHRoaXMuY3R4ID0gdGhpcy5jb21wb3NpdGVDdHg7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy50cmFuc3BhcmVudENhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLnRyYW5zcGFyZW50Q2FudmFzID0gbnVsbDtcbiAgICB9XG4gIH1cbiAgZW5kRHJhd2luZygpIHtcbiAgICB0aGlzLiNyZXN0b3JlSW5pdGlhbFN0YXRlKCk7XG4gICAgdGhpcy5jYWNoZWRDYW52YXNlcy5jbGVhcigpO1xuICAgIHRoaXMuY2FjaGVkUGF0dGVybnMuY2xlYXIoKTtcbiAgICBmb3IgKGNvbnN0IGNhY2hlIG9mIHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAudmFsdWVzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgY2FudmFzIG9mIGNhY2hlLnZhbHVlcygpKSB7XG4gICAgICAgIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09IFwidW5kZWZpbmVkXCIgJiYgY2FudmFzIGluc3RhbmNlb2YgSFRNTENhbnZhc0VsZW1lbnQpIHtcbiAgICAgICAgICBjYW52YXMud2lkdGggPSBjYW52YXMuaGVpZ2h0ID0gMDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2FjaGUuY2xlYXIoKTtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcC5jbGVhcigpO1xuICAgIHRoaXMuI2RyYXdGaWx0ZXIoKTtcbiAgfVxuICAjZHJhd0ZpbHRlcigpIHtcbiAgICBpZiAodGhpcy5wYWdlQ29sb3JzKSB7XG4gICAgICBjb25zdCBoY21GaWx0ZXJJZCA9IHRoaXMuZmlsdGVyRmFjdG9yeS5hZGRIQ01GaWx0ZXIodGhpcy5wYWdlQ29sb3JzLmZvcmVncm91bmQsIHRoaXMucGFnZUNvbG9ycy5iYWNrZ3JvdW5kKTtcbiAgICAgIGlmIChoY21GaWx0ZXJJZCAhPT0gXCJub25lXCIpIHtcbiAgICAgICAgY29uc3Qgc2F2ZWRGaWx0ZXIgPSB0aGlzLmN0eC5maWx0ZXI7XG4gICAgICAgIHRoaXMuY3R4LmZpbHRlciA9IGhjbUZpbHRlcklkO1xuICAgICAgICB0aGlzLmN0eC5kcmF3SW1hZ2UodGhpcy5jdHguY2FudmFzLCAwLCAwKTtcbiAgICAgICAgdGhpcy5jdHguZmlsdGVyID0gc2F2ZWRGaWx0ZXI7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9zY2FsZUltYWdlKGltZywgaW52ZXJzZVRyYW5zZm9ybSkge1xuICAgIGNvbnN0IHdpZHRoID0gaW1nLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZy5oZWlnaHQ7XG4gICAgbGV0IHdpZHRoU2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMF0sIGludmVyc2VUcmFuc2Zvcm1bMV0pLCAxKTtcbiAgICBsZXQgaGVpZ2h0U2NhbGUgPSBNYXRoLm1heChNYXRoLmh5cG90KGludmVyc2VUcmFuc2Zvcm1bMl0sIGludmVyc2VUcmFuc2Zvcm1bM10pLCAxKTtcbiAgICBsZXQgcGFpbnRXaWR0aCA9IHdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHQgPSBoZWlnaHQ7XG4gICAgbGV0IHRtcENhbnZhc0lkID0gXCJwcmVzY2FsZTFcIjtcbiAgICBsZXQgdG1wQ2FudmFzLCB0bXBDdHg7XG4gICAgd2hpbGUgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxIHx8IGhlaWdodFNjYWxlID4gMiAmJiBwYWludEhlaWdodCA+IDEpIHtcbiAgICAgIGxldCBuZXdXaWR0aCA9IHBhaW50V2lkdGgsXG4gICAgICAgIG5ld0hlaWdodCA9IHBhaW50SGVpZ2h0O1xuICAgICAgaWYgKHdpZHRoU2NhbGUgPiAyICYmIHBhaW50V2lkdGggPiAxKSB7XG4gICAgICAgIG5ld1dpZHRoID0gcGFpbnRXaWR0aCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRXaWR0aCAvIDIpIC0gMSB8fCAxIDogTWF0aC5jZWlsKHBhaW50V2lkdGggLyAyKTtcbiAgICAgICAgd2lkdGhTY2FsZSAvPSBwYWludFdpZHRoIC8gbmV3V2lkdGg7XG4gICAgICB9XG4gICAgICBpZiAoaGVpZ2h0U2NhbGUgPiAyICYmIHBhaW50SGVpZ2h0ID4gMSkge1xuICAgICAgICBuZXdIZWlnaHQgPSBwYWludEhlaWdodCA+PSAxNjM4NCA/IE1hdGguZmxvb3IocGFpbnRIZWlnaHQgLyAyKSAtIDEgfHwgMSA6IE1hdGguY2VpbChwYWludEhlaWdodCkgLyAyO1xuICAgICAgICBoZWlnaHRTY2FsZSAvPSBwYWludEhlaWdodCAvIG5ld0hlaWdodDtcbiAgICAgIH1cbiAgICAgIHRtcENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKHRtcENhbnZhc0lkLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIHRtcEN0eC5kcmF3SW1hZ2UoaW1nLCAwLCAwLCBwYWludFdpZHRoLCBwYWludEhlaWdodCwgMCwgMCwgbmV3V2lkdGgsIG5ld0hlaWdodCk7XG4gICAgICBpbWcgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgICAgcGFpbnRXaWR0aCA9IG5ld1dpZHRoO1xuICAgICAgcGFpbnRIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICB0bXBDYW52YXNJZCA9IHRtcENhbnZhc0lkID09PSBcInByZXNjYWxlMVwiID8gXCJwcmVzY2FsZTJcIiA6IFwicHJlc2NhbGUxXCI7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICBpbWcsXG4gICAgICBwYWludFdpZHRoLFxuICAgICAgcGFpbnRIZWlnaHRcbiAgICB9O1xuICB9XG4gIF9jcmVhdGVNYXNrQ2FudmFzKGltZykge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZztcbiAgICBjb25zdCBmaWxsQ29sb3IgPSB0aGlzLmN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGNvbnN0IGlzUGF0dGVybkZpbGwgPSB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGw7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgIGxldCBjYWNoZSwgY2FjaGVLZXksIHNjYWxlZCwgbWFza0NhbnZhcztcbiAgICBpZiAoKGltZy5iaXRtYXAgfHwgaW1nLmRhdGEpICYmIGltZy5jb3VudCA+IDEpIHtcbiAgICAgIGNvbnN0IG1haW5LZXkgPSBpbWcuYml0bWFwIHx8IGltZy5kYXRhLmJ1ZmZlcjtcbiAgICAgIGNhY2hlS2V5ID0gSlNPTi5zdHJpbmdpZnkoaXNQYXR0ZXJuRmlsbCA/IGN1cnJlbnRUcmFuc2Zvcm0gOiBbY3VycmVudFRyYW5zZm9ybS5zbGljZSgwLCA0KSwgZmlsbENvbG9yXSk7XG4gICAgICBjYWNoZSA9IHRoaXMuX2NhY2hlZEJpdG1hcHNNYXAuZ2V0KG1haW5LZXkpO1xuICAgICAgaWYgKCFjYWNoZSkge1xuICAgICAgICBjYWNoZSA9IG5ldyBNYXAoKTtcbiAgICAgICAgdGhpcy5fY2FjaGVkQml0bWFwc01hcC5zZXQobWFpbktleSwgY2FjaGUpO1xuICAgICAgfVxuICAgICAgY29uc3QgY2FjaGVkSW1hZ2UgPSBjYWNoZS5nZXQoY2FjaGVLZXkpO1xuICAgICAgaWYgKGNhY2hlZEltYWdlICYmICFpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNvbnN0IG9mZnNldFggPSBNYXRoLnJvdW5kKE1hdGgubWluKGN1cnJlbnRUcmFuc2Zvcm1bMF0sIGN1cnJlbnRUcmFuc2Zvcm1bMl0pICsgY3VycmVudFRyYW5zZm9ybVs0XSk7XG4gICAgICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLnJvdW5kKE1hdGgubWluKGN1cnJlbnRUcmFuc2Zvcm1bMV0sIGN1cnJlbnRUcmFuc2Zvcm1bM10pICsgY3VycmVudFRyYW5zZm9ybVs1XSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgY2FudmFzOiBjYWNoZWRJbWFnZSxcbiAgICAgICAgICBvZmZzZXRYLFxuICAgICAgICAgIG9mZnNldFlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIHNjYWxlZCA9IGNhY2hlZEltYWdlO1xuICAgIH1cbiAgICBpZiAoIXNjYWxlZCkge1xuICAgICAgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ2FudmFzLmNvbnRleHQsIGltZyk7XG4gICAgfVxuICAgIGxldCBtYXNrVG9DYW52YXMgPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShjdXJyZW50VHJhbnNmb3JtLCBbMSAvIHdpZHRoLCAwLCAwLCAtMSAvIGhlaWdodCwgMCwgMF0pO1xuICAgIG1hc2tUb0NhbnZhcyA9IF91dGlsLlV0aWwudHJhbnNmb3JtKG1hc2tUb0NhbnZhcywgWzEsIDAsIDAsIDEsIDAsIC1oZWlnaHRdKTtcbiAgICBjb25zdCBjb3JkMSA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIDBdLCBtYXNrVG9DYW52YXMpO1xuICAgIGNvbnN0IGNvcmQyID0gX3V0aWwuVXRpbC5hcHBseVRyYW5zZm9ybShbd2lkdGgsIGhlaWdodF0sIG1hc2tUb0NhbnZhcyk7XG4gICAgY29uc3QgcmVjdCA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbY29yZDFbMF0sIGNvcmQxWzFdLCBjb3JkMlswXSwgY29yZDJbMV1dKTtcbiAgICBjb25zdCBkcmF3bldpZHRoID0gTWF0aC5yb3VuZChyZWN0WzJdIC0gcmVjdFswXSkgfHwgMTtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IE1hdGgucm91bmQocmVjdFszXSAtIHJlY3RbMV0pIHx8IDE7XG4gICAgY29uc3QgZmlsbENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwiZmlsbENhbnZhc1wiLCBkcmF3bldpZHRoLCBkcmF3bkhlaWdodCk7XG4gICAgY29uc3QgZmlsbEN0eCA9IGZpbGxDYW52YXMuY29udGV4dDtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5taW4oY29yZDFbMF0sIGNvcmQyWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5taW4oY29yZDFbMV0sIGNvcmQyWzFdKTtcbiAgICBmaWxsQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgIGZpbGxDdHgudHJhbnNmb3JtKC4uLm1hc2tUb0NhbnZhcyk7XG4gICAgaWYgKCFzY2FsZWQpIHtcbiAgICAgIHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UobWFza0NhbnZhcy5jYW52YXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoZmlsbEN0eCkpO1xuICAgICAgc2NhbGVkID0gc2NhbGVkLmltZztcbiAgICAgIGlmIChjYWNoZSAmJiBpc1BhdHRlcm5GaWxsKSB7XG4gICAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgc2NhbGVkKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZmlsbEN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBnZXRJbWFnZVNtb290aGluZ0VuYWJsZWQoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGZpbGxDdHgpLCBpbWcuaW50ZXJwb2xhdGUpO1xuICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhmaWxsQ3R4LCBzY2FsZWQsIDAsIDAsIHNjYWxlZC53aWR0aCwgc2NhbGVkLmhlaWdodCwgMCwgMCwgd2lkdGgsIGhlaWdodCk7XG4gICAgZmlsbEN0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgIGNvbnN0IGludmVyc2UgPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGZpbGxDdHgpLCBbMSwgMCwgMCwgMSwgLW9mZnNldFgsIC1vZmZzZXRZXSk7XG4gICAgZmlsbEN0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCBpbnZlcnNlLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgZmlsbEN0eC5maWxsUmVjdCgwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBpZiAoY2FjaGUgJiYgIWlzUGF0dGVybkZpbGwpIHtcbiAgICAgIHRoaXMuY2FjaGVkQ2FudmFzZXMuZGVsZXRlKFwiZmlsbENhbnZhc1wiKTtcbiAgICAgIGNhY2hlLnNldChjYWNoZUtleSwgZmlsbENhbnZhcy5jYW52YXMpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgY2FudmFzOiBmaWxsQ2FudmFzLmNhbnZhcyxcbiAgICAgIG9mZnNldFg6IE1hdGgucm91bmQob2Zmc2V0WCksXG4gICAgICBvZmZzZXRZOiBNYXRoLnJvdW5kKG9mZnNldFkpXG4gICAgfTtcbiAgfVxuICBzZXRMaW5lV2lkdGgod2lkdGgpIHtcbiAgICBpZiAod2lkdGggIT09IHRoaXMuY3VycmVudC5saW5lV2lkdGgpIHtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmxpbmVXaWR0aCA9IHdpZHRoO1xuICAgIHRoaXMuY3R4LmxpbmVXaWR0aCA9IHdpZHRoO1xuICB9XG4gIHNldExpbmVDYXAoc3R5bGUpIHtcbiAgICB0aGlzLmN0eC5saW5lQ2FwID0gTElORV9DQVBfU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRMaW5lSm9pbihzdHlsZSkge1xuICAgIHRoaXMuY3R4LmxpbmVKb2luID0gTElORV9KT0lOX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TWl0ZXJMaW1pdChsaW1pdCkge1xuICAgIHRoaXMuY3R4Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgfVxuICBzZXREYXNoKGRhc2hBcnJheSwgZGFzaFBoYXNlKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgaWYgKGN0eC5zZXRMaW5lRGFzaCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaEFycmF5KTtcbiAgICAgIGN0eC5saW5lRGFzaE9mZnNldCA9IGRhc2hQaGFzZTtcbiAgICB9XG4gIH1cbiAgc2V0UmVuZGVyaW5nSW50ZW50KGludGVudCkge31cbiAgc2V0RmxhdG5lc3MoZmxhdG5lc3MpIHt9XG4gIHNldEdTdGF0ZShzdGF0ZXMpIHtcbiAgICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBzdGF0ZXMpIHtcbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJMV1wiOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxDXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lQ2FwKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkxKXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lSm9pbih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJNTFwiOlxuICAgICAgICAgIHRoaXMuc2V0TWl0ZXJMaW1pdCh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJEXCI6XG4gICAgICAgICAgdGhpcy5zZXREYXNoKHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJSSVwiOlxuICAgICAgICAgIHRoaXMuc2V0UmVuZGVyaW5nSW50ZW50KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZMXCI6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyh2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJGb250XCI6XG4gICAgICAgICAgdGhpcy5zZXRGb250KHZhbHVlWzBdLCB2YWx1ZVsxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJDQVwiOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5zdHJva2VBbHBoYSA9IHZhbHVlO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiY2FcIjpcbiAgICAgICAgICB0aGlzLmN1cnJlbnQuZmlsbEFscGhhID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQWxwaGEgPSB2YWx1ZTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkJNXCI6XG4gICAgICAgICAgdGhpcy5jdHguZ2xvYmFsQ29tcG9zaXRlT3BlcmF0aW9uID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJTTWFza1wiOlxuICAgICAgICAgIHRoaXMuY3VycmVudC5hY3RpdmVTTWFzayA9IHZhbHVlID8gdGhpcy50ZW1wU01hc2sgOiBudWxsO1xuICAgICAgICAgIHRoaXMudGVtcFNNYXNrID0gbnVsbDtcbiAgICAgICAgICB0aGlzLmNoZWNrU01hc2tTdGF0ZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiVFJcIjpcbiAgICAgICAgICB0aGlzLmN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzID0gdGhpcy5maWx0ZXJGYWN0b3J5LmFkZEZpbHRlcih2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGdldCBpblNNYXNrTW9kZSgpIHtcbiAgICByZXR1cm4gISF0aGlzLnN1c3BlbmRlZEN0eDtcbiAgfVxuICBjaGVja1NNYXNrU3RhdGUoKSB7XG4gICAgY29uc3QgaW5TTWFza01vZGUgPSB0aGlzLmluU01hc2tNb2RlO1xuICAgIGlmICh0aGlzLmN1cnJlbnQuYWN0aXZlU01hc2sgJiYgIWluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmJlZ2luU01hc2tNb2RlKCk7XG4gICAgfSBlbHNlIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrICYmIGluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgIH1cbiAgfVxuICBiZWdpblNNYXNrTW9kZSgpIHtcbiAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiYmVnaW5TTWFza01vZGUgY2FsbGVkIHdoaWxlIGFscmVhZHkgaW4gc21hc2sgbW9kZVwiKTtcbiAgICB9XG4gICAgY29uc3QgZHJhd25XaWR0aCA9IHRoaXMuY3R4LmNhbnZhcy53aWR0aDtcbiAgICBjb25zdCBkcmF3bkhlaWdodCA9IHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQ7XG4gICAgY29uc3QgY2FjaGVJZCA9IFwic21hc2tHcm91cEF0XCIgKyB0aGlzLmdyb3VwTGV2ZWw7XG4gICAgY29uc3Qgc2NyYXRjaENhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKGNhY2hlSWQsIGRyYXduV2lkdGgsIGRyYXduSGVpZ2h0KTtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuY3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oLi4uKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuc3VzcGVuZGVkQ3R4KSk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuc3VzcGVuZGVkQ3R4LCBjdHgpO1xuICAgIG1pcnJvckNvbnRleHRPcGVyYXRpb25zKGN0eCwgdGhpcy5zdXNwZW5kZWRDdHgpO1xuICAgIHRoaXMuc2V0R1N0YXRlKFtbXCJCTVwiLCBcInNvdXJjZS1vdmVyXCJdLCBbXCJjYVwiLCAxXSwgW1wiQ0FcIiwgMV1dKTtcbiAgfVxuICBlbmRTTWFza01vZGUoKSB7XG4gICAgaWYgKCF0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJlbmRTTWFza01vZGUgY2FsbGVkIHdoaWxlIG5vdCBpbiBzbWFzayBtb2RlXCIpO1xuICAgIH1cbiAgICB0aGlzLmN0eC5fcmVtb3ZlTWlycm9yaW5nKCk7XG4gICAgY29weUN0eFN0YXRlKHRoaXMuY3R4LCB0aGlzLnN1c3BlbmRlZEN0eCk7XG4gICAgdGhpcy5jdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICB0aGlzLnN1c3BlbmRlZEN0eCA9IG51bGw7XG4gIH1cbiAgY29tcG9zZShkaXJ0eUJveCkge1xuICAgIGlmICghdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghZGlydHlCb3gpIHtcbiAgICAgIGRpcnR5Qm94ID0gWzAsIDAsIHRoaXMuY3R4LmNhbnZhcy53aWR0aCwgdGhpcy5jdHguY2FudmFzLmhlaWdodF07XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpcnR5Qm94WzBdID0gTWF0aC5mbG9vcihkaXJ0eUJveFswXSk7XG4gICAgICBkaXJ0eUJveFsxXSA9IE1hdGguZmxvb3IoZGlydHlCb3hbMV0pO1xuICAgICAgZGlydHlCb3hbMl0gPSBNYXRoLmNlaWwoZGlydHlCb3hbMl0pO1xuICAgICAgZGlydHlCb3hbM10gPSBNYXRoLmNlaWwoZGlydHlCb3hbM10pO1xuICAgIH1cbiAgICBjb25zdCBzbWFzayA9IHRoaXMuY3VycmVudC5hY3RpdmVTTWFzaztcbiAgICBjb25zdCBzdXNwZW5kZWRDdHggPSB0aGlzLnN1c3BlbmRlZEN0eDtcbiAgICBjb21wb3NlU01hc2soc3VzcGVuZGVkQ3R4LCBzbWFzaywgdGhpcy5jdHgsIGRpcnR5Qm94KTtcbiAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgdGhpcy5jdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIDAsIDApO1xuICAgIHRoaXMuY3R4LmNsZWFyUmVjdCgwLCAwLCB0aGlzLmN0eC5jYW52YXMud2lkdGgsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQpO1xuICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgfVxuICBzYXZlKCkge1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICBjb3B5Q3R4U3RhdGUodGhpcy5jdHgsIHRoaXMuc3VzcGVuZGVkQ3R4KTtcbiAgICAgIHRoaXMuc3VzcGVuZGVkQ3R4LnNhdmUoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjb25zdCBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgdGhpcy5zdGF0ZVN0YWNrLnB1c2gob2xkKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBvbGQuY2xvbmUoKTtcbiAgfVxuICByZXN0b3JlKCkge1xuICAgIGlmICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoID09PSAwICYmIHRoaXMuaW5TTWFza01vZGUpIHtcbiAgICAgIHRoaXMuZW5kU01hc2tNb2RlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLnN0YXRlU3RhY2subGVuZ3RoICE9PSAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLnN0YXRlU3RhY2sucG9wKCk7XG4gICAgICBpZiAodGhpcy5pblNNYXNrTW9kZSkge1xuICAgICAgICB0aGlzLnN1c3BlbmRlZEN0eC5yZXN0b3JlKCk7XG4gICAgICAgIGNvcHlDdHhTdGF0ZSh0aGlzLnN1c3BlbmRlZEN0eCwgdGhpcy5jdHgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jdHgucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgdGhpcy5jaGVja1NNYXNrU3RhdGUoKTtcbiAgICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgICAgdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aCA9IG51bGw7XG4gICAgfVxuICB9XG4gIHRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgdGhpcy5jdHgudHJhbnNmb3JtKGEsIGIsIGMsIGQsIGUsIGYpO1xuICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMF0gPSAtMTtcbiAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gbnVsbDtcbiAgfVxuICBjb25zdHJ1Y3RQYXRoKG9wcywgYXJncywgbWluTWF4KSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBsZXQgeCA9IGN1cnJlbnQueCxcbiAgICAgIHkgPSBjdXJyZW50Lnk7XG4gICAgbGV0IHN0YXJ0WCwgc3RhcnRZO1xuICAgIGNvbnN0IGN1cnJlbnRUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgICBjb25zdCBpc1NjYWxpbmdNYXRyaXggPSBjdXJyZW50VHJhbnNmb3JtWzBdID09PSAwICYmIGN1cnJlbnRUcmFuc2Zvcm1bM10gPT09IDAgfHwgY3VycmVudFRyYW5zZm9ybVsxXSA9PT0gMCAmJiBjdXJyZW50VHJhbnNmb3JtWzJdID09PSAwO1xuICAgIGNvbnN0IG1pbk1heEZvckJlemllciA9IGlzU2NhbGluZ01hdHJpeCA/IG1pbk1heC5zbGljZSgwKSA6IG51bGw7XG4gICAgZm9yIChsZXQgaSA9IDAsIGogPSAwLCBpaSA9IG9wcy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBzd2l0Y2ggKG9wc1tpXSB8IDApIHtcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucmVjdGFuZ2xlOlxuICAgICAgICAgIHggPSBhcmdzW2orK107XG4gICAgICAgICAgeSA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB3aWR0aCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCBoZWlnaHQgPSBhcmdzW2orK107XG4gICAgICAgICAgY29uc3QgeHcgPSB4ICsgd2lkdGg7XG4gICAgICAgICAgY29uc3QgeWggPSB5ICsgaGVpZ2h0O1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKHdpZHRoID09PSAwIHx8IGhlaWdodCA9PT0gMCkge1xuICAgICAgICAgICAgY3R4LmxpbmVUbyh4dywgeWgpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjdHgubGluZVRvKHh3LCB5KTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeHcsIHloKTtcbiAgICAgICAgICAgIGN0eC5saW5lVG8oeCwgeWgpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVSZWN0TWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIFt4LCB5LCB4dywgeWhdKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY3R4LmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5tb3ZlVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGN0eC5tb3ZlVG8oeCwgeSk7XG4gICAgICAgICAgaWYgKCFpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgICAgICAgIGN1cnJlbnQudXBkYXRlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCB4LCB5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmxpbmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgY3R4LmxpbmVUbyh4LCB5KTtcbiAgICAgICAgICBpZiAoIWlzU2NhbGluZ01hdHJpeCkge1xuICAgICAgICAgICAgY3VycmVudC51cGRhdGVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHgsIHkpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzpcbiAgICAgICAgICBzdGFydFggPSB4O1xuICAgICAgICAgIHN0YXJ0WSA9IHk7XG4gICAgICAgICAgeCA9IGFyZ3NbaiArIDRdO1xuICAgICAgICAgIHkgPSBhcmdzW2ogKyA1XTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyhhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdLCB4LCB5KTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgeCwgeSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICBqICs9IDY7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmN1cnZlVG8yOlxuICAgICAgICAgIHN0YXJ0WCA9IHg7XG4gICAgICAgICAgc3RhcnRZID0geTtcbiAgICAgICAgICBjdHguYmV6aWVyQ3VydmVUbyh4LCB5LCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgYXJnc1tqICsgMl0sIGFyZ3NbaiArIDNdKTtcbiAgICAgICAgICBjdXJyZW50LnVwZGF0ZUN1cnZlUGF0aE1pbk1heChjdXJyZW50VHJhbnNmb3JtLCBzdGFydFgsIHN0YXJ0WSwgeCwgeSwgYXJnc1tqXSwgYXJnc1tqICsgMV0sIGFyZ3NbaiArIDJdLCBhcmdzW2ogKyAzXSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzM6XG4gICAgICAgICAgc3RhcnRYID0geDtcbiAgICAgICAgICBzdGFydFkgPSB5O1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgY3R4LmJlemllckN1cnZlVG8oYXJnc1tqXSwgYXJnc1tqICsgMV0sIHgsIHksIHgsIHkpO1xuICAgICAgICAgIGN1cnJlbnQudXBkYXRlQ3VydmVQYXRoTWluTWF4KGN1cnJlbnRUcmFuc2Zvcm0sIHN0YXJ0WCwgc3RhcnRZLCBhcmdzW2pdLCBhcmdzW2ogKyAxXSwgeCwgeSwgeCwgeSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICAgICAgICBqICs9IDQ7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICBjdHguY2xvc2VQYXRoKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc1NjYWxpbmdNYXRyaXgpIHtcbiAgICAgIGN1cnJlbnQudXBkYXRlU2NhbGluZ1BhdGhNaW5NYXgoY3VycmVudFRyYW5zZm9ybSwgbWluTWF4Rm9yQmV6aWVyKTtcbiAgICB9XG4gICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gIH1cbiAgY2xvc2VQYXRoKCkge1xuICAgIHRoaXMuY3R4LmNsb3NlUGF0aCgpO1xuICB9XG4gIHN0cm9rZSgpIHtcbiAgICBsZXQgY29uc3VtZVBhdGggPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRydWU7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgY3R4Lmdsb2JhbEFscGhhID0gdGhpcy5jdXJyZW50LnN0cm9rZUFscGhhO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICBpZiAodHlwZW9mIHN0cm9rZUNvbG9yID09PSBcIm9iamVjdFwiICYmIHN0cm9rZUNvbG9yPy5nZXRQYXR0ZXJuKSB7XG4gICAgICAgIGN0eC5zYXZlKCk7XG4gICAgICAgIGN0eC5zdHJva2VTdHlsZSA9IHN0cm9rZUNvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5TVFJPS0UpO1xuICAgICAgICB0aGlzLnJlc2NhbGVBbmRTdHJva2UoZmFsc2UpO1xuICAgICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5yZXNjYWxlQW5kU3Ryb2tlKHRydWUpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgodGhpcy5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3goKSk7XG4gICAgfVxuICAgIGN0eC5nbG9iYWxBbHBoYSA9IHRoaXMuY3VycmVudC5maWxsQWxwaGE7XG4gIH1cbiAgY2xvc2VTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLnN0cm9rZSgpO1xuICB9XG4gIGZpbGwoKSB7XG4gICAgbGV0IGNvbnN1bWVQYXRoID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB0cnVlO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3QgaXNQYXR0ZXJuRmlsbCA9IHRoaXMuY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBsZXQgbmVlZFJlc3RvcmUgPSBmYWxzZTtcbiAgICBpZiAoaXNQYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC5maWxsU3R5bGUgPSBmaWxsQ29sb3IuZ2V0UGF0dGVybihjdHgsIHRoaXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLkZJTEwpO1xuICAgICAgbmVlZFJlc3RvcmUgPSB0cnVlO1xuICAgIH1cbiAgICBjb25zdCBpbnRlcnNlY3QgPSB0aGlzLmN1cnJlbnQuZ2V0Q2xpcHBlZFBhdGhCb3VuZGluZ0JveCgpO1xuICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlICYmIGludGVyc2VjdCAhPT0gbnVsbCkge1xuICAgICAgaWYgKHRoaXMucGVuZGluZ0VPRmlsbCkge1xuICAgICAgICBjdHguZmlsbChcImV2ZW5vZGRcIik7XG4gICAgICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IGZhbHNlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY3R4LmZpbGwoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5lZWRSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICBpZiAoY29uc3VtZVBhdGgpIHtcbiAgICAgIHRoaXMuY29uc3VtZVBhdGgoaW50ZXJzZWN0KTtcbiAgICB9XG4gIH1cbiAgZW9GaWxsKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsKCk7XG4gIH1cbiAgZmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmZpbGwoZmFsc2UpO1xuICAgIHRoaXMuc3Ryb2tlKGZhbHNlKTtcbiAgICB0aGlzLmNvbnN1bWVQYXRoKCk7XG4gIH1cbiAgZW9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMucGVuZGluZ0VPRmlsbCA9IHRydWU7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VGaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VFT0ZpbGxTdHJva2UoKSB7XG4gICAgdGhpcy5wZW5kaW5nRU9GaWxsID0gdHJ1ZTtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGVuZFBhdGgoKSB7XG4gICAgdGhpcy5jb25zdW1lUGF0aCgpO1xuICB9XG4gIGNsaXAoKSB7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IE5PUk1BTF9DTElQO1xuICB9XG4gIGVvQ2xpcCgpIHtcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gRU9fQ0xJUDtcbiAgfVxuICBiZWdpblRleHQoKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5jdXJyZW50LnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggPSAwO1xuICAgIHRoaXMuY3VycmVudC55ID0gdGhpcy5jdXJyZW50LmxpbmVZID0gMDtcbiAgfVxuICBlbmRUZXh0KCkge1xuICAgIGNvbnN0IHBhdGhzID0gdGhpcy5wZW5kaW5nVGV4dFBhdGhzO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmIChwYXRocyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LmJlZ2luUGF0aCgpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiBwYXRocykge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5wYXRoLnRyYW5zZm9ybSk7XG4gICAgICBjdHgudHJhbnNsYXRlKHBhdGgueCwgcGF0aC55KTtcbiAgICAgIHBhdGguYWRkVG9QYXRoKGN0eCwgcGF0aC5mb250U2l6ZSk7XG4gICAgfVxuICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgY3R4LmNsaXAoKTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1RleHRQYXRocztcbiAgfVxuICBzZXRDaGFyU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRXb3JkU3BhY2luZyhzcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LndvcmRTcGFjaW5nID0gc3BhY2luZztcbiAgfVxuICBzZXRIU2NhbGUoc2NhbGUpIHtcbiAgICB0aGlzLmN1cnJlbnQudGV4dEhTY2FsZSA9IHNjYWxlIC8gMTAwO1xuICB9XG4gIHNldExlYWRpbmcobGVhZGluZykge1xuICAgIHRoaXMuY3VycmVudC5sZWFkaW5nID0gLWxlYWRpbmc7XG4gIH1cbiAgc2V0Rm9udChmb250UmVmTmFtZSwgc2l6ZSkge1xuICAgIGNvbnN0IGZvbnRPYmogPSB0aGlzLmNvbW1vbk9ianMuZ2V0KGZvbnRSZWZOYW1lKTtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmICghZm9udE9iaikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW4ndCBmaW5kIGZvbnQgZm9yICR7Zm9udFJlZk5hbWV9YCk7XG4gICAgfVxuICAgIGN1cnJlbnQuZm9udE1hdHJpeCA9IGZvbnRPYmouZm9udE1hdHJpeCB8fCBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBpZiAoY3VycmVudC5mb250TWF0cml4WzBdID09PSAwIHx8IGN1cnJlbnQuZm9udE1hdHJpeFszXSA9PT0gMCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiSW52YWxpZCBmb250IG1hdHJpeCBmb3IgZm9udCBcIiArIGZvbnRSZWZOYW1lKTtcbiAgICB9XG4gICAgaWYgKHNpemUgPCAwKSB7XG4gICAgICBzaXplID0gLXNpemU7XG4gICAgICBjdXJyZW50LmZvbnREaXJlY3Rpb24gPSAtMTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gMTtcbiAgICB9XG4gICAgdGhpcy5jdXJyZW50LmZvbnQgPSBmb250T2JqO1xuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZSA9IHNpemU7XG4gICAgaWYgKGZvbnRPYmouaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgbmFtZSA9IGZvbnRPYmoubG9hZGVkTmFtZSB8fCBcInNhbnMtc2VyaWZcIjtcbiAgICBjb25zdCB0eXBlZmFjZSA9IGZvbnRPYmouc3lzdGVtRm9udEluZm8/LmNzcyB8fCBgXCIke25hbWV9XCIsICR7Zm9udE9iai5mYWxsYmFja05hbWV9YDtcbiAgICBsZXQgYm9sZCA9IFwibm9ybWFsXCI7XG4gICAgaWYgKGZvbnRPYmouYmxhY2spIHtcbiAgICAgIGJvbGQgPSBcIjkwMFwiO1xuICAgIH0gZWxzZSBpZiAoZm9udE9iai5ib2xkKSB7XG4gICAgICBib2xkID0gXCJib2xkXCI7XG4gICAgfVxuICAgIGNvbnN0IGl0YWxpYyA9IGZvbnRPYmouaXRhbGljID8gXCJpdGFsaWNcIiA6IFwibm9ybWFsXCI7XG4gICAgbGV0IGJyb3dzZXJGb250U2l6ZSA9IHNpemU7XG4gICAgaWYgKHNpemUgPCBNSU5fRk9OVF9TSVpFKSB7XG4gICAgICBicm93c2VyRm9udFNpemUgPSBNSU5fRk9OVF9TSVpFO1xuICAgIH0gZWxzZSBpZiAoc2l6ZSA+IE1BWF9GT05UX1NJWkUpIHtcbiAgICAgIGJyb3dzZXJGb250U2l6ZSA9IE1BWF9GT05UX1NJWkU7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5mb250U2l6ZVNjYWxlID0gc2l6ZSAvIGJyb3dzZXJGb250U2l6ZTtcbiAgICB0aGlzLmN0eC5mb250ID0gYCR7aXRhbGljfSAke2JvbGR9ICR7YnJvd3NlckZvbnRTaXplfXB4ICR7dHlwZWZhY2V9YDtcbiAgfVxuICBzZXRUZXh0UmVuZGVyaW5nTW9kZShtb2RlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID0gbW9kZTtcbiAgfVxuICBzZXRUZXh0UmlzZShyaXNlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSaXNlID0gcmlzZTtcbiAgfVxuICBtb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5jdXJyZW50LnggPSB0aGlzLmN1cnJlbnQubGluZVggKz0geDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSArPSB5O1xuICB9XG4gIHNldExlYWRpbmdNb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5zZXRMZWFkaW5nKC15KTtcbiAgICB0aGlzLm1vdmVUZXh0KHgsIHkpO1xuICB9XG4gIHNldFRleHRNYXRyaXgoYSwgYiwgYywgZCwgZSwgZikge1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgIHRoaXMuY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgIHRoaXMuY3VycmVudC54ID0gdGhpcy5jdXJyZW50LmxpbmVYID0gMDtcbiAgICB0aGlzLmN1cnJlbnQueSA9IHRoaXMuY3VycmVudC5saW5lWSA9IDA7XG4gIH1cbiAgbmV4dExpbmUoKSB7XG4gICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gIH1cbiAgcGFpbnRDaGFyKGNoYXJhY3RlciwgeCwgeSwgcGF0dGVyblRyYW5zZm9ybSkge1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udCA9IGN1cnJlbnQuZm9udDtcbiAgICBjb25zdCB0ZXh0UmVuZGVyaW5nTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGU7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplIC8gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGZpbGxTdHJva2VNb2RlID0gdGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgIGNvbnN0IGlzQWRkVG9QYXRoU2V0ID0gISEodGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5BRERfVE9fUEFUSF9GTEFHKTtcbiAgICBjb25zdCBwYXR0ZXJuRmlsbCA9IGN1cnJlbnQucGF0dGVybkZpbGwgJiYgIWZvbnQubWlzc2luZ0ZpbGU7XG4gICAgbGV0IGFkZFRvUGF0aDtcbiAgICBpZiAoZm9udC5kaXNhYmxlRm9udEZhY2UgfHwgaXNBZGRUb1BhdGhTZXQgfHwgcGF0dGVybkZpbGwpIHtcbiAgICAgIGFkZFRvUGF0aCA9IGZvbnQuZ2V0UGF0aEdlbmVyYXRvcih0aGlzLmNvbW1vbk9ianMsIGNoYXJhY3Rlcik7XG4gICAgfVxuICAgIGlmIChmb250LmRpc2FibGVGb250RmFjZSB8fCBwYXR0ZXJuRmlsbCkge1xuICAgICAgY3R4LnNhdmUoKTtcbiAgICAgIGN0eC50cmFuc2xhdGUoeCwgeSk7XG4gICAgICBjdHguYmVnaW5QYXRoKCk7XG4gICAgICBhZGRUb1BhdGgoY3R4LCBmb250U2l6ZSk7XG4gICAgICBpZiAocGF0dGVyblRyYW5zZm9ybSkge1xuICAgICAgICBjdHguc2V0VHJhbnNmb3JtKC4uLnBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBjdHguZmlsbCgpO1xuICAgICAgfVxuICAgICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIH1cbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LmZpbGxUZXh0KGNoYXJhY3RlciwgeCwgeSk7XG4gICAgICB9XG4gICAgICBpZiAoZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLlNUUk9LRSB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgICAgY3R4LnN0cm9rZVRleHQoY2hhcmFjdGVyLCB4LCB5KTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGlzQWRkVG9QYXRoU2V0KSB7XG4gICAgICBjb25zdCBwYXRocyA9IHRoaXMucGVuZGluZ1RleHRQYXRocyB8fD0gW107XG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgdHJhbnNmb3JtOiAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KSxcbiAgICAgICAgeCxcbiAgICAgICAgeSxcbiAgICAgICAgZm9udFNpemUsXG4gICAgICAgIGFkZFRvUGF0aFxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGdldCBpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250ZXh0OiBjdHhcbiAgICB9ID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCAxMCwgMTApO1xuICAgIGN0eC5zY2FsZSgxLjUsIDEpO1xuICAgIGN0eC5maWxsVGV4dChcIklcIiwgMCwgMTApO1xuICAgIGNvbnN0IGRhdGEgPSBjdHguZ2V0SW1hZ2VEYXRhKDAsIDAsIDEwLCAxMCkuZGF0YTtcbiAgICBsZXQgZW5hYmxlZCA9IGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAzOyBpIDwgZGF0YS5sZW5ndGg7IGkgKz0gNCkge1xuICAgICAgaWYgKGRhdGFbaV0gPiAwICYmIGRhdGFbaV0gPCAyNTUpIHtcbiAgICAgICAgZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJpc0ZvbnRTdWJwaXhlbEFBRW5hYmxlZFwiLCBlbmFibGVkKTtcbiAgfVxuICBzaG93VGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgaWYgKGZvbnQuaXNUeXBlM0ZvbnQpIHtcbiAgICAgIHJldHVybiB0aGlzLnNob3dUeXBlM1RleHQoZ2x5cGhzKTtcbiAgICB9XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZm9udFNpemVTY2FsZSA9IGN1cnJlbnQuZm9udFNpemVTY2FsZTtcbiAgICBjb25zdCBjaGFyU3BhY2luZyA9IGN1cnJlbnQuY2hhclNwYWNpbmc7XG4gICAgY29uc3Qgd29yZFNwYWNpbmcgPSBjdXJyZW50LndvcmRTcGFjaW5nO1xuICAgIGNvbnN0IGZvbnREaXJlY3Rpb24gPSBjdXJyZW50LmZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZ2x5cGhzTGVuZ3RoID0gZ2x5cGhzLmxlbmd0aDtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgY29uc3Qgc2ltcGxlRmlsbFRleHQgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMICYmICFmb250LmRpc2FibGVGb250RmFjZSAmJiAhY3VycmVudC5wYXR0ZXJuRmlsbDtcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC50cmFuc2Zvcm0oLi4uY3VycmVudC50ZXh0TWF0cml4KTtcbiAgICBjdHgudHJhbnNsYXRlKGN1cnJlbnQueCwgY3VycmVudC55ICsgY3VycmVudC50ZXh0UmlzZSk7XG4gICAgaWYgKGZvbnREaXJlY3Rpb24gPiAwKSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgLTEpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdHguc2NhbGUodGV4dEhTY2FsZSwgMSk7XG4gICAgfVxuICAgIGxldCBwYXR0ZXJuVHJhbnNmb3JtO1xuICAgIGlmIChjdXJyZW50LnBhdHRlcm5GaWxsKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY29uc3QgcGF0dGVybiA9IGN1cnJlbnQuZmlsbENvbG9yLmdldFBhdHRlcm4oY3R4LCB0aGlzLCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybUludmVyc2UpKGN0eCksIF9wYXR0ZXJuX2hlbHBlci5QYXRoVHlwZS5GSUxMKTtcbiAgICAgIHBhdHRlcm5UcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoY3R4KTtcbiAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguZmlsbFN0eWxlID0gcGF0dGVybjtcbiAgICB9XG4gICAgbGV0IGxpbmVXaWR0aCA9IGN1cnJlbnQubGluZVdpZHRoO1xuICAgIGNvbnN0IHNjYWxlID0gY3VycmVudC50ZXh0TWF0cml4U2NhbGU7XG4gICAgaWYgKHNjYWxlID09PSAwIHx8IGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgY29uc3QgZmlsbFN0cm9rZU1vZGUgPSBjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0VfTUFTSztcbiAgICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuU1RST0tFIHx8IGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRSkge1xuICAgICAgICBsaW5lV2lkdGggPSB0aGlzLmdldFNpbmdsZVBpeGVsV2lkdGgoKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGluZVdpZHRoIC89IHNjYWxlO1xuICAgIH1cbiAgICBpZiAoZm9udFNpemVTY2FsZSAhPT0gMS4wKSB7XG4gICAgICBjdHguc2NhbGUoZm9udFNpemVTY2FsZSwgZm9udFNpemVTY2FsZSk7XG4gICAgICBsaW5lV2lkdGggLz0gZm9udFNpemVTY2FsZTtcbiAgICB9XG4gICAgY3R4LmxpbmVXaWR0aCA9IGxpbmVXaWR0aDtcbiAgICBpZiAoZm9udC5pc0ludmFsaWRQREZqc0ZvbnQpIHtcbiAgICAgIGNvbnN0IGNoYXJzID0gW107XG4gICAgICBsZXQgd2lkdGggPSAwO1xuICAgICAgZm9yIChjb25zdCBnbHlwaCBvZiBnbHlwaHMpIHtcbiAgICAgICAgY2hhcnMucHVzaChnbHlwaC51bmljb2RlKTtcbiAgICAgICAgd2lkdGggKz0gZ2x5cGgud2lkdGg7XG4gICAgICB9XG4gICAgICBjdHguZmlsbFRleHQoY2hhcnMuam9pbihcIlwiKSwgMCwgMCk7XG4gICAgICBjdXJyZW50LnggKz0gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAqIHRleHRIU2NhbGU7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgICAgdGhpcy5jb21wb3NlKCk7XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgIH1cbiAgICBsZXQgeCA9IDAsXG4gICAgICBpO1xuICAgIGZvciAoaSA9IDA7IGkgPCBnbHlwaHNMZW5ndGg7ICsraSkge1xuICAgICAgY29uc3QgZ2x5cGggPSBnbHlwaHNbaV07XG4gICAgICBpZiAodHlwZW9mIGdseXBoID09PSBcIm51bWJlclwiKSB7XG4gICAgICAgIHggKz0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGxldCByZXN0b3JlTmVlZGVkID0gZmFsc2U7XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBjaGFyYWN0ZXIgPSBnbHlwaC5mb250Q2hhcjtcbiAgICAgIGNvbnN0IGFjY2VudCA9IGdseXBoLmFjY2VudDtcbiAgICAgIGxldCBzY2FsZWRYLCBzY2FsZWRZO1xuICAgICAgbGV0IHdpZHRoID0gZ2x5cGgud2lkdGg7XG4gICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgY29uc3Qgdm1ldHJpYyA9IGdseXBoLnZtZXRyaWMgfHwgZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICBjb25zdCB2eCA9IC0oZ2x5cGgudm1ldHJpYyA/IHZtZXRyaWNbMV0gOiB3aWR0aCAqIDAuNSkgKiB3aWR0aEFkdmFuY2VTY2FsZTtcbiAgICAgICAgY29uc3QgdnkgPSB2bWV0cmljWzJdICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIHdpZHRoID0gdm1ldHJpYyA/IC12bWV0cmljWzBdIDogd2lkdGg7XG4gICAgICAgIHNjYWxlZFggPSB2eCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAoeCArIHZ5KSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2FsZWRYID0geCAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgIHNjYWxlZFkgPSAwO1xuICAgICAgfVxuICAgICAgaWYgKGZvbnQucmVtZWFzdXJlICYmIHdpZHRoID4gMCkge1xuICAgICAgICBjb25zdCBtZWFzdXJlZFdpZHRoID0gY3R4Lm1lYXN1cmVUZXh0KGNoYXJhY3Rlcikud2lkdGggKiAxMDAwIC8gZm9udFNpemUgKiBmb250U2l6ZVNjYWxlO1xuICAgICAgICBpZiAod2lkdGggPCBtZWFzdXJlZFdpZHRoICYmIHRoaXMuaXNGb250U3VicGl4ZWxBQUVuYWJsZWQpIHtcbiAgICAgICAgICBjb25zdCBjaGFyYWN0ZXJTY2FsZVggPSB3aWR0aCAvIG1lYXN1cmVkV2lkdGg7XG4gICAgICAgICAgcmVzdG9yZU5lZWRlZCA9IHRydWU7XG4gICAgICAgICAgY3R4LnNhdmUoKTtcbiAgICAgICAgICBjdHguc2NhbGUoY2hhcmFjdGVyU2NhbGVYLCAxKTtcbiAgICAgICAgICBzY2FsZWRYIC89IGNoYXJhY3RlclNjYWxlWDtcbiAgICAgICAgfSBlbHNlIGlmICh3aWR0aCAhPT0gbWVhc3VyZWRXaWR0aCkge1xuICAgICAgICAgIHNjYWxlZFggKz0gKHdpZHRoIC0gbWVhc3VyZWRXaWR0aCkgLyAyMDAwICogZm9udFNpemUgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5jb250ZW50VmlzaWJsZSAmJiAoZ2x5cGguaXNJbkZvbnQgfHwgZm9udC5taXNzaW5nRmlsZSkpIHtcbiAgICAgICAgaWYgKHNpbXBsZUZpbGxUZXh0ICYmICFhY2NlbnQpIHtcbiAgICAgICAgICBjdHguZmlsbFRleHQoY2hhcmFjdGVyLCBzY2FsZWRYLCBzY2FsZWRZKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLnBhaW50Q2hhcihjaGFyYWN0ZXIsIHNjYWxlZFgsIHNjYWxlZFksIHBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgICAgIGlmIChhY2NlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHNjYWxlZEFjY2VudFggPSBzY2FsZWRYICsgZm9udFNpemUgKiBhY2NlbnQub2Zmc2V0LnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkQWNjZW50WSA9IHNjYWxlZFkgLSBmb250U2l6ZSAqIGFjY2VudC5vZmZzZXQueSAvIGZvbnRTaXplU2NhbGU7XG4gICAgICAgICAgICB0aGlzLnBhaW50Q2hhcihhY2NlbnQuZm9udENoYXIsIHNjYWxlZEFjY2VudFgsIHNjYWxlZEFjY2VudFksIHBhdHRlcm5UcmFuc2Zvcm0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2hhcldpZHRoID0gdmVydGljYWwgPyB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlIC0gc3BhY2luZyAqIGZvbnREaXJlY3Rpb24gOiB3aWR0aCAqIHdpZHRoQWR2YW5jZVNjYWxlICsgc3BhY2luZyAqIGZvbnREaXJlY3Rpb247XG4gICAgICB4ICs9IGNoYXJXaWR0aDtcbiAgICAgIGlmIChyZXN0b3JlTmVlZGVkKSB7XG4gICAgICAgIGN0eC5yZXN0b3JlKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh2ZXJ0aWNhbCkge1xuICAgICAgY3VycmVudC55IC09IHg7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQueCArPSB4ICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHNob3dUeXBlM1RleHQoZ2x5cGhzKSB7XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjb25zdCBmb250ID0gY3VycmVudC5mb250O1xuICAgIGNvbnN0IGZvbnRTaXplID0gY3VycmVudC5mb250U2l6ZTtcbiAgICBjb25zdCBmb250RGlyZWN0aW9uID0gY3VycmVudC5mb250RGlyZWN0aW9uO1xuICAgIGNvbnN0IHNwYWNpbmdEaXIgPSBmb250LnZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgdGV4dEhTY2FsZSA9IGN1cnJlbnQudGV4dEhTY2FsZSAqIGZvbnREaXJlY3Rpb247XG4gICAgY29uc3QgZm9udE1hdHJpeCA9IGN1cnJlbnQuZm9udE1hdHJpeCB8fCBfdXRpbC5GT05UX0lERU5USVRZX01BVFJJWDtcbiAgICBjb25zdCBnbHlwaHNMZW5ndGggPSBnbHlwaHMubGVuZ3RoO1xuICAgIGNvbnN0IGlzVGV4dEludmlzaWJsZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLklOVklTSUJMRTtcbiAgICBsZXQgaSwgZ2x5cGgsIHdpZHRoLCBzcGFjaW5nTGVuZ3RoO1xuICAgIGlmIChpc1RleHRJbnZpc2libGUgfHwgZm9udFNpemUgPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IC0xO1xuICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBudWxsO1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY3R4LnRyYW5zZm9ybSguLi5jdXJyZW50LnRleHRNYXRyaXgpO1xuICAgIGN0eC50cmFuc2xhdGUoY3VycmVudC54LCBjdXJyZW50LnkpO1xuICAgIGN0eC5zY2FsZSh0ZXh0SFNjYWxlLCBmb250RGlyZWN0aW9uKTtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZ2x5cGhzTGVuZ3RoOyArK2kpIHtcbiAgICAgIGdseXBoID0gZ2x5cGhzW2ldO1xuICAgICAgaWYgKHR5cGVvZiBnbHlwaCA9PT0gXCJudW1iZXJcIikge1xuICAgICAgICBzcGFjaW5nTGVuZ3RoID0gc3BhY2luZ0RpciAqIGdseXBoICogZm9udFNpemUgLyAxMDAwO1xuICAgICAgICB0aGlzLmN0eC50cmFuc2xhdGUoc3BhY2luZ0xlbmd0aCwgMCk7XG4gICAgICAgIGN1cnJlbnQueCArPSBzcGFjaW5nTGVuZ3RoICogdGV4dEhTY2FsZTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBzcGFjaW5nID0gKGdseXBoLmlzU3BhY2UgPyB3b3JkU3BhY2luZyA6IDApICsgY2hhclNwYWNpbmc7XG4gICAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBmb250LmNoYXJQcm9jT3BlcmF0b3JMaXN0W2dseXBoLm9wZXJhdG9yTGlzdElkXTtcbiAgICAgIGlmICghb3BlcmF0b3JMaXN0KSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgVHlwZTMgY2hhcmFjdGVyIFwiJHtnbHlwaC5vcGVyYXRvckxpc3RJZH1cIiBpcyBub3QgYXZhaWxhYmxlLmApO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICAgIHRoaXMucHJvY2Vzc2luZ1R5cGUzID0gZ2x5cGg7XG4gICAgICAgIHRoaXMuc2F2ZSgpO1xuICAgICAgICBjdHguc2NhbGUoZm9udFNpemUsIGZvbnRTaXplKTtcbiAgICAgICAgY3R4LnRyYW5zZm9ybSguLi5mb250TWF0cml4KTtcbiAgICAgICAgdGhpcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgICAgIHRoaXMucmVzdG9yZSgpO1xuICAgICAgfVxuICAgICAgY29uc3QgdHJhbnNmb3JtZWQgPSBfdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFtnbHlwaC53aWR0aCwgMF0sIGZvbnRNYXRyaXgpO1xuICAgICAgd2lkdGggPSB0cmFuc2Zvcm1lZFswXSAqIGZvbnRTaXplICsgc3BhY2luZztcbiAgICAgIGN0eC50cmFuc2xhdGUod2lkdGgsIDApO1xuICAgICAgY3VycmVudC54ICs9IHdpZHRoICogdGV4dEhTY2FsZTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLnByb2Nlc3NpbmdUeXBlMyA9IG51bGw7XG4gIH1cbiAgc2V0Q2hhcldpZHRoKHhXaWR0aCwgeVdpZHRoKSB7fVxuICBzZXRDaGFyV2lkdGhBbmRCb3VuZHMoeFdpZHRoLCB5V2lkdGgsIGxseCwgbGx5LCB1cngsIHVyeSkge1xuICAgIHRoaXMuY3R4LnJlY3QobGx4LCBsbHksIHVyeCAtIGxseCwgdXJ5IC0gbGx5KTtcbiAgICB0aGlzLmN0eC5jbGlwKCk7XG4gICAgdGhpcy5lbmRQYXRoKCk7XG4gIH1cbiAgZ2V0Q29sb3JOX1BhdHRlcm4oSVIpIHtcbiAgICBsZXQgcGF0dGVybjtcbiAgICBpZiAoSVJbMF0gPT09IFwiVGlsaW5nUGF0dGVyblwiKSB7XG4gICAgICBjb25zdCBjb2xvciA9IElSWzFdO1xuICAgICAgY29uc3QgYmFzZVRyYW5zZm9ybSA9IHRoaXMuYmFzZVRyYW5zZm9ybSB8fCAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgICAgY29uc3QgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0ge1xuICAgICAgICBjcmVhdGVDYW52YXNHcmFwaGljczogY3R4ID0+IHtcbiAgICAgICAgICByZXR1cm4gbmV3IENhbnZhc0dyYXBoaWNzKGN0eCwgdGhpcy5jb21tb25PYmpzLCB0aGlzLm9ianMsIHRoaXMuY2FudmFzRmFjdG9yeSwgdGhpcy5maWx0ZXJGYWN0b3J5LCB7XG4gICAgICAgICAgICBvcHRpb25hbENvbnRlbnRDb25maWc6IHRoaXMub3B0aW9uYWxDb250ZW50Q29uZmlnLFxuICAgICAgICAgICAgbWFya2VkQ29udGVudFN0YWNrOiB0aGlzLm1hcmtlZENvbnRlbnRTdGFja1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9O1xuICAgICAgcGF0dGVybiA9IG5ldyBfcGF0dGVybl9oZWxwZXIuVGlsaW5nUGF0dGVybihJUiwgY29sb3IsIHRoaXMuY3R4LCBjYW52YXNHcmFwaGljc0ZhY3RvcnksIGJhc2VUcmFuc2Zvcm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihJUlsxXSwgSVJbMl0pO1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzZXRTdHJva2VDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gdGhpcy5nZXRDb2xvck5fUGF0dGVybihhcmd1bWVudHMpO1xuICB9XG4gIHNldEZpbGxDb2xvck4oKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuZ2V0Q29sb3JOX1BhdHRlcm4oYXJndW1lbnRzKTtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSB0cnVlO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICBjb25zdCBjb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgIHRoaXMuY3R4LnN0cm9rZVN0eWxlID0gY29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gY29sb3I7XG4gIH1cbiAgc2V0RmlsbFJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICBjb25zdCBjb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKHIsIGcsIGIpO1xuICAgIHRoaXMuY3R4LmZpbGxTdHlsZSA9IGNvbG9yO1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN1cnJlbnQucGF0dGVybkZpbGwgPSBmYWxzZTtcbiAgfVxuICBfZ2V0UGF0dGVybihvYmpJZCkge1xuICAgIGxldCBtYXRyaXggPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgbGV0IHBhdHRlcm47XG4gICAgaWYgKHRoaXMuY2FjaGVkUGF0dGVybnMuaGFzKG9iaklkKSkge1xuICAgICAgcGF0dGVybiA9IHRoaXMuY2FjaGVkUGF0dGVybnMuZ2V0KG9iaklkKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcGF0dGVybiA9ICgwLCBfcGF0dGVybl9oZWxwZXIuZ2V0U2hhZGluZ1BhdHRlcm4pKHRoaXMuZ2V0T2JqZWN0KG9iaklkKSk7XG4gICAgICB0aGlzLmNhY2hlZFBhdHRlcm5zLnNldChvYmpJZCwgcGF0dGVybik7XG4gICAgfVxuICAgIGlmIChtYXRyaXgpIHtcbiAgICAgIHBhdHRlcm4ubWF0cml4ID0gbWF0cml4O1xuICAgIH1cbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxuICBzaGFkaW5nRmlsbChvYmpJZCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBjb25zdCBwYXR0ZXJuID0gdGhpcy5fZ2V0UGF0dGVybihvYmpJZCk7XG4gICAgY3R4LmZpbGxTdHlsZSA9IHBhdHRlcm4uZ2V0UGF0dGVybihjdHgsIHRoaXMsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KSwgX3BhdHRlcm5faGVscGVyLlBhdGhUeXBlLlNIQURJTkcpO1xuICAgIGNvbnN0IGludiA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtSW52ZXJzZSkoY3R4KTtcbiAgICBpZiAoaW52KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHRcbiAgICAgIH0gPSBjdHguY2FudmFzO1xuICAgICAgY29uc3QgW3gwLCB5MCwgeDEsIHkxXSA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIHdpZHRoLCBoZWlnaHRdLCBpbnYpO1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoeDAsIHkwLCB4MSAtIHgwLCB5MSAtIHkwKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5jdHguZmlsbFJlY3QoLTFlMTAsIC0xZTEwLCAyZTEwLCAyZTEwKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKHRoaXMuY3VycmVudC5nZXRDbGlwcGVkUGF0aEJvdW5kaW5nQm94KCkpO1xuICAgIHRoaXMucmVzdG9yZSgpO1xuICB9XG4gIGJlZ2luSW5saW5lSW1hZ2UoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIlNob3VsZCBub3QgY2FsbCBiZWdpbklubGluZUltYWdlXCIpO1xuICB9XG4gIGJlZ2luSW1hZ2VEYXRhKCkge1xuICAgICgwLCBfdXRpbC51bnJlYWNoYWJsZSkoXCJTaG91bGQgbm90IGNhbGwgYmVnaW5JbWFnZURhdGFcIik7XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luKG1hdHJpeCwgYmJveCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnNhdmUoKTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMuYmFzZVRyYW5zZm9ybSk7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobWF0cml4KSAmJiBtYXRyaXgubGVuZ3RoID09PSA2KSB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSguLi5tYXRyaXgpO1xuICAgIH1cbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgIGlmIChiYm94KSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gICAgICB0aGlzLmN0eC5yZWN0KGJib3hbMF0sIGJib3hbMV0sIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgdGhpcy5jdXJyZW50LnVwZGF0ZVJlY3RNaW5NYXgoKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKHRoaXMuY3R4KSwgYmJveCk7XG4gICAgICB0aGlzLmNsaXAoKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBwYWludEZvcm1YT2JqZWN0RW5kKCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSB0aGlzLmJhc2VUcmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgfVxuICBiZWdpbkdyb3VwKGdyb3VwKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICh0aGlzLmluU01hc2tNb2RlKSB7XG4gICAgICB0aGlzLmVuZFNNYXNrTW9kZSgpO1xuICAgICAgdGhpcy5jdXJyZW50LmFjdGl2ZVNNYXNrID0gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgY3VycmVudEN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICghZ3JvdXAuaXNvbGF0ZWQpIHtcbiAgICAgICgwLCBfdXRpbC5pbmZvKShcIlRPRE86IFN1cHBvcnQgbm9uLWlzb2xhdGVkIGdyb3Vwcy5cIik7XG4gICAgfVxuICAgIGlmIChncm91cC5rbm9ja291dCkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiS25vY2tvdXQgZ3JvdXBzIG5vdCBzdXBwb3J0ZWQuXCIpO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50VHJhbnNmb3JtID0gKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN1cnJlbnRDdHgpO1xuICAgIGlmIChncm91cC5tYXRyaXgpIHtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNmb3JtKC4uLmdyb3VwLm1hdHJpeCk7XG4gICAgfVxuICAgIGlmICghZ3JvdXAuYmJveCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQm91bmRpbmcgYm94IGlzIHJlcXVpcmVkLlwiKTtcbiAgICB9XG4gICAgbGV0IGJvdW5kcyA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goZ3JvdXAuYmJveCwgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm0pKGN1cnJlbnRDdHgpKTtcbiAgICBjb25zdCBjYW52YXNCb3VuZHMgPSBbMCwgMCwgY3VycmVudEN0eC5jYW52YXMud2lkdGgsIGN1cnJlbnRDdHguY2FudmFzLmhlaWdodF07XG4gICAgYm91bmRzID0gX3V0aWwuVXRpbC5pbnRlcnNlY3QoYm91bmRzLCBjYW52YXNCb3VuZHMpIHx8IFswLCAwLCAwLCAwXTtcbiAgICBjb25zdCBvZmZzZXRYID0gTWF0aC5mbG9vcihib3VuZHNbMF0pO1xuICAgIGNvbnN0IG9mZnNldFkgPSBNYXRoLmZsb29yKGJvdW5kc1sxXSk7XG4gICAgbGV0IGRyYXduV2lkdGggPSBNYXRoLm1heChNYXRoLmNlaWwoYm91bmRzWzJdKSAtIG9mZnNldFgsIDEpO1xuICAgIGxldCBkcmF3bkhlaWdodCA9IE1hdGgubWF4KE1hdGguY2VpbChib3VuZHNbM10pIC0gb2Zmc2V0WSwgMSk7XG4gICAgbGV0IHNjYWxlWCA9IDEsXG4gICAgICBzY2FsZVkgPSAxO1xuICAgIGlmIChkcmF3bldpZHRoID4gTUFYX0dST1VQX1NJWkUpIHtcbiAgICAgIHNjYWxlWCA9IGRyYXduV2lkdGggLyBNQVhfR1JPVVBfU0laRTtcbiAgICAgIGRyYXduV2lkdGggPSBNQVhfR1JPVVBfU0laRTtcbiAgICB9XG4gICAgaWYgKGRyYXduSGVpZ2h0ID4gTUFYX0dST1VQX1NJWkUpIHtcbiAgICAgIHNjYWxlWSA9IGRyYXduSGVpZ2h0IC8gTUFYX0dST1VQX1NJWkU7XG4gICAgICBkcmF3bkhlaWdodCA9IE1BWF9HUk9VUF9TSVpFO1xuICAgIH1cbiAgICB0aGlzLmN1cnJlbnQuc3RhcnROZXdQYXRoQW5kQ2xpcEJveChbMCwgMCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHRdKTtcbiAgICBsZXQgY2FjaGVJZCA9IFwiZ3JvdXBBdFwiICsgdGhpcy5ncm91cExldmVsO1xuICAgIGlmIChncm91cC5zbWFzaykge1xuICAgICAgY2FjaGVJZCArPSBcIl9zbWFza19cIiArIHRoaXMuc21hc2tDb3VudGVyKysgJSAyO1xuICAgIH1cbiAgICBjb25zdCBzY3JhdGNoQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoY2FjaGVJZCwgZHJhd25XaWR0aCwgZHJhd25IZWlnaHQpO1xuICAgIGNvbnN0IGdyb3VwQ3R4ID0gc2NyYXRjaENhbnZhcy5jb250ZXh0O1xuICAgIGdyb3VwQ3R4LnNjYWxlKDEgLyBzY2FsZVgsIDEgLyBzY2FsZVkpO1xuICAgIGdyb3VwQ3R4LnRyYW5zbGF0ZSgtb2Zmc2V0WCwgLW9mZnNldFkpO1xuICAgIGdyb3VwQ3R4LnRyYW5zZm9ybSguLi5jdXJyZW50VHJhbnNmb3JtKTtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIHRoaXMuc21hc2tTdGFjay5wdXNoKHtcbiAgICAgICAgY2FudmFzOiBzY3JhdGNoQ2FudmFzLmNhbnZhcyxcbiAgICAgICAgY29udGV4dDogZ3JvdXBDdHgsXG4gICAgICAgIG9mZnNldFgsXG4gICAgICAgIG9mZnNldFksXG4gICAgICAgIHNjYWxlWCxcbiAgICAgICAgc2NhbGVZLFxuICAgICAgICBzdWJ0eXBlOiBncm91cC5zbWFzay5zdWJ0eXBlLFxuICAgICAgICBiYWNrZHJvcDogZ3JvdXAuc21hc2suYmFja2Ryb3AsXG4gICAgICAgIHRyYW5zZmVyTWFwOiBncm91cC5zbWFzay50cmFuc2Zlck1hcCB8fCBudWxsLFxuICAgICAgICBzdGFydFRyYW5zZm9ybUludmVyc2U6IG51bGxcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50Q3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICAgIGN1cnJlbnRDdHgudHJhbnNsYXRlKG9mZnNldFgsIG9mZnNldFkpO1xuICAgICAgY3VycmVudEN0eC5zY2FsZShzY2FsZVgsIHNjYWxlWSk7XG4gICAgICBjdXJyZW50Q3R4LnNhdmUoKTtcbiAgICB9XG4gICAgY29weUN0eFN0YXRlKGN1cnJlbnRDdHgsIGdyb3VwQ3R4KTtcbiAgICB0aGlzLmN0eCA9IGdyb3VwQ3R4O1xuICAgIHRoaXMuc2V0R1N0YXRlKFtbXCJCTVwiLCBcInNvdXJjZS1vdmVyXCJdLCBbXCJjYVwiLCAxXSwgW1wiQ0FcIiwgMV1dKTtcbiAgICB0aGlzLmdyb3VwU3RhY2sucHVzaChjdXJyZW50Q3R4KTtcbiAgICB0aGlzLmdyb3VwTGV2ZWwrKztcbiAgfVxuICBlbmRHcm91cChncm91cCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmdyb3VwTGV2ZWwtLTtcbiAgICBjb25zdCBncm91cEN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuZ3JvdXBTdGFjay5wb3AoKTtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmN0eC5pbWFnZVNtb290aGluZ0VuYWJsZWQgPSBmYWxzZTtcbiAgICBpZiAoZ3JvdXAuc21hc2spIHtcbiAgICAgIHRoaXMudGVtcFNNYXNrID0gdGhpcy5zbWFza1N0YWNrLnBvcCgpO1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuY3R4LnJlc3RvcmUoKTtcbiAgICAgIGNvbnN0IGN1cnJlbnRNdHggPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgICAgdGhpcy5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4uY3VycmVudE10eCk7XG4gICAgICBjb25zdCBkaXJ0eUJveCA9IF91dGlsLlV0aWwuZ2V0QXhpYWxBbGlnbmVkQm91bmRpbmdCb3goWzAsIDAsIGdyb3VwQ3R4LmNhbnZhcy53aWR0aCwgZ3JvdXBDdHguY2FudmFzLmhlaWdodF0sIGN1cnJlbnRNdHgpO1xuICAgICAgdGhpcy5jdHguZHJhd0ltYWdlKGdyb3VwQ3R4LmNhbnZhcywgMCwgMCk7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLmNvbXBvc2UoZGlydHlCb3gpO1xuICAgIH1cbiAgfVxuICBiZWdpbkFubm90YXRpb24oaWQsIHJlY3QsIHRyYW5zZm9ybSwgbWF0cml4LCBoYXNPd25DYW52YXMpIHtcbiAgICB0aGlzLiNyZXN0b3JlSW5pdGlhbFN0YXRlKCk7XG4gICAgcmVzZXRDdHhUb0RlZmF1bHQodGhpcy5jdHgpO1xuICAgIHRoaXMuY3R4LnNhdmUoKTtcbiAgICB0aGlzLnNhdmUoKTtcbiAgICBpZiAodGhpcy5iYXNlVHJhbnNmb3JtKSB7XG4gICAgICB0aGlzLmN0eC5zZXRUcmFuc2Zvcm0oLi4udGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVjdCkgJiYgcmVjdC5sZW5ndGggPT09IDQpIHtcbiAgICAgIGNvbnN0IHdpZHRoID0gcmVjdFsyXSAtIHJlY3RbMF07XG4gICAgICBjb25zdCBoZWlnaHQgPSByZWN0WzNdIC0gcmVjdFsxXTtcbiAgICAgIGlmIChoYXNPd25DYW52YXMgJiYgdGhpcy5hbm5vdGF0aW9uQ2FudmFzTWFwKSB7XG4gICAgICAgIHRyYW5zZm9ybSA9IHRyYW5zZm9ybS5zbGljZSgpO1xuICAgICAgICB0cmFuc2Zvcm1bNF0gLT0gcmVjdFswXTtcbiAgICAgICAgdHJhbnNmb3JtWzVdIC09IHJlY3RbMV07XG4gICAgICAgIHJlY3QgPSByZWN0LnNsaWNlKCk7XG4gICAgICAgIHJlY3RbMF0gPSByZWN0WzFdID0gMDtcbiAgICAgICAgcmVjdFsyXSA9IHdpZHRoO1xuICAgICAgICByZWN0WzNdID0gaGVpZ2h0O1xuICAgICAgICBjb25zdCBbc2NhbGVYLCBzY2FsZVldID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSgoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpKTtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHZpZXdwb3J0U2NhbGVcbiAgICAgICAgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IGNhbnZhc1dpZHRoID0gTWF0aC5jZWlsKHdpZHRoICogdGhpcy5vdXRwdXRTY2FsZVggKiB2aWV3cG9ydFNjYWxlKTtcbiAgICAgICAgY29uc3QgY2FudmFzSGVpZ2h0ID0gTWF0aC5jZWlsKGhlaWdodCAqIHRoaXMub3V0cHV0U2NhbGVZICogdmlld3BvcnRTY2FsZSk7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvbkNhbnZhcyA9IHRoaXMuY2FudmFzRmFjdG9yeS5jcmVhdGUoY2FudmFzV2lkdGgsIGNhbnZhc0hlaWdodCk7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBjYW52YXMsXG4gICAgICAgICAgY29udGV4dFxuICAgICAgICB9ID0gdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXNNYXAuc2V0KGlkLCBjYW52YXMpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHggPSB0aGlzLmN0eDtcbiAgICAgICAgdGhpcy5jdHggPSBjb250ZXh0O1xuICAgICAgICB0aGlzLmN0eC5zYXZlKCk7XG4gICAgICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybShzY2FsZVgsIDAsIDAsIC1zY2FsZVksIDAsIGhlaWdodCAqIHNjYWxlWSk7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHJlc2V0Q3R4VG9EZWZhdWx0KHRoaXMuY3R4KTtcbiAgICAgICAgdGhpcy5jdHgucmVjdChyZWN0WzBdLCByZWN0WzFdLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgICAgdGhpcy5jdHguY2xpcCgpO1xuICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jdXJyZW50ID0gbmV3IENhbnZhc0V4dHJhU3RhdGUodGhpcy5jdHguY2FudmFzLndpZHRoLCB0aGlzLmN0eC5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgIHRoaXMudHJhbnNmb3JtKC4uLm1hdHJpeCk7XG4gIH1cbiAgZW5kQW5ub3RhdGlvbigpIHtcbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uQ2FudmFzKSB7XG4gICAgICB0aGlzLmN0eC5yZXN0b3JlKCk7XG4gICAgICB0aGlzLiNkcmF3RmlsdGVyKCk7XG4gICAgICB0aGlzLmN0eCA9IHRoaXMuYW5ub3RhdGlvbkNhbnZhcy5zYXZlZEN0eDtcbiAgICAgIGRlbGV0ZSB0aGlzLmFubm90YXRpb25DYW52YXMuc2F2ZWRDdHg7XG4gICAgICBkZWxldGUgdGhpcy5hbm5vdGF0aW9uQ2FudmFzO1xuICAgIH1cbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3QoaW1nKSB7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvdW50ID0gaW1nLmNvdW50O1xuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGltZy5jb3VudCA9IGNvdW50O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGNvbnN0IGdseXBoID0gdGhpcy5wcm9jZXNzaW5nVHlwZTM7XG4gICAgaWYgKGdseXBoKSB7XG4gICAgICBpZiAoZ2x5cGguY29tcGlsZWQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBnbHlwaC5jb21waWxlZCA9IGNvbXBpbGVUeXBlM0dseXBoKGltZyk7XG4gICAgICB9XG4gICAgICBpZiAoZ2x5cGguY29tcGlsZWQpIHtcbiAgICAgICAgZ2x5cGguY29tcGlsZWQoY3R4KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBtYXNrID0gdGhpcy5fY3JlYXRlTWFza0NhbnZhcyhpbWcpO1xuICAgIGNvbnN0IG1hc2tDYW52YXMgPSBtYXNrLmNhbnZhcztcbiAgICBjdHguc2F2ZSgpO1xuICAgIGN0eC5zZXRUcmFuc2Zvcm0oMSwgMCwgMCwgMSwgMCwgMCk7XG4gICAgY3R4LmRyYXdJbWFnZShtYXNrQ2FudmFzLCBtYXNrLm9mZnNldFgsIG1hc2sub2Zmc2V0WSk7XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3RSZXBlYXQoaW1nLCBzY2FsZVgpIHtcbiAgICBsZXQgc2tld1ggPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IDA7XG4gICAgbGV0IHNrZXdZID0gYXJndW1lbnRzLmxlbmd0aCA+IDMgJiYgYXJndW1lbnRzWzNdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbM10gOiAwO1xuICAgIGxldCBzY2FsZVkgPSBhcmd1bWVudHMubGVuZ3RoID4gNCA/IGFyZ3VtZW50c1s0XSA6IHVuZGVmaW5lZDtcbiAgICBsZXQgcG9zaXRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgPyBhcmd1bWVudHNbNV0gOiB1bmRlZmluZWQ7XG4gICAgaWYgKCF0aGlzLmNvbnRlbnRWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGltZyA9IHRoaXMuZ2V0T2JqZWN0KGltZy5kYXRhLCBpbWcpO1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGN0eC5zYXZlKCk7XG4gICAgY29uc3QgY3VycmVudFRyYW5zZm9ybSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpO1xuICAgIGN0eC50cmFuc2Zvcm0oc2NhbGVYLCBza2V3WCwgc2tld1ksIHNjYWxlWSwgMCwgMCk7XG4gICAgY29uc3QgbWFzayA9IHRoaXMuX2NyZWF0ZU1hc2tDYW52YXMoaW1nKTtcbiAgICBjdHguc2V0VHJhbnNmb3JtKDEsIDAsIDAsIDEsIG1hc2sub2Zmc2V0WCAtIGN1cnJlbnRUcmFuc2Zvcm1bNF0sIG1hc2sub2Zmc2V0WSAtIGN1cnJlbnRUcmFuc2Zvcm1bNV0pO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBjb25zdCB0cmFucyA9IF91dGlsLlV0aWwudHJhbnNmb3JtKGN1cnJlbnRUcmFuc2Zvcm0sIFtzY2FsZVgsIHNrZXdYLCBza2V3WSwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV1dKTtcbiAgICAgIGNvbnN0IFt4LCB5XSA9IF91dGlsLlV0aWwuYXBwbHlUcmFuc2Zvcm0oWzAsIDBdLCB0cmFucyk7XG4gICAgICBjdHguZHJhd0ltYWdlKG1hc2suY2FudmFzLCB4LCB5KTtcbiAgICB9XG4gICAgY3R4LnJlc3RvcmUoKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlTWFza1hPYmplY3RHcm91cChpbWFnZXMpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgY29uc3QgZmlsbENvbG9yID0gdGhpcy5jdXJyZW50LmZpbGxDb2xvcjtcbiAgICBjb25zdCBpc1BhdHRlcm5GaWxsID0gdGhpcy5jdXJyZW50LnBhdHRlcm5GaWxsO1xuICAgIGZvciAoY29uc3QgaW1hZ2Ugb2YgaW1hZ2VzKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGRhdGEsXG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRyYW5zZm9ybVxuICAgICAgfSA9IGltYWdlO1xuICAgICAgY29uc3QgbWFza0NhbnZhcyA9IHRoaXMuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWFza0NhbnZhc1wiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IG1hc2tDdHggPSBtYXNrQ2FudmFzLmNvbnRleHQ7XG4gICAgICBtYXNrQ3R4LnNhdmUoKTtcbiAgICAgIGNvbnN0IGltZyA9IHRoaXMuZ2V0T2JqZWN0KGRhdGEsIGltYWdlKTtcbiAgICAgIHB1dEJpbmFyeUltYWdlTWFzayhtYXNrQ3R4LCBpbWcpO1xuICAgICAgbWFza0N0eC5nbG9iYWxDb21wb3NpdGVPcGVyYXRpb24gPSBcInNvdXJjZS1pblwiO1xuICAgICAgbWFza0N0eC5maWxsU3R5bGUgPSBpc1BhdHRlcm5GaWxsID8gZmlsbENvbG9yLmdldFBhdHRlcm4obWFza0N0eCwgdGhpcywgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpLCBfcGF0dGVybl9oZWxwZXIuUGF0aFR5cGUuRklMTCkgOiBmaWxsQ29sb3I7XG4gICAgICBtYXNrQ3R4LmZpbGxSZWN0KDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgbWFza0N0eC5yZXN0b3JlKCk7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgICAgY3R4LnRyYW5zZm9ybSguLi50cmFuc2Zvcm0pO1xuICAgICAgY3R4LnNjYWxlKDEsIC0xKTtcbiAgICAgIGRyYXdJbWFnZUF0SW50ZWdlckNvb3JkcyhjdHgsIG1hc2tDYW52YXMuY2FudmFzLCAwLCAwLCB3aWR0aCwgaGVpZ2h0LCAwLCAtMSwgMSwgMSk7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdChvYmpJZCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChpbWdEYXRhKTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdFJlcGVhdChvYmpJZCwgc2NhbGVYLCBzY2FsZVksIHBvc2l0aW9ucykge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3Qob2JqSWQpO1xuICAgIGlmICghaW1nRGF0YSkge1xuICAgICAgKDAsIF91dGlsLndhcm4pKFwiRGVwZW5kZW50IGltYWdlIGlzbid0IHJlYWR5IHlldFwiKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IG1hcCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvc2l0aW9ucy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICBtYXAucHVzaCh7XG4gICAgICAgIHRyYW5zZm9ybTogW3NjYWxlWCwgMCwgMCwgc2NhbGVZLCBwb3NpdGlvbnNbaV0sIHBvc2l0aW9uc1tpICsgMV1dLFxuICAgICAgICB4OiAwLFxuICAgICAgICB5OiAwLFxuICAgICAgICB3OiB3aWR0aCxcbiAgICAgICAgaDogaGVpZ2h0XG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKGltZ0RhdGEsIG1hcCk7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0NhbnZhcyhjdHgpIHtcbiAgICBpZiAodGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcyAhPT0gXCJub25lXCIpIHtcbiAgICAgIGN0eC5maWx0ZXIgPSB0aGlzLmN1cnJlbnQudHJhbnNmZXJNYXBzO1xuICAgICAgY3R4LmRyYXdJbWFnZShjdHguY2FudmFzLCAwLCAwKTtcbiAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICB9XG4gICAgcmV0dXJuIGN0eC5jYW52YXM7XG4gIH1cbiAgYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKSB7XG4gICAgaWYgKHRoaXMuY3VycmVudC50cmFuc2Zlck1hcHMgPT09IFwibm9uZVwiKSB7XG4gICAgICByZXR1cm4gaW1nRGF0YS5iaXRtYXA7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGJpdG1hcCxcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGltZ0RhdGE7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCB0bXBDdHggPSB0bXBDYW52YXMuY29udGV4dDtcbiAgICB0bXBDdHguZmlsdGVyID0gdGhpcy5jdXJyZW50LnRyYW5zZmVyTWFwcztcbiAgICB0bXBDdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCk7XG4gICAgdG1wQ3R4LmZpbHRlciA9IFwibm9uZVwiO1xuICAgIHJldHVybiB0bXBDYW52YXMuY2FudmFzO1xuICB9XG4gIHBhaW50SW5saW5lSW1hZ2VYT2JqZWN0KGltZ0RhdGEpIHtcbiAgICBpZiAoIXRoaXMuY29udGVudFZpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIGlmICghX3V0aWwuaXNOb2RlSlMpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlsdGVyXG4gICAgICB9ID0gY3R4O1xuICAgICAgaWYgKGZpbHRlciAhPT0gXCJub25lXCIgJiYgZmlsdGVyICE9PSBcIlwiKSB7XG4gICAgICAgIGN0eC5maWx0ZXIgPSBcIm5vbmVcIjtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LnNjYWxlKDEgLyB3aWR0aCwgLTEgLyBoZWlnaHQpO1xuICAgIGxldCBpbWdUb1BhaW50O1xuICAgIGlmIChpbWdEYXRhLmJpdG1hcCkge1xuICAgICAgaW1nVG9QYWludCA9IHRoaXMuYXBwbHlUcmFuc2Zlck1hcHNUb0JpdG1hcChpbWdEYXRhKTtcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBIVE1MRWxlbWVudCA9PT0gXCJmdW5jdGlvblwiICYmIGltZ0RhdGEgaW5zdGFuY2VvZiBIVE1MRWxlbWVudCB8fCAhaW1nRGF0YS5kYXRhKSB7XG4gICAgICBpbWdUb1BhaW50ID0gaW1nRGF0YTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gdGhpcy5jYWNoZWRDYW52YXNlcy5nZXRDYW52YXMoXCJpbmxpbmVJbWFnZVwiLCB3aWR0aCwgaGVpZ2h0KTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgcHV0QmluYXJ5SW1hZ2VEYXRhKHRtcEN0eCwgaW1nRGF0YSk7XG4gICAgICBpbWdUb1BhaW50ID0gdGhpcy5hcHBseVRyYW5zZmVyTWFwc1RvQ2FudmFzKHRtcEN0eCk7XG4gICAgfVxuICAgIGNvbnN0IHNjYWxlZCA9IHRoaXMuX3NjYWxlSW1hZ2UoaW1nVG9QYWludCwgKDAsIF9kaXNwbGF5X3V0aWxzLmdldEN1cnJlbnRUcmFuc2Zvcm1JbnZlcnNlKShjdHgpKTtcbiAgICBjdHguaW1hZ2VTbW9vdGhpbmdFbmFibGVkID0gZ2V0SW1hZ2VTbW9vdGhpbmdFbmFibGVkKCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpLCBpbWdEYXRhLmludGVycG9sYXRlKTtcbiAgICBkcmF3SW1hZ2VBdEludGVnZXJDb29yZHMoY3R4LCBzY2FsZWQuaW1nLCAwLCAwLCBzY2FsZWQucGFpbnRXaWR0aCwgc2NhbGVkLnBhaW50SGVpZ2h0LCAwLCAtaGVpZ2h0LCB3aWR0aCwgaGVpZ2h0KTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgICB0aGlzLnJlc3RvcmUoKTtcbiAgfVxuICBwYWludElubGluZUltYWdlWE9iamVjdEdyb3VwKGltZ0RhdGEsIG1hcCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdHggPSB0aGlzLmN0eDtcbiAgICBsZXQgaW1nVG9QYWludDtcbiAgICBpZiAoaW1nRGF0YS5iaXRtYXApIHtcbiAgICAgIGltZ1RvUGFpbnQgPSBpbWdEYXRhLmJpdG1hcDtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdyA9IGltZ0RhdGEud2lkdGg7XG4gICAgICBjb25zdCBoID0gaW1nRGF0YS5oZWlnaHQ7XG4gICAgICBjb25zdCB0bXBDYW52YXMgPSB0aGlzLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcImlubGluZUltYWdlXCIsIHcsIGgpO1xuICAgICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgICBwdXRCaW5hcnlJbWFnZURhdGEodG1wQ3R4LCBpbWdEYXRhKTtcbiAgICAgIGltZ1RvUGFpbnQgPSB0aGlzLmFwcGx5VHJhbnNmZXJNYXBzVG9DYW52YXModG1wQ3R4KTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbnRyeSBvZiBtYXApIHtcbiAgICAgIGN0eC5zYXZlKCk7XG4gICAgICBjdHgudHJhbnNmb3JtKC4uLmVudHJ5LnRyYW5zZm9ybSk7XG4gICAgICBjdHguc2NhbGUoMSwgLTEpO1xuICAgICAgZHJhd0ltYWdlQXRJbnRlZ2VyQ29vcmRzKGN0eCwgaW1nVG9QYWludCwgZW50cnkueCwgZW50cnkueSwgZW50cnkudywgZW50cnkuaCwgMCwgLTEsIDEsIDEpO1xuICAgICAgY3R4LnJlc3RvcmUoKTtcbiAgICB9XG4gICAgdGhpcy5jb21wb3NlKCk7XG4gIH1cbiAgcGFpbnRTb2xpZENvbG9ySW1hZ2VNYXNrKCkge1xuICAgIGlmICghdGhpcy5jb250ZW50VmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLmN0eC5maWxsUmVjdCgwLCAwLCAxLCAxKTtcbiAgICB0aGlzLmNvbXBvc2UoKTtcbiAgfVxuICBtYXJrUG9pbnQodGFnKSB7fVxuICBtYXJrUG9pbnRQcm9wcyh0YWcsIHByb3BlcnRpZXMpIHt9XG4gIGJlZ2luTWFya2VkQ29udGVudCh0YWcpIHtcbiAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgIHZpc2libGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICBiZWdpbk1hcmtlZENvbnRlbnRQcm9wcyh0YWcsIHByb3BlcnRpZXMpIHtcbiAgICBpZiAodGFnID09PSBcIk9DXCIpIHtcbiAgICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnB1c2goe1xuICAgICAgICB2aXNpYmxlOiB0aGlzLm9wdGlvbmFsQ29udGVudENvbmZpZy5pc1Zpc2libGUocHJvcGVydGllcylcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5wdXNoKHtcbiAgICAgICAgdmlzaWJsZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0aGlzLmlzQ29udGVudFZpc2libGUoKTtcbiAgfVxuICBlbmRNYXJrZWRDb250ZW50KCkge1xuICAgIHRoaXMubWFya2VkQ29udGVudFN0YWNrLnBvcCgpO1xuICAgIHRoaXMuY29udGVudFZpc2libGUgPSB0aGlzLmlzQ29udGVudFZpc2libGUoKTtcbiAgfVxuICBiZWdpbkNvbXBhdCgpIHt9XG4gIGVuZENvbXBhdCgpIHt9XG4gIGNvbnN1bWVQYXRoKGNsaXBCb3gpIHtcbiAgICBjb25zdCBpc0VtcHR5ID0gdGhpcy5jdXJyZW50LmlzRW1wdHlDbGlwKCk7XG4gICAgaWYgKHRoaXMucGVuZGluZ0NsaXApIHtcbiAgICAgIHRoaXMuY3VycmVudC51cGRhdGVDbGlwRnJvbVBhdGgoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICB0aGlzLmNvbXBvc2UoY2xpcEJveCk7XG4gICAgfVxuICAgIGNvbnN0IGN0eCA9IHRoaXMuY3R4O1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICBpZiAoIWlzRW1wdHkpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ0NsaXAgPT09IEVPX0NMSVApIHtcbiAgICAgICAgICBjdHguY2xpcChcImV2ZW5vZGRcIik7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3R4LmNsaXAoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudC5zdGFydE5ld1BhdGhBbmRDbGlwQm94KHRoaXMuY3VycmVudC5jbGlwQm94KTtcbiAgICBjdHguYmVnaW5QYXRoKCk7XG4gIH1cbiAgZ2V0U2luZ2xlUGl4ZWxXaWR0aCgpIHtcbiAgICBpZiAoIXRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGgpIHtcbiAgICAgIGNvbnN0IG0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkodGhpcy5jdHgpO1xuICAgICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgICB0aGlzLl9jYWNoZWRHZXRTaW5nbGVQaXhlbFdpZHRoID0gMSAvIE1hdGgubWluKE1hdGguYWJzKG1bMF0pLCBNYXRoLmFicyhtWzNdKSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCBhYnNEZXQgPSBNYXRoLmFicyhtWzBdICogbVszXSAtIG1bMl0gKiBtWzFdKTtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmh5cG90KG1bMF0sIG1bMl0pO1xuICAgICAgICBjb25zdCBub3JtWSA9IE1hdGguaHlwb3QobVsxXSwgbVszXSk7XG4gICAgICAgIHRoaXMuX2NhY2hlZEdldFNpbmdsZVBpeGVsV2lkdGggPSBNYXRoLm1heChub3JtWCwgbm9ybVkpIC8gYWJzRGV0O1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGhpcy5fY2FjaGVkR2V0U2luZ2xlUGl4ZWxXaWR0aDtcbiAgfVxuICBnZXRTY2FsZUZvclN0cm9raW5nKCkge1xuICAgIGlmICh0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nWzBdID09PSAtMSkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBsaW5lV2lkdGhcbiAgICAgIH0gPSB0aGlzLmN1cnJlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGEsXG4gICAgICAgIGIsXG4gICAgICAgIGMsXG4gICAgICAgIGRcbiAgICAgIH0gPSB0aGlzLmN0eC5nZXRUcmFuc2Zvcm0oKTtcbiAgICAgIGxldCBzY2FsZVgsIHNjYWxlWTtcbiAgICAgIGlmIChiID09PSAwICYmIGMgPT09IDApIHtcbiAgICAgICAgY29uc3Qgbm9ybVggPSBNYXRoLmFicyhhKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmFicyhkKTtcbiAgICAgICAgaWYgKG5vcm1YID09PSBub3JtWSkge1xuICAgICAgICAgIGlmIChsaW5lV2lkdGggPT09IDApIHtcbiAgICAgICAgICAgIHNjYWxlWCA9IHNjYWxlWSA9IDEgLyBub3JtWDtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgc2NhbGVkTGluZVdpZHRoID0gbm9ybVggKiBsaW5lV2lkdGg7XG4gICAgICAgICAgICBzY2FsZVggPSBzY2FsZVkgPSBzY2FsZWRMaW5lV2lkdGggPCAxID8gMSAvIHNjYWxlZExpbmVXaWR0aCA6IDE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKGxpbmVXaWR0aCA9PT0gMCkge1xuICAgICAgICAgIHNjYWxlWCA9IDEgLyBub3JtWDtcbiAgICAgICAgICBzY2FsZVkgPSAxIC8gbm9ybVk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc2NhbGVkWExpbmVXaWR0aCA9IG5vcm1YICogbGluZVdpZHRoO1xuICAgICAgICAgIGNvbnN0IHNjYWxlZFlMaW5lV2lkdGggPSBub3JtWSAqIGxpbmVXaWR0aDtcbiAgICAgICAgICBzY2FsZVggPSBzY2FsZWRYTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRYTGluZVdpZHRoIDogMTtcbiAgICAgICAgICBzY2FsZVkgPSBzY2FsZWRZTGluZVdpZHRoIDwgMSA/IDEgLyBzY2FsZWRZTGluZVdpZHRoIDogMTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgYWJzRGV0ID0gTWF0aC5hYnMoYSAqIGQgLSBiICogYyk7XG4gICAgICAgIGNvbnN0IG5vcm1YID0gTWF0aC5oeXBvdChhLCBiKTtcbiAgICAgICAgY29uc3Qgbm9ybVkgPSBNYXRoLmh5cG90KGMsIGQpO1xuICAgICAgICBpZiAobGluZVdpZHRoID09PSAwKSB7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgLyBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVZID0gbm9ybVggLyBhYnNEZXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3QgYmFzZUFyZWEgPSBsaW5lV2lkdGggKiBhYnNEZXQ7XG4gICAgICAgICAgc2NhbGVYID0gbm9ybVkgPiBiYXNlQXJlYSA/IG5vcm1ZIC8gYmFzZUFyZWEgOiAxO1xuICAgICAgICAgIHNjYWxlWSA9IG5vcm1YID4gYmFzZUFyZWEgPyBub3JtWCAvIGJhc2VBcmVhIDogMTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5fY2FjaGVkU2NhbGVGb3JTdHJva2luZ1swXSA9IHNjYWxlWDtcbiAgICAgIHRoaXMuX2NhY2hlZFNjYWxlRm9yU3Ryb2tpbmdbMV0gPSBzY2FsZVk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl9jYWNoZWRTY2FsZUZvclN0cm9raW5nO1xuICB9XG4gIHJlc2NhbGVBbmRTdHJva2Uoc2F2ZVJlc3RvcmUpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHhcbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCB7XG4gICAgICBsaW5lV2lkdGhcbiAgICB9ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IFtzY2FsZVgsIHNjYWxlWV0gPSB0aGlzLmdldFNjYWxlRm9yU3Ryb2tpbmcoKTtcbiAgICBjdHgubGluZVdpZHRoID0gbGluZVdpZHRoIHx8IDE7XG4gICAgaWYgKHNjYWxlWCA9PT0gMSAmJiBzY2FsZVkgPT09IDEpIHtcbiAgICAgIGN0eC5zdHJva2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgZGFzaGVzID0gY3R4LmdldExpbmVEYXNoKCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHguc2F2ZSgpO1xuICAgIH1cbiAgICBjdHguc2NhbGUoc2NhbGVYLCBzY2FsZVkpO1xuICAgIGlmIChkYXNoZXMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3Qgc2NhbGUgPSBNYXRoLm1heChzY2FsZVgsIHNjYWxlWSk7XG4gICAgICBjdHguc2V0TGluZURhc2goZGFzaGVzLm1hcCh4ID0+IHggLyBzY2FsZSkpO1xuICAgICAgY3R4LmxpbmVEYXNoT2Zmc2V0IC89IHNjYWxlO1xuICAgIH1cbiAgICBjdHguc3Ryb2tlKCk7XG4gICAgaWYgKHNhdmVSZXN0b3JlKSB7XG4gICAgICBjdHgucmVzdG9yZSgpO1xuICAgIH1cbiAgfVxuICBpc0NvbnRlbnRWaXNpYmxlKCkge1xuICAgIGZvciAobGV0IGkgPSB0aGlzLm1hcmtlZENvbnRlbnRTdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgICAgaWYgKCF0aGlzLm1hcmtlZENvbnRlbnRTdGFja1tpXS52aXNpYmxlKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbn1cbmV4cG9ydHMuQ2FudmFzR3JhcGhpY3MgPSBDYW52YXNHcmFwaGljcztcbmZvciAoY29uc3Qgb3AgaW4gX3V0aWwuT1BTKSB7XG4gIGlmIChDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdICE9PSB1bmRlZmluZWQpIHtcbiAgICBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbX3V0aWwuT1BTW29wXV0gPSBDYW52YXNHcmFwaGljcy5wcm90b3R5cGVbb3BdO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMTc0ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlRpbGluZ1BhdHRlcm4gPSBleHBvcnRzLlBhdGhUeXBlID0gdm9pZCAwO1xuZXhwb3J0cy5nZXRTaGFkaW5nUGF0dGVybiA9IGdldFNoYWRpbmdQYXR0ZXJuO1xuX193X3BkZmpzX3JlcXVpcmVfXygyKTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2OCk7XG5jb25zdCBQYXRoVHlwZSA9IHtcbiAgRklMTDogXCJGaWxsXCIsXG4gIFNUUk9LRTogXCJTdHJva2VcIixcbiAgU0hBRElORzogXCJTaGFkaW5nXCJcbn07XG5leHBvcnRzLlBhdGhUeXBlID0gUGF0aFR5cGU7XG5mdW5jdGlvbiBhcHBseUJvdW5kaW5nQm94KGN0eCwgYmJveCkge1xuICBpZiAoIWJib3gpIHtcbiAgICByZXR1cm47XG4gIH1cbiAgY29uc3Qgd2lkdGggPSBiYm94WzJdIC0gYmJveFswXTtcbiAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gIGNvbnN0IHJlZ2lvbiA9IG5ldyBQYXRoMkQoKTtcbiAgcmVnaW9uLnJlY3QoYmJveFswXSwgYmJveFsxXSwgd2lkdGgsIGhlaWdodCk7XG4gIGN0eC5jbGlwKHJlZ2lvbik7XG59XG5jbGFzcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3RvciA9PT0gQmFzZVNoYWRpbmdQYXR0ZXJuKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQ2Fubm90IGluaXRpYWxpemUgQmFzZVNoYWRpbmdQYXR0ZXJuLlwiKTtcbiAgICB9XG4gIH1cbiAgZ2V0UGF0dGVybigpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiQWJzdHJhY3QgbWV0aG9kIGBnZXRQYXR0ZXJuYCBjYWxsZWQuXCIpO1xuICB9XG59XG5jbGFzcyBSYWRpYWxBeGlhbFNoYWRpbmdQYXR0ZXJuIGV4dGVuZHMgQmFzZVNoYWRpbmdQYXR0ZXJuIHtcbiAgY29uc3RydWN0b3IoSVIpIHtcbiAgICBzdXBlcigpO1xuICAgIHRoaXMuX3R5cGUgPSBJUlsxXTtcbiAgICB0aGlzLl9iYm94ID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JTdG9wcyA9IElSWzNdO1xuICAgIHRoaXMuX3AwID0gSVJbNF07XG4gICAgdGhpcy5fcDEgPSBJUls1XTtcbiAgICB0aGlzLl9yMCA9IElSWzZdO1xuICAgIHRoaXMuX3IxID0gSVJbN107XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVHcmFkaWVudChjdHgpIHtcbiAgICBsZXQgZ3JhZDtcbiAgICBpZiAodGhpcy5fdHlwZSA9PT0gXCJheGlhbFwiKSB7XG4gICAgICBncmFkID0gY3R4LmNyZWF0ZUxpbmVhckdyYWRpZW50KHRoaXMuX3AwWzBdLCB0aGlzLl9wMFsxXSwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3R5cGUgPT09IFwicmFkaWFsXCIpIHtcbiAgICAgIGdyYWQgPSBjdHguY3JlYXRlUmFkaWFsR3JhZGllbnQodGhpcy5fcDBbMF0sIHRoaXMuX3AwWzFdLCB0aGlzLl9yMCwgdGhpcy5fcDFbMF0sIHRoaXMuX3AxWzFdLCB0aGlzLl9yMSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgY29sb3JTdG9wIG9mIHRoaXMuX2NvbG9yU3RvcHMpIHtcbiAgICAgIGdyYWQuYWRkQ29sb3JTdG9wKGNvbG9yU3RvcFswXSwgY29sb3JTdG9wWzFdKTtcbiAgICB9XG4gICAgcmV0dXJuIGdyYWQ7XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGxldCBwYXR0ZXJuO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU1RST0tFIHx8IHBhdGhUeXBlID09PSBQYXRoVHlwZS5GSUxMKSB7XG4gICAgICBjb25zdCBvd25lckJCb3ggPSBvd25lci5jdXJyZW50LmdldENsaXBwZWRQYXRoQm91bmRpbmdCb3gocGF0aFR5cGUsICgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpKSB8fCBbMCwgMCwgMCwgMF07XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGguY2VpbChvd25lckJCb3hbMl0gLSBvd25lckJCb3hbMF0pIHx8IDE7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwob3duZXJCQm94WzNdIC0gb3duZXJCQm94WzFdKSB8fCAxO1xuICAgICAgY29uc3QgdG1wQ2FudmFzID0gb3duZXIuY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwicGF0dGVyblwiLCB3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgICAgdG1wQ3R4LmNsZWFyUmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHguYmVnaW5QYXRoKCk7XG4gICAgICB0bXBDdHgucmVjdCgwLCAwLCB0bXBDdHguY2FudmFzLndpZHRoLCB0bXBDdHguY2FudmFzLmhlaWdodCk7XG4gICAgICB0bXBDdHgudHJhbnNsYXRlKC1vd25lckJCb3hbMF0sIC1vd25lckJCb3hbMV0pO1xuICAgICAgaW52ZXJzZSA9IF91dGlsLlV0aWwudHJhbnNmb3JtKGludmVyc2UsIFsxLCAwLCAwLCAxLCBvd25lckJCb3hbMF0sIG93bmVyQkJveFsxXV0pO1xuICAgICAgdG1wQ3R4LnRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICB0bXBDdHgudHJhbnNmb3JtKC4uLnRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICAgIGFwcGx5Qm91bmRpbmdCb3godG1wQ3R4LCB0aGlzLl9iYm94KTtcbiAgICAgIHRtcEN0eC5maWxsU3R5bGUgPSB0aGlzLl9jcmVhdGVHcmFkaWVudCh0bXBDdHgpO1xuICAgICAgdG1wQ3R4LmZpbGwoKTtcbiAgICAgIHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0bXBDYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgICAgIGNvbnN0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgoaW52ZXJzZSk7XG4gICAgICBwYXR0ZXJuLnNldFRyYW5zZm9ybShkb21NYXRyaXgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgICBwYXR0ZXJuID0gdGhpcy5fY3JlYXRlR3JhZGllbnQoY3R4KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhdHRlcm47XG4gIH1cbn1cbmZ1bmN0aW9uIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwMSwgcDIsIHAzLCBjMSwgYzIsIGMzKSB7XG4gIGNvbnN0IGNvb3JkcyA9IGNvbnRleHQuY29vcmRzLFxuICAgIGNvbG9ycyA9IGNvbnRleHQuY29sb3JzO1xuICBjb25zdCBieXRlcyA9IGRhdGEuZGF0YSxcbiAgICByb3dTaXplID0gZGF0YS53aWR0aCAqIDQ7XG4gIGxldCB0bXA7XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDIgKyAxXSA+IGNvb3Jkc1twMyArIDFdKSB7XG4gICAgdG1wID0gcDI7XG4gICAgcDIgPSBwMztcbiAgICBwMyA9IHRtcDtcbiAgICB0bXAgPSBjMjtcbiAgICBjMiA9IGMzO1xuICAgIGMzID0gdG1wO1xuICB9XG4gIGlmIChjb29yZHNbcDEgKyAxXSA+IGNvb3Jkc1twMiArIDFdKSB7XG4gICAgdG1wID0gcDE7XG4gICAgcDEgPSBwMjtcbiAgICBwMiA9IHRtcDtcbiAgICB0bXAgPSBjMTtcbiAgICBjMSA9IGMyO1xuICAgIGMyID0gdG1wO1xuICB9XG4gIGNvbnN0IHgxID0gKGNvb3Jkc1twMV0gKyBjb250ZXh0Lm9mZnNldFgpICogY29udGV4dC5zY2FsZVg7XG4gIGNvbnN0IHkxID0gKGNvb3Jkc1twMSArIDFdICsgY29udGV4dC5vZmZzZXRZKSAqIGNvbnRleHQuc2NhbGVZO1xuICBjb25zdCB4MiA9IChjb29yZHNbcDJdICsgY29udGV4dC5vZmZzZXRYKSAqIGNvbnRleHQuc2NhbGVYO1xuICBjb25zdCB5MiA9IChjb29yZHNbcDIgKyAxXSArIGNvbnRleHQub2Zmc2V0WSkgKiBjb250ZXh0LnNjYWxlWTtcbiAgY29uc3QgeDMgPSAoY29vcmRzW3AzXSArIGNvbnRleHQub2Zmc2V0WCkgKiBjb250ZXh0LnNjYWxlWDtcbiAgY29uc3QgeTMgPSAoY29vcmRzW3AzICsgMV0gKyBjb250ZXh0Lm9mZnNldFkpICogY29udGV4dC5zY2FsZVk7XG4gIGlmICh5MSA+PSB5Mykge1xuICAgIHJldHVybjtcbiAgfVxuICBjb25zdCBjMXIgPSBjb2xvcnNbYzFdLFxuICAgIGMxZyA9IGNvbG9yc1tjMSArIDFdLFxuICAgIGMxYiA9IGNvbG9yc1tjMSArIDJdO1xuICBjb25zdCBjMnIgPSBjb2xvcnNbYzJdLFxuICAgIGMyZyA9IGNvbG9yc1tjMiArIDFdLFxuICAgIGMyYiA9IGNvbG9yc1tjMiArIDJdO1xuICBjb25zdCBjM3IgPSBjb2xvcnNbYzNdLFxuICAgIGMzZyA9IGNvbG9yc1tjMyArIDFdLFxuICAgIGMzYiA9IGNvbG9yc1tjMyArIDJdO1xuICBjb25zdCBtaW5ZID0gTWF0aC5yb3VuZCh5MSksXG4gICAgbWF4WSA9IE1hdGgucm91bmQoeTMpO1xuICBsZXQgeGEsIGNhciwgY2FnLCBjYWI7XG4gIGxldCB4YiwgY2JyLCBjYmcsIGNiYjtcbiAgZm9yIChsZXQgeSA9IG1pblk7IHkgPD0gbWF4WTsgeSsrKSB7XG4gICAgaWYgKHkgPCB5Mikge1xuICAgICAgY29uc3QgayA9IHkgPCB5MSA/IDAgOiAoeTEgLSB5KSAvICh5MSAtIHkyKTtcbiAgICAgIHhhID0geDEgLSAoeDEgLSB4MikgKiBrO1xuICAgICAgY2FyID0gYzFyIC0gKGMxciAtIGMycikgKiBrO1xuICAgICAgY2FnID0gYzFnIC0gKGMxZyAtIGMyZykgKiBrO1xuICAgICAgY2FiID0gYzFiIC0gKGMxYiAtIGMyYikgKiBrO1xuICAgIH0gZWxzZSB7XG4gICAgICBsZXQgaztcbiAgICAgIGlmICh5ID4geTMpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9IGVsc2UgaWYgKHkyID09PSB5Mykge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGsgPSAoeTIgLSB5KSAvICh5MiAtIHkzKTtcbiAgICAgIH1cbiAgICAgIHhhID0geDIgLSAoeDIgLSB4MykgKiBrO1xuICAgICAgY2FyID0gYzJyIC0gKGMyciAtIGMzcikgKiBrO1xuICAgICAgY2FnID0gYzJnIC0gKGMyZyAtIGMzZykgKiBrO1xuICAgICAgY2FiID0gYzJiIC0gKGMyYiAtIGMzYikgKiBrO1xuICAgIH1cbiAgICBsZXQgaztcbiAgICBpZiAoeSA8IHkxKSB7XG4gICAgICBrID0gMDtcbiAgICB9IGVsc2UgaWYgKHkgPiB5Mykge1xuICAgICAgayA9IDE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGsgPSAoeTEgLSB5KSAvICh5MSAtIHkzKTtcbiAgICB9XG4gICAgeGIgPSB4MSAtICh4MSAtIHgzKSAqIGs7XG4gICAgY2JyID0gYzFyIC0gKGMxciAtIGMzcikgKiBrO1xuICAgIGNiZyA9IGMxZyAtIChjMWcgLSBjM2cpICogaztcbiAgICBjYmIgPSBjMWIgLSAoYzFiIC0gYzNiKSAqIGs7XG4gICAgY29uc3QgeDFfID0gTWF0aC5yb3VuZChNYXRoLm1pbih4YSwgeGIpKTtcbiAgICBjb25zdCB4Ml8gPSBNYXRoLnJvdW5kKE1hdGgubWF4KHhhLCB4YikpO1xuICAgIGxldCBqID0gcm93U2l6ZSAqIHkgKyB4MV8gKiA0O1xuICAgIGZvciAobGV0IHggPSB4MV87IHggPD0geDJfOyB4KyspIHtcbiAgICAgIGsgPSAoeGEgLSB4KSAvICh4YSAtIHhiKTtcbiAgICAgIGlmIChrIDwgMCkge1xuICAgICAgICBrID0gMDtcbiAgICAgIH0gZWxzZSBpZiAoayA+IDEpIHtcbiAgICAgICAgayA9IDE7XG4gICAgICB9XG4gICAgICBieXRlc1tqKytdID0gY2FyIC0gKGNhciAtIGNicikgKiBrIHwgMDtcbiAgICAgIGJ5dGVzW2orK10gPSBjYWcgLSAoY2FnIC0gY2JnKSAqIGsgfCAwO1xuICAgICAgYnl0ZXNbaisrXSA9IGNhYiAtIChjYWIgLSBjYmIpICogayB8IDA7XG4gICAgICBieXRlc1tqKytdID0gMjU1O1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gZHJhd0ZpZ3VyZShkYXRhLCBmaWd1cmUsIGNvbnRleHQpIHtcbiAgY29uc3QgcHMgPSBmaWd1cmUuY29vcmRzO1xuICBjb25zdCBjcyA9IGZpZ3VyZS5jb2xvcnM7XG4gIGxldCBpLCBpaTtcbiAgc3dpdGNoIChmaWd1cmUudHlwZSkge1xuICAgIGNhc2UgXCJsYXR0aWNlXCI6XG4gICAgICBjb25zdCB2ZXJ0aWNlc1BlclJvdyA9IGZpZ3VyZS52ZXJ0aWNlc1BlclJvdztcbiAgICAgIGNvbnN0IHJvd3MgPSBNYXRoLmZsb29yKHBzLmxlbmd0aCAvIHZlcnRpY2VzUGVyUm93KSAtIDE7XG4gICAgICBjb25zdCBjb2xzID0gdmVydGljZXNQZXJSb3cgLSAxO1xuICAgICAgZm9yIChpID0gMDsgaSA8IHJvd3M7IGkrKykge1xuICAgICAgICBsZXQgcSA9IGkgKiB2ZXJ0aWNlc1BlclJvdztcbiAgICAgICAgZm9yIChsZXQgaiA9IDA7IGogPCBjb2xzOyBqKyssIHErKykge1xuICAgICAgICAgIGRyYXdUcmlhbmdsZShkYXRhLCBjb250ZXh0LCBwc1txXSwgcHNbcSArIDFdLCBwc1txICsgdmVydGljZXNQZXJSb3ddLCBjc1txXSwgY3NbcSArIDFdLCBjc1txICsgdmVydGljZXNQZXJSb3ddKTtcbiAgICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIHBzW3EgKyAxXSwgcHNbcSArIHZlcnRpY2VzUGVyUm93XSwgY3NbcSArIHZlcnRpY2VzUGVyUm93ICsgMV0sIGNzW3EgKyAxXSwgY3NbcSArIHZlcnRpY2VzUGVyUm93XSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJ0cmlhbmdsZXNcIjpcbiAgICAgIGZvciAoaSA9IDAsIGlpID0gcHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMykge1xuICAgICAgICBkcmF3VHJpYW5nbGUoZGF0YSwgY29udGV4dCwgcHNbaV0sIHBzW2kgKyAxXSwgcHNbaSArIDJdLCBjc1tpXSwgY3NbaSArIDFdLCBjc1tpICsgMl0pO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgZmlndXJlXCIpO1xuICB9XG59XG5jbGFzcyBNZXNoU2hhZGluZ1BhdHRlcm4gZXh0ZW5kcyBCYXNlU2hhZGluZ1BhdHRlcm4ge1xuICBjb25zdHJ1Y3RvcihJUikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5fY29vcmRzID0gSVJbMl07XG4gICAgdGhpcy5fY29sb3JzID0gSVJbM107XG4gICAgdGhpcy5fZmlndXJlcyA9IElSWzRdO1xuICAgIHRoaXMuX2JvdW5kcyA9IElSWzVdO1xuICAgIHRoaXMuX2Jib3ggPSBJUls3XTtcbiAgICB0aGlzLl9iYWNrZ3JvdW5kID0gSVJbOF07XG4gICAgdGhpcy5tYXRyaXggPSBudWxsO1xuICB9XG4gIF9jcmVhdGVNZXNoQ2FudmFzKGNvbWJpbmVkU2NhbGUsIGJhY2tncm91bmRDb2xvciwgY2FjaGVkQ2FudmFzZXMpIHtcbiAgICBjb25zdCBFWFBFQ1RFRF9TQ0FMRSA9IDEuMTtcbiAgICBjb25zdCBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgb2Zmc2V0WCA9IE1hdGguZmxvb3IodGhpcy5fYm91bmRzWzBdKTtcbiAgICBjb25zdCBvZmZzZXRZID0gTWF0aC5mbG9vcih0aGlzLl9ib3VuZHNbMV0pO1xuICAgIGNvbnN0IGJvdW5kc1dpZHRoID0gTWF0aC5jZWlsKHRoaXMuX2JvdW5kc1syXSkgLSBvZmZzZXRYO1xuICAgIGNvbnN0IGJvdW5kc0hlaWdodCA9IE1hdGguY2VpbCh0aGlzLl9ib3VuZHNbM10pIC0gb2Zmc2V0WTtcbiAgICBjb25zdCB3aWR0aCA9IE1hdGgubWluKE1hdGguY2VpbChNYXRoLmFicyhib3VuZHNXaWR0aCAqIGNvbWJpbmVkU2NhbGVbMF0gKiBFWFBFQ1RFRF9TQ0FMRSkpLCBNQVhfUEFUVEVSTl9TSVpFKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLm1pbihNYXRoLmNlaWwoTWF0aC5hYnMoYm91bmRzSGVpZ2h0ICogY29tYmluZWRTY2FsZVsxXSAqIEVYUEVDVEVEX1NDQUxFKSksIE1BWF9QQVRURVJOX1NJWkUpO1xuICAgIGNvbnN0IHNjYWxlWCA9IGJvdW5kc1dpZHRoIC8gd2lkdGg7XG4gICAgY29uc3Qgc2NhbGVZID0gYm91bmRzSGVpZ2h0IC8gaGVpZ2h0O1xuICAgIGNvbnN0IGNvbnRleHQgPSB7XG4gICAgICBjb29yZHM6IHRoaXMuX2Nvb3JkcyxcbiAgICAgIGNvbG9yczogdGhpcy5fY29sb3JzLFxuICAgICAgb2Zmc2V0WDogLW9mZnNldFgsXG4gICAgICBvZmZzZXRZOiAtb2Zmc2V0WSxcbiAgICAgIHNjYWxlWDogMSAvIHNjYWxlWCxcbiAgICAgIHNjYWxlWTogMSAvIHNjYWxlWVxuICAgIH07XG4gICAgY29uc3QgcGFkZGVkV2lkdGggPSB3aWR0aCArIEJPUkRFUl9TSVpFICogMjtcbiAgICBjb25zdCBwYWRkZWRIZWlnaHQgPSBoZWlnaHQgKyBCT1JERVJfU0laRSAqIDI7XG4gICAgY29uc3QgdG1wQ2FudmFzID0gY2FjaGVkQ2FudmFzZXMuZ2V0Q2FudmFzKFwibWVzaFwiLCBwYWRkZWRXaWR0aCwgcGFkZGVkSGVpZ2h0LCBmYWxzZSk7XG4gICAgY29uc3QgdG1wQ3R4ID0gdG1wQ2FudmFzLmNvbnRleHQ7XG4gICAgY29uc3QgZGF0YSA9IHRtcEN0eC5jcmVhdGVJbWFnZURhdGEod2lkdGgsIGhlaWdodCk7XG4gICAgaWYgKGJhY2tncm91bmRDb2xvcikge1xuICAgICAgY29uc3QgYnl0ZXMgPSBkYXRhLmRhdGE7XG4gICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBieXRlcy5sZW5ndGg7IGkgPCBpaTsgaSArPSA0KSB7XG4gICAgICAgIGJ5dGVzW2ldID0gYmFja2dyb3VuZENvbG9yWzBdO1xuICAgICAgICBieXRlc1tpICsgMV0gPSBiYWNrZ3JvdW5kQ29sb3JbMV07XG4gICAgICAgIGJ5dGVzW2kgKyAyXSA9IGJhY2tncm91bmRDb2xvclsyXTtcbiAgICAgICAgYnl0ZXNbaSArIDNdID0gMjU1O1xuICAgICAgfVxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGZpZ3VyZSBvZiB0aGlzLl9maWd1cmVzKSB7XG4gICAgICBkcmF3RmlndXJlKGRhdGEsIGZpZ3VyZSwgY29udGV4dCk7XG4gICAgfVxuICAgIHRtcEN0eC5wdXRJbWFnZURhdGEoZGF0YSwgQk9SREVSX1NJWkUsIEJPUkRFUl9TSVpFKTtcbiAgICBjb25zdCBjYW52YXMgPSB0bXBDYW52YXMuY2FudmFzO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXMsXG4gICAgICBvZmZzZXRYOiBvZmZzZXRYIC0gQk9SREVSX1NJWkUgKiBzY2FsZVgsXG4gICAgICBvZmZzZXRZOiBvZmZzZXRZIC0gQk9SREVSX1NJWkUgKiBzY2FsZVksXG4gICAgICBzY2FsZVgsXG4gICAgICBzY2FsZVlcbiAgICB9O1xuICB9XG4gIGdldFBhdHRlcm4oY3R4LCBvd25lciwgaW52ZXJzZSwgcGF0aFR5cGUpIHtcbiAgICBhcHBseUJvdW5kaW5nQm94KGN0eCwgdGhpcy5fYmJveCk7XG4gICAgbGV0IHNjYWxlO1xuICAgIGlmIChwYXRoVHlwZSA9PT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShjdHgpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKG93bmVyLmJhc2VUcmFuc2Zvcm0pO1xuICAgICAgaWYgKHRoaXMubWF0cml4KSB7XG4gICAgICAgIGNvbnN0IG1hdHJpeFNjYWxlID0gX3V0aWwuVXRpbC5zaW5ndWxhclZhbHVlRGVjb21wb3NlMmRTY2FsZSh0aGlzLm1hdHJpeCk7XG4gICAgICAgIHNjYWxlID0gW3NjYWxlWzBdICogbWF0cml4U2NhbGVbMF0sIHNjYWxlWzFdICogbWF0cml4U2NhbGVbMV1dO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzID0gdGhpcy5fY3JlYXRlTWVzaENhbnZhcyhzY2FsZSwgcGF0aFR5cGUgPT09IFBhdGhUeXBlLlNIQURJTkcgPyBudWxsIDogdGhpcy5fYmFja2dyb3VuZCwgb3duZXIuY2FjaGVkQ2FudmFzZXMpO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgY3R4LnNldFRyYW5zZm9ybSguLi5vd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBjdHgudHJhbnNmb3JtKC4uLnRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY3R4LnRyYW5zbGF0ZSh0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLm9mZnNldFgsIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WSk7XG4gICAgY3R4LnNjYWxlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCB0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLnNjYWxlWSk7XG4gICAgcmV0dXJuIGN0eC5jcmVhdGVQYXR0ZXJuKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuY2FudmFzLCBcIm5vLXJlcGVhdFwiKTtcbiAgfVxufVxuY2xhc3MgRHVtbXlTaGFkaW5nUGF0dGVybiBleHRlbmRzIEJhc2VTaGFkaW5nUGF0dGVybiB7XG4gIGdldFBhdHRlcm4oKSB7XG4gICAgcmV0dXJuIFwiaG90cGlua1wiO1xuICB9XG59XG5mdW5jdGlvbiBnZXRTaGFkaW5nUGF0dGVybihJUikge1xuICBzd2l0Y2ggKElSWzBdKSB7XG4gICAgY2FzZSBcIlJhZGlhbEF4aWFsXCI6XG4gICAgICByZXR1cm4gbmV3IFJhZGlhbEF4aWFsU2hhZGluZ1BhdHRlcm4oSVIpO1xuICAgIGNhc2UgXCJNZXNoXCI6XG4gICAgICByZXR1cm4gbmV3IE1lc2hTaGFkaW5nUGF0dGVybihJUik7XG4gICAgY2FzZSBcIkR1bW15XCI6XG4gICAgICByZXR1cm4gbmV3IER1bW15U2hhZGluZ1BhdHRlcm4oKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gSVIgdHlwZTogJHtJUlswXX1gKTtcbn1cbmNvbnN0IFBhaW50VHlwZSA9IHtcbiAgQ09MT1JFRDogMSxcbiAgVU5DT0xPUkVEOiAyXG59O1xuY2xhc3MgVGlsaW5nUGF0dGVybiB7XG4gIHN0YXRpYyBNQVhfUEFUVEVSTl9TSVpFID0gMzAwMDtcbiAgY29uc3RydWN0b3IoSVIsIGNvbG9yLCBjdHgsIGNhbnZhc0dyYXBoaWNzRmFjdG9yeSwgYmFzZVRyYW5zZm9ybSkge1xuICAgIHRoaXMub3BlcmF0b3JMaXN0ID0gSVJbMl07XG4gICAgdGhpcy5tYXRyaXggPSBJUlszXSB8fCBbMSwgMCwgMCwgMSwgMCwgMF07XG4gICAgdGhpcy5iYm94ID0gSVJbNF07XG4gICAgdGhpcy54c3RlcCA9IElSWzVdO1xuICAgIHRoaXMueXN0ZXAgPSBJUls2XTtcbiAgICB0aGlzLnBhaW50VHlwZSA9IElSWzddO1xuICAgIHRoaXMudGlsaW5nVHlwZSA9IElSWzhdO1xuICAgIHRoaXMuY29sb3IgPSBjb2xvcjtcbiAgICB0aGlzLmN0eCA9IGN0eDtcbiAgICB0aGlzLmNhbnZhc0dyYXBoaWNzRmFjdG9yeSA9IGNhbnZhc0dyYXBoaWNzRmFjdG9yeTtcbiAgICB0aGlzLmJhc2VUcmFuc2Zvcm0gPSBiYXNlVHJhbnNmb3JtO1xuICB9XG4gIGNyZWF0ZVBhdHRlcm5DYW52YXMob3duZXIpIHtcbiAgICBjb25zdCBvcGVyYXRvckxpc3QgPSB0aGlzLm9wZXJhdG9yTGlzdDtcbiAgICBjb25zdCBiYm94ID0gdGhpcy5iYm94O1xuICAgIGNvbnN0IHhzdGVwID0gdGhpcy54c3RlcDtcbiAgICBjb25zdCB5c3RlcCA9IHRoaXMueXN0ZXA7XG4gICAgY29uc3QgcGFpbnRUeXBlID0gdGhpcy5wYWludFR5cGU7XG4gICAgY29uc3QgdGlsaW5nVHlwZSA9IHRoaXMudGlsaW5nVHlwZTtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuY29sb3I7XG4gICAgY29uc3QgY2FudmFzR3JhcGhpY3NGYWN0b3J5ID0gdGhpcy5jYW52YXNHcmFwaGljc0ZhY3Rvcnk7XG4gICAgKDAsIF91dGlsLmluZm8pKFwiVGlsaW5nVHlwZTogXCIgKyB0aWxpbmdUeXBlKTtcbiAgICBjb25zdCB4MCA9IGJib3hbMF0sXG4gICAgICB5MCA9IGJib3hbMV0sXG4gICAgICB4MSA9IGJib3hbMl0sXG4gICAgICB5MSA9IGJib3hbM107XG4gICAgY29uc3QgbWF0cml4U2NhbGUgPSBfdXRpbC5VdGlsLnNpbmd1bGFyVmFsdWVEZWNvbXBvc2UyZFNjYWxlKHRoaXMubWF0cml4KTtcbiAgICBjb25zdCBjdXJNYXRyaXhTY2FsZSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUodGhpcy5iYXNlVHJhbnNmb3JtKTtcbiAgICBjb25zdCBjb21iaW5lZFNjYWxlID0gW21hdHJpeFNjYWxlWzBdICogY3VyTWF0cml4U2NhbGVbMF0sIG1hdHJpeFNjYWxlWzFdICogY3VyTWF0cml4U2NhbGVbMV1dO1xuICAgIGNvbnN0IGRpbXggPSB0aGlzLmdldFNpemVBbmRTY2FsZSh4c3RlcCwgdGhpcy5jdHguY2FudmFzLndpZHRoLCBjb21iaW5lZFNjYWxlWzBdKTtcbiAgICBjb25zdCBkaW15ID0gdGhpcy5nZXRTaXplQW5kU2NhbGUoeXN0ZXAsIHRoaXMuY3R4LmNhbnZhcy5oZWlnaHQsIGNvbWJpbmVkU2NhbGVbMV0pO1xuICAgIGNvbnN0IHRtcENhbnZhcyA9IG93bmVyLmNhY2hlZENhbnZhc2VzLmdldENhbnZhcyhcInBhdHRlcm5cIiwgZGlteC5zaXplLCBkaW15LnNpemUsIHRydWUpO1xuICAgIGNvbnN0IHRtcEN0eCA9IHRtcENhbnZhcy5jb250ZXh0O1xuICAgIGNvbnN0IGdyYXBoaWNzID0gY2FudmFzR3JhcGhpY3NGYWN0b3J5LmNyZWF0ZUNhbnZhc0dyYXBoaWNzKHRtcEN0eCk7XG4gICAgZ3JhcGhpY3MuZ3JvdXBMZXZlbCA9IG93bmVyLmdyb3VwTGV2ZWw7XG4gICAgdGhpcy5zZXRGaWxsQW5kU3Ryb2tlU3R5bGVUb0NvbnRleHQoZ3JhcGhpY3MsIHBhaW50VHlwZSwgY29sb3IpO1xuICAgIGxldCBhZGp1c3RlZFgwID0geDA7XG4gICAgbGV0IGFkanVzdGVkWTAgPSB5MDtcbiAgICBsZXQgYWRqdXN0ZWRYMSA9IHgxO1xuICAgIGxldCBhZGp1c3RlZFkxID0geTE7XG4gICAgaWYgKHgwIDwgMCkge1xuICAgICAgYWRqdXN0ZWRYMCA9IDA7XG4gICAgICBhZGp1c3RlZFgxICs9IE1hdGguYWJzKHgwKTtcbiAgICB9XG4gICAgaWYgKHkwIDwgMCkge1xuICAgICAgYWRqdXN0ZWRZMCA9IDA7XG4gICAgICBhZGp1c3RlZFkxICs9IE1hdGguYWJzKHkwKTtcbiAgICB9XG4gICAgdG1wQ3R4LnRyYW5zbGF0ZSgtKGRpbXguc2NhbGUgKiBhZGp1c3RlZFgwKSwgLShkaW15LnNjYWxlICogYWRqdXN0ZWRZMCkpO1xuICAgIGdyYXBoaWNzLnRyYW5zZm9ybShkaW14LnNjYWxlLCAwLCAwLCBkaW15LnNjYWxlLCAwLCAwKTtcbiAgICB0bXBDdHguc2F2ZSgpO1xuICAgIHRoaXMuY2xpcEJib3goZ3JhcGhpY3MsIGFkanVzdGVkWDAsIGFkanVzdGVkWTAsIGFkanVzdGVkWDEsIGFkanVzdGVkWTEpO1xuICAgIGdyYXBoaWNzLmJhc2VUcmFuc2Zvcm0gPSAoMCwgX2Rpc3BsYXlfdXRpbHMuZ2V0Q3VycmVudFRyYW5zZm9ybSkoZ3JhcGhpY3MuY3R4KTtcbiAgICBncmFwaGljcy5leGVjdXRlT3BlcmF0b3JMaXN0KG9wZXJhdG9yTGlzdCk7XG4gICAgZ3JhcGhpY3MuZW5kRHJhd2luZygpO1xuICAgIHJldHVybiB7XG4gICAgICBjYW52YXM6IHRtcENhbnZhcy5jYW52YXMsXG4gICAgICBzY2FsZVg6IGRpbXguc2NhbGUsXG4gICAgICBzY2FsZVk6IGRpbXkuc2NhbGUsXG4gICAgICBvZmZzZXRYOiBhZGp1c3RlZFgwLFxuICAgICAgb2Zmc2V0WTogYWRqdXN0ZWRZMFxuICAgIH07XG4gIH1cbiAgZ2V0U2l6ZUFuZFNjYWxlKHN0ZXAsIHJlYWxPdXRwdXRTaXplLCBzY2FsZSkge1xuICAgIHN0ZXAgPSBNYXRoLmFicyhzdGVwKTtcbiAgICBjb25zdCBtYXhTaXplID0gTWF0aC5tYXgoVGlsaW5nUGF0dGVybi5NQVhfUEFUVEVSTl9TSVpFLCByZWFsT3V0cHV0U2l6ZSk7XG4gICAgbGV0IHNpemUgPSBNYXRoLmNlaWwoc3RlcCAqIHNjYWxlKTtcbiAgICBpZiAoc2l6ZSA+PSBtYXhTaXplKSB7XG4gICAgICBzaXplID0gbWF4U2l6ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgc2NhbGUgPSBzaXplIC8gc3RlcDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHNjYWxlLFxuICAgICAgc2l6ZVxuICAgIH07XG4gIH1cbiAgY2xpcEJib3goZ3JhcGhpY3MsIHgwLCB5MCwgeDEsIHkxKSB7XG4gICAgY29uc3QgYmJveFdpZHRoID0geDEgLSB4MDtcbiAgICBjb25zdCBiYm94SGVpZ2h0ID0geTEgLSB5MDtcbiAgICBncmFwaGljcy5jdHgucmVjdCh4MCwgeTAsIGJib3hXaWR0aCwgYmJveEhlaWdodCk7XG4gICAgZ3JhcGhpY3MuY3VycmVudC51cGRhdGVSZWN0TWluTWF4KCgwLCBfZGlzcGxheV91dGlscy5nZXRDdXJyZW50VHJhbnNmb3JtKShncmFwaGljcy5jdHgpLCBbeDAsIHkwLCB4MSwgeTFdKTtcbiAgICBncmFwaGljcy5jbGlwKCk7XG4gICAgZ3JhcGhpY3MuZW5kUGF0aCgpO1xuICB9XG4gIHNldEZpbGxBbmRTdHJva2VTdHlsZVRvQ29udGV4dChncmFwaGljcywgcGFpbnRUeXBlLCBjb2xvcikge1xuICAgIGNvbnN0IGNvbnRleHQgPSBncmFwaGljcy5jdHgsXG4gICAgICBjdXJyZW50ID0gZ3JhcGhpY3MuY3VycmVudDtcbiAgICBzd2l0Y2ggKHBhaW50VHlwZSkge1xuICAgICAgY2FzZSBQYWludFR5cGUuQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3R4ID0gdGhpcy5jdHg7XG4gICAgICAgIGNvbnRleHQuZmlsbFN0eWxlID0gY3R4LmZpbGxTdHlsZTtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGN0eC5zdHJva2VTdHlsZTtcbiAgICAgICAgY3VycmVudC5maWxsQ29sb3IgPSBjdHguZmlsbFN0eWxlO1xuICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3R4LnN0cm9rZVN0eWxlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgUGFpbnRUeXBlLlVOQ09MT1JFRDpcbiAgICAgICAgY29uc3QgY3NzQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihjb2xvclswXSwgY29sb3JbMV0sIGNvbG9yWzJdKTtcbiAgICAgICAgY29udGV4dC5maWxsU3R5bGUgPSBjc3NDb2xvcjtcbiAgICAgICAgY29udGV4dC5zdHJva2VTdHlsZSA9IGNzc0NvbG9yO1xuICAgICAgICBjdXJyZW50LmZpbGxDb2xvciA9IGNzc0NvbG9yO1xuICAgICAgICBjdXJyZW50LnN0cm9rZUNvbG9yID0gY3NzQ29sb3I7XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IF91dGlsLkZvcm1hdEVycm9yKGBVbnN1cHBvcnRlZCBwYWludCB0eXBlOiAke3BhaW50VHlwZX1gKTtcbiAgICB9XG4gIH1cbiAgZ2V0UGF0dGVybihjdHgsIG93bmVyLCBpbnZlcnNlLCBwYXRoVHlwZSkge1xuICAgIGxldCBtYXRyaXggPSBpbnZlcnNlO1xuICAgIGlmIChwYXRoVHlwZSAhPT0gUGF0aFR5cGUuU0hBRElORykge1xuICAgICAgbWF0cml4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0obWF0cml4LCBvd25lci5iYXNlVHJhbnNmb3JtKTtcbiAgICAgIGlmICh0aGlzLm1hdHJpeCkge1xuICAgICAgICBtYXRyaXggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybShtYXRyaXgsIHRoaXMubWF0cml4KTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcyA9IHRoaXMuY3JlYXRlUGF0dGVybkNhbnZhcyhvd25lcik7XG4gICAgbGV0IGRvbU1hdHJpeCA9IG5ldyBET01NYXRyaXgobWF0cml4KTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXgudHJhbnNsYXRlKHRlbXBvcmFyeVBhdHRlcm5DYW52YXMub2Zmc2V0WCwgdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5vZmZzZXRZKTtcbiAgICBkb21NYXRyaXggPSBkb21NYXRyaXguc2NhbGUoMSAvIHRlbXBvcmFyeVBhdHRlcm5DYW52YXMuc2NhbGVYLCAxIC8gdGVtcG9yYXJ5UGF0dGVybkNhbnZhcy5zY2FsZVkpO1xuICAgIGNvbnN0IHBhdHRlcm4gPSBjdHguY3JlYXRlUGF0dGVybih0ZW1wb3JhcnlQYXR0ZXJuQ2FudmFzLmNhbnZhcywgXCJyZXBlYXRcIik7XG4gICAgcGF0dGVybi5zZXRUcmFuc2Zvcm0oZG9tTWF0cml4KTtcbiAgICByZXR1cm4gcGF0dGVybjtcbiAgfVxufVxuZXhwb3J0cy5UaWxpbmdQYXR0ZXJuID0gVGlsaW5nUGF0dGVybjtcblxuLyoqKi8gfSksXG4vKiAxNzUgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuY29udmVydEJsYWNrQW5kV2hpdGVUb1JHQkEgPSBjb252ZXJ0QmxhY2tBbmRXaGl0ZVRvUkdCQTtcbmV4cG9ydHMuY29udmVydFRvUkdCQSA9IGNvbnZlcnRUb1JHQkE7XG5leHBvcnRzLmdyYXlUb1JHQkEgPSBncmF5VG9SR0JBO1xuX193X3BkZmpzX3JlcXVpcmVfXyg5Myk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwOSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExNik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyMyk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuZnVuY3Rpb24gY29udmVydFRvUkdCQShwYXJhbXMpIHtcbiAgc3dpdGNoIChwYXJhbXMua2luZCkge1xuICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLkdSQVlTQ0FMRV8xQlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKHBhcmFtcyk7XG4gICAgY2FzZSBfdXRpbC5JbWFnZUtpbmQuUkdCXzI0QlBQOlxuICAgICAgcmV0dXJuIGNvbnZlcnRSR0JUb1JHQkEocGFyYW1zKTtcbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRCbGFja0FuZFdoaXRlVG9SR0JBKF9yZWYpIHtcbiAgbGV0IHtcbiAgICBzcmMsXG4gICAgc3JjUG9zID0gMCxcbiAgICBkZXN0LFxuICAgIHdpZHRoLFxuICAgIGhlaWdodCxcbiAgICBub25CbGFja0NvbG9yID0gMHhmZmZmZmZmZixcbiAgICBpbnZlcnNlRGVjb2RlID0gZmFsc2VcbiAgfSA9IF9yZWY7XG4gIGNvbnN0IGJsYWNrID0gX3V0aWwuRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4gPyAweGZmMDAwMDAwIDogMHgwMDAwMDBmZjtcbiAgY29uc3QgW3plcm9NYXBwaW5nLCBvbmVNYXBwaW5nXSA9IGludmVyc2VEZWNvZGUgPyBbbm9uQmxhY2tDb2xvciwgYmxhY2tdIDogW2JsYWNrLCBub25CbGFja0NvbG9yXTtcbiAgY29uc3Qgd2lkdGhJblNvdXJjZSA9IHdpZHRoID4+IDM7XG4gIGNvbnN0IHdpZHRoUmVtYWluZGVyID0gd2lkdGggJiA3O1xuICBjb25zdCBzcmNMZW5ndGggPSBzcmMubGVuZ3RoO1xuICBkZXN0ID0gbmV3IFVpbnQzMkFycmF5KGRlc3QuYnVmZmVyKTtcbiAgbGV0IGRlc3RQb3MgPSAwO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGhlaWdodDsgaSsrKSB7XG4gICAgZm9yIChjb25zdCBtYXggPSBzcmNQb3MgKyB3aWR0aEluU291cmNlOyBzcmNQb3MgPCBtYXg7IHNyY1BvcysrKSB7XG4gICAgICBjb25zdCBlbGVtID0gc3JjUG9zIDwgc3JjTGVuZ3RoID8gc3JjW3NyY1Bvc10gOiAyNTU7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAwMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEwMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMDAgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgICBkZXN0W2Rlc3RQb3MrK10gPSBlbGVtICYgMGIxMCA/IG9uZU1hcHBpbmcgOiB6ZXJvTWFwcGluZztcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IGVsZW0gJiAwYjEgPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICAgIGlmICh3aWR0aFJlbWFpbmRlciA9PT0gMCkge1xuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGNvbnN0IGVsZW0gPSBzcmNQb3MgPCBzcmNMZW5ndGggPyBzcmNbc3JjUG9zKytdIDogMjU1O1xuICAgIGZvciAobGV0IGogPSAwOyBqIDwgd2lkdGhSZW1haW5kZXI7IGorKykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gZWxlbSAmIDEgPDwgNyAtIGogPyBvbmVNYXBwaW5nIDogemVyb01hcHBpbmc7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRSR0JUb1JHQkEoX3JlZjIpIHtcbiAgbGV0IHtcbiAgICBzcmMsXG4gICAgc3JjUG9zID0gMCxcbiAgICBkZXN0LFxuICAgIGRlc3RQb3MgPSAwLFxuICAgIHdpZHRoLFxuICAgIGhlaWdodFxuICB9ID0gX3JlZjI7XG4gIGxldCBpID0gMDtcbiAgY29uc3QgbGVuMzIgPSBzcmMubGVuZ3RoID4+IDI7XG4gIGNvbnN0IHNyYzMyID0gbmV3IFVpbnQzMkFycmF5KHNyYy5idWZmZXIsIHNyY1BvcywgbGVuMzIpO1xuICBpZiAoX3V0aWwuRmVhdHVyZVRlc3QuaXNMaXR0bGVFbmRpYW4pIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPj4+IDI0IHwgczIgPDwgOCB8IDB4ZmYwMDAwMDA7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyID4+PiAxNiB8IHMzIDw8IDE2IHwgMHhmZjAwMDAwMDtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPj4+IDggfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgICBmb3IgKGxldCBqID0gaSAqIDQsIGpqID0gc3JjLmxlbmd0aDsgaiA8IGpqOyBqICs9IDMpIHtcbiAgICAgIGRlc3RbZGVzdFBvcysrXSA9IHNyY1tqXSB8IHNyY1tqICsgMV0gPDwgOCB8IHNyY1tqICsgMl0gPDwgMTYgfCAweGZmMDAwMDAwO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBmb3IgKDsgaSA8IGxlbjMyIC0gMjsgaSArPSAzLCBkZXN0UG9zICs9IDQpIHtcbiAgICAgIGNvbnN0IHMxID0gc3JjMzJbaV07XG4gICAgICBjb25zdCBzMiA9IHNyYzMyW2kgKyAxXTtcbiAgICAgIGNvbnN0IHMzID0gc3JjMzJbaSArIDJdO1xuICAgICAgZGVzdFtkZXN0UG9zXSA9IHMxIHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDFdID0gczEgPDwgMjQgfCBzMiA+Pj4gOCB8IDB4ZmY7XG4gICAgICBkZXN0W2Rlc3RQb3MgKyAyXSA9IHMyIDw8IDE2IHwgczMgPj4+IDE2IHwgMHhmZjtcbiAgICAgIGRlc3RbZGVzdFBvcyArIDNdID0gczMgPDwgOCB8IDB4ZmY7XG4gICAgfVxuICAgIGZvciAobGV0IGogPSBpICogNCwgamogPSBzcmMubGVuZ3RoOyBqIDwgamo7IGogKz0gMykge1xuICAgICAgZGVzdFtkZXN0UG9zKytdID0gc3JjW2pdIDw8IDI0IHwgc3JjW2ogKyAxXSA8PCAxNiB8IHNyY1tqICsgMl0gPDwgOCB8IDB4ZmY7XG4gICAgfVxuICB9XG4gIHJldHVybiB7XG4gICAgc3JjUG9zLFxuICAgIGRlc3RQb3NcbiAgfTtcbn1cbmZ1bmN0aW9uIGdyYXlUb1JHQkEoc3JjLCBkZXN0KSB7XG4gIGlmIChfdXRpbC5GZWF0dXJlVGVzdC5pc0xpdHRsZUVuZGlhbikge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMSB8IDB4ZmYwMDAwMDA7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHNyYy5sZW5ndGg7IGkgPCBpaTsgaSsrKSB7XG4gICAgICBkZXN0W2ldID0gc3JjW2ldICogMHgxMDEwMTAwIHwgMHgwMDAwMDBmZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxNzYgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuR2xvYmFsV29ya2VyT3B0aW9ucyA9IHZvaWQgMDtcbmNvbnN0IEdsb2JhbFdvcmtlck9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuZXhwb3J0cy5HbG9iYWxXb3JrZXJPcHRpb25zID0gR2xvYmFsV29ya2VyT3B0aW9ucztcbkdsb2JhbFdvcmtlck9wdGlvbnMud29ya2VyUG9ydCA9IG51bGw7XG5HbG9iYWxXb3JrZXJPcHRpb25zLndvcmtlclNyYyA9IFwiXCI7XG5cbi8qKiovIH0pLFxuLyogMTc3ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk1lc3NhZ2VIYW5kbGVyID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXygyKTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG5jb25zdCBDYWxsYmFja0tpbmQgPSB7XG4gIFVOS05PV046IDAsXG4gIERBVEE6IDEsXG4gIEVSUk9SOiAyXG59O1xuY29uc3QgU3RyZWFtS2luZCA9IHtcbiAgVU5LTk9XTjogMCxcbiAgQ0FOQ0VMOiAxLFxuICBDQU5DRUxfQ09NUExFVEU6IDIsXG4gIENMT1NFOiAzLFxuICBFTlFVRVVFOiA0LFxuICBFUlJPUjogNSxcbiAgUFVMTDogNixcbiAgUFVMTF9DT01QTEVURTogNyxcbiAgU1RBUlRfQ09NUExFVEU6IDhcbn07XG5mdW5jdGlvbiB3cmFwUmVhc29uKHJlYXNvbikge1xuICBpZiAoIShyZWFzb24gaW5zdGFuY2VvZiBFcnJvciB8fCB0eXBlb2YgcmVhc29uID09PSBcIm9iamVjdFwiICYmIHJlYXNvbiAhPT0gbnVsbCkpIHtcbiAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKCd3cmFwUmVhc29uOiBFeHBlY3RlZCBcInJlYXNvblwiIHRvIGJlIGEgKHBvc3NpYmx5IGNsb25lZCkgRXJyb3IuJyk7XG4gIH1cbiAgc3dpdGNoIChyZWFzb24ubmFtZSkge1xuICAgIGNhc2UgXCJBYm9ydEV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSk7XG4gICAgY2FzZSBcIk1pc3NpbmdQREZFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuTWlzc2luZ1BERkV4Y2VwdGlvbihyZWFzb24ubWVzc2FnZSk7XG4gICAgY2FzZSBcIlBhc3N3b3JkRXhjZXB0aW9uXCI6XG4gICAgICByZXR1cm4gbmV3IF91dGlsLlBhc3N3b3JkRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uY29kZSk7XG4gICAgY2FzZSBcIlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvblwiOlxuICAgICAgcmV0dXJuIG5ldyBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24ocmVhc29uLm1lc3NhZ2UsIHJlYXNvbi5zdGF0dXMpO1xuICAgIGNhc2UgXCJVbmtub3duRXJyb3JFeGNlcHRpb25cIjpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24uZGV0YWlscyk7XG4gICAgZGVmYXVsdDpcbiAgICAgIHJldHVybiBuZXcgX3V0aWwuVW5rbm93bkVycm9yRXhjZXB0aW9uKHJlYXNvbi5tZXNzYWdlLCByZWFzb24udG9TdHJpbmcoKSk7XG4gIH1cbn1cbmNsYXNzIE1lc3NhZ2VIYW5kbGVyIHtcbiAgY29uc3RydWN0b3Ioc291cmNlTmFtZSwgdGFyZ2V0TmFtZSwgY29tT2JqKSB7XG4gICAgdGhpcy5zb3VyY2VOYW1lID0gc291cmNlTmFtZTtcbiAgICB0aGlzLnRhcmdldE5hbWUgPSB0YXJnZXROYW1lO1xuICAgIHRoaXMuY29tT2JqID0gY29tT2JqO1xuICAgIHRoaXMuY2FsbGJhY2tJZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1JZCA9IDE7XG4gICAgdGhpcy5zdHJlYW1TaW5rcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5zdHJlYW1Db250cm9sbGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5jYWxsYmFja0NhcGFiaWxpdGllcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgdGhpcy5hY3Rpb25IYW5kbGVyID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSA9IGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRhdGEgPSBldmVudC5kYXRhO1xuICAgICAgaWYgKGRhdGEudGFyZ2V0TmFtZSAhPT0gdGhpcy5zb3VyY2VOYW1lKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmIChkYXRhLnN0cmVhbSkge1xuICAgICAgICB0aGlzLiNwcm9jZXNzU3RyZWFtTWVzc2FnZShkYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuY2FsbGJhY2spIHtcbiAgICAgICAgY29uc3QgY2FsbGJhY2tJZCA9IGRhdGEuY2FsbGJhY2tJZDtcbiAgICAgICAgY29uc3QgY2FwYWJpbGl0eSA9IHRoaXMuY2FsbGJhY2tDYXBhYmlsaXRpZXNbY2FsbGJhY2tJZF07XG4gICAgICAgIGlmICghY2FwYWJpbGl0eSkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHJlc29sdmUgY2FsbGJhY2sgJHtjYWxsYmFja0lkfWApO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdO1xuICAgICAgICBpZiAoZGF0YS5jYWxsYmFjayA9PT0gQ2FsbGJhY2tLaW5kLkRBVEEpIHtcbiAgICAgICAgICBjYXBhYmlsaXR5LnJlc29sdmUoZGF0YS5kYXRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChkYXRhLmNhbGxiYWNrID09PSBDYWxsYmFja0tpbmQuRVJST1IpIHtcbiAgICAgICAgICBjYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBjYWxsYmFjayBjYXNlXCIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgICBpZiAoIWFjdGlvbikge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gYWN0aW9uIGZyb20gd29ya2VyOiAke2RhdGEuYWN0aW9ufWApO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuY2FsbGJhY2tJZCkge1xuICAgICAgICBjb25zdCBjYlNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWU7XG4gICAgICAgIGNvbnN0IGNiVGFyZ2V0TmFtZSA9IGRhdGEuc291cmNlTmFtZTtcbiAgICAgICAgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICByZXNvbHZlKGFjdGlvbihkYXRhLmRhdGEpKTtcbiAgICAgICAgfSkudGhlbihmdW5jdGlvbiAocmVzdWx0KSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWU6IGNiU291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IGNiVGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBDYWxsYmFja0tpbmQuREFUQSxcbiAgICAgICAgICAgIGNhbGxiYWNrSWQ6IGRhdGEuY2FsbGJhY2tJZCxcbiAgICAgICAgICAgIGRhdGE6IHJlc3VsdFxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWU6IGNiU291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWU6IGNiVGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiBDYWxsYmFja0tpbmQuRVJST1IsXG4gICAgICAgICAgICBjYWxsYmFja0lkOiBkYXRhLmNhbGxiYWNrSWQsXG4gICAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEuc3RyZWFtSWQpIHtcbiAgICAgICAgdGhpcy4jY3JlYXRlU3RyZWFtU2luayhkYXRhKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgYWN0aW9uKGRhdGEuZGF0YSk7XG4gICAgfTtcbiAgICBjb21PYmouYWRkRXZlbnRMaXN0ZW5lcihcIm1lc3NhZ2VcIiwgdGhpcy5fb25Db21PYmpPbk1lc3NhZ2UpO1xuICB9XG4gIG9uKGFjdGlvbk5hbWUsIGhhbmRsZXIpIHtcbiAgICBjb25zdCBhaCA9IHRoaXMuYWN0aW9uSGFuZGxlcjtcbiAgICBpZiAoYWhbYWN0aW9uTmFtZV0pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVGhlcmUgaXMgYWxyZWFkeSBhbiBhY3Rpb25OYW1lIGNhbGxlZCBcIiR7YWN0aW9uTmFtZX1cImApO1xuICAgIH1cbiAgICBhaFthY3Rpb25OYW1lXSA9IGhhbmRsZXI7XG4gIH1cbiAgc2VuZChhY3Rpb25OYW1lLCBkYXRhLCB0cmFuc2ZlcnMpIHtcbiAgICB0aGlzLmNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lOiB0aGlzLnRhcmdldE5hbWUsXG4gICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICBkYXRhXG4gICAgfSwgdHJhbnNmZXJzKTtcbiAgfVxuICBzZW5kV2l0aFByb21pc2UoYWN0aW9uTmFtZSwgZGF0YSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3QgY2FsbGJhY2tJZCA9IHRoaXMuY2FsbGJhY2tJZCsrO1xuICAgIGNvbnN0IGNhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLmNhbGxiYWNrQ2FwYWJpbGl0aWVzW2NhbGxiYWNrSWRdID0gY2FwYWJpbGl0eTtcbiAgICB0cnkge1xuICAgICAgdGhpcy5jb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICBzb3VyY2VOYW1lOiB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWU6IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgICAgYWN0aW9uOiBhY3Rpb25OYW1lLFxuICAgICAgICBjYWxsYmFja0lkLFxuICAgICAgICBkYXRhXG4gICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgIH0gY2F0Y2ggKGV4KSB7XG4gICAgICBjYXBhYmlsaXR5LnJlamVjdChleCk7XG4gICAgfVxuICAgIHJldHVybiBjYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgc2VuZFdpdGhTdHJlYW0oYWN0aW9uTmFtZSwgZGF0YSwgcXVldWVpbmdTdHJhdGVneSwgdHJhbnNmZXJzKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSB0aGlzLnN0cmVhbUlkKyssXG4gICAgICBzb3VyY2VOYW1lID0gdGhpcy5zb3VyY2VOYW1lLFxuICAgICAgdGFyZ2V0TmFtZSA9IHRoaXMudGFyZ2V0TmFtZSxcbiAgICAgIGNvbU9iaiA9IHRoaXMuY29tT2JqO1xuICAgIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQ6IGNvbnRyb2xsZXIgPT4ge1xuICAgICAgICBjb25zdCBzdGFydENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0gPSB7XG4gICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICBzdGFydENhbGw6IHN0YXJ0Q2FwYWJpbGl0eSxcbiAgICAgICAgICBwdWxsQ2FsbDogbnVsbCxcbiAgICAgICAgICBjYW5jZWxDYWxsOiBudWxsLFxuICAgICAgICAgIGlzQ2xvc2VkOiBmYWxzZVxuICAgICAgICB9O1xuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBhY3Rpb246IGFjdGlvbk5hbWUsXG4gICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICBkZXNpcmVkU2l6ZTogY29udHJvbGxlci5kZXNpcmVkU2l6ZVxuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgICByZXR1cm4gc3RhcnRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgICB9LFxuICAgICAgcHVsbDogY29udHJvbGxlciA9PiB7XG4gICAgICAgIGNvbnN0IHB1bGxDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLnB1bGxDYWxsID0gcHVsbENhcGFiaWxpdHk7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5QVUxMLFxuICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgIGRlc2lyZWRTaXplOiBjb250cm9sbGVyLmRlc2lyZWRTaXplXG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcHVsbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH0sXG4gICAgICBjYW5jZWw6IHJlYXNvbiA9PiB7XG4gICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImNhbmNlbCBtdXN0IGhhdmUgYSB2YWxpZCByZWFzb25cIik7XG4gICAgICAgIGNvbnN0IGNhbmNlbENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgICAgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF0uY2FuY2VsQ2FsbCA9IGNhbmNlbENhcGFiaWxpdHk7XG4gICAgICAgIHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNBTkNFTCxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGNhbmNlbENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgIH1cbiAgICB9LCBxdWV1ZWluZ1N0cmF0ZWd5KTtcbiAgfVxuICAjY3JlYXRlU3RyZWFtU2luayhkYXRhKSB7XG4gICAgY29uc3Qgc3RyZWFtSWQgPSBkYXRhLnN0cmVhbUlkLFxuICAgICAgc291cmNlTmFtZSA9IHRoaXMuc291cmNlTmFtZSxcbiAgICAgIHRhcmdldE5hbWUgPSBkYXRhLnNvdXJjZU5hbWUsXG4gICAgICBjb21PYmogPSB0aGlzLmNvbU9iajtcbiAgICBjb25zdCBzZWxmID0gdGhpcyxcbiAgICAgIGFjdGlvbiA9IHRoaXMuYWN0aW9uSGFuZGxlcltkYXRhLmFjdGlvbl07XG4gICAgY29uc3Qgc3RyZWFtU2luayA9IHtcbiAgICAgIGVucXVldWUoY2h1bmspIHtcbiAgICAgICAgbGV0IHNpemUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgICAgIGxldCB0cmFuc2ZlcnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMiA/IGFyZ3VtZW50c1syXSA6IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbGFzdERlc2lyZWRTaXplID0gdGhpcy5kZXNpcmVkU2l6ZTtcbiAgICAgICAgdGhpcy5kZXNpcmVkU2l6ZSAtPSBzaXplO1xuICAgICAgICBpZiAobGFzdERlc2lyZWRTaXplID4gMCAmJiB0aGlzLmRlc2lyZWRTaXplIDw9IDApIHtcbiAgICAgICAgICB0aGlzLnNpbmtDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgICAgICAgdGhpcy5yZWFkeSA9IHRoaXMuc2lua0NhcGFiaWxpdHkucHJvbWlzZTtcbiAgICAgICAgfVxuICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuRU5RVUVVRSxcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICBjaHVua1xuICAgICAgICB9LCB0cmFuc2ZlcnMpO1xuICAgICAgfSxcbiAgICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5pc0NhbmNlbGxlZCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzQ2FuY2VsbGVkID0gdHJ1ZTtcbiAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLkNMT1NFLFxuICAgICAgICAgIHN0cmVhbUlkXG4gICAgICAgIH0pO1xuICAgICAgICBkZWxldGUgc2VsZi5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICB9LFxuICAgICAgZXJyb3IocmVhc29uKSB7XG4gICAgICAgICgwLCBfdXRpbC5hc3NlcnQpKHJlYXNvbiBpbnN0YW5jZW9mIEVycm9yLCBcImVycm9yIG11c3QgaGF2ZSBhIHZhbGlkIHJlYXNvblwiKTtcbiAgICAgICAgaWYgKHRoaXMuaXNDYW5jZWxsZWQpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pc0NhbmNlbGxlZCA9IHRydWU7XG4gICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5FUlJPUixcbiAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICByZWFzb246IHdyYXBSZWFzb24ocmVhc29uKVxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBzaW5rQ2FwYWJpbGl0eTogbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCksXG4gICAgICBvblB1bGw6IG51bGwsXG4gICAgICBvbkNhbmNlbDogbnVsbCxcbiAgICAgIGlzQ2FuY2VsbGVkOiBmYWxzZSxcbiAgICAgIGRlc2lyZWRTaXplOiBkYXRhLmRlc2lyZWRTaXplLFxuICAgICAgcmVhZHk6IG51bGxcbiAgICB9O1xuICAgIHN0cmVhbVNpbmsuc2lua0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIHN0cmVhbVNpbmsucmVhZHkgPSBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF0gPSBzdHJlYW1TaW5rO1xuICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICByZXNvbHZlKGFjdGlvbihkYXRhLmRhdGEsIHN0cmVhbVNpbmspKTtcbiAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgIH0pO1xuICAgIH0sIGZ1bmN0aW9uIChyZWFzb24pIHtcbiAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURSxcbiAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuICAjcHJvY2Vzc1N0cmVhbU1lc3NhZ2UoZGF0YSkge1xuICAgIGNvbnN0IHN0cmVhbUlkID0gZGF0YS5zdHJlYW1JZCxcbiAgICAgIHNvdXJjZU5hbWUgPSB0aGlzLnNvdXJjZU5hbWUsXG4gICAgICB0YXJnZXROYW1lID0gZGF0YS5zb3VyY2VOYW1lLFxuICAgICAgY29tT2JqID0gdGhpcy5jb21PYmo7XG4gICAgY29uc3Qgc3RyZWFtQ29udHJvbGxlciA9IHRoaXMuc3RyZWFtQ29udHJvbGxlcnNbc3RyZWFtSWRdLFxuICAgICAgc3RyZWFtU2luayA9IHRoaXMuc3RyZWFtU2lua3Nbc3RyZWFtSWRdO1xuICAgIHN3aXRjaCAoZGF0YS5zdHJlYW0pIHtcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5TVEFSVF9DT01QTEVURTpcbiAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnN0YXJ0Q2FsbC5yZWplY3Qod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEU6XG4gICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsLnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuUFVMTDpcbiAgICAgICAgaWYgKCFzdHJlYW1TaW5rKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA8PSAwICYmIGRhdGEuZGVzaXJlZFNpemUgPiAwKSB7XG4gICAgICAgICAgc3RyZWFtU2luay5zaW5rQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtU2luay5kZXNpcmVkU2l6ZSA9IGRhdGEuZGVzaXJlZFNpemU7XG4gICAgICAgIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgcmVzb2x2ZShzdHJlYW1TaW5rLm9uUHVsbD8uKCkpO1xuICAgICAgICB9KS50aGVuKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBjb21PYmoucG9zdE1lc3NhZ2Uoe1xuICAgICAgICAgICAgc291cmNlTmFtZSxcbiAgICAgICAgICAgIHRhcmdldE5hbWUsXG4gICAgICAgICAgICBzdHJlYW06IFN0cmVhbUtpbmQuUFVMTF9DT01QTEVURSxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgc3VjY2VzczogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9LCBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgICAgY29tT2JqLnBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHNvdXJjZU5hbWUsXG4gICAgICAgICAgICB0YXJnZXROYW1lLFxuICAgICAgICAgICAgc3RyZWFtOiBTdHJlYW1LaW5kLlBVTExfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgU3RyZWFtS2luZC5FTlFVRVVFOlxuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShzdHJlYW1Db250cm9sbGVyLCBcImVucXVldWUgc2hvdWxkIGhhdmUgc3RyZWFtIGNvbnRyb2xsZXJcIik7XG4gICAgICAgIGlmIChzdHJlYW1Db250cm9sbGVyLmlzQ2xvc2VkKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jb250cm9sbGVyLmVucXVldWUoZGF0YS5jaHVuayk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkNMT1NFOlxuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShzdHJlYW1Db250cm9sbGVyLCBcImNsb3NlIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBpZiAoc3RyZWFtQ29udHJvbGxlci5pc0Nsb3NlZCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHN0cmVhbUNvbnRyb2xsZXIuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgdGhpcy4jZGVsZXRlU3RyZWFtQ29udHJvbGxlcihzdHJlYW1Db250cm9sbGVyLCBzdHJlYW1JZCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBTdHJlYW1LaW5kLkVSUk9SOlxuICAgICAgICAoMCwgX3V0aWwuYXNzZXJ0KShzdHJlYW1Db250cm9sbGVyLCBcImVycm9yIHNob3VsZCBoYXZlIHN0cmVhbSBjb250cm9sbGVyXCIpO1xuICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNvbnRyb2xsZXIuZXJyb3Iod3JhcFJlYXNvbihkYXRhLnJlYXNvbikpO1xuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMX0NPTVBMRVRFOlxuICAgICAgICBpZiAoZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgc3RyZWFtQ29udHJvbGxlci5jYW5jZWxDYWxsLnJlc29sdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGwucmVqZWN0KHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNkZWxldGVTdHJlYW1Db250cm9sbGVyKHN0cmVhbUNvbnRyb2xsZXIsIHN0cmVhbUlkKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIFN0cmVhbUtpbmQuQ0FOQ0VMOlxuICAgICAgICBpZiAoIXN0cmVhbVNpbmspIHtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSkge1xuICAgICAgICAgIHJlc29sdmUoc3RyZWFtU2luay5vbkNhbmNlbD8uKHdyYXBSZWFzb24oZGF0YS5yZWFzb24pKSk7XG4gICAgICAgIH0pLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHN1Y2Nlc3M6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSwgZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgICAgIGNvbU9iai5wb3N0TWVzc2FnZSh7XG4gICAgICAgICAgICBzb3VyY2VOYW1lLFxuICAgICAgICAgICAgdGFyZ2V0TmFtZSxcbiAgICAgICAgICAgIHN0cmVhbTogU3RyZWFtS2luZC5DQU5DRUxfQ09NUExFVEUsXG4gICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgIHJlYXNvbjogd3JhcFJlYXNvbihyZWFzb24pXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzdHJlYW1TaW5rLnNpbmtDYXBhYmlsaXR5LnJlamVjdCh3cmFwUmVhc29uKGRhdGEucmVhc29uKSk7XG4gICAgICAgIHN0cmVhbVNpbmsuaXNDYW5jZWxsZWQgPSB0cnVlO1xuICAgICAgICBkZWxldGUgdGhpcy5zdHJlYW1TaW5rc1tzdHJlYW1JZF07XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVW5leHBlY3RlZCBzdHJlYW0gY2FzZVwiKTtcbiAgICB9XG4gIH1cbiAgYXN5bmMgI2RlbGV0ZVN0cmVhbUNvbnRyb2xsZXIoc3RyZWFtQ29udHJvbGxlciwgc3RyZWFtSWQpIHtcbiAgICBhd2FpdCBQcm9taXNlLmFsbFNldHRsZWQoW3N0cmVhbUNvbnRyb2xsZXIuc3RhcnRDYWxsPy5wcm9taXNlLCBzdHJlYW1Db250cm9sbGVyLnB1bGxDYWxsPy5wcm9taXNlLCBzdHJlYW1Db250cm9sbGVyLmNhbmNlbENhbGw/LnByb21pc2VdKTtcbiAgICBkZWxldGUgdGhpcy5zdHJlYW1Db250cm9sbGVyc1tzdHJlYW1JZF07XG4gIH1cbiAgZGVzdHJveSgpIHtcbiAgICB0aGlzLmNvbU9iai5yZW1vdmVFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCB0aGlzLl9vbkNvbU9iak9uTWVzc2FnZSk7XG4gIH1cbn1cbmV4cG9ydHMuTWVzc2FnZUhhbmRsZXIgPSBNZXNzYWdlSGFuZGxlcjtcblxuLyoqKi8gfSksXG4vKiAxNzggKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTWV0YWRhdGEgPSB2b2lkIDA7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuY2xhc3MgTWV0YWRhdGEge1xuICAjbWV0YWRhdGFNYXA7XG4gICNkYXRhO1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIHBhcnNlZERhdGEsXG4gICAgICByYXdEYXRhXG4gICAgfSA9IF9yZWY7XG4gICAgdGhpcy4jbWV0YWRhdGFNYXAgPSBwYXJzZWREYXRhO1xuICAgIHRoaXMuI2RhdGEgPSByYXdEYXRhO1xuICB9XG4gIGdldFJhdygpIHtcbiAgICByZXR1cm4gdGhpcy4jZGF0YTtcbiAgfVxuICBnZXQobmFtZSkge1xuICAgIHJldHVybiB0aGlzLiNtZXRhZGF0YU1hcC5nZXQobmFtZSkgPz8gbnVsbDtcbiAgfVxuICBnZXRBbGwoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5vYmplY3RGcm9tTWFwKSh0aGlzLiNtZXRhZGF0YU1hcCk7XG4gIH1cbiAgaGFzKG5hbWUpIHtcbiAgICByZXR1cm4gdGhpcy4jbWV0YWRhdGFNYXAuaGFzKG5hbWUpO1xuICB9XG59XG5leHBvcnRzLk1ldGFkYXRhID0gTWV0YWRhdGE7XG5cbi8qKiovIH0pLFxuLyogMTc5ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLk9wdGlvbmFsQ29udGVudENvbmZpZyA9IHZvaWQgMDtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX211cm11cmhhc2ggPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE3MCk7XG5jb25zdCBJTlRFUk5BTCA9IFN5bWJvbChcIklOVEVSTkFMXCIpO1xuY2xhc3MgT3B0aW9uYWxDb250ZW50R3JvdXAge1xuICAjdmlzaWJsZSA9IHRydWU7XG4gIGNvbnN0cnVjdG9yKG5hbWUsIGludGVudCkge1xuICAgIHRoaXMubmFtZSA9IG5hbWU7XG4gICAgdGhpcy5pbnRlbnQgPSBpbnRlbnQ7XG4gIH1cbiAgZ2V0IHZpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3Zpc2libGU7XG4gIH1cbiAgX3NldFZpc2libGUoaW50ZXJuYWwsIHZpc2libGUpIHtcbiAgICBpZiAoaW50ZXJuYWwgIT09IElOVEVSTkFMKSB7XG4gICAgICAoMCwgX3V0aWwudW5yZWFjaGFibGUpKFwiSW50ZXJuYWwgbWV0aG9kIGBfc2V0VmlzaWJsZWAgY2FsbGVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy4jdmlzaWJsZSA9IHZpc2libGU7XG4gIH1cbn1cbmNsYXNzIE9wdGlvbmFsQ29udGVudENvbmZpZyB7XG4gICNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgI2dyb3VwcyA9IG5ldyBNYXAoKTtcbiAgI2luaXRpYWxIYXNoID0gbnVsbDtcbiAgI29yZGVyID0gbnVsbDtcbiAgY29uc3RydWN0b3IoZGF0YSkge1xuICAgIHRoaXMubmFtZSA9IG51bGw7XG4gICAgdGhpcy5jcmVhdG9yID0gbnVsbDtcbiAgICBpZiAoZGF0YSA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLm5hbWUgPSBkYXRhLm5hbWU7XG4gICAgdGhpcy5jcmVhdG9yID0gZGF0YS5jcmVhdG9yO1xuICAgIHRoaXMuI29yZGVyID0gZGF0YS5vcmRlcjtcbiAgICBmb3IgKGNvbnN0IGdyb3VwIG9mIGRhdGEuZ3JvdXBzKSB7XG4gICAgICB0aGlzLiNncm91cHMuc2V0KGdyb3VwLmlkLCBuZXcgT3B0aW9uYWxDb250ZW50R3JvdXAoZ3JvdXAubmFtZSwgZ3JvdXAuaW50ZW50KSk7XG4gICAgfVxuICAgIGlmIChkYXRhLmJhc2VTdGF0ZSA9PT0gXCJPRkZcIikge1xuICAgICAgZm9yIChjb25zdCBncm91cCBvZiB0aGlzLiNncm91cHMudmFsdWVzKCkpIHtcbiAgICAgICAgZ3JvdXAuX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBvbiBvZiBkYXRhLm9uKSB7XG4gICAgICB0aGlzLiNncm91cHMuZ2V0KG9uKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgdHJ1ZSk7XG4gICAgfVxuICAgIGZvciAoY29uc3Qgb2ZmIG9mIGRhdGEub2ZmKSB7XG4gICAgICB0aGlzLiNncm91cHMuZ2V0KG9mZikuX3NldFZpc2libGUoSU5URVJOQUwsIGZhbHNlKTtcbiAgICB9XG4gICAgdGhpcy4jaW5pdGlhbEhhc2ggPSB0aGlzLmdldEhhc2goKTtcbiAgfVxuICAjZXZhbHVhdGVWaXNpYmlsaXR5RXhwcmVzc2lvbihhcnJheSkge1xuICAgIGNvbnN0IGxlbmd0aCA9IGFycmF5Lmxlbmd0aDtcbiAgICBpZiAobGVuZ3RoIDwgMikge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGNvbnN0IG9wZXJhdG9yID0gYXJyYXlbMF07XG4gICAgZm9yIChsZXQgaSA9IDE7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgZWxlbWVudCA9IGFycmF5W2ldO1xuICAgICAgbGV0IHN0YXRlO1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZWxlbWVudCkpIHtcbiAgICAgICAgc3RhdGUgPSB0aGlzLiNldmFsdWF0ZVZpc2liaWxpdHlFeHByZXNzaW9uKGVsZW1lbnQpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLiNncm91cHMuaGFzKGVsZW1lbnQpKSB7XG4gICAgICAgIHN0YXRlID0gdGhpcy4jZ3JvdXBzLmdldChlbGVtZW50KS52aXNpYmxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtlbGVtZW50fWApO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAob3BlcmF0b3IpIHtcbiAgICAgICAgY2FzZSBcIkFuZFwiOlxuICAgICAgICAgIGlmICghc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJPclwiOlxuICAgICAgICAgIGlmIChzdGF0ZSkge1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTm90XCI6XG4gICAgICAgICAgcmV0dXJuICFzdGF0ZTtcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIG9wZXJhdG9yID09PSBcIkFuZFwiO1xuICB9XG4gIGlzVmlzaWJsZShncm91cCkge1xuICAgIGlmICh0aGlzLiNncm91cHMuc2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmICghZ3JvdXApIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIk9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGRlZmluZWQuXCIpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICAgIGlmIChncm91cC50eXBlID09PSBcIk9DR1wiKSB7XG4gICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoZ3JvdXAuaWQpKSB7XG4gICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7Z3JvdXAuaWR9YCk7XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5nZXQoZ3JvdXAuaWQpLnZpc2libGU7XG4gICAgfSBlbHNlIGlmIChncm91cC50eXBlID09PSBcIk9DTURcIikge1xuICAgICAgaWYgKGdyb3VwLmV4cHJlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuI2V2YWx1YXRlVmlzaWJpbGl0eUV4cHJlc3Npb24oZ3JvdXAuZXhwcmVzc2lvbik7XG4gICAgICB9XG4gICAgICBpZiAoIWdyb3VwLnBvbGljeSB8fCBncm91cC5wb2xpY3kgPT09IFwiQW55T25cIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbGxPblwiKSB7XG4gICAgICAgIGZvciAoY29uc3QgaWQgb2YgZ3JvdXAuaWRzKSB7XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuaGFzKGlkKSkge1xuICAgICAgICAgICAgKDAsIF91dGlsLndhcm4pKGBPcHRpb25hbCBjb250ZW50IGdyb3VwIG5vdCBmb3VuZDogJHtpZH1gKTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5nZXQoaWQpLnZpc2libGUpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9IGVsc2UgaWYgKGdyb3VwLnBvbGljeSA9PT0gXCJBbnlPZmZcIikge1xuICAgICAgICBmb3IgKGNvbnN0IGlkIG9mIGdyb3VwLmlkcykge1xuICAgICAgICAgIGlmICghdGhpcy4jZ3JvdXBzLmhhcyhpZCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgT3B0aW9uYWwgY29udGVudCBncm91cCBub3QgZm91bmQ6ICR7aWR9YCk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCF0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfSBlbHNlIGlmIChncm91cC5wb2xpY3kgPT09IFwiQWxsT2ZmXCIpIHtcbiAgICAgICAgZm9yIChjb25zdCBpZCBvZiBncm91cC5pZHMpIHtcbiAgICAgICAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAgICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmICh0aGlzLiNncm91cHMuZ2V0KGlkKS52aXNpYmxlKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgfVxuICAgICAgKDAsIF91dGlsLndhcm4pKGBVbmtub3duIG9wdGlvbmFsIGNvbnRlbnQgcG9saWN5ICR7Z3JvdXAucG9saWN5fS5gKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH1cbiAgICAoMCwgX3V0aWwud2FybikoYFVua25vd24gZ3JvdXAgdHlwZSAke2dyb3VwLnR5cGV9LmApO1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIHNldFZpc2liaWxpdHkoaWQpIHtcbiAgICBsZXQgdmlzaWJsZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogdHJ1ZTtcbiAgICBpZiAoIXRoaXMuI2dyb3Vwcy5oYXMoaWQpKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYE9wdGlvbmFsIGNvbnRlbnQgZ3JvdXAgbm90IGZvdW5kOiAke2lkfWApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNncm91cHMuZ2V0KGlkKS5fc2V0VmlzaWJsZShJTlRFUk5BTCwgISF2aXNpYmxlKTtcbiAgICB0aGlzLiNjYWNoZWRHZXRIYXNoID0gbnVsbDtcbiAgfVxuICBnZXQgaGFzSW5pdGlhbFZpc2liaWxpdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2luaXRpYWxIYXNoID09PSBudWxsIHx8IHRoaXMuZ2V0SGFzaCgpID09PSB0aGlzLiNpbml0aWFsSGFzaDtcbiAgfVxuICBnZXRPcmRlcigpIHtcbiAgICBpZiAoIXRoaXMuI2dyb3Vwcy5zaXplKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuI29yZGVyKSB7XG4gICAgICByZXR1cm4gdGhpcy4jb3JkZXIuc2xpY2UoKTtcbiAgICB9XG4gICAgcmV0dXJuIFsuLi50aGlzLiNncm91cHMua2V5cygpXTtcbiAgfVxuICBnZXRHcm91cHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2dyb3Vwcy5zaXplID4gMCA/ICgwLCBfdXRpbC5vYmplY3RGcm9tTWFwKSh0aGlzLiNncm91cHMpIDogbnVsbDtcbiAgfVxuICBnZXRHcm91cChpZCkge1xuICAgIHJldHVybiB0aGlzLiNncm91cHMuZ2V0KGlkKSB8fCBudWxsO1xuICB9XG4gIGdldEhhc2goKSB7XG4gICAgaWYgKHRoaXMuI2NhY2hlZEdldEhhc2ggIT09IG51bGwpIHtcbiAgICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoO1xuICAgIH1cbiAgICBjb25zdCBoYXNoID0gbmV3IF9tdXJtdXJoYXNoLk11cm11ckhhc2gzXzY0KCk7XG4gICAgZm9yIChjb25zdCBbaWQsIGdyb3VwXSBvZiB0aGlzLiNncm91cHMpIHtcbiAgICAgIGhhc2gudXBkYXRlKGAke2lkfToke2dyb3VwLnZpc2libGV9YCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLiNjYWNoZWRHZXRIYXNoID0gaGFzaC5oZXhkaWdlc3QoKTtcbiAgfVxufVxuZXhwb3J0cy5PcHRpb25hbENvbnRlbnRDb25maWcgPSBPcHRpb25hbENvbnRlbnRDb25maWc7XG5cbi8qKiovIH0pLFxuLyogMTgwICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlBERkRhdGFUcmFuc3BvcnRTdHJlYW0gPSB2b2lkIDA7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDkzKTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTAxKTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTAyKTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTA1KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTA3KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTA5KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTEzKTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTE2KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMTIzKTtcbl9fd19wZGZqc19yZXF1aXJlX18oODkpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTY4KTtcbmNsYXNzIFBERkRhdGFUcmFuc3BvcnRTdHJlYW0ge1xuICBjb25zdHJ1Y3RvcihfcmVmLCBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQpIHtcbiAgICBsZXQge1xuICAgICAgbGVuZ3RoLFxuICAgICAgaW5pdGlhbERhdGEsXG4gICAgICBwcm9ncmVzc2l2ZURvbmUgPSBmYWxzZSxcbiAgICAgIGNvbnRlbnREaXNwb3NpdGlvbkZpbGVuYW1lID0gbnVsbCxcbiAgICAgIGRpc2FibGVSYW5nZSA9IGZhbHNlLFxuICAgICAgZGlzYWJsZVN0cmVhbSA9IGZhbHNlXG4gICAgfSA9IF9yZWY7XG4gICAgKDAsIF91dGlsLmFzc2VydCkocGRmRGF0YVJhbmdlVHJhbnNwb3J0LCAnUERGRGF0YVRyYW5zcG9ydFN0cmVhbSAtIG1pc3NpbmcgcmVxdWlyZWQgXCJwZGZEYXRhUmFuZ2VUcmFuc3BvcnRcIiBhcmd1bWVudC4nKTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBbXTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSBwcm9ncmVzc2l2ZURvbmU7XG4gICAgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZTtcbiAgICBpZiAoaW5pdGlhbERhdGE/Lmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGJ1ZmZlciA9IGluaXRpYWxEYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSAmJiBpbml0aWFsRGF0YS5ieXRlTGVuZ3RoID09PSBpbml0aWFsRGF0YS5idWZmZXIuYnl0ZUxlbmd0aCA/IGluaXRpYWxEYXRhLmJ1ZmZlciA6IG5ldyBVaW50OEFycmF5KGluaXRpYWxEYXRhKS5idWZmZXI7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgIH1cbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQgPSBwZGZEYXRhUmFuZ2VUcmFuc3BvcnQ7XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSAhZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIWRpc2FibGVSYW5nZTtcbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gbGVuZ3RoO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlYWRlcnMgPSBbXTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUmFuZ2VMaXN0ZW5lcigoYmVnaW4sIGNodW5rKSA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgYmVnaW4sXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICB0aGlzLl9wZGZEYXRhUmFuZ2VUcmFuc3BvcnQuYWRkUHJvZ3Jlc3NMaXN0ZW5lcigobG9hZGVkLCB0b3RhbCkgPT4ge1xuICAgICAgdGhpcy5fb25Qcm9ncmVzcyh7XG4gICAgICAgIGxvYWRlZCxcbiAgICAgICAgdG90YWxcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZVJlYWRMaXN0ZW5lcihjaHVuayA9PiB7XG4gICAgICB0aGlzLl9vblJlY2VpdmVEYXRhKHtcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC5hZGRQcm9ncmVzc2l2ZURvbmVMaXN0ZW5lcigoKSA9PiB7XG4gICAgICB0aGlzLl9vblByb2dyZXNzaXZlRG9uZSgpO1xuICAgIH0pO1xuICAgIHRoaXMuX3BkZkRhdGFSYW5nZVRyYW5zcG9ydC50cmFuc3BvcnRSZWFkeSgpO1xuICB9XG4gIF9vblJlY2VpdmVEYXRhKF9yZWYyKSB7XG4gICAgbGV0IHtcbiAgICAgIGJlZ2luLFxuICAgICAgY2h1bmtcbiAgICB9ID0gX3JlZjI7XG4gICAgY29uc3QgYnVmZmVyID0gY2h1bmsgaW5zdGFuY2VvZiBVaW50OEFycmF5ICYmIGNodW5rLmJ5dGVMZW5ndGggPT09IGNodW5rLmJ1ZmZlci5ieXRlTGVuZ3RoID8gY2h1bmsuYnVmZmVyIDogbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICBpZiAoYmVnaW4gPT09IHVuZGVmaW5lZCkge1xuICAgICAgaWYgKHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyKSB7XG4gICAgICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLl9lbnF1ZXVlKGJ1ZmZlcik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChidWZmZXIpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBmb3VuZCA9IHRoaXMuX3JhbmdlUmVhZGVycy5zb21lKGZ1bmN0aW9uIChyYW5nZVJlYWRlcikge1xuICAgICAgICBpZiAocmFuZ2VSZWFkZXIuX2JlZ2luICE9PSBiZWdpbikge1xuICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICByYW5nZVJlYWRlci5fZW5xdWV1ZShidWZmZXIpO1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgIH0pO1xuICAgICAgKDAsIF91dGlsLmFzc2VydCkoZm91bmQsIFwiX29uUmVjZWl2ZURhdGEgLSBubyBgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyYCBpbnN0YW5jZSBmb3VuZC5cIik7XG4gICAgfVxuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmIChldnQudG90YWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZWFkZXJzWzBdPy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8ub25Qcm9ncmVzcz8uKHtcbiAgICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgICB0b3RhbDogZXZ0LnRvdGFsXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgX29uUHJvZ3Jlc3NpdmVEb25lKCkge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5wcm9ncmVzc2l2ZURvbmUoKTtcbiAgICB0aGlzLl9wcm9ncmVzc2l2ZURvbmUgPSB0cnVlO1xuICB9XG4gIF9yZW1vdmVSYW5nZVJlYWRlcihyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZWFkZXJzLmluZGV4T2YocmVhZGVyKTtcbiAgICBpZiAoaSA+PSAwKSB7XG4gICAgICB0aGlzLl9yYW5nZVJlYWRlcnMuc3BsaWNlKGksIDEpO1xuICAgIH1cbiAgfVxuICBnZXRGdWxsUmVhZGVyKCkge1xuICAgICgwLCBfdXRpbC5hc3NlcnQpKCF0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciwgXCJQREZEYXRhVHJhbnNwb3J0U3RyZWFtLmdldEZ1bGxSZWFkZXIgY2FuIG9ubHkgYmUgY2FsbGVkIG9uY2UuXCIpO1xuICAgIGNvbnN0IHF1ZXVlZENodW5rcyA9IHRoaXMuX3F1ZXVlZENodW5rcztcbiAgICB0aGlzLl9xdWV1ZWRDaHVua3MgPSBudWxsO1xuICAgIHJldHVybiBuZXcgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJlYWRlcih0aGlzLCBxdWV1ZWRDaHVua3MsIHRoaXMuX3Byb2dyZXNzaXZlRG9uZSwgdGhpcy5fY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUpO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmFuZ2VSZWFkZXIodGhpcywgYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LnJlcXVlc3REYXRhUmFuZ2UoYmVnaW4sIGVuZCk7XG4gICAgdGhpcy5fcmFuZ2VSZWFkZXJzLnB1c2gocmVhZGVyKTtcbiAgICByZXR1cm4gcmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gICAgdGhpcy5fcGRmRGF0YVJhbmdlVHJhbnNwb3J0LmFib3J0KCk7XG4gIH1cbn1cbmV4cG9ydHMuUERGRGF0YVRyYW5zcG9ydFN0cmVhbSA9IFBERkRhdGFUcmFuc3BvcnRTdHJlYW07XG5jbGFzcyBQREZEYXRhVHJhbnNwb3J0U3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBxdWV1ZWRDaHVua3MpIHtcbiAgICBsZXQgcHJvZ3Jlc3NpdmVEb25lID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBmYWxzZTtcbiAgICBsZXQgY29udGVudERpc3Bvc2l0aW9uRmlsZW5hbWUgPSBhcmd1bWVudHMubGVuZ3RoID4gMyAmJiBhcmd1bWVudHNbM10gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1szXSA6IG51bGw7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2RvbmUgPSBwcm9ncmVzc2l2ZURvbmUgfHwgZmFsc2U7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSAoMCwgX2Rpc3BsYXlfdXRpbHMuaXNQZGZGaWxlKShjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSkgPyBjb250ZW50RGlzcG9zaXRpb25GaWxlbmFtZSA6IG51bGw7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmtzID0gcXVldWVkQ2h1bmtzIHx8IFtdO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgZm9yIChjb25zdCBjaHVuayBvZiB0aGlzLl9xdWV1ZWRDaHVua3MpIHtcbiAgICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2hlYWRlcnNSZWFkeSA9IFByb21pc2UucmVzb2x2ZSgpO1xuICAgIHN0cmVhbS5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX2VucXVldWUoY2h1bmspIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAodGhpcy5fcmVxdWVzdHMubGVuZ3RoID4gMCkge1xuICAgICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSB0aGlzLl9yZXF1ZXN0cy5zaGlmdCgpO1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9xdWV1ZWRDaHVua3MucHVzaChjaHVuayk7XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSBjaHVuay5ieXRlTGVuZ3RoO1xuICB9XG4gIGdldCBoZWFkZXJzUmVhZHkoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2hlYWRlcnNSZWFkeTtcbiAgfVxuICBnZXQgZmlsZW5hbWUoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2ZpbGVuYW1lO1xuICB9XG4gIGdldCBpc1JhbmdlU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGdldCBjb250ZW50TGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9zdHJlYW0uX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fcXVldWVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcXVldWVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICB9XG4gIHByb2dyZXNzaXZlRG9uZSgpIHtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgfVxufVxuY2xhc3MgUERGRGF0YVRyYW5zcG9ydFN0cmVhbVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBiZWdpbiwgZW5kKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX2JlZ2luID0gYmVnaW47XG4gICAgdGhpcy5fZW5kID0gZW5kO1xuICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICB0aGlzLl9yZXF1ZXN0cyA9IFtdO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICB9XG4gIF9lbnF1ZXVlKGNodW5rKSB7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBjaHVuaztcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgcmVxdWVzdHNDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RzQ2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfSk7XG4gICAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIHRoaXMuX3N0cmVhbS5fcmVtb3ZlUmFuZ2VSZWFkZXIodGhpcyk7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGlmICh0aGlzLl9xdWV1ZWRDaHVuaykge1xuICAgICAgY29uc3QgY2h1bmsgPSB0aGlzLl9xdWV1ZWRDaHVuaztcbiAgICAgIHRoaXMuX3F1ZXVlZENodW5rID0gbnVsbDtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBjaHVuayxcbiAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9kb25lKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX3JlcXVlc3RzLnB1c2gocmVxdWVzdENhcGFiaWxpdHkpO1xuICAgIHJldHVybiByZXF1ZXN0Q2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGNhbmNlbChyZWFzb24pIHtcbiAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fc3RyZWFtLl9yZW1vdmVSYW5nZVJlYWRlcih0aGlzKTtcbiAgfVxufVxuXG4vKioqLyB9KSxcbi8qIDE4MSAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5QREZGZXRjaFN0cmVhbSA9IHZvaWQgMDtcbl9fd19wZGZqc19yZXF1aXJlX18oOTMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDEpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDIpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDcpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMDkpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMTMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMTYpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMjMpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9uZXR3b3JrX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxODIpO1xuO1xuZnVuY3Rpb24gY3JlYXRlRmV0Y2hPcHRpb25zKGhlYWRlcnMsIHdpdGhDcmVkZW50aWFscywgYWJvcnRDb250cm9sbGVyKSB7XG4gIHJldHVybiB7XG4gICAgbWV0aG9kOiBcIkdFVFwiLFxuICAgIGhlYWRlcnMsXG4gICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsLFxuICAgIG1vZGU6IFwiY29yc1wiLFxuICAgIGNyZWRlbnRpYWxzOiB3aXRoQ3JlZGVudGlhbHMgPyBcImluY2x1ZGVcIiA6IFwic2FtZS1vcmlnaW5cIixcbiAgICByZWRpcmVjdDogXCJmb2xsb3dcIlxuICB9O1xufVxuZnVuY3Rpb24gY3JlYXRlSGVhZGVycyhodHRwSGVhZGVycykge1xuICBjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcbiAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBodHRwSGVhZGVycykge1xuICAgIGNvbnN0IHZhbHVlID0gaHR0cEhlYWRlcnNbcHJvcGVydHldO1xuICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaGVhZGVycy5hcHBlbmQocHJvcGVydHksIHZhbHVlKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cbmZ1bmN0aW9uIGdldEFycmF5QnVmZmVyKHZhbCkge1xuICBpZiAodmFsIGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuICAgIHJldHVybiB2YWwuYnVmZmVyO1xuICB9XG4gIGlmICh2YWwgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiB2YWw7XG4gIH1cbiAgKDAsIF91dGlsLndhcm4pKGBnZXRBcnJheUJ1ZmZlciAtIHVuZXhwZWN0ZWQgZGF0YSBmb3JtYXQ6ICR7dmFsfWApO1xuICByZXR1cm4gbmV3IFVpbnQ4QXJyYXkodmFsKS5idWZmZXI7XG59XG5jbGFzcyBQREZGZXRjaFN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMuaXNIdHRwID0gL15odHRwcz86L2kudGVzdChzb3VyY2UudXJsKTtcbiAgICB0aGlzLmh0dHBIZWFkZXJzID0gdGhpcy5pc0h0dHAgJiYgc291cmNlLmh0dHBIZWFkZXJzIHx8IHt9O1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzID0gW107XG4gIH1cbiAgZ2V0IF9wcm9ncmVzc2l2ZURhdGFMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5fbG9hZGVkID8/IDA7XG4gIH1cbiAgZ2V0RnVsbFJlYWRlcigpIHtcbiAgICAoMCwgX3V0aWwuYXNzZXJ0KSghdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIsIFwiUERGRmV0Y2hTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGRmV0Y2hTdHJlYW1SZWFkZXIodGhpcyk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBpZiAoZW5kIDw9IHRoaXMuX3Byb2dyZXNzaXZlRGF0YUxlbmd0aCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IHJlYWRlciA9IG5ldyBQREZGZXRjaFN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIGJlZ2luLCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuUERGRmV0Y2hTdHJlYW0gPSBQREZGZXRjaFN0cmVhbTtcbmNsYXNzIFBERkZldGNoU3RyZWFtUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtKSB7XG4gICAgdGhpcy5fc3RyZWFtID0gc3RyZWFtO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fbG9hZGVkID0gMDtcbiAgICB0aGlzLl9maWxlbmFtZSA9IG51bGw7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl93aXRoQ3JlZGVudGlhbHMgPSBzb3VyY2Uud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gc291cmNlLmRpc2FibGVSYW5nZSB8fCBmYWxzZTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICBpZiAoIXRoaXMuX3JhbmdlQ2h1bmtTaXplICYmICF0aGlzLl9kaXNhYmxlUmFuZ2UpIHtcbiAgICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5faGVhZGVycyA9IGNyZWF0ZUhlYWRlcnModGhpcy5fc3RyZWFtLmh0dHBIZWFkZXJzKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKHRoaXMuX2hlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBpZiAoISgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKShyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgY29uc3QgZ2V0UmVzcG9uc2VIZWFkZXIgPSBuYW1lID0+IHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlLmhlYWRlcnMuZ2V0KG5hbWUpO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYWxsb3dSYW5nZVJlcXVlc3RzLFxuICAgICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICAgIH0gPSAoMCwgX25ldHdvcmtfdXRpbHMudmFsaWRhdGVSYW5nZVJlcXVlc3RDYXBhYmlsaXRpZXMpKHtcbiAgICAgICAgZ2V0UmVzcG9uc2VIZWFkZXIsXG4gICAgICAgIGlzSHR0cDogdGhpcy5fc3RyZWFtLmlzSHR0cCxcbiAgICAgICAgcmFuZ2VDaHVua1NpemU6IHRoaXMuX3JhbmdlQ2h1bmtTaXplLFxuICAgICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgICAgfSk7XG4gICAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gYWxsb3dSYW5nZVJlcXVlc3RzO1xuICAgICAgdGhpcy5fY29udGVudExlbmd0aCA9IHN1Z2dlc3RlZExlbmd0aCB8fCB0aGlzLl9jb250ZW50TGVuZ3RoO1xuICAgICAgdGhpcy5fZmlsZW5hbWUgPSAoMCwgX25ldHdvcmtfdXRpbHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcikoZ2V0UmVzcG9uc2VIZWFkZXIpO1xuICAgICAgaWYgKCF0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCAmJiB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICAgIHRoaXMuY2FuY2VsKG5ldyBfdXRpbC5BYm9ydEV4Y2VwdGlvbihcIlN0cmVhbWluZyBpcyBkaXNhYmxlZC5cIikpO1xuICAgICAgfVxuICAgIH0pLmNhdGNoKHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgY29uc3Qge1xuICAgICAgdmFsdWUsXG4gICAgICBkb25lXG4gICAgfSA9IGF3YWl0IHRoaXMuX3JlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBkb25lXG4gICAgICB9O1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gdmFsdWUuYnl0ZUxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cbmNsYXNzIFBERkZldGNoU3RyZWFtUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9zdHJlYW0gPSBzdHJlYW07XG4gICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB0aGlzLl9sb2FkZWQgPSAwO1xuICAgIGNvbnN0IHNvdXJjZSA9IHN0cmVhbS5zb3VyY2U7XG4gICAgdGhpcy5fd2l0aENyZWRlbnRpYWxzID0gc291cmNlLndpdGhDcmVkZW50aWFscyB8fCBmYWxzZTtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlU3RyZWFtO1xuICAgIHRoaXMuX2Fib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0aGlzLl9oZWFkZXJzID0gY3JlYXRlSGVhZGVycyh0aGlzLl9zdHJlYW0uaHR0cEhlYWRlcnMpO1xuICAgIHRoaXMuX2hlYWRlcnMuYXBwZW5kKFwiUmFuZ2VcIiwgYGJ5dGVzPSR7YmVnaW59LSR7ZW5kIC0gMX1gKTtcbiAgICBjb25zdCB1cmwgPSBzb3VyY2UudXJsO1xuICAgIGZldGNoKHVybCwgY3JlYXRlRmV0Y2hPcHRpb25zKHRoaXMuX2hlYWRlcnMsIHRoaXMuX3dpdGhDcmVkZW50aWFscywgdGhpcy5fYWJvcnRDb250cm9sbGVyKSkudGhlbihyZXNwb25zZSA9PiB7XG4gICAgICBpZiAoISgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzKShyZXNwb25zZS5zdGF0dXMpKSB7XG4gICAgICAgIHRocm93ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShyZXNwb25zZS5zdGF0dXMsIHVybCk7XG4gICAgICB9XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgICB0aGlzLl9yZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICAgIH0pLmNhdGNoKHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlamVjdCk7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGRvbmVcbiAgICB9ID0gYXdhaXQgdGhpcy5fcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAoZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIGRvbmVcbiAgICAgIH07XG4gICAgfVxuICAgIHRoaXMuX2xvYWRlZCArPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHZhbHVlOiBnZXRBcnJheUJ1ZmZlcih2YWx1ZSksXG4gICAgICBkb25lOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX3JlYWRlcj8uY2FuY2VsKHJlYXNvbik7XG4gICAgdGhpcy5fYWJvcnRDb250cm9sbGVyLmFib3J0KCk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxODIgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvciA9IGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3I7XG5leHBvcnRzLmV4dHJhY3RGaWxlbmFtZUZyb21IZWFkZXIgPSBleHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyO1xuZXhwb3J0cy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyA9IHZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzO1xuZXhwb3J0cy52YWxpZGF0ZVJlc3BvbnNlU3RhdHVzID0gdmFsaWRhdGVSZXNwb25zZVN0YXR1cztcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2NvbnRlbnRfZGlzcG9zaXRpb24gPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4Myk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2OCk7XG5mdW5jdGlvbiB2YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcyhfcmVmKSB7XG4gIGxldCB7XG4gICAgZ2V0UmVzcG9uc2VIZWFkZXIsXG4gICAgaXNIdHRwLFxuICAgIHJhbmdlQ2h1bmtTaXplLFxuICAgIGRpc2FibGVSYW5nZVxuICB9ID0gX3JlZjtcbiAgY29uc3QgcmV0dXJuVmFsdWVzID0ge1xuICAgIGFsbG93UmFuZ2VSZXF1ZXN0czogZmFsc2UsXG4gICAgc3VnZ2VzdGVkTGVuZ3RoOiB1bmRlZmluZWRcbiAgfTtcbiAgY29uc3QgbGVuZ3RoID0gcGFyc2VJbnQoZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LUxlbmd0aFwiKSwgMTApO1xuICBpZiAoIU51bWJlci5pc0ludGVnZXIobGVuZ3RoKSkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgcmV0dXJuVmFsdWVzLnN1Z2dlc3RlZExlbmd0aCA9IGxlbmd0aDtcbiAgaWYgKGxlbmd0aCA8PSAyICogcmFuZ2VDaHVua1NpemUpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIGlmIChkaXNhYmxlUmFuZ2UgfHwgIWlzSHR0cCkge1xuICAgIHJldHVybiByZXR1cm5WYWx1ZXM7XG4gIH1cbiAgaWYgKGdldFJlc3BvbnNlSGVhZGVyKFwiQWNjZXB0LVJhbmdlc1wiKSAhPT0gXCJieXRlc1wiKSB7XG4gICAgcmV0dXJuIHJldHVyblZhbHVlcztcbiAgfVxuICBjb25zdCBjb250ZW50RW5jb2RpbmcgPSBnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRW5jb2RpbmdcIikgfHwgXCJpZGVudGl0eVwiO1xuICBpZiAoY29udGVudEVuY29kaW5nICE9PSBcImlkZW50aXR5XCIpIHtcbiAgICByZXR1cm4gcmV0dXJuVmFsdWVzO1xuICB9XG4gIHJldHVyblZhbHVlcy5hbGxvd1JhbmdlUmVxdWVzdHMgPSB0cnVlO1xuICByZXR1cm4gcmV0dXJuVmFsdWVzO1xufVxuZnVuY3Rpb24gZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcihnZXRSZXNwb25zZUhlYWRlcikge1xuICBjb25zdCBjb250ZW50RGlzcG9zaXRpb24gPSBnZXRSZXNwb25zZUhlYWRlcihcIkNvbnRlbnQtRGlzcG9zaXRpb25cIik7XG4gIGlmIChjb250ZW50RGlzcG9zaXRpb24pIHtcbiAgICBsZXQgZmlsZW5hbWUgPSAoMCwgX2NvbnRlbnRfZGlzcG9zaXRpb24uZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKShjb250ZW50RGlzcG9zaXRpb24pO1xuICAgIGlmIChmaWxlbmFtZS5pbmNsdWRlcyhcIiVcIikpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGZpbGVuYW1lID0gZGVjb2RlVVJJQ29tcG9uZW50KGZpbGVuYW1lKTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgaWYgKCgwLCBfZGlzcGxheV91dGlscy5pc1BkZkZpbGUpKGZpbGVuYW1lKSkge1xuICAgICAgcmV0dXJuIGZpbGVuYW1lO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbnVsbDtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJlc3BvbnNlU3RhdHVzRXJyb3Ioc3RhdHVzLCB1cmwpIHtcbiAgaWYgKHN0YXR1cyA9PT0gNDA0IHx8IHN0YXR1cyA9PT0gMCAmJiB1cmwuc3RhcnRzV2l0aChcImZpbGU6XCIpKSB7XG4gICAgcmV0dXJuIG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKCdNaXNzaW5nIFBERiBcIicgKyB1cmwgKyAnXCIuJyk7XG4gIH1cbiAgcmV0dXJuIG5ldyBfdXRpbC5VbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb24oYFVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlICgke3N0YXR1c30pIHdoaWxlIHJldHJpZXZpbmcgUERGIFwiJHt1cmx9XCIuYCwgc3RhdHVzKTtcbn1cbmZ1bmN0aW9uIHZhbGlkYXRlUmVzcG9uc2VTdGF0dXMoc3RhdHVzKSB7XG4gIHJldHVybiBzdGF0dXMgPT09IDIwMCB8fCBzdGF0dXMgPT09IDIwNjtcbn1cblxuLyoqKi8gfSksXG4vKiAxODMgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyID0gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDE0OSk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuZnVuY3Rpb24gZ2V0RmlsZW5hbWVGcm9tQ29udGVudERpc3Bvc2l0aW9uSGVhZGVyKGNvbnRlbnREaXNwb3NpdGlvbikge1xuICBsZXQgbmVlZHNFbmNvZGluZ0ZpeHVwID0gdHJ1ZTtcbiAgbGV0IHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVxcXFwqXCIsIFwiaVwiKS5leGVjKGNvbnRlbnREaXNwb3NpdGlvbik7XG4gIGlmICh0bXApIHtcbiAgICB0bXAgPSB0bXBbMV07XG4gICAgbGV0IGZpbGVuYW1lID0gcmZjMjYxNnVucXVvdGUodG1wKTtcbiAgICBmaWxlbmFtZSA9IHVuZXNjYXBlKGZpbGVuYW1lKTtcbiAgICBmaWxlbmFtZSA9IHJmYzU5ODdkZWNvZGUoZmlsZW5hbWUpO1xuICAgIGZpbGVuYW1lID0gcmZjMjA0N2RlY29kZShmaWxlbmFtZSk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgY29uc3QgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKHRtcCk7XG4gICAgcmV0dXJuIGZpeHVwRW5jb2RpbmcoZmlsZW5hbWUpO1xuICB9XG4gIHRtcCA9IHRvUGFyYW1SZWdFeHAoXCJmaWxlbmFtZVwiLCBcImlcIikuZXhlYyhjb250ZW50RGlzcG9zaXRpb24pO1xuICBpZiAodG1wKSB7XG4gICAgdG1wID0gdG1wWzFdO1xuICAgIGxldCBmaWxlbmFtZSA9IHJmYzI2MTZ1bnF1b3RlKHRtcCk7XG4gICAgZmlsZW5hbWUgPSByZmMyMDQ3ZGVjb2RlKGZpbGVuYW1lKTtcbiAgICByZXR1cm4gZml4dXBFbmNvZGluZyhmaWxlbmFtZSk7XG4gIH1cbiAgZnVuY3Rpb24gdG9QYXJhbVJlZ0V4cChhdHRyaWJ1dGVQYXR0ZXJuLCBmbGFncykge1xuICAgIHJldHVybiBuZXcgUmVnRXhwKFwiKD86Xnw7KVxcXFxzKlwiICsgYXR0cmlidXRlUGF0dGVybiArIFwiXFxcXHMqPVxcXFxzKlwiICsgXCIoXCIgKyAnW15cIjtcXFxcc11bXjtcXFxcc10qJyArIFwifFwiICsgJ1wiKD86W15cIlxcXFxcXFxcXXxcXFxcXFxcXFwiPykrXCI/JyArIFwiKVwiLCBmbGFncyk7XG4gIH1cbiAgZnVuY3Rpb24gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpIHtcbiAgICBpZiAoZW5jb2RpbmcpIHtcbiAgICAgIGlmICghL15bXFx4MDAtXFx4RkZdKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoZW5jb2RpbmcsIHtcbiAgICAgICAgICBmYXRhbDogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYnVmZmVyID0gKDAsIF91dGlsLnN0cmluZ1RvQnl0ZXMpKHZhbHVlKTtcbiAgICAgICAgdmFsdWUgPSBkZWNvZGVyLmRlY29kZShidWZmZXIpO1xuICAgICAgICBuZWVkc0VuY29kaW5nRml4dXAgPSBmYWxzZTtcbiAgICAgIH0gY2F0Y2gge31cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIGZpeHVwRW5jb2RpbmcodmFsdWUpIHtcbiAgICBpZiAobmVlZHNFbmNvZGluZ0ZpeHVwICYmIC9bXFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgdmFsdWUgPSB0ZXh0ZGVjb2RlKFwidXRmLThcIiwgdmFsdWUpO1xuICAgICAgaWYgKG5lZWRzRW5jb2RpbmdGaXh1cCkge1xuICAgICAgICB2YWx1ZSA9IHRleHRkZWNvZGUoXCJpc28tODg1OS0xXCIsIHZhbHVlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZhbHVlO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIyMzFnZXRwYXJhbShjb250ZW50RGlzcG9zaXRpb25TdHIpIHtcbiAgICBjb25zdCBtYXRjaGVzID0gW107XG4gICAgbGV0IG1hdGNoO1xuICAgIGNvbnN0IGl0ZXIgPSB0b1BhcmFtUmVnRXhwKFwiZmlsZW5hbWVcXFxcKigoPyEwXFxcXGQpXFxcXGQrKShcXFxcKj8pXCIsIFwiaWdcIik7XG4gICAgd2hpbGUgKChtYXRjaCA9IGl0ZXIuZXhlYyhjb250ZW50RGlzcG9zaXRpb25TdHIpKSAhPT0gbnVsbCkge1xuICAgICAgbGV0IFssIG4sIHF1b3QsIHBhcnRdID0gbWF0Y2g7XG4gICAgICBuID0gcGFyc2VJbnQobiwgMTApO1xuICAgICAgaWYgKG4gaW4gbWF0Y2hlcykge1xuICAgICAgICBpZiAobiA9PT0gMCkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbWF0Y2hlc1tuXSA9IFtxdW90LCBwYXJ0XTtcbiAgICB9XG4gICAgY29uc3QgcGFydHMgPSBbXTtcbiAgICBmb3IgKGxldCBuID0gMDsgbiA8IG1hdGNoZXMubGVuZ3RoOyArK24pIHtcbiAgICAgIGlmICghKG4gaW4gbWF0Y2hlcykpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBsZXQgW3F1b3QsIHBhcnRdID0gbWF0Y2hlc1tuXTtcbiAgICAgIHBhcnQgPSByZmMyNjE2dW5xdW90ZShwYXJ0KTtcbiAgICAgIGlmIChxdW90KSB7XG4gICAgICAgIHBhcnQgPSB1bmVzY2FwZShwYXJ0KTtcbiAgICAgICAgaWYgKG4gPT09IDApIHtcbiAgICAgICAgICBwYXJ0ID0gcmZjNTk4N2RlY29kZShwYXJ0KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgcGFydHMucHVzaChwYXJ0KTtcbiAgICB9XG4gICAgcmV0dXJuIHBhcnRzLmpvaW4oXCJcIik7XG4gIH1cbiAgZnVuY3Rpb24gcmZjMjYxNnVucXVvdGUodmFsdWUpIHtcbiAgICBpZiAodmFsdWUuc3RhcnRzV2l0aCgnXCInKSkge1xuICAgICAgY29uc3QgcGFydHMgPSB2YWx1ZS5zbGljZSgxKS5zcGxpdCgnXFxcXFwiJyk7XG4gICAgICBmb3IgKGxldCBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHF1b3RpbmRleCA9IHBhcnRzW2ldLmluZGV4T2YoJ1wiJyk7XG4gICAgICAgIGlmIChxdW90aW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgcGFydHNbaV0gPSBwYXJ0c1tpXS5zbGljZSgwLCBxdW90aW5kZXgpO1xuICAgICAgICAgIHBhcnRzLmxlbmd0aCA9IGkgKyAxO1xuICAgICAgICB9XG4gICAgICAgIHBhcnRzW2ldID0gcGFydHNbaV0ucmVwbGFjZUFsbCgvXFxcXCguKS9nLCBcIiQxXCIpO1xuICAgICAgfVxuICAgICAgdmFsdWUgPSBwYXJ0cy5qb2luKCdcIicpO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgZnVuY3Rpb24gcmZjNTk4N2RlY29kZShleHR2YWx1ZSkge1xuICAgIGNvbnN0IGVuY29kaW5nZW5kID0gZXh0dmFsdWUuaW5kZXhPZihcIidcIik7XG4gICAgaWYgKGVuY29kaW5nZW5kID09PSAtMSkge1xuICAgICAgcmV0dXJuIGV4dHZhbHVlO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZyA9IGV4dHZhbHVlLnNsaWNlKDAsIGVuY29kaW5nZW5kKTtcbiAgICBjb25zdCBsYW5ndmFsdWUgPSBleHR2YWx1ZS5zbGljZShlbmNvZGluZ2VuZCArIDEpO1xuICAgIGNvbnN0IHZhbHVlID0gbGFuZ3ZhbHVlLnJlcGxhY2UoL15bXiddKicvLCBcIlwiKTtcbiAgICByZXR1cm4gdGV4dGRlY29kZShlbmNvZGluZywgdmFsdWUpO1xuICB9XG4gIGZ1bmN0aW9uIHJmYzIwNDdkZWNvZGUodmFsdWUpIHtcbiAgICBpZiAoIXZhbHVlLnN0YXJ0c1dpdGgoXCI9P1wiKSB8fCAvW1xceDAwLVxceDE5XFx4ODAtXFx4ZmZdLy50ZXN0KHZhbHVlKSkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsdWUucmVwbGFjZUFsbCgvPVxcPyhbXFx3LV0qKVxcPyhbUXFCYl0pXFw/KCg/OlteP118XFw/KD8hPSkpKilcXD89L2csIGZ1bmN0aW9uIChtYXRjaGVzLCBjaGFyc2V0LCBlbmNvZGluZywgdGV4dCkge1xuICAgICAgaWYgKGVuY29kaW5nID09PSBcInFcIiB8fCBlbmNvZGluZyA9PT0gXCJRXCIpIHtcbiAgICAgICAgdGV4dCA9IHRleHQucmVwbGFjZUFsbChcIl9cIiwgXCIgXCIpO1xuICAgICAgICB0ZXh0ID0gdGV4dC5yZXBsYWNlQWxsKC89KFswLTlhLWZBLUZdezJ9KS9nLCBmdW5jdGlvbiAobWF0Y2gsIGhleCkge1xuICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KGhleCwgMTYpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB0ZXh0ZGVjb2RlKGNoYXJzZXQsIHRleHQpO1xuICAgICAgfVxuICAgICAgdHJ5IHtcbiAgICAgICAgdGV4dCA9IGF0b2IodGV4dCk7XG4gICAgICB9IGNhdGNoIHt9XG4gICAgICByZXR1cm4gdGV4dGRlY29kZShjaGFyc2V0LCB0ZXh0KTtcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gXCJcIjtcbn1cblxuLyoqKi8gfSksXG4vKiAxODQgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUERGTmV0d29ya1N0cmVhbSA9IHZvaWQgMDtcbl9fd19wZGZqc19yZXF1aXJlX18oODkpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfbmV0d29ya191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTgyKTtcbjtcbmNvbnN0IE9LX1JFU1BPTlNFID0gMjAwO1xuY29uc3QgUEFSVElBTF9DT05URU5UX1JFU1BPTlNFID0gMjA2O1xuZnVuY3Rpb24gZ2V0QXJyYXlCdWZmZXIoeGhyKSB7XG4gIGNvbnN0IGRhdGEgPSB4aHIucmVzcG9uc2U7XG4gIGlmICh0eXBlb2YgZGF0YSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBkYXRhO1xuICB9XG4gIHJldHVybiAoMCwgX3V0aWwuc3RyaW5nVG9CeXRlcykoZGF0YSkuYnVmZmVyO1xufVxuY2xhc3MgTmV0d29ya01hbmFnZXIge1xuICBjb25zdHJ1Y3Rvcih1cmwpIHtcbiAgICBsZXQgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDoge307XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5pc0h0dHAgPSAvXmh0dHBzPzovaS50ZXN0KHVybCk7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIGFyZ3MuaHR0cEhlYWRlcnMgfHwgT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLndpdGhDcmVkZW50aWFscyA9IGFyZ3Mud2l0aENyZWRlbnRpYWxzIHx8IGZhbHNlO1xuICAgIHRoaXMuY3VyclhocklkID0gMDtcbiAgICB0aGlzLnBlbmRpbmdSZXF1ZXN0cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH1cbiAgcmVxdWVzdFJhbmdlKGJlZ2luLCBlbmQsIGxpc3RlbmVycykge1xuICAgIGNvbnN0IGFyZ3MgPSB7XG4gICAgICBiZWdpbixcbiAgICAgIGVuZFxuICAgIH07XG4gICAgZm9yIChjb25zdCBwcm9wIGluIGxpc3RlbmVycykge1xuICAgICAgYXJnc1twcm9wXSA9IGxpc3RlbmVyc1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdChhcmdzKTtcbiAgfVxuICByZXF1ZXN0RnVsbChsaXN0ZW5lcnMpIHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KGxpc3RlbmVycyk7XG4gIH1cbiAgcmVxdWVzdChhcmdzKSB7XG4gICAgY29uc3QgeGhyID0gbmV3IFhNTEh0dHBSZXF1ZXN0KCk7XG4gICAgY29uc3QgeGhySWQgPSB0aGlzLmN1cnJYaHJJZCsrO1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdID0ge1xuICAgICAgeGhyXG4gICAgfTtcbiAgICB4aHIub3BlbihcIkdFVFwiLCB0aGlzLnVybCk7XG4gICAgeGhyLndpdGhDcmVkZW50aWFscyA9IHRoaXMud2l0aENyZWRlbnRpYWxzO1xuICAgIGZvciAoY29uc3QgcHJvcGVydHkgaW4gdGhpcy5odHRwSGVhZGVycykge1xuICAgICAgY29uc3QgdmFsdWUgPSB0aGlzLmh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIocHJvcGVydHksIHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuaXNIdHRwICYmIFwiYmVnaW5cIiBpbiBhcmdzICYmIFwiZW5kXCIgaW4gYXJncykge1xuICAgICAgeGhyLnNldFJlcXVlc3RIZWFkZXIoXCJSYW5nZVwiLCBgYnl0ZXM9JHthcmdzLmJlZ2lufS0ke2FyZ3MuZW5kIC0gMX1gKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID0gUEFSVElBTF9DT05URU5UX1JFU1BPTlNFO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5leHBlY3RlZFN0YXR1cyA9IE9LX1JFU1BPTlNFO1xuICAgIH1cbiAgICB4aHIucmVzcG9uc2VUeXBlID0gXCJhcnJheWJ1ZmZlclwiO1xuICAgIGlmIChhcmdzLm9uRXJyb3IpIHtcbiAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGV2dCkge1xuICAgICAgICBhcmdzLm9uRXJyb3IoeGhyLnN0YXR1cyk7XG4gICAgICB9O1xuICAgIH1cbiAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gdGhpcy5vblN0YXRlQ2hhbmdlLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHhoci5vbnByb2dyZXNzID0gdGhpcy5vblByb2dyZXNzLmJpbmQodGhpcywgeGhySWQpO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkID0gYXJncy5vbkhlYWRlcnNSZWNlaXZlZDtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUgPSBhcmdzLm9uRG9uZTtcbiAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yID0gYXJncy5vbkVycm9yO1xuICAgIHBlbmRpbmdSZXF1ZXN0Lm9uUHJvZ3Jlc3MgPSBhcmdzLm9uUHJvZ3Jlc3M7XG4gICAgeGhyLnNlbmQobnVsbCk7XG4gICAgcmV0dXJuIHhocklkO1xuICB9XG4gIG9uUHJvZ3Jlc3MoeGhySWQsIGV2dCkge1xuICAgIGNvbnN0IHBlbmRpbmdSZXF1ZXN0ID0gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdO1xuICAgIGlmICghcGVuZGluZ1JlcXVlc3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgcGVuZGluZ1JlcXVlc3Qub25Qcm9ncmVzcz8uKGV2dCk7XG4gIH1cbiAgb25TdGF0ZUNoYW5nZSh4aHJJZCwgZXZ0KSB7XG4gICAgY29uc3QgcGVuZGluZ1JlcXVlc3QgPSB0aGlzLnBlbmRpbmdSZXF1ZXN0c1t4aHJJZF07XG4gICAgaWYgKCFwZW5kaW5nUmVxdWVzdCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHIgPSBwZW5kaW5nUmVxdWVzdC54aHI7XG4gICAgaWYgKHhoci5yZWFkeVN0YXRlID49IDIgJiYgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uSGVhZGVyc1JlY2VpdmVkKCk7XG4gICAgICBkZWxldGUgcGVuZGluZ1JlcXVlc3Qub25IZWFkZXJzUmVjZWl2ZWQ7XG4gICAgfVxuICAgIGlmICh4aHIucmVhZHlTdGF0ZSAhPT0gNCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoISh4aHJJZCBpbiB0aGlzLnBlbmRpbmdSZXF1ZXN0cykpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICBpZiAoeGhyLnN0YXR1cyA9PT0gMCAmJiB0aGlzLmlzSHR0cCkge1xuICAgICAgcGVuZGluZ1JlcXVlc3Qub25FcnJvcj8uKHhoci5zdGF0dXMpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCB4aHJTdGF0dXMgPSB4aHIuc3RhdHVzIHx8IE9LX1JFU1BPTlNFO1xuICAgIGNvbnN0IG9rX3Jlc3BvbnNlX29uX3JhbmdlX3JlcXVlc3QgPSB4aHJTdGF0dXMgPT09IE9LX1JFU1BPTlNFICYmIHBlbmRpbmdSZXF1ZXN0LmV4cGVjdGVkU3RhdHVzID09PSBQQVJUSUFMX0NPTlRFTlRfUkVTUE9OU0U7XG4gICAgaWYgKCFva19yZXNwb25zZV9vbl9yYW5nZV9yZXF1ZXN0ICYmIHhoclN0YXR1cyAhPT0gcGVuZGluZ1JlcXVlc3QuZXhwZWN0ZWRTdGF0dXMpIHtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRXJyb3I/Lih4aHIuc3RhdHVzKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSBnZXRBcnJheUJ1ZmZlcih4aHIpO1xuICAgIGlmICh4aHJTdGF0dXMgPT09IFBBUlRJQUxfQ09OVEVOVF9SRVNQT05TRSkge1xuICAgICAgY29uc3QgcmFuZ2VIZWFkZXIgPSB4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoXCJDb250ZW50LVJhbmdlXCIpO1xuICAgICAgY29uc3QgbWF0Y2hlcyA9IC9ieXRlcyAoXFxkKyktKFxcZCspXFwvKFxcZCspLy5leGVjKHJhbmdlSGVhZGVyKTtcbiAgICAgIHBlbmRpbmdSZXF1ZXN0Lm9uRG9uZSh7XG4gICAgICAgIGJlZ2luOiBwYXJzZUludChtYXRjaGVzWzFdLCAxMCksXG4gICAgICAgIGNodW5rXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKGNodW5rKSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkRvbmUoe1xuICAgICAgICBiZWdpbjogMCxcbiAgICAgICAgY2h1bmtcbiAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBwZW5kaW5nUmVxdWVzdC5vbkVycm9yPy4oeGhyLnN0YXR1cyk7XG4gICAgfVxuICB9XG4gIGdldFJlcXVlc3RYaHIoeGhySWQpIHtcbiAgICByZXR1cm4gdGhpcy5wZW5kaW5nUmVxdWVzdHNbeGhySWRdLnhocjtcbiAgfVxuICBpc1BlbmRpbmdSZXF1ZXN0KHhocklkKSB7XG4gICAgcmV0dXJuIHhocklkIGluIHRoaXMucGVuZGluZ1JlcXVlc3RzO1xuICB9XG4gIGFib3J0UmVxdWVzdCh4aHJJZCkge1xuICAgIGNvbnN0IHhociA9IHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXS54aHI7XG4gICAgZGVsZXRlIHRoaXMucGVuZGluZ1JlcXVlc3RzW3hocklkXTtcbiAgICB4aHIuYWJvcnQoKTtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuX3NvdXJjZSA9IHNvdXJjZTtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbmV3IE5ldHdvcmtNYW5hZ2VyKHNvdXJjZS51cmwsIHtcbiAgICAgIGh0dHBIZWFkZXJzOiBzb3VyY2UuaHR0cEhlYWRlcnMsXG4gICAgICB3aXRoQ3JlZGVudGlhbHM6IHNvdXJjZS53aXRoQ3JlZGVudGlhbHNcbiAgICB9KTtcbiAgICB0aGlzLl9yYW5nZUNodW5rU2l6ZSA9IHNvdXJjZS5yYW5nZUNodW5rU2l6ZTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIF9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZChyZWFkZXIpIHtcbiAgICBjb25zdCBpID0gdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5pbmRleE9mKHJlYWRlcik7XG4gICAgaWYgKGkgPj0gMCkge1xuICAgICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycy5zcGxpY2UoaSwgMSk7XG4gICAgfVxuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5ldHdvcmtTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbUZ1bGxSZXF1ZXN0UmVhZGVyKHRoaXMuX21hbmFnZXIsIHRoaXMuX3NvdXJjZSk7XG4gICAgcmV0dXJuIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyO1xuICB9XG4gIGdldFJhbmdlUmVhZGVyKGJlZ2luLCBlbmQpIHtcbiAgICBjb25zdCByZWFkZXIgPSBuZXcgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlcih0aGlzLl9tYW5hZ2VyLCBiZWdpbiwgZW5kKTtcbiAgICByZWFkZXIub25DbG9zZWQgPSB0aGlzLl9vblJhbmdlUmVxdWVzdFJlYWRlckNsb3NlZC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyZWFkZXIpO1xuICAgIHJldHVybiByZWFkZXI7XG4gIH1cbiAgY2FuY2VsQWxsUmVxdWVzdHMocmVhc29uKSB7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI/LmNhbmNlbChyZWFzb24pO1xuICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMuc2xpY2UoMCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwocmVhc29uKTtcbiAgICB9XG4gIH1cbn1cbmV4cG9ydHMuUERGTmV0d29ya1N0cmVhbSA9IFBERk5ldHdvcmtTdHJlYW07XG5jbGFzcyBQREZOZXR3b3JrU3RyZWFtRnVsbFJlcXVlc3RSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihtYW5hZ2VyLCBzb3VyY2UpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgb25IZWFkZXJzUmVjZWl2ZWQ6IHRoaXMuX29uSGVhZGVyc1JlY2VpdmVkLmJpbmQodGhpcyksXG4gICAgICBvbkRvbmU6IHRoaXMuX29uRG9uZS5iaW5kKHRoaXMpLFxuICAgICAgb25FcnJvcjogdGhpcy5fb25FcnJvci5iaW5kKHRoaXMpLFxuICAgICAgb25Qcm9ncmVzczogdGhpcy5fb25Qcm9ncmVzcy5iaW5kKHRoaXMpXG4gICAgfTtcbiAgICB0aGlzLl91cmwgPSBzb3VyY2UudXJsO1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0SWQgPSBtYW5hZ2VyLnJlcXVlc3RGdWxsKGFyZ3MpO1xuICAgIHRoaXMuX2hlYWRlcnNSZWNlaXZlZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSBzb3VyY2UuZGlzYWJsZVJhbmdlIHx8IGZhbHNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX3JhbmdlQ2h1bmtTaXplID0gc291cmNlLnJhbmdlQ2h1bmtTaXplO1xuICAgIGlmICghdGhpcy5fcmFuZ2VDaHVua1NpemUgJiYgIXRoaXMuX2Rpc2FibGVSYW5nZSkge1xuICAgICAgdGhpcy5fZGlzYWJsZVJhbmdlID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzID0gW107XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9kb25lID0gZmFsc2U7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSB1bmRlZmluZWQ7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gIH1cbiAgX29uSGVhZGVyc1JlY2VpdmVkKCkge1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhySWQgPSB0aGlzLl9mdWxsUmVxdWVzdElkO1xuICAgIGNvbnN0IGZ1bGxSZXF1ZXN0WGhyID0gdGhpcy5fbWFuYWdlci5nZXRSZXF1ZXN0WGhyKGZ1bGxSZXF1ZXN0WGhySWQpO1xuICAgIGNvbnN0IGdldFJlc3BvbnNlSGVhZGVyID0gbmFtZSA9PiB7XG4gICAgICByZXR1cm4gZnVsbFJlcXVlc3RYaHIuZ2V0UmVzcG9uc2VIZWFkZXIobmFtZSk7XG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICBzdWdnZXN0ZWRMZW5ndGhcbiAgICB9ID0gKDAsIF9uZXR3b3JrX3V0aWxzLnZhbGlkYXRlUmFuZ2VSZXF1ZXN0Q2FwYWJpbGl0aWVzKSh7XG4gICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgIGlzSHR0cDogdGhpcy5fbWFuYWdlci5pc0h0dHAsXG4gICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICBkaXNhYmxlUmFuZ2U6IHRoaXMuX2Rpc2FibGVSYW5nZVxuICAgIH0pO1xuICAgIGlmIChhbGxvd1JhbmdlUmVxdWVzdHMpIHtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSAoMCwgX25ldHdvcmtfdXRpbHMuZXh0cmFjdEZpbGVuYW1lRnJvbUhlYWRlcikoZ2V0UmVzcG9uc2VIZWFkZXIpO1xuICAgIGlmICh0aGlzLl9pc1JhbmdlU3VwcG9ydGVkKSB7XG4gICAgICB0aGlzLl9tYW5hZ2VyLmFib3J0UmVxdWVzdChmdWxsUmVxdWVzdFhocklkKTtcbiAgICB9XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX29uRG9uZShkYXRhKSB7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIGlmICh0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGRhdGEuY2h1bmssXG4gICAgICAgICAgZG9uZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLl9jYWNoZWRDaHVua3MucHVzaChkYXRhLmNodW5rKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgaWYgKHRoaXMuX2NhY2hlZENodW5rcy5sZW5ndGggPiAwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgfVxuICBfb25FcnJvcihzdGF0dXMpIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9ICgwLCBfbmV0d29ya191dGlscy5jcmVhdGVSZXNwb25zZVN0YXR1c0Vycm9yKShzdGF0dXMsIHRoaXMuX3VybCk7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZWplY3QodGhpcy5fc3RvcmVkRXJyb3IpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA9IDA7XG4gIH1cbiAgX29uUHJvZ3Jlc3MoZXZ0KSB7XG4gICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgbG9hZGVkOiBldnQubG9hZGVkLFxuICAgICAgdG90YWw6IGV2dC5sZW5ndGhDb21wdXRhYmxlID8gZXZ0LnRvdGFsIDogdGhpcy5fY29udGVudExlbmd0aFxuICAgIH0pO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBnZXQgY29udGVudExlbmd0aCgpIHtcbiAgICByZXR1cm4gdGhpcy5fY29udGVudExlbmd0aDtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzUmVjZWl2ZWRDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgYXN5bmMgcmVhZCgpIHtcbiAgICBpZiAodGhpcy5fc3RvcmVkRXJyb3IpIHtcbiAgICAgIHRocm93IHRoaXMuX3N0b3JlZEVycm9yO1xuICAgIH1cbiAgICBpZiAodGhpcy5fY2FjaGVkQ2h1bmtzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IGNodW5rID0gdGhpcy5fY2FjaGVkQ2h1bmtzLnNoaWZ0KCk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICB0aGlzLl9yZXF1ZXN0cy5wdXNoKHJlcXVlc3RDYXBhYmlsaXR5KTtcbiAgICByZXR1cm4gcmVxdWVzdENhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgdGhpcy5faGVhZGVyc1JlY2VpdmVkQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5IG9mIHRoaXMuX3JlcXVlc3RzKSB7XG4gICAgICByZXF1ZXN0Q2FwYWJpbGl0eS5yZXNvbHZlKHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgaWYgKHRoaXMuX21hbmFnZXIuaXNQZW5kaW5nUmVxdWVzdCh0aGlzLl9mdWxsUmVxdWVzdElkKSkge1xuICAgICAgdGhpcy5fbWFuYWdlci5hYm9ydFJlcXVlc3QodGhpcy5fZnVsbFJlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyID0gbnVsbDtcbiAgfVxufVxuY2xhc3MgUERGTmV0d29ya1N0cmVhbVJhbmdlUmVxdWVzdFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKG1hbmFnZXIsIGJlZ2luLCBlbmQpIHtcbiAgICB0aGlzLl9tYW5hZ2VyID0gbWFuYWdlcjtcbiAgICBjb25zdCBhcmdzID0ge1xuICAgICAgb25Eb25lOiB0aGlzLl9vbkRvbmUuYmluZCh0aGlzKSxcbiAgICAgIG9uRXJyb3I6IHRoaXMuX29uRXJyb3IuYmluZCh0aGlzKSxcbiAgICAgIG9uUHJvZ3Jlc3M6IHRoaXMuX29uUHJvZ3Jlc3MuYmluZCh0aGlzKVxuICAgIH07XG4gICAgdGhpcy5fdXJsID0gbWFuYWdlci51cmw7XG4gICAgdGhpcy5fcmVxdWVzdElkID0gbWFuYWdlci5yZXF1ZXN0UmFuZ2UoYmVnaW4sIGVuZCwgYXJncyk7XG4gICAgdGhpcy5fcmVxdWVzdHMgPSBbXTtcbiAgICB0aGlzLl9xdWV1ZWRDaHVuayA9IG51bGw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gdW5kZWZpbmVkO1xuICAgIHRoaXMub25Qcm9ncmVzcyA9IG51bGw7XG4gICAgdGhpcy5vbkNsb3NlZCA9IG51bGw7XG4gIH1cbiAgX2Nsb3NlKCkge1xuICAgIHRoaXMub25DbG9zZWQ/Lih0aGlzKTtcbiAgfVxuICBfb25Eb25lKGRhdGEpIHtcbiAgICBjb25zdCBjaHVuayA9IGRhdGEuY2h1bms7XG4gICAgaWYgKHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gdGhpcy5fcmVxdWVzdHMuc2hpZnQoKTtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogY2h1bmssXG4gICAgICAgIGRvbmU6IGZhbHNlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBjaHVuaztcbiAgICB9XG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XG4gICAgZm9yIChjb25zdCByZXF1ZXN0Q2FwYWJpbGl0eSBvZiB0aGlzLl9yZXF1ZXN0cykge1xuICAgICAgcmVxdWVzdENhcGFiaWxpdHkucmVzb2x2ZSh7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0cy5sZW5ndGggPSAwO1xuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cbiAgX29uRXJyb3Ioc3RhdHVzKSB7XG4gICAgdGhpcy5fc3RvcmVkRXJyb3IgPSAoMCwgX25ldHdvcmtfdXRpbHMuY3JlYXRlUmVzcG9uc2VTdGF0dXNFcnJvcikoc3RhdHVzLCB0aGlzLl91cmwpO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlamVjdCh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3RzLmxlbmd0aCA9IDA7XG4gICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICB9XG4gIF9vblByb2dyZXNzKGV2dCkge1xuICAgIGlmICghdGhpcy5pc1N0cmVhbWluZ1N1cHBvcnRlZCkge1xuICAgICAgdGhpcy5vblByb2dyZXNzPy4oe1xuICAgICAgICBsb2FkZWQ6IGV2dC5sb2FkZWRcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3F1ZXVlZENodW5rICE9PSBudWxsKSB7XG4gICAgICBjb25zdCBjaHVuayA9IHRoaXMuX3F1ZXVlZENodW5rO1xuICAgICAgdGhpcy5fcXVldWVkQ2h1bmsgPSBudWxsO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IGNodW5rLFxuICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IHJlcXVlc3RDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5fcmVxdWVzdHMucHVzaChyZXF1ZXN0Q2FwYWJpbGl0eSk7XG4gICAgcmV0dXJuIHJlcXVlc3RDYXBhYmlsaXR5LnByb21pc2U7XG4gIH1cbiAgY2FuY2VsKHJlYXNvbikge1xuICAgIHRoaXMuX2RvbmUgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgcmVxdWVzdENhcGFiaWxpdHkgb2YgdGhpcy5fcmVxdWVzdHMpIHtcbiAgICAgIHJlcXVlc3RDYXBhYmlsaXR5LnJlc29sdmUoe1xuICAgICAgICB2YWx1ZTogdW5kZWZpbmVkLFxuICAgICAgICBkb25lOiB0cnVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5fcmVxdWVzdHMubGVuZ3RoID0gMDtcbiAgICBpZiAodGhpcy5fbWFuYWdlci5pc1BlbmRpbmdSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCkpIHtcbiAgICAgIHRoaXMuX21hbmFnZXIuYWJvcnRSZXF1ZXN0KHRoaXMuX3JlcXVlc3RJZCk7XG4gICAgfVxuICAgIHRoaXMuX2Nsb3NlKCk7XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxODUgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuUERGTm9kZVN0cmVhbSA9IHZvaWQgMDtcbl9fd19wZGZqc19yZXF1aXJlX18oODkpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg5Myk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwOSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExNik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyMyk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9uZXR3b3JrX3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxODIpO1xuO1xuY29uc3QgZmlsZVVyaVJlZ2V4ID0gL15maWxlOlxcL1xcL1xcL1thLXpBLVpdOlxcLy87XG5mdW5jdGlvbiBwYXJzZVVybChzb3VyY2VVcmwpIHtcbiAgY29uc3QgdXJsID0gcmVxdWlyZShcInVybFwiKTtcbiAgY29uc3QgcGFyc2VkVXJsID0gdXJsLnBhcnNlKHNvdXJjZVVybCk7XG4gIGlmIChwYXJzZWRVcmwucHJvdG9jb2wgPT09IFwiZmlsZTpcIiB8fCBwYXJzZWRVcmwuaG9zdCkge1xuICAgIHJldHVybiBwYXJzZWRVcmw7XG4gIH1cbiAgaWYgKC9eW2Etel06Wy9cXFxcXS9pLnRlc3Qoc291cmNlVXJsKSkge1xuICAgIHJldHVybiB1cmwucGFyc2UoYGZpbGU6Ly8vJHtzb3VyY2VVcmx9YCk7XG4gIH1cbiAgaWYgKCFwYXJzZWRVcmwuaG9zdCkge1xuICAgIHBhcnNlZFVybC5wcm90b2NvbCA9IFwiZmlsZTpcIjtcbiAgfVxuICByZXR1cm4gcGFyc2VkVXJsO1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbSB7XG4gIGNvbnN0cnVjdG9yKHNvdXJjZSkge1xuICAgIHRoaXMuc291cmNlID0gc291cmNlO1xuICAgIHRoaXMudXJsID0gcGFyc2VVcmwoc291cmNlLnVybCk7XG4gICAgdGhpcy5pc0h0dHAgPSB0aGlzLnVybC5wcm90b2NvbCA9PT0gXCJodHRwOlwiIHx8IHRoaXMudXJsLnByb3RvY29sID09PSBcImh0dHBzOlwiO1xuICAgIHRoaXMuaXNGc1VybCA9IHRoaXMudXJsLnByb3RvY29sID09PSBcImZpbGU6XCI7XG4gICAgdGhpcy5odHRwSGVhZGVycyA9IHRoaXMuaXNIdHRwICYmIHNvdXJjZS5odHRwSGVhZGVycyB8fCB7fTtcbiAgICB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fcmFuZ2VSZXF1ZXN0UmVhZGVycyA9IFtdO1xuICB9XG4gIGdldCBfcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKCkge1xuICAgIHJldHVybiB0aGlzLl9mdWxsUmVxdWVzdFJlYWRlcj8uX2xvYWRlZCA/PyAwO1xuICB9XG4gIGdldEZ1bGxSZWFkZXIoKSB7XG4gICAgKDAsIF91dGlsLmFzc2VydCkoIXRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyLCBcIlBERk5vZGVTdHJlYW0uZ2V0RnVsbFJlYWRlciBjYW4gb25seSBiZSBjYWxsZWQgb25jZS5cIik7XG4gICAgdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzRnVsbFJlYWRlcih0aGlzKSA6IG5ldyBQREZOb2RlU3RyZWFtRnVsbFJlYWRlcih0aGlzKTtcbiAgICByZXR1cm4gdGhpcy5fZnVsbFJlcXVlc3RSZWFkZXI7XG4gIH1cbiAgZ2V0UmFuZ2VSZWFkZXIoc3RhcnQsIGVuZCkge1xuICAgIGlmIChlbmQgPD0gdGhpcy5fcHJvZ3Jlc3NpdmVEYXRhTGVuZ3RoKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmFuZ2VSZWFkZXIgPSB0aGlzLmlzRnNVcmwgPyBuZXcgUERGTm9kZVN0cmVhbUZzUmFuZ2VSZWFkZXIodGhpcywgc3RhcnQsIGVuZCkgOiBuZXcgUERGTm9kZVN0cmVhbVJhbmdlUmVhZGVyKHRoaXMsIHN0YXJ0LCBlbmQpO1xuICAgIHRoaXMuX3JhbmdlUmVxdWVzdFJlYWRlcnMucHVzaChyYW5nZVJlYWRlcik7XG4gICAgcmV0dXJuIHJhbmdlUmVhZGVyO1xuICB9XG4gIGNhbmNlbEFsbFJlcXVlc3RzKHJlYXNvbikge1xuICAgIHRoaXMuX2Z1bGxSZXF1ZXN0UmVhZGVyPy5jYW5jZWwocmVhc29uKTtcbiAgICBmb3IgKGNvbnN0IHJlYWRlciBvZiB0aGlzLl9yYW5nZVJlcXVlc3RSZWFkZXJzLnNsaWNlKDApKSB7XG4gICAgICByZWFkZXIuY2FuY2VsKHJlYXNvbik7XG4gICAgfVxuICB9XG59XG5leHBvcnRzLlBERk5vZGVTdHJlYW0gPSBQREZOb2RlU3RyZWFtO1xuY2xhc3MgQmFzZUZ1bGxSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0pIHtcbiAgICB0aGlzLl91cmwgPSBzdHJlYW0udXJsO1xuICAgIHRoaXMuX2RvbmUgPSBmYWxzZTtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IG51bGw7XG4gICAgdGhpcy5vblByb2dyZXNzID0gbnVsbDtcbiAgICBjb25zdCBzb3VyY2UgPSBzdHJlYW0uc291cmNlO1xuICAgIHRoaXMuX2NvbnRlbnRMZW5ndGggPSBzb3VyY2UubGVuZ3RoO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fZmlsZW5hbWUgPSBudWxsO1xuICAgIHRoaXMuX2Rpc2FibGVSYW5nZSA9IHNvdXJjZS5kaXNhYmxlUmFuZ2UgfHwgZmFsc2U7XG4gICAgdGhpcy5fcmFuZ2VDaHVua1NpemUgPSBzb3VyY2UucmFuZ2VDaHVua1NpemU7XG4gICAgaWYgKCF0aGlzLl9yYW5nZUNodW5rU2l6ZSAmJiAhdGhpcy5fZGlzYWJsZVJhbmdlKSB7XG4gICAgICB0aGlzLl9kaXNhYmxlUmFuZ2UgPSB0cnVlO1xuICAgIH1cbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9pc1JhbmdlU3VwcG9ydGVkID0gIXNvdXJjZS5kaXNhYmxlUmFuZ2U7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgdGhpcy5faGVhZGVyc0NhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgfVxuICBnZXQgaGVhZGVyc1JlYWR5KCkge1xuICAgIHJldHVybiB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5wcm9taXNlO1xuICB9XG4gIGdldCBmaWxlbmFtZSgpIHtcbiAgICByZXR1cm4gdGhpcy5fZmlsZW5hbWU7XG4gIH1cbiAgZ2V0IGNvbnRlbnRMZW5ndGgoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gIH1cbiAgZ2V0IGlzUmFuZ2VTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQ7XG4gIH1cbiAgZ2V0IGlzU3RyZWFtaW5nU3VwcG9ydGVkKCkge1xuICAgIHJldHVybiB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZDtcbiAgfVxuICBhc3luYyByZWFkKCkge1xuICAgIGF3YWl0IHRoaXMuX3JlYWRDYXBhYmlsaXR5LnByb21pc2U7XG4gICAgaWYgKHRoaXMuX2RvbmUpIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiB1bmRlZmluZWQsXG4gICAgICAgIGRvbmU6IHRydWVcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhyb3cgdGhpcy5fc3RvcmVkRXJyb3I7XG4gICAgfVxuICAgIGNvbnN0IGNodW5rID0gdGhpcy5fcmVhZGFibGVTdHJlYW0ucmVhZCgpO1xuICAgIGlmIChjaHVuayA9PT0gbnVsbCkge1xuICAgICAgdGhpcy5fcmVhZENhcGFiaWxpdHkgPSBuZXcgX3V0aWwuUHJvbWlzZUNhcGFiaWxpdHkoKTtcbiAgICAgIHJldHVybiB0aGlzLnJlYWQoKTtcbiAgICB9XG4gICAgdGhpcy5fbG9hZGVkICs9IGNodW5rLmxlbmd0aDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3M/Lih7XG4gICAgICBsb2FkZWQ6IHRoaXMuX2xvYWRlZCxcbiAgICAgIHRvdGFsOiB0aGlzLl9jb250ZW50TGVuZ3RoXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICghdGhpcy5faXNTdHJlYW1pbmdTdXBwb3J0ZWQgJiYgdGhpcy5faXNSYW5nZVN1cHBvcnRlZCkge1xuICAgICAgdGhpcy5fZXJyb3IobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwic3RyZWFtaW5nIGlzIGRpc2FibGVkXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aGlzLl9yZWFkYWJsZVN0cmVhbS5kZXN0cm95KHRoaXMuX3N0b3JlZEVycm9yKTtcbiAgICB9XG4gIH1cbn1cbmNsYXNzIEJhc2VSYW5nZVJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHRoaXMuX3VybCA9IHN0cmVhbS51cmw7XG4gICAgdGhpcy5fZG9uZSA9IGZhbHNlO1xuICAgIHRoaXMuX3N0b3JlZEVycm9yID0gbnVsbDtcbiAgICB0aGlzLm9uUHJvZ3Jlc3MgPSBudWxsO1xuICAgIHRoaXMuX2xvYWRlZCA9IDA7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSBudWxsO1xuICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgY29uc3Qgc291cmNlID0gc3RyZWFtLnNvdXJjZTtcbiAgICB0aGlzLl9pc1N0cmVhbWluZ1N1cHBvcnRlZCA9ICFzb3VyY2UuZGlzYWJsZVN0cmVhbTtcbiAgfVxuICBnZXQgaXNTdHJlYW1pbmdTdXBwb3J0ZWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2lzU3RyZWFtaW5nU3VwcG9ydGVkO1xuICB9XG4gIGFzeW5jIHJlYWQoKSB7XG4gICAgYXdhaXQgdGhpcy5fcmVhZENhcGFiaWxpdHkucHJvbWlzZTtcbiAgICBpZiAodGhpcy5fZG9uZSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdmFsdWU6IHVuZGVmaW5lZCxcbiAgICAgICAgZG9uZTogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHRoaXMuX3N0b3JlZEVycm9yKSB7XG4gICAgICB0aHJvdyB0aGlzLl9zdG9yZWRFcnJvcjtcbiAgICB9XG4gICAgY29uc3QgY2h1bmsgPSB0aGlzLl9yZWFkYWJsZVN0cmVhbS5yZWFkKCk7XG4gICAgaWYgKGNodW5rID09PSBudWxsKSB7XG4gICAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgICAgcmV0dXJuIHRoaXMucmVhZCgpO1xuICAgIH1cbiAgICB0aGlzLl9sb2FkZWQgKz0gY2h1bmsubGVuZ3RoO1xuICAgIHRoaXMub25Qcm9ncmVzcz8uKHtcbiAgICAgIGxvYWRlZDogdGhpcy5fbG9hZGVkXG4gICAgfSk7XG4gICAgY29uc3QgYnVmZmVyID0gbmV3IFVpbnQ4QXJyYXkoY2h1bmspLmJ1ZmZlcjtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IGJ1ZmZlcixcbiAgICAgIGRvbmU6IGZhbHNlXG4gICAgfTtcbiAgfVxuICBjYW5jZWwocmVhc29uKSB7XG4gICAgaWYgKCF0aGlzLl9yZWFkYWJsZVN0cmVhbSkge1xuICAgICAgdGhpcy5fZXJyb3IocmVhc29uKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveShyZWFzb24pO1xuICB9XG4gIF9lcnJvcihyZWFzb24pIHtcbiAgICB0aGlzLl9zdG9yZWRFcnJvciA9IHJlYXNvbjtcbiAgICB0aGlzLl9yZWFkQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gIH1cbiAgX3NldFJlYWRhYmxlU3RyZWFtKHJlYWRhYmxlU3RyZWFtKSB7XG4gICAgdGhpcy5fcmVhZGFibGVTdHJlYW0gPSByZWFkYWJsZVN0cmVhbTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcInJlYWRhYmxlXCIsICgpID0+IHtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVuZFwiLCAoKSA9PiB7XG4gICAgICByZWFkYWJsZVN0cmVhbS5kZXN0cm95KCk7XG4gICAgICB0aGlzLl9kb25lID0gdHJ1ZTtcbiAgICAgIHRoaXMuX3JlYWRDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICB9KTtcbiAgICByZWFkYWJsZVN0cmVhbS5vbihcImVycm9yXCIsIHJlYXNvbiA9PiB7XG4gICAgICB0aGlzLl9lcnJvcihyZWFzb24pO1xuICAgIH0pO1xuICAgIGlmICh0aGlzLl9zdG9yZWRFcnJvcikge1xuICAgICAgdGhpcy5fcmVhZGFibGVTdHJlYW0uZGVzdHJveSh0aGlzLl9zdG9yZWRFcnJvcik7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0T3B0aW9ucyhwYXJzZWRVcmwsIGhlYWRlcnMpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcGFyc2VkVXJsLnByb3RvY29sLFxuICAgIGF1dGg6IHBhcnNlZFVybC5hdXRoLFxuICAgIGhvc3Q6IHBhcnNlZFVybC5ob3N0bmFtZSxcbiAgICBwb3J0OiBwYXJzZWRVcmwucG9ydCxcbiAgICBwYXRoOiBwYXJzZWRVcmwucGF0aCxcbiAgICBtZXRob2Q6IFwiR0VUXCIsXG4gICAgaGVhZGVyc1xuICB9O1xufVxuY2xhc3MgUERGTm9kZVN0cmVhbUZ1bGxSZWFkZXIgZXh0ZW5kcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgY29uc3QgaGFuZGxlUmVzcG9uc2UgPSByZXNwb25zZSA9PiB7XG4gICAgICBpZiAocmVzcG9uc2Uuc3RhdHVzQ29kZSA9PT0gNDA0KSB7XG4gICAgICAgIGNvbnN0IGVycm9yID0gbmV3IF91dGlsLk1pc3NpbmdQREZFeGNlcHRpb24oYE1pc3NpbmcgUERGIFwiJHt0aGlzLl91cmx9XCIuYCk7XG4gICAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gZXJyb3I7XG4gICAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlamVjdChlcnJvcik7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuX2hlYWRlcnNDYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICAgIHRoaXMuX3NldFJlYWRhYmxlU3RyZWFtKHJlc3BvbnNlKTtcbiAgICAgIGNvbnN0IGdldFJlc3BvbnNlSGVhZGVyID0gbmFtZSA9PiB7XG4gICAgICAgIHJldHVybiB0aGlzLl9yZWFkYWJsZVN0cmVhbS5oZWFkZXJzW25hbWUudG9Mb3dlckNhc2UoKV07XG4gICAgICB9O1xuICAgICAgY29uc3Qge1xuICAgICAgICBhbGxvd1JhbmdlUmVxdWVzdHMsXG4gICAgICAgIHN1Z2dlc3RlZExlbmd0aFxuICAgICAgfSA9ICgwLCBfbmV0d29ya191dGlscy52YWxpZGF0ZVJhbmdlUmVxdWVzdENhcGFiaWxpdGllcykoe1xuICAgICAgICBnZXRSZXNwb25zZUhlYWRlcixcbiAgICAgICAgaXNIdHRwOiBzdHJlYW0uaXNIdHRwLFxuICAgICAgICByYW5nZUNodW5rU2l6ZTogdGhpcy5fcmFuZ2VDaHVua1NpemUsXG4gICAgICAgIGRpc2FibGVSYW5nZTogdGhpcy5fZGlzYWJsZVJhbmdlXG4gICAgICB9KTtcbiAgICAgIHRoaXMuX2lzUmFuZ2VTdXBwb3J0ZWQgPSBhbGxvd1JhbmdlUmVxdWVzdHM7XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3VnZ2VzdGVkTGVuZ3RoIHx8IHRoaXMuX2NvbnRlbnRMZW5ndGg7XG4gICAgICB0aGlzLl9maWxlbmFtZSA9ICgwLCBfbmV0d29ya191dGlscy5leHRyYWN0RmlsZW5hbWVGcm9tSGVhZGVyKShnZXRSZXNwb25zZUhlYWRlcik7XG4gICAgfTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgIGNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCBzdHJlYW0uaHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGh0dHBzID0gcmVxdWlyZShcImh0dHBzXCIpO1xuICAgICAgdGhpcy5fcmVxdWVzdCA9IGh0dHBzLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCBzdHJlYW0uaHR0cEhlYWRlcnMpLCBoYW5kbGVSZXNwb25zZSk7XG4gICAgfVxuICAgIHRoaXMuX3JlcXVlc3Qub24oXCJlcnJvclwiLCByZWFzb24gPT4ge1xuICAgICAgdGhpcy5fc3RvcmVkRXJyb3IgPSByZWFzb247XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QocmVhc29uKTtcbiAgICB9KTtcbiAgICB0aGlzLl9yZXF1ZXN0LmVuZCgpO1xuICB9XG59XG5jbGFzcyBQREZOb2RlU3RyZWFtUmFuZ2VSZWFkZXIgZXh0ZW5kcyBCYXNlUmFuZ2VSZWFkZXIge1xuICBjb25zdHJ1Y3RvcihzdHJlYW0sIHN0YXJ0LCBlbmQpIHtcbiAgICBzdXBlcihzdHJlYW0pO1xuICAgIHRoaXMuX2h0dHBIZWFkZXJzID0ge307XG4gICAgZm9yIChjb25zdCBwcm9wZXJ0eSBpbiBzdHJlYW0uaHR0cEhlYWRlcnMpIHtcbiAgICAgIGNvbnN0IHZhbHVlID0gc3RyZWFtLmh0dHBIZWFkZXJzW3Byb3BlcnR5XTtcbiAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5faHR0cEhlYWRlcnNbcHJvcGVydHldID0gdmFsdWU7XG4gICAgfVxuICAgIHRoaXMuX2h0dHBIZWFkZXJzLlJhbmdlID0gYGJ5dGVzPSR7c3RhcnR9LSR7ZW5kIC0gMX1gO1xuICAgIGNvbnN0IGhhbmRsZVJlc3BvbnNlID0gcmVzcG9uc2UgPT4ge1xuICAgICAgaWYgKHJlc3BvbnNlLnN0YXR1c0NvZGUgPT09IDQwNCkge1xuICAgICAgICBjb25zdCBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7dGhpcy5fdXJsfVwiLmApO1xuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShyZXNwb25zZSk7XG4gICAgfTtcbiAgICB0aGlzLl9yZXF1ZXN0ID0gbnVsbDtcbiAgICBpZiAodGhpcy5fdXJsLnByb3RvY29sID09PSBcImh0dHA6XCIpIHtcbiAgICAgIGNvbnN0IGh0dHAgPSByZXF1aXJlKFwiaHR0cFwiKTtcbiAgICAgIHRoaXMuX3JlcXVlc3QgPSBodHRwLnJlcXVlc3QoY3JlYXRlUmVxdWVzdE9wdGlvbnModGhpcy5fdXJsLCB0aGlzLl9odHRwSGVhZGVycyksIGhhbmRsZVJlc3BvbnNlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgaHR0cHMgPSByZXF1aXJlKFwiaHR0cHNcIik7XG4gICAgICB0aGlzLl9yZXF1ZXN0ID0gaHR0cHMucmVxdWVzdChjcmVhdGVSZXF1ZXN0T3B0aW9ucyh0aGlzLl91cmwsIHRoaXMuX2h0dHBIZWFkZXJzKSwgaGFuZGxlUmVzcG9uc2UpO1xuICAgIH1cbiAgICB0aGlzLl9yZXF1ZXN0Lm9uKFwiZXJyb3JcIiwgcmVhc29uID0+IHtcbiAgICAgIHRoaXMuX3N0b3JlZEVycm9yID0gcmVhc29uO1xuICAgIH0pO1xuICAgIHRoaXMuX3JlcXVlc3QuZW5kKCk7XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc0Z1bGxSZWFkZXIgZXh0ZW5kcyBCYXNlRnVsbFJlYWRlciB7XG4gIGNvbnN0cnVjdG9yKHN0cmVhbSkge1xuICAgIHN1cGVyKHN0cmVhbSk7XG4gICAgbGV0IHBhdGggPSBkZWNvZGVVUklDb21wb25lbnQodGhpcy5fdXJsLnBhdGgpO1xuICAgIGlmIChmaWxlVXJpUmVnZXgudGVzdCh0aGlzLl91cmwuaHJlZikpIHtcbiAgICAgIHBhdGggPSBwYXRoLnJlcGxhY2UoL15cXC8vLCBcIlwiKTtcbiAgICB9XG4gICAgY29uc3QgZnMgPSByZXF1aXJlKFwiZnNcIik7XG4gICAgZnMubHN0YXQocGF0aCwgKGVycm9yLCBzdGF0KSA9PiB7XG4gICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGVycm9yLmNvZGUgPT09IFwiRU5PRU5UXCIpIHtcbiAgICAgICAgICBlcnJvciA9IG5ldyBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uKGBNaXNzaW5nIFBERiBcIiR7cGF0aH1cIi5gKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zdG9yZWRFcnJvciA9IGVycm9yO1xuICAgICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZWplY3QoZXJyb3IpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB0aGlzLl9jb250ZW50TGVuZ3RoID0gc3RhdC5zaXplO1xuICAgICAgdGhpcy5fc2V0UmVhZGFibGVTdHJlYW0oZnMuY3JlYXRlUmVhZFN0cmVhbShwYXRoKSk7XG4gICAgICB0aGlzLl9oZWFkZXJzQ2FwYWJpbGl0eS5yZXNvbHZlKCk7XG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIFBERk5vZGVTdHJlYW1Gc1JhbmdlUmVhZGVyIGV4dGVuZHMgQmFzZVJhbmdlUmVhZGVyIHtcbiAgY29uc3RydWN0b3Ioc3RyZWFtLCBzdGFydCwgZW5kKSB7XG4gICAgc3VwZXIoc3RyZWFtKTtcbiAgICBsZXQgcGF0aCA9IGRlY29kZVVSSUNvbXBvbmVudCh0aGlzLl91cmwucGF0aCk7XG4gICAgaWYgKGZpbGVVcmlSZWdleC50ZXN0KHRoaXMuX3VybC5ocmVmKSkge1xuICAgICAgcGF0aCA9IHBhdGgucmVwbGFjZSgvXlxcLy8sIFwiXCIpO1xuICAgIH1cbiAgICBjb25zdCBmcyA9IHJlcXVpcmUoXCJmc1wiKTtcbiAgICB0aGlzLl9zZXRSZWFkYWJsZVN0cmVhbShmcy5jcmVhdGVSZWFkU3RyZWFtKHBhdGgsIHtcbiAgICAgIHN0YXJ0LFxuICAgICAgZW5kOiBlbmQgLSAxXG4gICAgfSkpO1xuICB9XG59XG5cbi8qKiovIH0pLFxuLyogMTg2ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlNWR0dyYXBoaWNzID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4NCk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDg2KTtcbl9fd19wZGZqc19yZXF1aXJlX18oODcpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg5Myk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwMik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwNyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEwOSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDExNik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyMyk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDIpO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDE4Nyk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2OCk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xuO1xuY29uc3QgU1ZHX0RFRkFVTFRTID0ge1xuICBmb250U3R5bGU6IFwibm9ybWFsXCIsXG4gIGZvbnRXZWlnaHQ6IFwibm9ybWFsXCIsXG4gIGZpbGxDb2xvcjogXCIjMDAwMDAwXCJcbn07XG5jb25zdCBYTUxfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnL1hNTC8xOTk4L25hbWVzcGFjZVwiO1xuY29uc3QgWExJTktfTlMgPSBcImh0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmtcIjtcbmNvbnN0IExJTkVfQ0FQX1NUWUxFUyA9IFtcImJ1dHRcIiwgXCJyb3VuZFwiLCBcInNxdWFyZVwiXTtcbmNvbnN0IExJTkVfSk9JTl9TVFlMRVMgPSBbXCJtaXRlclwiLCBcInJvdW5kXCIsIFwiYmV2ZWxcIl07XG5jb25zdCBjcmVhdGVPYmplY3RVUkwgPSBmdW5jdGlvbiAoZGF0YSkge1xuICBsZXQgY29udGVudFR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IFwiXCI7XG4gIGxldCBmb3JjZURhdGFTY2hlbWEgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuICBpZiAoVVJMLmNyZWF0ZU9iamVjdFVSTCAmJiB0eXBlb2YgQmxvYiAhPT0gXCJ1bmRlZmluZWRcIiAmJiAhZm9yY2VEYXRhU2NoZW1hKSB7XG4gICAgcmV0dXJuIFVSTC5jcmVhdGVPYmplY3RVUkwobmV3IEJsb2IoW2RhdGFdLCB7XG4gICAgICB0eXBlOiBjb250ZW50VHlwZVxuICAgIH0pKTtcbiAgfVxuICBjb25zdCBkaWdpdHMgPSBcIkFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXowMTIzNDU2Nzg5Ky89XCI7XG4gIGxldCBidWZmZXIgPSBgZGF0YToke2NvbnRlbnRUeXBlfTtiYXNlNjQsYDtcbiAgZm9yIChsZXQgaSA9IDAsIGlpID0gZGF0YS5sZW5ndGg7IGkgPCBpaTsgaSArPSAzKSB7XG4gICAgY29uc3QgYjEgPSBkYXRhW2ldICYgMHhmZjtcbiAgICBjb25zdCBiMiA9IGRhdGFbaSArIDFdICYgMHhmZjtcbiAgICBjb25zdCBiMyA9IGRhdGFbaSArIDJdICYgMHhmZjtcbiAgICBjb25zdCBkMSA9IGIxID4+IDIsXG4gICAgICBkMiA9IChiMSAmIDMpIDw8IDQgfCBiMiA+PiA0O1xuICAgIGNvbnN0IGQzID0gaSArIDEgPCBpaSA/IChiMiAmIDB4ZikgPDwgMiB8IGIzID4+IDYgOiA2NDtcbiAgICBjb25zdCBkNCA9IGkgKyAyIDwgaWkgPyBiMyAmIDB4M2YgOiA2NDtcbiAgICBidWZmZXIgKz0gZGlnaXRzW2QxXSArIGRpZ2l0c1tkMl0gKyBkaWdpdHNbZDNdICsgZGlnaXRzW2Q0XTtcbiAgfVxuICByZXR1cm4gYnVmZmVyO1xufTtcbmNvbnN0IGNvbnZlcnRJbWdEYXRhVG9QbmcgPSBmdW5jdGlvbiAoKSB7XG4gIGNvbnN0IFBOR19IRUFERVIgPSBuZXcgVWludDhBcnJheShbMHg4OSwgMHg1MCwgMHg0ZSwgMHg0NywgMHgwZCwgMHgwYSwgMHgxYSwgMHgwYV0pO1xuICBjb25zdCBDSFVOS19XUkFQUEVSX1NJWkUgPSAxMjtcbiAgY29uc3QgY3JjVGFibGUgPSBuZXcgSW50MzJBcnJheSgyNTYpO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG4gICAgbGV0IGMgPSBpO1xuICAgIGZvciAobGV0IGggPSAwOyBoIDwgODsgaCsrKSB7XG4gICAgICBjID0gYyAmIDEgPyAweGVkYjg4MzIwIF4gYyA+PiAxICYgMHg3ZmZmZmZmZiA6IGMgPj4gMSAmIDB4N2ZmZmZmZmY7XG4gICAgfVxuICAgIGNyY1RhYmxlW2ldID0gYztcbiAgfVxuICBmdW5jdGlvbiBjcmMzMihkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IGNyYyA9IC0xO1xuICAgIGZvciAobGV0IGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICBjb25zdCBhID0gKGNyYyBeIGRhdGFbaV0pICYgMHhmZjtcbiAgICAgIGNvbnN0IGIgPSBjcmNUYWJsZVthXTtcbiAgICAgIGNyYyA9IGNyYyA+Pj4gOCBeIGI7XG4gICAgfVxuICAgIHJldHVybiBjcmMgXiAtMTtcbiAgfVxuICBmdW5jdGlvbiB3cml0ZVBuZ0NodW5rKHR5cGUsIGJvZHksIGRhdGEsIG9mZnNldCkge1xuICAgIGxldCBwID0gb2Zmc2V0O1xuICAgIGNvbnN0IGxlbiA9IGJvZHkubGVuZ3RoO1xuICAgIGRhdGFbcF0gPSBsZW4gPj4gMjQgJiAweGZmO1xuICAgIGRhdGFbcCArIDFdID0gbGVuID4+IDE2ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAyXSA9IGxlbiA+PiA4ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAzXSA9IGxlbiAmIDB4ZmY7XG4gICAgcCArPSA0O1xuICAgIGRhdGFbcF0gPSB0eXBlLmNoYXJDb2RlQXQoMCkgJiAweGZmO1xuICAgIGRhdGFbcCArIDFdID0gdHlwZS5jaGFyQ29kZUF0KDEpICYgMHhmZjtcbiAgICBkYXRhW3AgKyAyXSA9IHR5cGUuY2hhckNvZGVBdCgyKSAmIDB4ZmY7XG4gICAgZGF0YVtwICsgM10gPSB0eXBlLmNoYXJDb2RlQXQoMykgJiAweGZmO1xuICAgIHAgKz0gNDtcbiAgICBkYXRhLnNldChib2R5LCBwKTtcbiAgICBwICs9IGJvZHkubGVuZ3RoO1xuICAgIGNvbnN0IGNyYyA9IGNyYzMyKGRhdGEsIG9mZnNldCArIDQsIHApO1xuICAgIGRhdGFbcF0gPSBjcmMgPj4gMjQgJiAweGZmO1xuICAgIGRhdGFbcCArIDFdID0gY3JjID4+IDE2ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAyXSA9IGNyYyA+PiA4ICYgMHhmZjtcbiAgICBkYXRhW3AgKyAzXSA9IGNyYyAmIDB4ZmY7XG4gIH1cbiAgZnVuY3Rpb24gYWRsZXIzMihkYXRhLCBzdGFydCwgZW5kKSB7XG4gICAgbGV0IGEgPSAxO1xuICAgIGxldCBiID0gMDtcbiAgICBmb3IgKGxldCBpID0gc3RhcnQ7IGkgPCBlbmQ7ICsraSkge1xuICAgICAgYSA9IChhICsgKGRhdGFbaV0gJiAweGZmKSkgJSA2NTUyMTtcbiAgICAgIGIgPSAoYiArIGEpICUgNjU1MjE7XG4gICAgfVxuICAgIHJldHVybiBiIDw8IDE2IHwgYTtcbiAgfVxuICBmdW5jdGlvbiBkZWZsYXRlU3luYyhsaXRlcmFscykge1xuICAgIGlmICghX3V0aWwuaXNOb2RlSlMpIHtcbiAgICAgIHJldHVybiBkZWZsYXRlU3luY1VuY29tcHJlc3NlZChsaXRlcmFscyk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICBjb25zdCBpbnB1dCA9IHBhcnNlSW50KHByb2Nlc3MudmVyc2lvbnMubm9kZSkgPj0gOCA/IGxpdGVyYWxzIDogQnVmZmVyLmZyb20obGl0ZXJhbHMpO1xuICAgICAgY29uc3Qgb3V0cHV0ID0gcmVxdWlyZShcInpsaWJcIikuZGVmbGF0ZVN5bmMoaW5wdXQsIHtcbiAgICAgICAgbGV2ZWw6IDlcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIG91dHB1dCBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkgPyBvdXRwdXQgOiBuZXcgVWludDhBcnJheShvdXRwdXQpO1xuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICgwLCBfdXRpbC53YXJuKShcIk5vdCBjb21wcmVzc2luZyBQTkcgYmVjYXVzZSB6bGliLmRlZmxhdGVTeW5jIGlzIHVuYXZhaWxhYmxlOiBcIiArIGUpO1xuICAgIH1cbiAgICByZXR1cm4gZGVmbGF0ZVN5bmNVbmNvbXByZXNzZWQobGl0ZXJhbHMpO1xuICB9XG4gIGZ1bmN0aW9uIGRlZmxhdGVTeW5jVW5jb21wcmVzc2VkKGxpdGVyYWxzKSB7XG4gICAgbGV0IGxlbiA9IGxpdGVyYWxzLmxlbmd0aDtcbiAgICBjb25zdCBtYXhCbG9ja0xlbmd0aCA9IDB4ZmZmZjtcbiAgICBjb25zdCBkZWZsYXRlQmxvY2tzID0gTWF0aC5jZWlsKGxlbiAvIG1heEJsb2NrTGVuZ3RoKTtcbiAgICBjb25zdCBpZGF0ID0gbmV3IFVpbnQ4QXJyYXkoMiArIGxlbiArIGRlZmxhdGVCbG9ja3MgKiA1ICsgNCk7XG4gICAgbGV0IHBpID0gMDtcbiAgICBpZGF0W3BpKytdID0gMHg3ODtcbiAgICBpZGF0W3BpKytdID0gMHg5YztcbiAgICBsZXQgcG9zID0gMDtcbiAgICB3aGlsZSAobGVuID4gbWF4QmxvY2tMZW5ndGgpIHtcbiAgICAgIGlkYXRbcGkrK10gPSAweDAwO1xuICAgICAgaWRhdFtwaSsrXSA9IDB4ZmY7XG4gICAgICBpZGF0W3BpKytdID0gMHhmZjtcbiAgICAgIGlkYXRbcGkrK10gPSAweDAwO1xuICAgICAgaWRhdFtwaSsrXSA9IDB4MDA7XG4gICAgICBpZGF0LnNldChsaXRlcmFscy5zdWJhcnJheShwb3MsIHBvcyArIG1heEJsb2NrTGVuZ3RoKSwgcGkpO1xuICAgICAgcGkgKz0gbWF4QmxvY2tMZW5ndGg7XG4gICAgICBwb3MgKz0gbWF4QmxvY2tMZW5ndGg7XG4gICAgICBsZW4gLT0gbWF4QmxvY2tMZW5ndGg7XG4gICAgfVxuICAgIGlkYXRbcGkrK10gPSAweDAxO1xuICAgIGlkYXRbcGkrK10gPSBsZW4gJiAweGZmO1xuICAgIGlkYXRbcGkrK10gPSBsZW4gPj4gOCAmIDB4ZmY7XG4gICAgaWRhdFtwaSsrXSA9IH5sZW4gJiAweGZmZmYgJiAweGZmO1xuICAgIGlkYXRbcGkrK10gPSAofmxlbiAmIDB4ZmZmZikgPj4gOCAmIDB4ZmY7XG4gICAgaWRhdC5zZXQobGl0ZXJhbHMuc3ViYXJyYXkocG9zKSwgcGkpO1xuICAgIHBpICs9IGxpdGVyYWxzLmxlbmd0aCAtIHBvcztcbiAgICBjb25zdCBhZGxlciA9IGFkbGVyMzIobGl0ZXJhbHMsIDAsIGxpdGVyYWxzLmxlbmd0aCk7XG4gICAgaWRhdFtwaSsrXSA9IGFkbGVyID4+IDI0ICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gYWRsZXIgPj4gMTYgJiAweGZmO1xuICAgIGlkYXRbcGkrK10gPSBhZGxlciA+PiA4ICYgMHhmZjtcbiAgICBpZGF0W3BpKytdID0gYWRsZXIgJiAweGZmO1xuICAgIHJldHVybiBpZGF0O1xuICB9XG4gIGZ1bmN0aW9uIGVuY29kZShpbWdEYXRhLCBraW5kLCBmb3JjZURhdGFTY2hlbWEsIGlzTWFzaykge1xuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBsZXQgYml0RGVwdGgsIGNvbG9yVHlwZSwgbGluZVNpemU7XG4gICAgY29uc3QgYnl0ZXMgPSBpbWdEYXRhLmRhdGE7XG4gICAgc3dpdGNoIChraW5kKSB7XG4gICAgICBjYXNlIF91dGlsLkltYWdlS2luZC5HUkFZU0NBTEVfMUJQUDpcbiAgICAgICAgY29sb3JUeXBlID0gMDtcbiAgICAgICAgYml0RGVwdGggPSAxO1xuICAgICAgICBsaW5lU2l6ZSA9IHdpZHRoICsgNyA+PiAzO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuSW1hZ2VLaW5kLlJHQl8yNEJQUDpcbiAgICAgICAgY29sb3JUeXBlID0gMjtcbiAgICAgICAgYml0RGVwdGggPSA4O1xuICAgICAgICBsaW5lU2l6ZSA9IHdpZHRoICogMztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkltYWdlS2luZC5SR0JBXzMyQlBQOlxuICAgICAgICBjb2xvclR5cGUgPSA2O1xuICAgICAgICBiaXREZXB0aCA9IDg7XG4gICAgICAgIGxpbmVTaXplID0gd2lkdGggKiA0O1xuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcImludmFsaWQgZm9ybWF0XCIpO1xuICAgIH1cbiAgICBjb25zdCBsaXRlcmFscyA9IG5ldyBVaW50OEFycmF5KCgxICsgbGluZVNpemUpICogaGVpZ2h0KTtcbiAgICBsZXQgb2Zmc2V0TGl0ZXJhbHMgPSAwLFxuICAgICAgb2Zmc2V0Qnl0ZXMgPSAwO1xuICAgIGZvciAobGV0IHkgPSAwOyB5IDwgaGVpZ2h0OyArK3kpIHtcbiAgICAgIGxpdGVyYWxzW29mZnNldExpdGVyYWxzKytdID0gMDtcbiAgICAgIGxpdGVyYWxzLnNldChieXRlcy5zdWJhcnJheShvZmZzZXRCeXRlcywgb2Zmc2V0Qnl0ZXMgKyBsaW5lU2l6ZSksIG9mZnNldExpdGVyYWxzKTtcbiAgICAgIG9mZnNldEJ5dGVzICs9IGxpbmVTaXplO1xuICAgICAgb2Zmc2V0TGl0ZXJhbHMgKz0gbGluZVNpemU7XG4gICAgfVxuICAgIGlmIChraW5kID09PSBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFAgJiYgaXNNYXNrKSB7XG4gICAgICBvZmZzZXRMaXRlcmFscyA9IDA7XG4gICAgICBmb3IgKGxldCB5ID0gMDsgeSA8IGhlaWdodDsgeSsrKSB7XG4gICAgICAgIG9mZnNldExpdGVyYWxzKys7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGluZVNpemU7IGkrKykge1xuICAgICAgICAgIGxpdGVyYWxzW29mZnNldExpdGVyYWxzKytdIF49IDB4ZmY7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgaWhkciA9IG5ldyBVaW50OEFycmF5KFt3aWR0aCA+PiAyNCAmIDB4ZmYsIHdpZHRoID4+IDE2ICYgMHhmZiwgd2lkdGggPj4gOCAmIDB4ZmYsIHdpZHRoICYgMHhmZiwgaGVpZ2h0ID4+IDI0ICYgMHhmZiwgaGVpZ2h0ID4+IDE2ICYgMHhmZiwgaGVpZ2h0ID4+IDggJiAweGZmLCBoZWlnaHQgJiAweGZmLCBiaXREZXB0aCwgY29sb3JUeXBlLCAweDAwLCAweDAwLCAweDAwXSk7XG4gICAgY29uc3QgaWRhdCA9IGRlZmxhdGVTeW5jKGxpdGVyYWxzKTtcbiAgICBjb25zdCBwbmdMZW5ndGggPSBQTkdfSEVBREVSLmxlbmd0aCArIENIVU5LX1dSQVBQRVJfU0laRSAqIDMgKyBpaGRyLmxlbmd0aCArIGlkYXQubGVuZ3RoO1xuICAgIGNvbnN0IGRhdGEgPSBuZXcgVWludDhBcnJheShwbmdMZW5ndGgpO1xuICAgIGxldCBvZmZzZXQgPSAwO1xuICAgIGRhdGEuc2V0KFBOR19IRUFERVIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IFBOR19IRUFERVIubGVuZ3RoO1xuICAgIHdyaXRlUG5nQ2h1bmsoXCJJSERSXCIsIGloZHIsIGRhdGEsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IENIVU5LX1dSQVBQRVJfU0laRSArIGloZHIubGVuZ3RoO1xuICAgIHdyaXRlUG5nQ2h1bmsoXCJJREFUQVwiLCBpZGF0LCBkYXRhLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBDSFVOS19XUkFQUEVSX1NJWkUgKyBpZGF0Lmxlbmd0aDtcbiAgICB3cml0ZVBuZ0NodW5rKFwiSUVORFwiLCBuZXcgVWludDhBcnJheSgwKSwgZGF0YSwgb2Zmc2V0KTtcbiAgICByZXR1cm4gY3JlYXRlT2JqZWN0VVJMKGRhdGEsIFwiaW1hZ2UvcG5nXCIsIGZvcmNlRGF0YVNjaGVtYSk7XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbnZlcnRJbWdEYXRhVG9QbmcoaW1nRGF0YSwgZm9yY2VEYXRhU2NoZW1hLCBpc01hc2spIHtcbiAgICBjb25zdCBraW5kID0gaW1nRGF0YS5raW5kID09PSB1bmRlZmluZWQgPyBfdXRpbC5JbWFnZUtpbmQuR1JBWVNDQUxFXzFCUFAgOiBpbWdEYXRhLmtpbmQ7XG4gICAgcmV0dXJuIGVuY29kZShpbWdEYXRhLCBraW5kLCBmb3JjZURhdGFTY2hlbWEsIGlzTWFzayk7XG4gIH07XG59KCk7XG5jbGFzcyBTVkdFeHRyYVN0YXRlIHtcbiAgY29uc3RydWN0b3IoKSB7XG4gICAgdGhpcy5mb250U2l6ZVNjYWxlID0gMTtcbiAgICB0aGlzLmZvbnRXZWlnaHQgPSBTVkdfREVGQVVMVFMuZm9udFdlaWdodDtcbiAgICB0aGlzLmZvbnRTaXplID0gMDtcbiAgICB0aGlzLnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5mb250TWF0cml4ID0gX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy5sZWFkaW5nID0gMDtcbiAgICB0aGlzLnRleHRSZW5kZXJpbmdNb2RlID0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTDtcbiAgICB0aGlzLnRleHRNYXRyaXhTY2FsZSA9IDE7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMubGluZVggPSAwO1xuICAgIHRoaXMubGluZVkgPSAwO1xuICAgIHRoaXMuY2hhclNwYWNpbmcgPSAwO1xuICAgIHRoaXMud29yZFNwYWNpbmcgPSAwO1xuICAgIHRoaXMudGV4dEhTY2FsZSA9IDE7XG4gICAgdGhpcy50ZXh0UmlzZSA9IDA7XG4gICAgdGhpcy5maWxsQ29sb3IgPSBTVkdfREVGQVVMVFMuZmlsbENvbG9yO1xuICAgIHRoaXMuc3Ryb2tlQ29sb3IgPSBcIiMwMDAwMDBcIjtcbiAgICB0aGlzLmZpbGxBbHBoYSA9IDE7XG4gICAgdGhpcy5zdHJva2VBbHBoYSA9IDE7XG4gICAgdGhpcy5saW5lV2lkdGggPSAxO1xuICAgIHRoaXMubGluZUpvaW4gPSBcIlwiO1xuICAgIHRoaXMubGluZUNhcCA9IFwiXCI7XG4gICAgdGhpcy5taXRlckxpbWl0ID0gMDtcbiAgICB0aGlzLmRhc2hBcnJheSA9IFtdO1xuICAgIHRoaXMuZGFzaFBoYXNlID0gMDtcbiAgICB0aGlzLmRlcGVuZGVuY2llcyA9IFtdO1xuICAgIHRoaXMuYWN0aXZlQ2xpcFVybCA9IG51bGw7XG4gICAgdGhpcy5jbGlwR3JvdXAgPSBudWxsO1xuICAgIHRoaXMubWFza0lkID0gXCJcIjtcbiAgfVxuICBjbG9uZSgpIHtcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZSh0aGlzKTtcbiAgfVxuICBzZXRDdXJyZW50UG9pbnQoeCwgeSkge1xuICAgIHRoaXMueCA9IHg7XG4gICAgdGhpcy55ID0geTtcbiAgfVxufVxuZnVuY3Rpb24gb3BMaXN0VG9UcmVlKG9wTGlzdCkge1xuICBsZXQgb3BUcmVlID0gW107XG4gIGNvbnN0IHRtcCA9IFtdO1xuICBmb3IgKGNvbnN0IG9wTGlzdEVsZW1lbnQgb2Ygb3BMaXN0KSB7XG4gICAgaWYgKG9wTGlzdEVsZW1lbnQuZm4gPT09IFwic2F2ZVwiKSB7XG4gICAgICBvcFRyZWUucHVzaCh7XG4gICAgICAgIGZuSWQ6IDkyLFxuICAgICAgICBmbjogXCJncm91cFwiLFxuICAgICAgICBpdGVtczogW11cbiAgICAgIH0pO1xuICAgICAgdG1wLnB1c2gob3BUcmVlKTtcbiAgICAgIG9wVHJlZSA9IG9wVHJlZS5hdCgtMSkuaXRlbXM7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKG9wTGlzdEVsZW1lbnQuZm4gPT09IFwicmVzdG9yZVwiKSB7XG4gICAgICBvcFRyZWUgPSB0bXAucG9wKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wVHJlZS5wdXNoKG9wTGlzdEVsZW1lbnQpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb3BUcmVlO1xufVxuZnVuY3Rpb24gcGYodmFsdWUpIHtcbiAgaWYgKE51bWJlci5pc0ludGVnZXIodmFsdWUpKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG4gIH1cbiAgY29uc3QgcyA9IHZhbHVlLnRvRml4ZWQoMTApO1xuICBsZXQgaSA9IHMubGVuZ3RoIC0gMTtcbiAgaWYgKHNbaV0gIT09IFwiMFwiKSB7XG4gICAgcmV0dXJuIHM7XG4gIH1cbiAgZG8ge1xuICAgIGktLTtcbiAgfSB3aGlsZSAoc1tpXSA9PT0gXCIwXCIpO1xuICByZXR1cm4gcy5zdWJzdHJpbmcoMCwgc1tpXSA9PT0gXCIuXCIgPyBpIDogaSArIDEpO1xufVxuZnVuY3Rpb24gcG0obSkge1xuICBpZiAobVs0XSA9PT0gMCAmJiBtWzVdID09PSAwKSB7XG4gICAgaWYgKG1bMV0gPT09IDAgJiYgbVsyXSA9PT0gMCkge1xuICAgICAgaWYgKG1bMF0gPT09IDEgJiYgbVszXSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIH1cbiAgICAgIHJldHVybiBgc2NhbGUoJHtwZihtWzBdKX0gJHtwZihtWzNdKX0pYDtcbiAgICB9XG4gICAgaWYgKG1bMF0gPT09IG1bM10gJiYgbVsxXSA9PT0gLW1bMl0pIHtcbiAgICAgIGNvbnN0IGEgPSBNYXRoLmFjb3MobVswXSkgKiAxODAgLyBNYXRoLlBJO1xuICAgICAgcmV0dXJuIGByb3RhdGUoJHtwZihhKX0pYDtcbiAgICB9XG4gIH0gZWxzZSBpZiAobVswXSA9PT0gMSAmJiBtWzFdID09PSAwICYmIG1bMl0gPT09IDAgJiYgbVszXSA9PT0gMSkge1xuICAgIHJldHVybiBgdHJhbnNsYXRlKCR7cGYobVs0XSl9ICR7cGYobVs1XSl9KWA7XG4gIH1cbiAgcmV0dXJuIGBtYXRyaXgoJHtwZihtWzBdKX0gJHtwZihtWzFdKX0gJHtwZihtWzJdKX0gJHtwZihtWzNdKX0gJHtwZihtWzRdKX0gYCArIGAke3BmKG1bNV0pfSlgO1xufVxubGV0IGNsaXBDb3VudCA9IDA7XG5sZXQgbWFza0NvdW50ID0gMDtcbmxldCBzaGFkaW5nQ291bnQgPSAwO1xuY2xhc3MgU1ZHR3JhcGhpY3Mge1xuICBjb25zdHJ1Y3Rvcihjb21tb25PYmpzLCBvYmpzKSB7XG4gICAgbGV0IGZvcmNlRGF0YVNjaGVtYSA9IGFyZ3VtZW50cy5sZW5ndGggPiAyICYmIGFyZ3VtZW50c1syXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzJdIDogZmFsc2U7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLmRlcHJlY2F0ZWQpKFwiVGhlIFNWRyBiYWNrLWVuZCBpcyBubyBsb25nZXIgbWFpbnRhaW5lZCBhbmQgKm1heSogYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLlwiKTtcbiAgICB0aGlzLnN2Z0ZhY3RvcnkgPSBuZXcgX2Rpc3BsYXlfdXRpbHMuRE9NU1ZHRmFjdG9yeSgpO1xuICAgIHRoaXMuY3VycmVudCA9IG5ldyBTVkdFeHRyYVN0YXRlKCk7XG4gICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgdGhpcy50cmFuc2Zvcm1TdGFjayA9IFtdO1xuICAgIHRoaXMuZXh0cmFTdGFjayA9IFtdO1xuICAgIHRoaXMuY29tbW9uT2JqcyA9IGNvbW1vbk9ianM7XG4gICAgdGhpcy5vYmpzID0gb2JqcztcbiAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICB0aGlzLnBlbmRpbmdFT0ZpbGwgPSBmYWxzZTtcbiAgICB0aGlzLmVtYmVkRm9udHMgPSBmYWxzZTtcbiAgICB0aGlzLmVtYmVkZGVkRm9udHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuY3NzU3R5bGUgPSBudWxsO1xuICAgIHRoaXMuZm9yY2VEYXRhU2NoZW1hID0gISFmb3JjZURhdGFTY2hlbWE7XG4gICAgdGhpcy5fb3BlcmF0b3JJZE1hcHBpbmcgPSBbXTtcbiAgICBmb3IgKGNvbnN0IG9wIGluIF91dGlsLk9QUykge1xuICAgICAgdGhpcy5fb3BlcmF0b3JJZE1hcHBpbmdbX3V0aWwuT1BTW29wXV0gPSBvcDtcbiAgICB9XG4gIH1cbiAgZ2V0T2JqZWN0KGRhdGEpIHtcbiAgICBsZXQgZmFsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG4gICAgICByZXR1cm4gZGF0YS5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMuZ2V0KGRhdGEpIDogdGhpcy5vYmpzLmdldChkYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbGxiYWNrO1xuICB9XG4gIHNhdmUoKSB7XG4gICAgdGhpcy50cmFuc2Zvcm1TdGFjay5wdXNoKHRoaXMudHJhbnNmb3JtTWF0cml4KTtcbiAgICBjb25zdCBvbGQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgdGhpcy5leHRyYVN0YWNrLnB1c2gob2xkKTtcbiAgICB0aGlzLmN1cnJlbnQgPSBvbGQuY2xvbmUoKTtcbiAgfVxuICByZXN0b3JlKCkge1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gdGhpcy50cmFuc2Zvcm1TdGFjay5wb3AoKTtcbiAgICB0aGlzLmN1cnJlbnQgPSB0aGlzLmV4dHJhU3RhY2sucG9wKCk7XG4gICAgdGhpcy5wZW5kaW5nQ2xpcCA9IG51bGw7XG4gICAgdGhpcy50Z3JwID0gbnVsbDtcbiAgfVxuICBncm91cChpdGVtcykge1xuICAgIHRoaXMuc2F2ZSgpO1xuICAgIHRoaXMuZXhlY3V0ZU9wVHJlZShpdGVtcyk7XG4gICAgdGhpcy5yZXN0b3JlKCk7XG4gIH1cbiAgbG9hZERlcGVuZGVuY2llcyhvcGVyYXRvckxpc3QpIHtcbiAgICBjb25zdCBmbkFycmF5ID0gb3BlcmF0b3JMaXN0LmZuQXJyYXk7XG4gICAgY29uc3QgYXJnc0FycmF5ID0gb3BlcmF0b3JMaXN0LmFyZ3NBcnJheTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBmbkFycmF5Lmxlbmd0aDsgaSA8IGlpOyBpKyspIHtcbiAgICAgIGlmIChmbkFycmF5W2ldICE9PSBfdXRpbC5PUFMuZGVwZW5kZW5jeSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGZvciAoY29uc3Qgb2JqIG9mIGFyZ3NBcnJheVtpXSkge1xuICAgICAgICBjb25zdCBvYmpzUG9vbCA9IG9iai5zdGFydHNXaXRoKFwiZ19cIikgPyB0aGlzLmNvbW1vbk9ianMgOiB0aGlzLm9ianM7XG4gICAgICAgIGNvbnN0IHByb21pc2UgPSBuZXcgUHJvbWlzZShyZXNvbHZlID0+IHtcbiAgICAgICAgICBvYmpzUG9vbC5nZXQob2JqLCByZXNvbHZlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuY3VycmVudC5kZXBlbmRlbmNpZXMucHVzaChwcm9taXNlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKHRoaXMuY3VycmVudC5kZXBlbmRlbmNpZXMpO1xuICB9XG4gIHRyYW5zZm9ybShhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtTWF0cml4ID0gW2EsIGIsIGMsIGQsIGUsIGZdO1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gX3V0aWwuVXRpbC50cmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgsIHRyYW5zZm9ybU1hdHJpeCk7XG4gICAgdGhpcy50Z3JwID0gbnVsbDtcbiAgfVxuICBnZXRTVkcob3BlcmF0b3JMaXN0LCB2aWV3cG9ydCkge1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICBjb25zdCBzdmdFbGVtZW50ID0gdGhpcy5faW5pdGlhbGl6ZSh2aWV3cG9ydCk7XG4gICAgcmV0dXJuIHRoaXMubG9hZERlcGVuZGVuY2llcyhvcGVyYXRvckxpc3QpLnRoZW4oKCkgPT4ge1xuICAgICAgdGhpcy50cmFuc2Zvcm1NYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgICB0aGlzLmV4ZWN1dGVPcFRyZWUodGhpcy5jb252ZXJ0T3BMaXN0KG9wZXJhdG9yTGlzdCkpO1xuICAgICAgcmV0dXJuIHN2Z0VsZW1lbnQ7XG4gICAgfSk7XG4gIH1cbiAgY29udmVydE9wTGlzdChvcGVyYXRvckxpc3QpIHtcbiAgICBjb25zdCBvcGVyYXRvcklkTWFwcGluZyA9IHRoaXMuX29wZXJhdG9ySWRNYXBwaW5nO1xuICAgIGNvbnN0IGFyZ3NBcnJheSA9IG9wZXJhdG9yTGlzdC5hcmdzQXJyYXk7XG4gICAgY29uc3QgZm5BcnJheSA9IG9wZXJhdG9yTGlzdC5mbkFycmF5O1xuICAgIGNvbnN0IG9wTGlzdCA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IGZuQXJyYXkubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgZm5JZCA9IGZuQXJyYXlbaV07XG4gICAgICBvcExpc3QucHVzaCh7XG4gICAgICAgIGZuSWQsXG4gICAgICAgIGZuOiBvcGVyYXRvcklkTWFwcGluZ1tmbklkXSxcbiAgICAgICAgYXJnczogYXJnc0FycmF5W2ldXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG9wTGlzdFRvVHJlZShvcExpc3QpO1xuICB9XG4gIGV4ZWN1dGVPcFRyZWUob3BUcmVlKSB7XG4gICAgZm9yIChjb25zdCBvcFRyZWVFbGVtZW50IG9mIG9wVHJlZSkge1xuICAgICAgY29uc3QgZm4gPSBvcFRyZWVFbGVtZW50LmZuO1xuICAgICAgY29uc3QgZm5JZCA9IG9wVHJlZUVsZW1lbnQuZm5JZDtcbiAgICAgIGNvbnN0IGFyZ3MgPSBvcFRyZWVFbGVtZW50LmFyZ3M7XG4gICAgICBzd2l0Y2ggKGZuSWQgfCAwKSB7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmJlZ2luVGV4dDpcbiAgICAgICAgICB0aGlzLmJlZ2luVGV4dCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5kZXBlbmRlbmN5OlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMZWFkaW5nOlxuICAgICAgICAgIHRoaXMuc2V0TGVhZGluZyhhcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGVhZGluZ01vdmVUZXh0OlxuICAgICAgICAgIHRoaXMuc2V0TGVhZGluZ01vdmVUZXh0KGFyZ3NbMF0sIGFyZ3NbMV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGb250OlxuICAgICAgICAgIHRoaXMuc2V0Rm9udChhcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hvd1RleHQ6XG4gICAgICAgICAgdGhpcy5zaG93VGV4dChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hvd1NwYWNlZFRleHQ6XG4gICAgICAgICAgdGhpcy5zaG93VGV4dChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW5kVGV4dDpcbiAgICAgICAgICB0aGlzLmVuZFRleHQoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMubW92ZVRleHQ6XG4gICAgICAgICAgdGhpcy5tb3ZlVGV4dChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0Q2hhclNwYWNpbmc6XG4gICAgICAgICAgdGhpcy5zZXRDaGFyU3BhY2luZyhhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0V29yZFNwYWNpbmc6XG4gICAgICAgICAgdGhpcy5zZXRXb3JkU3BhY2luZyhhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0SFNjYWxlOlxuICAgICAgICAgIHRoaXMuc2V0SFNjYWxlKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRUZXh0TWF0cml4OlxuICAgICAgICAgIHRoaXMuc2V0VGV4dE1hdHJpeChhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdLCBhcmdzWzNdLCBhcmdzWzRdLCBhcmdzWzVdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dFJpc2U6XG4gICAgICAgICAgdGhpcy5zZXRUZXh0UmlzZShhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0VGV4dFJlbmRlcmluZ01vZGU6XG4gICAgICAgICAgdGhpcy5zZXRUZXh0UmVuZGVyaW5nTW9kZShhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TGluZVdpZHRoOlxuICAgICAgICAgIHRoaXMuc2V0TGluZVdpZHRoKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lSm9pbjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRMaW5lQ2FwOlxuICAgICAgICAgIHRoaXMuc2V0TGluZUNhcChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0TWl0ZXJMaW1pdDpcbiAgICAgICAgICB0aGlzLnNldE1pdGVyTGltaXQoYXJnc1swXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldEZpbGxSR0JDb2xvcjpcbiAgICAgICAgICB0aGlzLnNldEZpbGxSR0JDb2xvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0U3Ryb2tlUkdCQ29sb3I6XG4gICAgICAgICAgdGhpcy5zZXRTdHJva2VSR0JDb2xvcihhcmdzWzBdLCBhcmdzWzFdLCBhcmdzWzJdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0U3Ryb2tlQ29sb3JOOlxuICAgICAgICAgIHRoaXMuc2V0U3Ryb2tlQ29sb3JOKGFyZ3MpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5zZXRGaWxsQ29sb3JOOlxuICAgICAgICAgIHRoaXMuc2V0RmlsbENvbG9yTihhcmdzKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2hhZGluZ0ZpbGw6XG4gICAgICAgICAgdGhpcy5zaGFkaW5nRmlsbChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RGFzaDpcbiAgICAgICAgICB0aGlzLnNldERhc2goYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnNldFJlbmRlcmluZ0ludGVudDpcbiAgICAgICAgICB0aGlzLnNldFJlbmRlcmluZ0ludGVudChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0RmxhdG5lc3M6XG4gICAgICAgICAgdGhpcy5zZXRGbGF0bmVzcyhhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc2V0R1N0YXRlOlxuICAgICAgICAgIHRoaXMuc2V0R1N0YXRlKGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5maWxsOlxuICAgICAgICAgIHRoaXMuZmlsbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5lb0ZpbGw6XG4gICAgICAgICAgdGhpcy5lb0ZpbGwoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuc3Ryb2tlOlxuICAgICAgICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmZpbGxTdHJva2U6XG4gICAgICAgICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvRmlsbFN0cm9rZTpcbiAgICAgICAgICB0aGlzLmVvRmlsbFN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbGlwOlxuICAgICAgICAgIHRoaXMuY2xpcChcIm5vbnplcm9cIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmVvQ2xpcDpcbiAgICAgICAgICB0aGlzLmNsaXAoXCJldmVub2RkXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludFNvbGlkQ29sb3JJbWFnZU1hc2s6XG4gICAgICAgICAgdGhpcy5wYWludFNvbGlkQ29sb3JJbWFnZU1hc2soKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbWFnZVhPYmplY3Q6XG4gICAgICAgICAgdGhpcy5wYWludEltYWdlWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3Q6XG4gICAgICAgICAgdGhpcy5wYWludElubGluZUltYWdlWE9iamVjdChhcmdzWzBdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMucGFpbnRJbWFnZU1hc2tYT2JqZWN0OlxuICAgICAgICAgIHRoaXMucGFpbnRJbWFnZU1hc2tYT2JqZWN0KGFyZ3NbMF0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5wYWludEZvcm1YT2JqZWN0QmVnaW46XG4gICAgICAgICAgdGhpcy5wYWludEZvcm1YT2JqZWN0QmVnaW4oYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLnBhaW50Rm9ybVhPYmplY3RFbmQ6XG4gICAgICAgICAgdGhpcy5wYWludEZvcm1YT2JqZWN0RW5kKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlUGF0aDpcbiAgICAgICAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZVN0cm9rZTpcbiAgICAgICAgICB0aGlzLmNsb3NlU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLmNsb3NlRmlsbFN0cm9rZTpcbiAgICAgICAgICB0aGlzLmNsb3NlRmlsbFN0cm9rZSgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jbG9zZUVPRmlsbFN0cm9rZTpcbiAgICAgICAgICB0aGlzLmNsb3NlRU9GaWxsU3Ryb2tlKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLm5leHRMaW5lOlxuICAgICAgICAgIHRoaXMubmV4dExpbmUoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMudHJhbnNmb3JtOlxuICAgICAgICAgIHRoaXMudHJhbnNmb3JtKGFyZ3NbMF0sIGFyZ3NbMV0sIGFyZ3NbMl0sIGFyZ3NbM10sIGFyZ3NbNF0sIGFyZ3NbNV0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jb25zdHJ1Y3RQYXRoOlxuICAgICAgICAgIHRoaXMuY29uc3RydWN0UGF0aChhcmdzWzBdLCBhcmdzWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuZW5kUGF0aDpcbiAgICAgICAgICB0aGlzLmVuZFBhdGgoKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSA5MjpcbiAgICAgICAgICB0aGlzLmdyb3VwKG9wVHJlZUVsZW1lbnQuaXRlbXMpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgVW5pbXBsZW1lbnRlZCBvcGVyYXRvciAke2ZufWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBzZXRXb3JkU3BhY2luZyh3b3JkU3BhY2luZykge1xuICAgIHRoaXMuY3VycmVudC53b3JkU3BhY2luZyA9IHdvcmRTcGFjaW5nO1xuICB9XG4gIHNldENoYXJTcGFjaW5nKGNoYXJTcGFjaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmNoYXJTcGFjaW5nID0gY2hhclNwYWNpbmc7XG4gIH1cbiAgbmV4dExpbmUoKSB7XG4gICAgdGhpcy5tb3ZlVGV4dCgwLCB0aGlzLmN1cnJlbnQubGVhZGluZyk7XG4gIH1cbiAgc2V0VGV4dE1hdHJpeChhLCBiLCBjLCBkLCBlLCBmKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXggPSBjdXJyZW50LmxpbmVNYXRyaXggPSBbYSwgYiwgYywgZCwgZSwgZl07XG4gICAgY3VycmVudC50ZXh0TWF0cml4U2NhbGUgPSBNYXRoLmh5cG90KGEsIGIpO1xuICAgIGN1cnJlbnQueCA9IGN1cnJlbnQubGluZVggPSAwO1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgPSAwO1xuICAgIGN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgIGN1cnJlbnQueWNvb3JkcyA9IFtdO1xuICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1mYW1pbHlcIiwgY3VycmVudC5mb250RmFtaWx5KTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZm9udC1zaXplXCIsIGAke3BmKGN1cnJlbnQuZm9udFNpemUpfXB4YCk7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgIGN1cnJlbnQudHh0RWxlbWVudCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnRleHRcIik7XG4gICAgY3VycmVudC50eHRFbGVtZW50LmFwcGVuZChjdXJyZW50LnRzcGFuKTtcbiAgfVxuICBiZWdpblRleHQoKSB7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBjdXJyZW50LnggPSBjdXJyZW50LmxpbmVYID0gMDtcbiAgICBjdXJyZW50LnkgPSBjdXJyZW50LmxpbmVZID0gMDtcbiAgICBjdXJyZW50LnRleHRNYXRyaXggPSBfdXRpbC5JREVOVElUWV9NQVRSSVg7XG4gICAgY3VycmVudC5saW5lTWF0cml4ID0gX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIGN1cnJlbnQudGV4dE1hdHJpeFNjYWxlID0gMTtcbiAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgY3VycmVudC50eHRFbGVtZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dGV4dFwiKTtcbiAgICBjdXJyZW50LnR4dGdycCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgY3VycmVudC55Y29vcmRzID0gW107XG4gIH1cbiAgbW92ZVRleHQoeCwgeSkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY3VycmVudC54ID0gY3VycmVudC5saW5lWCArPSB4O1xuICAgIGN1cnJlbnQueSA9IGN1cnJlbnQubGluZVkgKz0geTtcbiAgICBjdXJyZW50Lnhjb29yZHMgPSBbXTtcbiAgICBjdXJyZW50Lnljb29yZHMgPSBbXTtcbiAgICBjdXJyZW50LnRzcGFuID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6dHNwYW5cIik7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtZmFtaWx5XCIsIGN1cnJlbnQuZm9udEZhbWlseSk7XG4gICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZvbnQtc2l6ZVwiLCBgJHtwZihjdXJyZW50LmZvbnRTaXplKX1weGApO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIHBmKC1jdXJyZW50LnkpKTtcbiAgfVxuICBzaG93VGV4dChnbHlwaHMpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGNvbnN0IGZvbnQgPSBjdXJyZW50LmZvbnQ7XG4gICAgY29uc3QgZm9udFNpemUgPSBjdXJyZW50LmZvbnRTaXplO1xuICAgIGlmIChmb250U2l6ZSA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBmb250U2l6ZVNjYWxlID0gY3VycmVudC5mb250U2l6ZVNjYWxlO1xuICAgIGNvbnN0IGNoYXJTcGFjaW5nID0gY3VycmVudC5jaGFyU3BhY2luZztcbiAgICBjb25zdCB3b3JkU3BhY2luZyA9IGN1cnJlbnQud29yZFNwYWNpbmc7XG4gICAgY29uc3QgZm9udERpcmVjdGlvbiA9IGN1cnJlbnQuZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB0ZXh0SFNjYWxlID0gY3VycmVudC50ZXh0SFNjYWxlICogZm9udERpcmVjdGlvbjtcbiAgICBjb25zdCB2ZXJ0aWNhbCA9IGZvbnQudmVydGljYWw7XG4gICAgY29uc3Qgc3BhY2luZ0RpciA9IHZlcnRpY2FsID8gMSA6IC0xO1xuICAgIGNvbnN0IGRlZmF1bHRWTWV0cmljcyA9IGZvbnQuZGVmYXVsdFZNZXRyaWNzO1xuICAgIGNvbnN0IHdpZHRoQWR2YW5jZVNjYWxlID0gZm9udFNpemUgKiBjdXJyZW50LmZvbnRNYXRyaXhbMF07XG4gICAgbGV0IHggPSAwO1xuICAgIGZvciAoY29uc3QgZ2x5cGggb2YgZ2x5cGhzKSB7XG4gICAgICBpZiAoZ2x5cGggPT09IG51bGwpIHtcbiAgICAgICAgeCArPSBmb250RGlyZWN0aW9uICogd29yZFNwYWNpbmc7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgZ2x5cGggPT09IFwibnVtYmVyXCIpIHtcbiAgICAgICAgeCArPSBzcGFjaW5nRGlyICogZ2x5cGggKiBmb250U2l6ZSAvIDEwMDA7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3Qgc3BhY2luZyA9IChnbHlwaC5pc1NwYWNlID8gd29yZFNwYWNpbmcgOiAwKSArIGNoYXJTcGFjaW5nO1xuICAgICAgY29uc3QgY2hhcmFjdGVyID0gZ2x5cGguZm9udENoYXI7XG4gICAgICBsZXQgc2NhbGVkWCwgc2NhbGVkWTtcbiAgICAgIGxldCB3aWR0aCA9IGdseXBoLndpZHRoO1xuICAgICAgaWYgKHZlcnRpY2FsKSB7XG4gICAgICAgIGxldCB2eDtcbiAgICAgICAgY29uc3Qgdm1ldHJpYyA9IGdseXBoLnZtZXRyaWMgfHwgZGVmYXVsdFZNZXRyaWNzO1xuICAgICAgICB2eCA9IGdseXBoLnZtZXRyaWMgPyB2bWV0cmljWzFdIDogd2lkdGggKiAwLjU7XG4gICAgICAgIHZ4ID0gLXZ4ICogd2lkdGhBZHZhbmNlU2NhbGU7XG4gICAgICAgIGNvbnN0IHZ5ID0gdm1ldHJpY1syXSAqIHdpZHRoQWR2YW5jZVNjYWxlO1xuICAgICAgICB3aWR0aCA9IHZtZXRyaWMgPyAtdm1ldHJpY1swXSA6IHdpZHRoO1xuICAgICAgICBzY2FsZWRYID0gdnggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gKHggKyB2eSkgLyBmb250U2l6ZVNjYWxlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgc2NhbGVkWCA9IHggLyBmb250U2l6ZVNjYWxlO1xuICAgICAgICBzY2FsZWRZID0gMDtcbiAgICAgIH1cbiAgICAgIGlmIChnbHlwaC5pc0luRm9udCB8fCBmb250Lm1pc3NpbmdGaWxlKSB7XG4gICAgICAgIGN1cnJlbnQueGNvb3Jkcy5wdXNoKGN1cnJlbnQueCArIHNjYWxlZFgpO1xuICAgICAgICBpZiAodmVydGljYWwpIHtcbiAgICAgICAgICBjdXJyZW50Lnljb29yZHMucHVzaCgtY3VycmVudC55ICsgc2NhbGVkWSk7XG4gICAgICAgIH1cbiAgICAgICAgY3VycmVudC50c3Bhbi50ZXh0Q29udGVudCArPSBjaGFyYWN0ZXI7XG4gICAgICB9IGVsc2Uge31cbiAgICAgIGNvbnN0IGNoYXJXaWR0aCA9IHZlcnRpY2FsID8gd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSAtIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uIDogd2lkdGggKiB3aWR0aEFkdmFuY2VTY2FsZSArIHNwYWNpbmcgKiBmb250RGlyZWN0aW9uO1xuICAgICAgeCArPSBjaGFyV2lkdGg7XG4gICAgfVxuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ4XCIsIGN1cnJlbnQueGNvb3Jkcy5tYXAocGYpLmpvaW4oXCIgXCIpKTtcbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIGN1cnJlbnQueWNvb3Jkcy5tYXAocGYpLmpvaW4oXCIgXCIpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY3VycmVudC50c3Bhbi5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgcGYoLWN1cnJlbnQueSkpO1xuICAgIH1cbiAgICBpZiAodmVydGljYWwpIHtcbiAgICAgIGN1cnJlbnQueSAtPSB4O1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnggKz0geCAqIHRleHRIU2NhbGU7XG4gICAgfVxuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LWZhbWlseVwiLCBjdXJyZW50LmZvbnRGYW1pbHkpO1xuICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXNpemVcIiwgYCR7cGYoY3VycmVudC5mb250U2l6ZSl9cHhgKTtcbiAgICBpZiAoY3VycmVudC5mb250U3R5bGUgIT09IFNWR19ERUZBVUxUUy5mb250U3R5bGUpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXN0eWxlXCIsIGN1cnJlbnQuZm9udFN0eWxlKTtcbiAgICB9XG4gICAgaWYgKGN1cnJlbnQuZm9udFdlaWdodCAhPT0gU1ZHX0RFRkFVTFRTLmZvbnRXZWlnaHQpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmb250LXdlaWdodFwiLCBjdXJyZW50LmZvbnRXZWlnaHQpO1xuICAgIH1cbiAgICBjb25zdCBmaWxsU3Ryb2tlTW9kZSA9IGN1cnJlbnQudGV4dFJlbmRlcmluZ01vZGUgJiBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5GSUxMX1NUUk9LRV9NQVNLO1xuICAgIGlmIChmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTCB8fCBmaWxsU3Ryb2tlTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuRklMTF9TVFJPS0UpIHtcbiAgICAgIGlmIChjdXJyZW50LmZpbGxDb2xvciAhPT0gU1ZHX0RFRkFVTFRTLmZpbGxDb2xvcikge1xuICAgICAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBjdXJyZW50LmZpbGxDb2xvcik7XG4gICAgICB9XG4gICAgICBpZiAoY3VycmVudC5maWxsQWxwaGEgPCAxKSB7XG4gICAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgY3VycmVudC5maWxsQWxwaGEpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoY3VycmVudC50ZXh0UmVuZGVyaW5nTW9kZSA9PT0gX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEgpIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQudHNwYW4uc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICB9XG4gICAgaWYgKGZpbGxTdHJva2VNb2RlID09PSBfdXRpbC5UZXh0UmVuZGVyaW5nTW9kZS5TVFJPS0UgfHwgZmlsbFN0cm9rZU1vZGUgPT09IF91dGlsLlRleHRSZW5kZXJpbmdNb2RlLkZJTExfU1RST0tFKSB7XG4gICAgICBjb25zdCBsaW5lV2lkdGhTY2FsZSA9IDEgLyAoY3VycmVudC50ZXh0TWF0cml4U2NhbGUgfHwgMSk7XG4gICAgICB0aGlzLl9zZXRTdHJva2VBdHRyaWJ1dGVzKGN1cnJlbnQudHNwYW4sIGxpbmVXaWR0aFNjYWxlKTtcbiAgICB9XG4gICAgbGV0IHRleHRNYXRyaXggPSBjdXJyZW50LnRleHRNYXRyaXg7XG4gICAgaWYgKGN1cnJlbnQudGV4dFJpc2UgIT09IDApIHtcbiAgICAgIHRleHRNYXRyaXggPSB0ZXh0TWF0cml4LnNsaWNlKCk7XG4gICAgICB0ZXh0TWF0cml4WzVdICs9IGN1cnJlbnQudGV4dFJpc2U7XG4gICAgfVxuICAgIGN1cnJlbnQudHh0RWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInRyYW5zZm9ybVwiLCBgJHtwbSh0ZXh0TWF0cml4KX0gc2NhbGUoJHtwZih0ZXh0SFNjYWxlKX0sIC0xKWApO1xuICAgIGN1cnJlbnQudHh0RWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhYTUxfTlMsIFwieG1sOnNwYWNlXCIsIFwicHJlc2VydmVcIik7XG4gICAgY3VycmVudC50eHRFbGVtZW50LmFwcGVuZChjdXJyZW50LnRzcGFuKTtcbiAgICBjdXJyZW50LnR4dGdycC5hcHBlbmQoY3VycmVudC50eHRFbGVtZW50KTtcbiAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChjdXJyZW50LnR4dEVsZW1lbnQpO1xuICB9XG4gIHNldExlYWRpbmdNb3ZlVGV4dCh4LCB5KSB7XG4gICAgdGhpcy5zZXRMZWFkaW5nKC15KTtcbiAgICB0aGlzLm1vdmVUZXh0KHgsIHkpO1xuICB9XG4gIGFkZEZvbnRTdHlsZShmb250T2JqKSB7XG4gICAgaWYgKCFmb250T2JqLmRhdGEpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcImFkZEZvbnRTdHlsZTogTm8gZm9udCBkYXRhIGF2YWlsYWJsZSwgXCIgKyAnZW5zdXJlIHRoYXQgdGhlIFwiZm9udEV4dHJhUHJvcGVydGllc1wiIEFQSSBwYXJhbWV0ZXIgaXMgc2V0LicpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY3NzU3R5bGUpIHtcbiAgICAgIHRoaXMuY3NzU3R5bGUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpzdHlsZVwiKTtcbiAgICAgIHRoaXMuY3NzU3R5bGUuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ0eXBlXCIsIFwidGV4dC9jc3NcIik7XG4gICAgICB0aGlzLmRlZnMuYXBwZW5kKHRoaXMuY3NzU3R5bGUpO1xuICAgIH1cbiAgICBjb25zdCB1cmwgPSBjcmVhdGVPYmplY3RVUkwoZm9udE9iai5kYXRhLCBmb250T2JqLm1pbWV0eXBlLCB0aGlzLmZvcmNlRGF0YVNjaGVtYSk7XG4gICAgdGhpcy5jc3NTdHlsZS50ZXh0Q29udGVudCArPSBgQGZvbnQtZmFjZSB7IGZvbnQtZmFtaWx5OiBcIiR7Zm9udE9iai5sb2FkZWROYW1lfVwiO2AgKyBgIHNyYzogdXJsKCR7dXJsfSk7IH1cXG5gO1xuICB9XG4gIHNldEZvbnQoZGV0YWlscykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3QgZm9udE9iaiA9IHRoaXMuY29tbW9uT2Jqcy5nZXQoZGV0YWlsc1swXSk7XG4gICAgbGV0IHNpemUgPSBkZXRhaWxzWzFdO1xuICAgIGN1cnJlbnQuZm9udCA9IGZvbnRPYmo7XG4gICAgaWYgKHRoaXMuZW1iZWRGb250cyAmJiAhZm9udE9iai5taXNzaW5nRmlsZSAmJiAhdGhpcy5lbWJlZGRlZEZvbnRzW2ZvbnRPYmoubG9hZGVkTmFtZV0pIHtcbiAgICAgIHRoaXMuYWRkRm9udFN0eWxlKGZvbnRPYmopO1xuICAgICAgdGhpcy5lbWJlZGRlZEZvbnRzW2ZvbnRPYmoubG9hZGVkTmFtZV0gPSBmb250T2JqO1xuICAgIH1cbiAgICBjdXJyZW50LmZvbnRNYXRyaXggPSBmb250T2JqLmZvbnRNYXRyaXggfHwgX3V0aWwuRk9OVF9JREVOVElUWV9NQVRSSVg7XG4gICAgbGV0IGJvbGQgPSBcIm5vcm1hbFwiO1xuICAgIGlmIChmb250T2JqLmJsYWNrKSB7XG4gICAgICBib2xkID0gXCI5MDBcIjtcbiAgICB9IGVsc2UgaWYgKGZvbnRPYmouYm9sZCkge1xuICAgICAgYm9sZCA9IFwiYm9sZFwiO1xuICAgIH1cbiAgICBjb25zdCBpdGFsaWMgPSBmb250T2JqLml0YWxpYyA/IFwiaXRhbGljXCIgOiBcIm5vcm1hbFwiO1xuICAgIGlmIChzaXplIDwgMCkge1xuICAgICAgc2l6ZSA9IC1zaXplO1xuICAgICAgY3VycmVudC5mb250RGlyZWN0aW9uID0gLTE7XG4gICAgfSBlbHNlIHtcbiAgICAgIGN1cnJlbnQuZm9udERpcmVjdGlvbiA9IDE7XG4gICAgfVxuICAgIGN1cnJlbnQuZm9udFNpemUgPSBzaXplO1xuICAgIGN1cnJlbnQuZm9udEZhbWlseSA9IGZvbnRPYmoubG9hZGVkTmFtZTtcbiAgICBjdXJyZW50LmZvbnRXZWlnaHQgPSBib2xkO1xuICAgIGN1cnJlbnQuZm9udFN0eWxlID0gaXRhbGljO1xuICAgIGN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICBjdXJyZW50LnRzcGFuLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtY3VycmVudC55KSk7XG4gICAgY3VycmVudC54Y29vcmRzID0gW107XG4gICAgY3VycmVudC55Y29vcmRzID0gW107XG4gIH1cbiAgZW5kVGV4dCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlICYgX3V0aWwuVGV4dFJlbmRlcmluZ01vZGUuQUREX1RPX1BBVEhfRkxBRyAmJiBjdXJyZW50LnR4dEVsZW1lbnQ/Lmhhc0NoaWxkTm9kZXMoKSkge1xuICAgICAgY3VycmVudC5lbGVtZW50ID0gY3VycmVudC50eHRFbGVtZW50O1xuICAgICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICAgIHRoaXMuZW5kUGF0aCgpO1xuICAgIH1cbiAgfVxuICBzZXRMaW5lV2lkdGgod2lkdGgpIHtcbiAgICBpZiAod2lkdGggPiAwKSB7XG4gICAgICB0aGlzLmN1cnJlbnQubGluZVdpZHRoID0gd2lkdGg7XG4gICAgfVxuICB9XG4gIHNldExpbmVDYXAoc3R5bGUpIHtcbiAgICB0aGlzLmN1cnJlbnQubGluZUNhcCA9IExJTkVfQ0FQX1NUWUxFU1tzdHlsZV07XG4gIH1cbiAgc2V0TGluZUpvaW4oc3R5bGUpIHtcbiAgICB0aGlzLmN1cnJlbnQubGluZUpvaW4gPSBMSU5FX0pPSU5fU1RZTEVTW3N0eWxlXTtcbiAgfVxuICBzZXRNaXRlckxpbWl0KGxpbWl0KSB7XG4gICAgdGhpcy5jdXJyZW50Lm1pdGVyTGltaXQgPSBsaW1pdDtcbiAgfVxuICBzZXRTdHJva2VBbHBoYShzdHJva2VBbHBoYSkge1xuICAgIHRoaXMuY3VycmVudC5zdHJva2VBbHBoYSA9IHN0cm9rZUFscGhhO1xuICB9XG4gIHNldFN0cm9rZVJHQkNvbG9yKHIsIGcsIGIpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgfVxuICBzZXRGaWxsQWxwaGEoZmlsbEFscGhhKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxBbHBoYSA9IGZpbGxBbHBoYTtcbiAgfVxuICBzZXRGaWxsUkdCQ29sb3IociwgZywgYikge1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihyLCBnLCBiKTtcbiAgICB0aGlzLmN1cnJlbnQudHNwYW4gPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2Zzp0c3BhblwiKTtcbiAgICB0aGlzLmN1cnJlbnQueGNvb3JkcyA9IFtdO1xuICAgIHRoaXMuY3VycmVudC55Y29vcmRzID0gW107XG4gIH1cbiAgc2V0U3Ryb2tlQ29sb3JOKGFyZ3MpIHtcbiAgICB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3IgPSB0aGlzLl9tYWtlQ29sb3JOX1BhdHRlcm4oYXJncyk7XG4gIH1cbiAgc2V0RmlsbENvbG9yTihhcmdzKSB7XG4gICAgdGhpcy5jdXJyZW50LmZpbGxDb2xvciA9IHRoaXMuX21ha2VDb2xvck5fUGF0dGVybihhcmdzKTtcbiAgfVxuICBzaGFkaW5nRmlsbChhcmdzKSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy52aWV3cG9ydDtcbiAgICBjb25zdCBpbnYgPSBfdXRpbC5VdGlsLmludmVyc2VUcmFuc2Zvcm0odGhpcy50cmFuc2Zvcm1NYXRyaXgpO1xuICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBfdXRpbC5VdGlsLmdldEF4aWFsQWxpZ25lZEJvdW5kaW5nQm94KFswLCAwLCB3aWR0aCwgaGVpZ2h0XSwgaW52KTtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCB4MCk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgeTApO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB4MSAtIHgwKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHkxIC0geTApO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIHRoaXMuX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKSk7XG4gICAgaWYgKHRoaXMuY3VycmVudC5maWxsQWxwaGEgPCAxKSB7XG4gICAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1vcGFjaXR5XCIsIHRoaXMuY3VycmVudC5maWxsQWxwaGEpO1xuICAgIH1cbiAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChyZWN0KTtcbiAgfVxuICBfbWFrZUNvbG9yTl9QYXR0ZXJuKGFyZ3MpIHtcbiAgICBpZiAoYXJnc1swXSA9PT0gXCJUaWxpbmdQYXR0ZXJuXCIpIHtcbiAgICAgIHJldHVybiB0aGlzLl9tYWtlVGlsaW5nUGF0dGVybihhcmdzKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuX21ha2VTaGFkaW5nUGF0dGVybihhcmdzKTtcbiAgfVxuICBfbWFrZVRpbGluZ1BhdHRlcm4oYXJncykge1xuICAgIGNvbnN0IGNvbG9yID0gYXJnc1sxXTtcbiAgICBjb25zdCBvcGVyYXRvckxpc3QgPSBhcmdzWzJdO1xuICAgIGNvbnN0IG1hdHJpeCA9IGFyZ3NbM10gfHwgX3V0aWwuSURFTlRJVFlfTUFUUklYO1xuICAgIGNvbnN0IFt4MCwgeTAsIHgxLCB5MV0gPSBhcmdzWzRdO1xuICAgIGNvbnN0IHhzdGVwID0gYXJnc1s1XTtcbiAgICBjb25zdCB5c3RlcCA9IGFyZ3NbNl07XG4gICAgY29uc3QgcGFpbnRUeXBlID0gYXJnc1s3XTtcbiAgICBjb25zdCB0aWxpbmdJZCA9IGBzaGFkaW5nJHtzaGFkaW5nQ291bnQrK31gO1xuICAgIGNvbnN0IFt0eDAsIHR5MCwgdHgxLCB0eTFdID0gX3V0aWwuVXRpbC5ub3JtYWxpemVSZWN0KFsuLi5fdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4MCwgeTBdLCBtYXRyaXgpLCAuLi5fdXRpbC5VdGlsLmFwcGx5VHJhbnNmb3JtKFt4MSwgeTFdLCBtYXRyaXgpXSk7XG4gICAgY29uc3QgW3hzY2FsZSwgeXNjYWxlXSA9IF91dGlsLlV0aWwuc2luZ3VsYXJWYWx1ZURlY29tcG9zZTJkU2NhbGUobWF0cml4KTtcbiAgICBjb25zdCB0eHN0ZXAgPSB4c3RlcCAqIHhzY2FsZTtcbiAgICBjb25zdCB0eXN0ZXAgPSB5c3RlcCAqIHlzY2FsZTtcbiAgICBjb25zdCB0aWxpbmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXR0ZXJuXCIpO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHRpbGluZ0lkKTtcbiAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJwYXR0ZXJuVW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICB0aWxpbmcuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCB0eHN0ZXApO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCB0eXN0ZXApO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgYCR7dHgwfWApO1xuICAgIHRpbGluZy5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgYCR7dHkwfWApO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnO1xuICAgIGNvbnN0IHRyYW5zZm9ybU1hdHJpeCA9IHRoaXMudHJhbnNmb3JtTWF0cml4O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IHRoaXMuY3VycmVudC5maWxsQ29sb3I7XG4gICAgY29uc3Qgc3Ryb2tlQ29sb3IgPSB0aGlzLmN1cnJlbnQuc3Ryb2tlQ29sb3I7XG4gICAgY29uc3QgYmJveCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUodHgxIC0gdHgwLCB0eTEgLSB0eTApO1xuICAgIHRoaXMuc3ZnID0gYmJveDtcbiAgICB0aGlzLnRyYW5zZm9ybU1hdHJpeCA9IG1hdHJpeDtcbiAgICBpZiAocGFpbnRUeXBlID09PSAyKSB7XG4gICAgICBjb25zdCBjc3NDb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKC4uLmNvbG9yKTtcbiAgICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBjc3NDb2xvcjtcbiAgICAgIHRoaXMuY3VycmVudC5zdHJva2VDb2xvciA9IGNzc0NvbG9yO1xuICAgIH1cbiAgICB0aGlzLmV4ZWN1dGVPcFRyZWUodGhpcy5jb252ZXJ0T3BMaXN0KG9wZXJhdG9yTGlzdCkpO1xuICAgIHRoaXMuc3ZnID0gc3ZnO1xuICAgIHRoaXMudHJhbnNmb3JtTWF0cml4ID0gdHJhbnNmb3JtTWF0cml4O1xuICAgIHRoaXMuY3VycmVudC5maWxsQ29sb3IgPSBmaWxsQ29sb3I7XG4gICAgdGhpcy5jdXJyZW50LnN0cm9rZUNvbG9yID0gc3Ryb2tlQ29sb3I7XG4gICAgdGlsaW5nLmFwcGVuZChiYm94LmNoaWxkTm9kZXNbMF0pO1xuICAgIHRoaXMuZGVmcy5hcHBlbmQodGlsaW5nKTtcbiAgICByZXR1cm4gYHVybCgjJHt0aWxpbmdJZH0pYDtcbiAgfVxuICBfbWFrZVNoYWRpbmdQYXR0ZXJuKGFyZ3MpIHtcbiAgICBpZiAodHlwZW9mIGFyZ3MgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIGFyZ3MgPSB0aGlzLm9ianMuZ2V0KGFyZ3MpO1xuICAgIH1cbiAgICBzd2l0Y2ggKGFyZ3NbMF0pIHtcbiAgICAgIGNhc2UgXCJSYWRpYWxBeGlhbFwiOlxuICAgICAgICBjb25zdCBzaGFkaW5nSWQgPSBgc2hhZGluZyR7c2hhZGluZ0NvdW50Kyt9YDtcbiAgICAgICAgY29uc3QgY29sb3JTdG9wcyA9IGFyZ3NbM107XG4gICAgICAgIGxldCBncmFkaWVudDtcbiAgICAgICAgc3dpdGNoIChhcmdzWzFdKSB7XG4gICAgICAgICAgY2FzZSBcImF4aWFsXCI6XG4gICAgICAgICAgICBjb25zdCBwb2ludDAgPSBhcmdzWzRdO1xuICAgICAgICAgICAgY29uc3QgcG9pbnQxID0gYXJnc1s1XTtcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZWFyR3JhZGllbnRcIik7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHNoYWRpbmdJZCk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieDFcIiwgcG9pbnQwWzBdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieTFcIiwgcG9pbnQwWzFdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieDJcIiwgcG9pbnQxWzBdKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieTJcIiwgcG9pbnQxWzFdKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJyYWRpYWxcIjpcbiAgICAgICAgICAgIGNvbnN0IGZvY2FsUG9pbnQgPSBhcmdzWzRdO1xuICAgICAgICAgICAgY29uc3QgY2lyY2xlUG9pbnQgPSBhcmdzWzVdO1xuICAgICAgICAgICAgY29uc3QgZm9jYWxSYWRpdXMgPSBhcmdzWzZdO1xuICAgICAgICAgICAgY29uc3QgY2lyY2xlUmFkaXVzID0gYXJnc1s3XTtcbiAgICAgICAgICAgIGdyYWRpZW50ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmFkaWFsR3JhZGllbnRcIik7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIHNoYWRpbmdJZCk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImdyYWRpZW50VW5pdHNcIiwgXCJ1c2VyU3BhY2VPblVzZVwiKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY3hcIiwgY2lyY2xlUG9pbnRbMF0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjeVwiLCBjaXJjbGVQb2ludFsxXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInJcIiwgY2lyY2xlUmFkaXVzKTtcbiAgICAgICAgICAgIGdyYWRpZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZnhcIiwgZm9jYWxQb2ludFswXSk7XG4gICAgICAgICAgICBncmFkaWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZ5XCIsIGZvY2FsUG9pbnRbMV0pO1xuICAgICAgICAgICAgZ3JhZGllbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmclwiLCBmb2NhbFJhZGl1cyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIFJhZGlhbEF4aWFsIHR5cGU6ICR7YXJnc1sxXX1gKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGNvbG9yU3RvcCBvZiBjb2xvclN0b3BzKSB7XG4gICAgICAgICAgY29uc3Qgc3RvcCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnN0b3BcIik7XG4gICAgICAgICAgc3RvcC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIm9mZnNldFwiLCBjb2xvclN0b3BbMF0pO1xuICAgICAgICAgIHN0b3Auc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdG9wLWNvbG9yXCIsIGNvbG9yU3RvcFsxXSk7XG4gICAgICAgICAgZ3JhZGllbnQuYXBwZW5kKHN0b3ApO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZGVmcy5hcHBlbmQoZ3JhZGllbnQpO1xuICAgICAgICByZXR1cm4gYHVybCgjJHtzaGFkaW5nSWR9KWA7XG4gICAgICBjYXNlIFwiTWVzaFwiOlxuICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIHBhdHRlcm4gTWVzaFwiKTtcbiAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICBjYXNlIFwiRHVtbXlcIjpcbiAgICAgICAgcmV0dXJuIFwiaG90cGlua1wiO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIElSIHR5cGU6ICR7YXJnc1swXX1gKTtcbiAgICB9XG4gIH1cbiAgc2V0RGFzaChkYXNoQXJyYXksIGRhc2hQaGFzZSkge1xuICAgIHRoaXMuY3VycmVudC5kYXNoQXJyYXkgPSBkYXNoQXJyYXk7XG4gICAgdGhpcy5jdXJyZW50LmRhc2hQaGFzZSA9IGRhc2hQaGFzZTtcbiAgfVxuICBjb25zdHJ1Y3RQYXRoKG9wcywgYXJncykge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgbGV0IHggPSBjdXJyZW50LngsXG4gICAgICB5ID0gY3VycmVudC55O1xuICAgIGxldCBkID0gW107XG4gICAgbGV0IGogPSAwO1xuICAgIGZvciAoY29uc3Qgb3Agb2Ygb3BzKSB7XG4gICAgICBzd2l0Y2ggKG9wIHwgMCkge1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5yZWN0YW5nbGU6XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IHdpZHRoID0gYXJnc1tqKytdO1xuICAgICAgICAgIGNvbnN0IGhlaWdodCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICBjb25zdCB4dyA9IHggKyB3aWR0aDtcbiAgICAgICAgICBjb25zdCB5aCA9IHkgKyBoZWlnaHQ7XG4gICAgICAgICAgZC5wdXNoKFwiTVwiLCBwZih4KSwgcGYoeSksIFwiTFwiLCBwZih4dyksIHBmKHkpLCBcIkxcIiwgcGYoeHcpLCBwZih5aCksIFwiTFwiLCBwZih4KSwgcGYoeWgpLCBcIlpcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgX3V0aWwuT1BTLm1vdmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqKytdO1xuICAgICAgICAgIHkgPSBhcmdzW2orK107XG4gICAgICAgICAgZC5wdXNoKFwiTVwiLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5saW5lVG86XG4gICAgICAgICAgeCA9IGFyZ3NbaisrXTtcbiAgICAgICAgICB5ID0gYXJnc1tqKytdO1xuICAgICAgICAgIGQucHVzaChcIkxcIiwgcGYoeCksIHBmKHkpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY3VydmVUbzpcbiAgICAgICAgICB4ID0gYXJnc1tqICsgNF07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDVdO1xuICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoYXJnc1tqICsgMl0pLCBwZihhcmdzW2ogKyAzXSksIHBmKHgpLCBwZih5KSk7XG4gICAgICAgICAgaiArPSA2O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMjpcbiAgICAgICAgICBkLnB1c2goXCJDXCIsIHBmKHgpLCBwZih5KSwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoYXJnc1tqICsgMl0pLCBwZihhcmdzW2ogKyAzXSkpO1xuICAgICAgICAgIHggPSBhcmdzW2ogKyAyXTtcbiAgICAgICAgICB5ID0gYXJnc1tqICsgM107XG4gICAgICAgICAgaiArPSA0O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLk9QUy5jdXJ2ZVRvMzpcbiAgICAgICAgICB4ID0gYXJnc1tqICsgMl07XG4gICAgICAgICAgeSA9IGFyZ3NbaiArIDNdO1xuICAgICAgICAgIGQucHVzaChcIkNcIiwgcGYoYXJnc1tqXSksIHBmKGFyZ3NbaiArIDFdKSwgcGYoeCksIHBmKHkpLCBwZih4KSwgcGYoeSkpO1xuICAgICAgICAgIGogKz0gNDtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5PUFMuY2xvc2VQYXRoOlxuICAgICAgICAgIGQucHVzaChcIlpcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICAgIGQgPSBkLmpvaW4oXCIgXCIpO1xuICAgIGlmIChjdXJyZW50LnBhdGggJiYgb3BzLmxlbmd0aCA+IDAgJiYgb3BzWzBdICE9PSBfdXRpbC5PUFMucmVjdGFuZ2xlICYmIG9wc1swXSAhPT0gX3V0aWwuT1BTLm1vdmVUbykge1xuICAgICAgZCA9IGN1cnJlbnQucGF0aC5nZXRBdHRyaWJ1dGVOUyhudWxsLCBcImRcIikgKyBkO1xuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50LnBhdGggPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpwYXRoXCIpO1xuICAgICAgdGhpcy5fZW5zdXJlVHJhbnNmb3JtR3JvdXAoKS5hcHBlbmQoY3VycmVudC5wYXRoKTtcbiAgICB9XG4gICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBkKTtcbiAgICBjdXJyZW50LnBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsXCIsIFwibm9uZVwiKTtcbiAgICBjdXJyZW50LmVsZW1lbnQgPSBjdXJyZW50LnBhdGg7XG4gICAgY3VycmVudC5zZXRDdXJyZW50UG9pbnQoeCwgeSk7XG4gIH1cbiAgZW5kUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGN1cnJlbnQucGF0aCA9IG51bGw7XG4gICAgaWYgKCF0aGlzLnBlbmRpbmdDbGlwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghY3VycmVudC5lbGVtZW50KSB7XG4gICAgICB0aGlzLnBlbmRpbmdDbGlwID0gbnVsbDtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgY2xpcElkID0gYGNsaXBwYXRoJHtjbGlwQ291bnQrK31gO1xuICAgIGNvbnN0IGNsaXBQYXRoID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6Y2xpcFBhdGhcIik7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlTlMobnVsbCwgXCJpZFwiLCBjbGlwSWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIHBtKHRoaXMudHJhbnNmb3JtTWF0cml4KSk7XG4gICAgY29uc3QgY2xpcEVsZW1lbnQgPSBjdXJyZW50LmVsZW1lbnQuY2xvbmVOb2RlKHRydWUpO1xuICAgIGlmICh0aGlzLnBlbmRpbmdDbGlwID09PSBcImV2ZW5vZGRcIikge1xuICAgICAgY2xpcEVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJjbGlwLXJ1bGVcIiwgXCJldmVub2RkXCIpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjbGlwRWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcnVsZVwiLCBcIm5vbnplcm9cIik7XG4gICAgfVxuICAgIHRoaXMucGVuZGluZ0NsaXAgPSBudWxsO1xuICAgIGNsaXBQYXRoLmFwcGVuZChjbGlwRWxlbWVudCk7XG4gICAgdGhpcy5kZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgaWYgKGN1cnJlbnQuYWN0aXZlQ2xpcFVybCkge1xuICAgICAgY3VycmVudC5jbGlwR3JvdXAgPSBudWxsO1xuICAgICAgZm9yIChjb25zdCBwcmV2IG9mIHRoaXMuZXh0cmFTdGFjaykge1xuICAgICAgICBwcmV2LmNsaXBHcm91cCA9IG51bGw7XG4gICAgICB9XG4gICAgICBjbGlwUGF0aC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImNsaXAtcGF0aFwiLCBjdXJyZW50LmFjdGl2ZUNsaXBVcmwpO1xuICAgIH1cbiAgICBjdXJyZW50LmFjdGl2ZUNsaXBVcmwgPSBgdXJsKCMke2NsaXBJZH0pYDtcbiAgICB0aGlzLnRncnAgPSBudWxsO1xuICB9XG4gIGNsaXAodHlwZSkge1xuICAgIHRoaXMucGVuZGluZ0NsaXAgPSB0eXBlO1xuICB9XG4gIGNsb3NlUGF0aCgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LnBhdGgpIHtcbiAgICAgIGNvbnN0IGQgPSBgJHtjdXJyZW50LnBhdGguZ2V0QXR0cmlidXRlTlMobnVsbCwgXCJkXCIpfVpgO1xuICAgICAgY3VycmVudC5wYXRoLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZFwiLCBkKTtcbiAgICB9XG4gIH1cbiAgc2V0TGVhZGluZyhsZWFkaW5nKSB7XG4gICAgdGhpcy5jdXJyZW50LmxlYWRpbmcgPSAtbGVhZGluZztcbiAgfVxuICBzZXRUZXh0UmlzZSh0ZXh0UmlzZSkge1xuICAgIHRoaXMuY3VycmVudC50ZXh0UmlzZSA9IHRleHRSaXNlO1xuICB9XG4gIHNldFRleHRSZW5kZXJpbmdNb2RlKHRleHRSZW5kZXJpbmdNb2RlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRSZW5kZXJpbmdNb2RlID0gdGV4dFJlbmRlcmluZ01vZGU7XG4gIH1cbiAgc2V0SFNjYWxlKHNjYWxlKSB7XG4gICAgdGhpcy5jdXJyZW50LnRleHRIU2NhbGUgPSBzY2FsZSAvIDEwMDtcbiAgfVxuICBzZXRSZW5kZXJpbmdJbnRlbnQoaW50ZW50KSB7fVxuICBzZXRGbGF0bmVzcyhmbGF0bmVzcykge31cbiAgc2V0R1N0YXRlKHN0YXRlcykge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIHN0YXRlcykge1xuICAgICAgc3dpdGNoIChrZXkpIHtcbiAgICAgICAgY2FzZSBcIkxXXCI6XG4gICAgICAgICAgdGhpcy5zZXRMaW5lV2lkdGgodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTENcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVDYXAodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiTEpcIjpcbiAgICAgICAgICB0aGlzLnNldExpbmVKb2luKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIk1MXCI6XG4gICAgICAgICAgdGhpcy5zZXRNaXRlckxpbWl0KHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkRcIjpcbiAgICAgICAgICB0aGlzLnNldERhc2godmFsdWVbMF0sIHZhbHVlWzFdKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIlJJXCI6XG4gICAgICAgICAgdGhpcy5zZXRSZW5kZXJpbmdJbnRlbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiRkxcIjpcbiAgICAgICAgICB0aGlzLnNldEZsYXRuZXNzKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcIkZvbnRcIjpcbiAgICAgICAgICB0aGlzLnNldEZvbnQodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiQ0FcIjpcbiAgICAgICAgICB0aGlzLnNldFN0cm9rZUFscGhhKHZhbHVlKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImNhXCI6XG4gICAgICAgICAgdGhpcy5zZXRGaWxsQWxwaGEodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgVW5pbXBsZW1lbnRlZCBncmFwaGljIHN0YXRlIG9wZXJhdG9yICR7a2V5fWApO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmaWxsKCkge1xuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgaWYgKGN1cnJlbnQuZWxlbWVudCkge1xuICAgICAgY3VycmVudC5lbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCBjdXJyZW50LmZpbGxDb2xvcik7XG4gICAgICBjdXJyZW50LmVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJmaWxsLW9wYWNpdHlcIiwgY3VycmVudC5maWxsQWxwaGEpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIHN0cm9rZSgpIHtcbiAgICBjb25zdCBjdXJyZW50ID0gdGhpcy5jdXJyZW50O1xuICAgIGlmIChjdXJyZW50LmVsZW1lbnQpIHtcbiAgICAgIHRoaXMuX3NldFN0cm9rZUF0dHJpYnV0ZXMoY3VycmVudC5lbGVtZW50KTtcbiAgICAgIGN1cnJlbnQuZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgXCJub25lXCIpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIF9zZXRTdHJva2VBdHRyaWJ1dGVzKGVsZW1lbnQpIHtcbiAgICBsZXQgbGluZVdpZHRoU2NhbGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IDE7XG4gICAgY29uc3QgY3VycmVudCA9IHRoaXMuY3VycmVudDtcbiAgICBsZXQgZGFzaEFycmF5ID0gY3VycmVudC5kYXNoQXJyYXk7XG4gICAgaWYgKGxpbmVXaWR0aFNjYWxlICE9PSAxICYmIGRhc2hBcnJheS5sZW5ndGggPiAwKSB7XG4gICAgICBkYXNoQXJyYXkgPSBkYXNoQXJyYXkubWFwKGZ1bmN0aW9uICh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gbGluZVdpZHRoU2NhbGUgKiB2YWx1ZTtcbiAgICAgIH0pO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlXCIsIGN1cnJlbnQuc3Ryb2tlQ29sb3IpO1xuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJzdHJva2Utb3BhY2l0eVwiLCBjdXJyZW50LnN0cm9rZUFscGhhKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLW1pdGVybGltaXRcIiwgcGYoY3VycmVudC5taXRlckxpbWl0KSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1saW5lY2FwXCIsIGN1cnJlbnQubGluZUNhcCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1saW5lam9pblwiLCBjdXJyZW50LmxpbmVKb2luKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLXdpZHRoXCIsIHBmKGxpbmVXaWR0aFNjYWxlICogY3VycmVudC5saW5lV2lkdGgpICsgXCJweFwiKTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwic3Ryb2tlLWRhc2hhcnJheVwiLCBkYXNoQXJyYXkubWFwKHBmKS5qb2luKFwiIFwiKSk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInN0cm9rZS1kYXNob2Zmc2V0XCIsIHBmKGxpbmVXaWR0aFNjYWxlICogY3VycmVudC5kYXNoUGhhc2UpICsgXCJweFwiKTtcbiAgfVxuICBlb0ZpbGwoKSB7XG4gICAgdGhpcy5jdXJyZW50LmVsZW1lbnQ/LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbC1ydWxlXCIsIFwiZXZlbm9kZFwiKTtcbiAgICB0aGlzLmZpbGwoKTtcbiAgfVxuICBmaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuc3Ryb2tlKCk7XG4gICAgdGhpcy5maWxsKCk7XG4gIH1cbiAgZW9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuY3VycmVudC5lbGVtZW50Py5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGwtcnVsZVwiLCBcImV2ZW5vZGRcIik7XG4gICAgdGhpcy5maWxsU3Ryb2tlKCk7XG4gIH1cbiAgY2xvc2VTdHJva2UoKSB7XG4gICAgdGhpcy5jbG9zZVBhdGgoKTtcbiAgICB0aGlzLnN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRmlsbFN0cm9rZSgpIHtcbiAgICB0aGlzLmNsb3NlUGF0aCgpO1xuICAgIHRoaXMuZmlsbFN0cm9rZSgpO1xuICB9XG4gIGNsb3NlRU9GaWxsU3Ryb2tlKCkge1xuICAgIHRoaXMuY2xvc2VQYXRoKCk7XG4gICAgdGhpcy5lb0ZpbGxTdHJva2UoKTtcbiAgfVxuICBwYWludFNvbGlkQ29sb3JJbWFnZU1hc2soKSB7XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ5XCIsIFwiMFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwid2lkdGhcIiwgXCIxcHhcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBcIjFweFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiZmlsbFwiLCB0aGlzLmN1cnJlbnQuZmlsbENvbG9yKTtcbiAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChyZWN0KTtcbiAgfVxuICBwYWludEltYWdlWE9iamVjdChvYmpJZCkge1xuICAgIGNvbnN0IGltZ0RhdGEgPSB0aGlzLmdldE9iamVjdChvYmpJZCk7XG4gICAgaWYgKCFpbWdEYXRhKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoYERlcGVuZGVudCBpbWFnZSB3aXRoIG9iamVjdCBJRCAke29iaklkfSBpcyBub3QgcmVhZHkgeWV0YCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSk7XG4gIH1cbiAgcGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSwgbWFzaykge1xuICAgIGNvbnN0IHdpZHRoID0gaW1nRGF0YS53aWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSBpbWdEYXRhLmhlaWdodDtcbiAgICBjb25zdCBpbWdTcmMgPSBjb252ZXJ0SW1nRGF0YVRvUG5nKGltZ0RhdGEsIHRoaXMuZm9yY2VEYXRhU2NoZW1hLCAhIW1hc2spO1xuICAgIGNvbnN0IGNsaXByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBcIjBcIik7XG4gICAgY2xpcHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkpO1xuICAgIGNsaXByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkpO1xuICAgIHRoaXMuY3VycmVudC5lbGVtZW50ID0gY2xpcHJlY3Q7XG4gICAgdGhpcy5jbGlwKFwibm9uemVyb1wiKTtcbiAgICBjb25zdCBpbWdFbCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmltYWdlXCIpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKFhMSU5LX05TLCBcInhsaW5rOmhyZWZcIiwgaW1nU3JjKTtcbiAgICBpbWdFbC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgXCIwXCIpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieVwiLCBwZigtaGVpZ2h0KSk7XG4gICAgaW1nRWwuc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkgKyBcInB4XCIpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiaGVpZ2h0XCIsIHBmKGhlaWdodCkgKyBcInB4XCIpO1xuICAgIGltZ0VsLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIGBzY2FsZSgke3BmKDEgLyB3aWR0aCl9ICR7cGYoLTEgLyBoZWlnaHQpfSlgKTtcbiAgICBpZiAobWFzaykge1xuICAgICAgbWFzay5hcHBlbmQoaW1nRWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9lbnN1cmVUcmFuc2Zvcm1Hcm91cCgpLmFwcGVuZChpbWdFbCk7XG4gICAgfVxuICB9XG4gIHBhaW50SW1hZ2VNYXNrWE9iamVjdChpbWcpIHtcbiAgICBjb25zdCBpbWdEYXRhID0gdGhpcy5nZXRPYmplY3QoaW1nLmRhdGEsIGltZyk7XG4gICAgaWYgKGltZ0RhdGEuYml0bWFwKSB7XG4gICAgICAoMCwgX3V0aWwud2FybikoXCJwYWludEltYWdlTWFza1hPYmplY3Q6IEltYWdlQml0bWFwIHN1cHBvcnQgaXMgbm90IGltcGxlbWVudGVkLCBcIiArIFwiZW5zdXJlIHRoYXQgdGhlIGBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZGAgQVBJIHBhcmFtZXRlciBpcyBkaXNhYmxlZC5cIik7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGN1cnJlbnQgPSB0aGlzLmN1cnJlbnQ7XG4gICAgY29uc3Qgd2lkdGggPSBpbWdEYXRhLndpZHRoO1xuICAgIGNvbnN0IGhlaWdodCA9IGltZ0RhdGEuaGVpZ2h0O1xuICAgIGNvbnN0IGZpbGxDb2xvciA9IGN1cnJlbnQuZmlsbENvbG9yO1xuICAgIGN1cnJlbnQubWFza0lkID0gYG1hc2ske21hc2tDb3VudCsrfWA7XG4gICAgY29uc3QgbWFzayA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOm1hc2tcIik7XG4gICAgbWFzay5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImlkXCIsIGN1cnJlbnQubWFza0lkKTtcbiAgICBjb25zdCByZWN0ID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwieFwiLCBcIjBcIik7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgXCIwXCIpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJ3aWR0aFwiLCBwZih3aWR0aCkpO1xuICAgIHJlY3Quc2V0QXR0cmlidXRlTlMobnVsbCwgXCJoZWlnaHRcIiwgcGYoaGVpZ2h0KSk7XG4gICAgcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImZpbGxcIiwgZmlsbENvbG9yKTtcbiAgICByZWN0LnNldEF0dHJpYnV0ZU5TKG51bGwsIFwibWFza1wiLCBgdXJsKCMke2N1cnJlbnQubWFza0lkfSlgKTtcbiAgICB0aGlzLmRlZnMuYXBwZW5kKG1hc2spO1xuICAgIHRoaXMuX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkuYXBwZW5kKHJlY3QpO1xuICAgIHRoaXMucGFpbnRJbmxpbmVJbWFnZVhPYmplY3QoaW1nRGF0YSwgbWFzayk7XG4gIH1cbiAgcGFpbnRGb3JtWE9iamVjdEJlZ2luKG1hdHJpeCwgYmJveCkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KG1hdHJpeCkgJiYgbWF0cml4Lmxlbmd0aCA9PT0gNikge1xuICAgICAgdGhpcy50cmFuc2Zvcm0obWF0cml4WzBdLCBtYXRyaXhbMV0sIG1hdHJpeFsyXSwgbWF0cml4WzNdLCBtYXRyaXhbNF0sIG1hdHJpeFs1XSk7XG4gICAgfVxuICAgIGlmIChiYm94KSB7XG4gICAgICBjb25zdCB3aWR0aCA9IGJib3hbMl0gLSBiYm94WzBdO1xuICAgICAgY29uc3QgaGVpZ2h0ID0gYmJveFszXSAtIGJib3hbMV07XG4gICAgICBjb25zdCBjbGlwcmVjdCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOnJlY3RcIik7XG4gICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInhcIiwgYmJveFswXSk7XG4gICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcInlcIiwgYmJveFsxXSk7XG4gICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcIndpZHRoXCIsIHBmKHdpZHRoKSk7XG4gICAgICBjbGlwcmVjdC5zZXRBdHRyaWJ1dGVOUyhudWxsLCBcImhlaWdodFwiLCBwZihoZWlnaHQpKTtcbiAgICAgIHRoaXMuY3VycmVudC5lbGVtZW50ID0gY2xpcHJlY3Q7XG4gICAgICB0aGlzLmNsaXAoXCJub256ZXJvXCIpO1xuICAgICAgdGhpcy5lbmRQYXRoKCk7XG4gICAgfVxuICB9XG4gIHBhaW50Rm9ybVhPYmplY3RFbmQoKSB7fVxuICBfaW5pdGlhbGl6ZSh2aWV3cG9ydCkge1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUodmlld3BvcnQud2lkdGgsIHZpZXdwb3J0LmhlaWdodCk7XG4gICAgY29uc3QgZGVmaW5pdGlvbnMgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpkZWZzXCIpO1xuICAgIHN2Zy5hcHBlbmQoZGVmaW5pdGlvbnMpO1xuICAgIHRoaXMuZGVmcyA9IGRlZmluaXRpb25zO1xuICAgIGNvbnN0IHJvb3RHcm91cCA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmdcIik7XG4gICAgcm9vdEdyb3VwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIHBtKHZpZXdwb3J0LnRyYW5zZm9ybSkpO1xuICAgIHN2Zy5hcHBlbmQocm9vdEdyb3VwKTtcbiAgICB0aGlzLnN2ZyA9IHJvb3RHcm91cDtcbiAgICByZXR1cm4gc3ZnO1xuICB9XG4gIF9lbnN1cmVDbGlwR3JvdXAoKSB7XG4gICAgaWYgKCF0aGlzLmN1cnJlbnQuY2xpcEdyb3VwKSB7XG4gICAgICBjb25zdCBjbGlwR3JvdXAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgICAgY2xpcEdyb3VwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwiY2xpcC1wYXRoXCIsIHRoaXMuY3VycmVudC5hY3RpdmVDbGlwVXJsKTtcbiAgICAgIHRoaXMuc3ZnLmFwcGVuZChjbGlwR3JvdXApO1xuICAgICAgdGhpcy5jdXJyZW50LmNsaXBHcm91cCA9IGNsaXBHcm91cDtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY3VycmVudC5jbGlwR3JvdXA7XG4gIH1cbiAgX2Vuc3VyZVRyYW5zZm9ybUdyb3VwKCkge1xuICAgIGlmICghdGhpcy50Z3JwKSB7XG4gICAgICB0aGlzLnRncnAgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcInN2ZzpnXCIpO1xuICAgICAgdGhpcy50Z3JwLnNldEF0dHJpYnV0ZU5TKG51bGwsIFwidHJhbnNmb3JtXCIsIHBtKHRoaXMudHJhbnNmb3JtTWF0cml4KSk7XG4gICAgICBpZiAodGhpcy5jdXJyZW50LmFjdGl2ZUNsaXBVcmwpIHtcbiAgICAgICAgdGhpcy5fZW5zdXJlQ2xpcEdyb3VwKCkuYXBwZW5kKHRoaXMudGdycCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnN2Zy5hcHBlbmQodGhpcy50Z3JwKTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRoaXMudGdycDtcbiAgfVxufVxuZXhwb3J0cy5TVkdHcmFwaGljcyA9IFNWR0dyYXBoaWNzO1xuXG4vKioqLyB9KSxcbi8qIDE4NyAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyICQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDMpO1xudmFyICRncm91cCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTg4KTtcbnZhciBhZGRUb1Vuc2NvcGFibGVzID0gX193X3BkZmpzX3JlcXVpcmVfXygxOTMpO1xuJCh7XG4gdGFyZ2V0OiAnQXJyYXknLFxuIHByb3RvOiB0cnVlXG59LCB7XG4gZ3JvdXA6IGZ1bmN0aW9uIGdyb3VwKGNhbGxiYWNrZm4pIHtcbiAgdmFyIHRoaXNBcmcgPSBhcmd1bWVudHMubGVuZ3RoID4gMSA/IGFyZ3VtZW50c1sxXSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuICRncm91cCh0aGlzLCBjYWxsYmFja2ZuLCB0aGlzQXJnKTtcbiB9XG59KTtcbmFkZFRvVW5zY29wYWJsZXMoJ2dyb3VwJyk7XG5cbi8qKiovIH0pLFxuLyogMTg4ICovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIGJpbmQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDk5KTtcbnZhciB1bmN1cnJ5VGhpcyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTQpO1xudmFyIEluZGV4ZWRPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEzKTtcbnZhciB0b09iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDApO1xudmFyIHRvUHJvcGVydHlLZXkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4KTtcbnZhciBsZW5ndGhPZkFycmF5TGlrZSA9IF9fd19wZGZqc19yZXF1aXJlX18oNjQpO1xudmFyIG9iamVjdENyZWF0ZSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTg5KTtcbnZhciBhcnJheUZyb21Db25zdHJ1Y3RvckFuZExpc3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEwOCk7XG52YXIgJEFycmF5ID0gQXJyYXk7XG52YXIgcHVzaCA9IHVuY3VycnlUaGlzKFtdLnB1c2gpO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoJHRoaXMsIGNhbGxiYWNrZm4sIHRoYXQsIHNwZWNpZmljQ29uc3RydWN0b3IpIHtcbiB2YXIgTyA9IHRvT2JqZWN0KCR0aGlzKTtcbiB2YXIgc2VsZiA9IEluZGV4ZWRPYmplY3QoTyk7XG4gdmFyIGJvdW5kRnVuY3Rpb24gPSBiaW5kKGNhbGxiYWNrZm4sIHRoYXQpO1xuIHZhciB0YXJnZXQgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gdmFyIGxlbmd0aCA9IGxlbmd0aE9mQXJyYXlMaWtlKHNlbGYpO1xuIHZhciBpbmRleCA9IDA7XG4gdmFyIENvbnN0cnVjdG9yLCBrZXksIHZhbHVlO1xuIGZvciAoOyBsZW5ndGggPiBpbmRleDsgaW5kZXgrKykge1xuICB2YWx1ZSA9IHNlbGZbaW5kZXhdO1xuICBrZXkgPSB0b1Byb3BlcnR5S2V5KGJvdW5kRnVuY3Rpb24odmFsdWUsIGluZGV4LCBPKSk7XG4gIGlmIChrZXkgaW4gdGFyZ2V0KVxuICAgcHVzaCh0YXJnZXRba2V5XSwgdmFsdWUpO1xuICBlbHNlXG4gICB0YXJnZXRba2V5XSA9IFt2YWx1ZV07XG4gfVxuIGlmIChzcGVjaWZpY0NvbnN0cnVjdG9yKSB7XG4gIENvbnN0cnVjdG9yID0gc3BlY2lmaWNDb25zdHJ1Y3RvcihPKTtcbiAgaWYgKENvbnN0cnVjdG9yICE9PSAkQXJyYXkpIHtcbiAgIGZvciAoa2V5IGluIHRhcmdldClcbiAgICB0YXJnZXRba2V5XSA9IGFycmF5RnJvbUNvbnN0cnVjdG9yQW5kTGlzdChDb25zdHJ1Y3RvciwgdGFyZ2V0W2tleV0pO1xuICB9XG4gfVxuIHJldHVybiB0YXJnZXQ7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE4OSAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBhbk9iamVjdCA9IF9fd19wZGZqc19yZXF1aXJlX18oNDcpO1xudmFyIGRlZmluZVByb3BlcnRpZXNNb2R1bGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5MCk7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY2KTtcbnZhciBoaWRkZW5LZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXyg1NSk7XG52YXIgaHRtbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTkyKTtcbnZhciBkb2N1bWVudENyZWF0ZUVsZW1lbnQgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQzKTtcbnZhciBzaGFyZWRLZXkgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDU0KTtcbnZhciBHVCA9ICc+JztcbnZhciBMVCA9ICc8JztcbnZhciBQUk9UT1RZUEUgPSAncHJvdG90eXBlJztcbnZhciBTQ1JJUFQgPSAnc2NyaXB0JztcbnZhciBJRV9QUk9UTyA9IHNoYXJlZEtleSgnSUVfUFJPVE8nKTtcbnZhciBFbXB0eUNvbnN0cnVjdG9yID0gZnVuY3Rpb24gKCkge1xufTtcbnZhciBzY3JpcHRUYWcgPSBmdW5jdGlvbiAoY29udGVudCkge1xuIHJldHVybiBMVCArIFNDUklQVCArIEdUICsgY29udGVudCArIExUICsgJy8nICsgU0NSSVBUICsgR1Q7XG59O1xudmFyIE51bGxQcm90b09iamVjdFZpYUFjdGl2ZVggPSBmdW5jdGlvbiAoYWN0aXZlWERvY3VtZW50KSB7XG4gYWN0aXZlWERvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnJykpO1xuIGFjdGl2ZVhEb2N1bWVudC5jbG9zZSgpO1xuIHZhciB0ZW1wID0gYWN0aXZlWERvY3VtZW50LnBhcmVudFdpbmRvdy5PYmplY3Q7XG4gYWN0aXZlWERvY3VtZW50ID0gbnVsbDtcbiByZXR1cm4gdGVtcDtcbn07XG52YXIgTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lID0gZnVuY3Rpb24gKCkge1xuIHZhciBpZnJhbWUgPSBkb2N1bWVudENyZWF0ZUVsZW1lbnQoJ2lmcmFtZScpO1xuIHZhciBKUyA9ICdqYXZhJyArIFNDUklQVCArICc6JztcbiB2YXIgaWZyYW1lRG9jdW1lbnQ7XG4gaWZyYW1lLnN0eWxlLmRpc3BsYXkgPSAnbm9uZSc7XG4gaHRtbC5hcHBlbmRDaGlsZChpZnJhbWUpO1xuIGlmcmFtZS5zcmMgPSBTdHJpbmcoSlMpO1xuIGlmcmFtZURvY3VtZW50ID0gaWZyYW1lLmNvbnRlbnRXaW5kb3cuZG9jdW1lbnQ7XG4gaWZyYW1lRG9jdW1lbnQub3BlbigpO1xuIGlmcmFtZURvY3VtZW50LndyaXRlKHNjcmlwdFRhZygnZG9jdW1lbnQuRj1PYmplY3QnKSk7XG4gaWZyYW1lRG9jdW1lbnQuY2xvc2UoKTtcbiByZXR1cm4gaWZyYW1lRG9jdW1lbnQuRjtcbn07XG52YXIgYWN0aXZlWERvY3VtZW50O1xudmFyIE51bGxQcm90b09iamVjdCA9IGZ1bmN0aW9uICgpIHtcbiB0cnkge1xuICBhY3RpdmVYRG9jdW1lbnQgPSBuZXcgQWN0aXZlWE9iamVjdCgnaHRtbGZpbGUnKTtcbiB9IGNhdGNoIChlcnJvcikge1xuIH1cbiBOdWxsUHJvdG9PYmplY3QgPSB0eXBlb2YgZG9jdW1lbnQgIT0gJ3VuZGVmaW5lZCcgPyBkb2N1bWVudC5kb21haW4gJiYgYWN0aXZlWERvY3VtZW50ID8gTnVsbFByb3RvT2JqZWN0VmlhQWN0aXZlWChhY3RpdmVYRG9jdW1lbnQpIDogTnVsbFByb3RvT2JqZWN0VmlhSUZyYW1lKCkgOiBOdWxsUHJvdG9PYmplY3RWaWFBY3RpdmVYKGFjdGl2ZVhEb2N1bWVudCk7XG4gdmFyIGxlbmd0aCA9IGVudW1CdWdLZXlzLmxlbmd0aDtcbiB3aGlsZSAobGVuZ3RoLS0pXG4gIGRlbGV0ZSBOdWxsUHJvdG9PYmplY3RbUFJPVE9UWVBFXVtlbnVtQnVnS2V5c1tsZW5ndGhdXTtcbiByZXR1cm4gTnVsbFByb3RvT2JqZWN0KCk7XG59O1xuaGlkZGVuS2V5c1tJRV9QUk9UT10gPSB0cnVlO1xubW9kdWxlLmV4cG9ydHMgPSBPYmplY3QuY3JlYXRlIHx8IGZ1bmN0aW9uIGNyZWF0ZShPLCBQcm9wZXJ0aWVzKSB7XG4gdmFyIHJlc3VsdDtcbiBpZiAoTyAhPT0gbnVsbCkge1xuICBFbXB0eUNvbnN0cnVjdG9yW1BST1RPVFlQRV0gPSBhbk9iamVjdChPKTtcbiAgcmVzdWx0ID0gbmV3IEVtcHR5Q29uc3RydWN0b3IoKTtcbiAgRW1wdHlDb25zdHJ1Y3RvcltQUk9UT1RZUEVdID0gbnVsbDtcbiAgcmVzdWx0W0lFX1BST1RPXSA9IE87XG4gfSBlbHNlXG4gIHJlc3VsdCA9IE51bGxQcm90b09iamVjdCgpO1xuIHJldHVybiBQcm9wZXJ0aWVzID09PSB1bmRlZmluZWQgPyByZXN1bHQgOiBkZWZpbmVQcm9wZXJ0aWVzTW9kdWxlLmYocmVzdWx0LCBQcm9wZXJ0aWVzKTtcbn07XG5cbi8qKiovIH0pLFxuLyogMTkwICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxudmFyIERFU0NSSVBUT1JTID0gX193X3BkZmpzX3JlcXVpcmVfXyg2KTtcbnZhciBWOF9QUk9UT1RZUEVfREVGSU5FX0JVRyA9IF9fd19wZGZqc19yZXF1aXJlX18oNDYpO1xudmFyIGRlZmluZVByb3BlcnR5TW9kdWxlID0gX193X3BkZmpzX3JlcXVpcmVfXyg0NSk7XG52YXIgYW5PYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDQ3KTtcbnZhciB0b0luZGV4ZWRPYmplY3QgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEyKTtcbnZhciBvYmplY3RLZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXygxOTEpO1xuZXhwb3J0cy5mID0gREVTQ1JJUFRPUlMgJiYgIVY4X1BST1RPVFlQRV9ERUZJTkVfQlVHID8gT2JqZWN0LmRlZmluZVByb3BlcnRpZXMgOiBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKE8sIFByb3BlcnRpZXMpIHtcbiBhbk9iamVjdChPKTtcbiB2YXIgcHJvcHMgPSB0b0luZGV4ZWRPYmplY3QoUHJvcGVydGllcyk7XG4gdmFyIGtleXMgPSBvYmplY3RLZXlzKFByb3BlcnRpZXMpO1xuIHZhciBsZW5ndGggPSBrZXlzLmxlbmd0aDtcbiB2YXIgaW5kZXggPSAwO1xuIHZhciBrZXk7XG4gd2hpbGUgKGxlbmd0aCA+IGluZGV4KVxuICBkZWZpbmVQcm9wZXJ0eU1vZHVsZS5mKE8sIGtleSA9IGtleXNbaW5kZXgrK10sIHByb3BzW2tleV0pO1xuIHJldHVybiBPO1xufTtcblxuLyoqKi8gfSksXG4vKiAxOTEgKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG52YXIgaW50ZXJuYWxPYmplY3RLZXlzID0gX193X3BkZmpzX3JlcXVpcmVfXyg1OSk7XG52YXIgZW51bUJ1Z0tleXMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDY2KTtcbm1vZHVsZS5leHBvcnRzID0gT2JqZWN0LmtleXMgfHwgZnVuY3Rpb24ga2V5cyhPKSB7XG4gcmV0dXJuIGludGVybmFsT2JqZWN0S2V5cyhPLCBlbnVtQnVnS2V5cyk7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE5MiAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciBnZXRCdWlsdEluID0gX193X3BkZmpzX3JlcXVpcmVfXygyNCk7XG5tb2R1bGUuZXhwb3J0cyA9IGdldEJ1aWx0SW4oJ2RvY3VtZW50JywgJ2RvY3VtZW50RWxlbWVudCcpO1xuXG4vKioqLyB9KSxcbi8qIDE5MyAqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cbnZhciB3ZWxsS25vd25TeW1ib2wgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDM0KTtcbnZhciBjcmVhdGUgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE4OSk7XG52YXIgZGVmaW5lUHJvcGVydHkgPSAoX193X3BkZmpzX3JlcXVpcmVfXyg0NSkuZik7XG52YXIgVU5TQ09QQUJMRVMgPSB3ZWxsS25vd25TeW1ib2woJ3Vuc2NvcGFibGVzJyk7XG52YXIgQXJyYXlQcm90b3R5cGUgPSBBcnJheS5wcm90b3R5cGU7XG5pZiAoQXJyYXlQcm90b3R5cGVbVU5TQ09QQUJMRVNdID09PSB1bmRlZmluZWQpIHtcbiBkZWZpbmVQcm9wZXJ0eShBcnJheVByb3RvdHlwZSwgVU5TQ09QQUJMRVMsIHtcbiAgY29uZmlndXJhYmxlOiB0cnVlLFxuICB2YWx1ZTogY3JlYXRlKG51bGwpXG4gfSk7XG59XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChrZXkpIHtcbiBBcnJheVByb3RvdHlwZVtVTlNDT1BBQkxFU11ba2V5XSA9IHRydWU7XG59O1xuXG4vKioqLyB9KSxcbi8qIDE5NCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5YZmFUZXh0ID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG5jbGFzcyBYZmFUZXh0IHtcbiAgc3RhdGljIHRleHRDb250ZW50KHhmYSkge1xuICAgIGNvbnN0IGl0ZW1zID0gW107XG4gICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgaXRlbXMsXG4gICAgICBzdHlsZXM6IE9iamVjdC5jcmVhdGUobnVsbClcbiAgICB9O1xuICAgIGZ1bmN0aW9uIHdhbGsobm9kZSkge1xuICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCBzdHIgPSBudWxsO1xuICAgICAgY29uc3QgbmFtZSA9IG5vZGUubmFtZTtcbiAgICAgIGlmIChuYW1lID09PSBcIiN0ZXh0XCIpIHtcbiAgICAgICAgc3RyID0gbm9kZS52YWx1ZTtcbiAgICAgIH0gZWxzZSBpZiAoIVhmYVRleHQuc2hvdWxkQnVpbGRUZXh0KG5hbWUpKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH0gZWxzZSBpZiAobm9kZT8uYXR0cmlidXRlcz8udGV4dENvbnRlbnQpIHtcbiAgICAgICAgc3RyID0gbm9kZS5hdHRyaWJ1dGVzLnRleHRDb250ZW50O1xuICAgICAgfSBlbHNlIGlmIChub2RlLnZhbHVlKSB7XG4gICAgICAgIHN0ciA9IG5vZGUudmFsdWU7XG4gICAgICB9XG4gICAgICBpZiAoc3RyICE9PSBudWxsKSB7XG4gICAgICAgIGl0ZW1zLnB1c2goe1xuICAgICAgICAgIHN0clxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGlmICghbm9kZS5jaGlsZHJlbikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmb3IgKGNvbnN0IGNoaWxkIG9mIG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgICAgd2FsayhjaGlsZCk7XG4gICAgICB9XG4gICAgfVxuICAgIHdhbGsoeGZhKTtcbiAgICByZXR1cm4gb3V0cHV0O1xuICB9XG4gIHN0YXRpYyBzaG91bGRCdWlsZFRleHQobmFtZSkge1xuICAgIHJldHVybiAhKG5hbWUgPT09IFwidGV4dGFyZWFcIiB8fCBuYW1lID09PSBcImlucHV0XCIgfHwgbmFtZSA9PT0gXCJvcHRpb25cIiB8fCBuYW1lID09PSBcInNlbGVjdFwiKTtcbiAgfVxufVxuZXhwb3J0cy5YZmFUZXh0ID0gWGZhVGV4dDtcblxuLyoqKi8gfSksXG4vKiAxOTUgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuVGV4dExheWVyUmVuZGVyVGFzayA9IHZvaWQgMDtcbmV4cG9ydHMucmVuZGVyVGV4dExheWVyID0gcmVuZGVyVGV4dExheWVyO1xuZXhwb3J0cy51cGRhdGVUZXh0TGF5ZXIgPSB1cGRhdGVUZXh0TGF5ZXI7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDg5KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMik7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjgpO1xuY29uc3QgTUFYX1RFWFRfRElWU19UT19SRU5ERVIgPSAxMDAwMDA7XG5jb25zdCBERUZBVUxUX0ZPTlRfU0laRSA9IDMwO1xuY29uc3QgREVGQVVMVF9GT05UX0FTQ0VOVCA9IDAuODtcbmNvbnN0IGFzY2VudENhY2hlID0gbmV3IE1hcCgpO1xuZnVuY3Rpb24gZ2V0Q3R4KHNpemUsIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKSB7XG4gIGxldCBjdHg7XG4gIGlmIChpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCAmJiBfdXRpbC5GZWF0dXJlVGVzdC5pc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCkge1xuICAgIGN0eCA9IG5ldyBPZmZzY3JlZW5DYW52YXMoc2l6ZSwgc2l6ZSkuZ2V0Q29udGV4dChcIjJkXCIsIHtcbiAgICAgIGFscGhhOiBmYWxzZVxuICAgIH0pO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgY2FudmFzLndpZHRoID0gY2FudmFzLmhlaWdodCA9IHNpemU7XG4gICAgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiLCB7XG4gICAgICBhbHBoYTogZmFsc2VcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gY3R4O1xufVxuZnVuY3Rpb24gZ2V0QXNjZW50KGZvbnRGYW1pbHksIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkKSB7XG4gIGNvbnN0IGNhY2hlZEFzY2VudCA9IGFzY2VudENhY2hlLmdldChmb250RmFtaWx5KTtcbiAgaWYgKGNhY2hlZEFzY2VudCkge1xuICAgIHJldHVybiBjYWNoZWRBc2NlbnQ7XG4gIH1cbiAgY29uc3QgY3R4ID0gZ2V0Q3R4KERFRkFVTFRfRk9OVF9TSVpFLCBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZCk7XG4gIGN0eC5mb250ID0gYCR7REVGQVVMVF9GT05UX1NJWkV9cHggJHtmb250RmFtaWx5fWA7XG4gIGNvbnN0IG1ldHJpY3MgPSBjdHgubWVhc3VyZVRleHQoXCJcIik7XG4gIGxldCBhc2NlbnQgPSBtZXRyaWNzLmZvbnRCb3VuZGluZ0JveEFzY2VudDtcbiAgbGV0IGRlc2NlbnQgPSBNYXRoLmFicyhtZXRyaWNzLmZvbnRCb3VuZGluZ0JveERlc2NlbnQpO1xuICBpZiAoYXNjZW50KSB7XG4gICAgY29uc3QgcmF0aW8gPSBhc2NlbnQgLyAoYXNjZW50ICsgZGVzY2VudCk7XG4gICAgYXNjZW50Q2FjaGUuc2V0KGZvbnRGYW1pbHksIHJhdGlvKTtcbiAgICBjdHguY2FudmFzLndpZHRoID0gY3R4LmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIHJldHVybiByYXRpbztcbiAgfVxuICBjdHguc3Ryb2tlU3R5bGUgPSBcInJlZFwiO1xuICBjdHguY2xlYXJSZWN0KDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIGN0eC5zdHJva2VUZXh0KFwiZ1wiLCAwLCAwKTtcbiAgbGV0IHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKS5kYXRhO1xuICBkZXNjZW50ID0gMDtcbiAgZm9yIChsZXQgaSA9IHBpeGVscy5sZW5ndGggLSAxIC0gMzsgaSA+PSAwOyBpIC09IDQpIHtcbiAgICBpZiAocGl4ZWxzW2ldID4gMCkge1xuICAgICAgZGVzY2VudCA9IE1hdGguY2VpbChpIC8gNCAvIERFRkFVTFRfRk9OVF9TSVpFKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBjdHguY2xlYXJSZWN0KDAsIDAsIERFRkFVTFRfRk9OVF9TSVpFLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIGN0eC5zdHJva2VUZXh0KFwiQVwiLCAwLCBERUZBVUxUX0ZPTlRfU0laRSk7XG4gIHBpeGVscyA9IGN0eC5nZXRJbWFnZURhdGEoMCwgMCwgREVGQVVMVF9GT05UX1NJWkUsIERFRkFVTFRfRk9OVF9TSVpFKS5kYXRhO1xuICBhc2NlbnQgPSAwO1xuICBmb3IgKGxldCBpID0gMCwgaWkgPSBwaXhlbHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gNCkge1xuICAgIGlmIChwaXhlbHNbaV0gPiAwKSB7XG4gICAgICBhc2NlbnQgPSBERUZBVUxUX0ZPTlRfU0laRSAtIE1hdGguZmxvb3IoaSAvIDQgLyBERUZBVUxUX0ZPTlRfU0laRSk7XG4gICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgY3R4LmNhbnZhcy53aWR0aCA9IGN0eC5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgaWYgKGFzY2VudCkge1xuICAgIGNvbnN0IHJhdGlvID0gYXNjZW50IC8gKGFzY2VudCArIGRlc2NlbnQpO1xuICAgIGFzY2VudENhY2hlLnNldChmb250RmFtaWx5LCByYXRpbyk7XG4gICAgcmV0dXJuIHJhdGlvO1xuICB9XG4gIGFzY2VudENhY2hlLnNldChmb250RmFtaWx5LCBERUZBVUxUX0ZPTlRfQVNDRU5UKTtcbiAgcmV0dXJuIERFRkFVTFRfRk9OVF9BU0NFTlQ7XG59XG5mdW5jdGlvbiBhcHBlbmRUZXh0KHRhc2ssIGdlb20sIHN0eWxlcykge1xuICBjb25zdCB0ZXh0RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInNwYW5cIik7XG4gIGNvbnN0IHRleHREaXZQcm9wZXJ0aWVzID0ge1xuICAgIGFuZ2xlOiAwLFxuICAgIGNhbnZhc1dpZHRoOiAwLFxuICAgIGhhc1RleHQ6IGdlb20uc3RyICE9PSBcIlwiLFxuICAgIGhhc0VPTDogZ2VvbS5oYXNFT0wsXG4gICAgZm9udFNpemU6IDBcbiAgfTtcbiAgdGFzay5fdGV4dERpdnMucHVzaCh0ZXh0RGl2KTtcbiAgY29uc3QgdHggPSBfdXRpbC5VdGlsLnRyYW5zZm9ybSh0YXNrLl90cmFuc2Zvcm0sIGdlb20udHJhbnNmb3JtKTtcbiAgbGV0IGFuZ2xlID0gTWF0aC5hdGFuMih0eFsxXSwgdHhbMF0pO1xuICBjb25zdCBzdHlsZSA9IHN0eWxlc1tnZW9tLmZvbnROYW1lXTtcbiAgaWYgKHN0eWxlLnZlcnRpY2FsKSB7XG4gICAgYW5nbGUgKz0gTWF0aC5QSSAvIDI7XG4gIH1cbiAgY29uc3QgZm9udEhlaWdodCA9IE1hdGguaHlwb3QodHhbMl0sIHR4WzNdKTtcbiAgY29uc3QgZm9udEFzY2VudCA9IGZvbnRIZWlnaHQgKiBnZXRBc2NlbnQoc3R5bGUuZm9udEZhbWlseSwgdGFzay5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpO1xuICBsZXQgbGVmdCwgdG9wO1xuICBpZiAoYW5nbGUgPT09IDApIHtcbiAgICBsZWZ0ID0gdHhbNF07XG4gICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50O1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSB0eFs0XSArIGZvbnRBc2NlbnQgKiBNYXRoLnNpbihhbmdsZSk7XG4gICAgdG9wID0gdHhbNV0gLSBmb250QXNjZW50ICogTWF0aC5jb3MoYW5nbGUpO1xuICB9XG4gIGNvbnN0IHNjYWxlRmFjdG9yU3RyID0gXCJjYWxjKHZhcigtLXNjYWxlLWZhY3RvcikqXCI7XG4gIGNvbnN0IGRpdlN0eWxlID0gdGV4dERpdi5zdHlsZTtcbiAgaWYgKHRhc2suX2NvbnRhaW5lciA9PT0gdGFzay5fcm9vdENvbnRhaW5lcikge1xuICAgIGRpdlN0eWxlLmxlZnQgPSBgJHsoMTAwICogbGVmdCAvIHRhc2suX3BhZ2VXaWR0aCkudG9GaXhlZCgyKX0lYDtcbiAgICBkaXZTdHlsZS50b3AgPSBgJHsoMTAwICogdG9wIC8gdGFzay5fcGFnZUhlaWdodCkudG9GaXhlZCgyKX0lYDtcbiAgfSBlbHNlIHtcbiAgICBkaXZTdHlsZS5sZWZ0ID0gYCR7c2NhbGVGYWN0b3JTdHJ9JHtsZWZ0LnRvRml4ZWQoMil9cHgpYDtcbiAgICBkaXZTdHlsZS50b3AgPSBgJHtzY2FsZUZhY3RvclN0cn0ke3RvcC50b0ZpeGVkKDIpfXB4KWA7XG4gIH1cbiAgZGl2U3R5bGUuZm9udFNpemUgPSBgJHtzY2FsZUZhY3RvclN0cn0ke2ZvbnRIZWlnaHQudG9GaXhlZCgyKX1weClgO1xuICBkaXZTdHlsZS5mb250RmFtaWx5ID0gc3R5bGUuZm9udEZhbWlseTtcbiAgdGV4dERpdlByb3BlcnRpZXMuZm9udFNpemUgPSBmb250SGVpZ2h0O1xuICB0ZXh0RGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gIHRleHREaXYudGV4dENvbnRlbnQgPSBnZW9tLnN0cjtcbiAgdGV4dERpdi5kaXIgPSBnZW9tLmRpcjtcbiAgaWYgKHRhc2suX2ZvbnRJbnNwZWN0b3JFbmFibGVkKSB7XG4gICAgdGV4dERpdi5kYXRhc2V0LmZvbnROYW1lID0gZ2VvbS5mb250TmFtZTtcbiAgfVxuICBpZiAoYW5nbGUgIT09IDApIHtcbiAgICB0ZXh0RGl2UHJvcGVydGllcy5hbmdsZSA9IGFuZ2xlICogKDE4MCAvIE1hdGguUEkpO1xuICB9XG4gIGxldCBzaG91bGRTY2FsZVRleHQgPSBmYWxzZTtcbiAgaWYgKGdlb20uc3RyLmxlbmd0aCA+IDEpIHtcbiAgICBzaG91bGRTY2FsZVRleHQgPSB0cnVlO1xuICB9IGVsc2UgaWYgKGdlb20uc3RyICE9PSBcIiBcIiAmJiBnZW9tLnRyYW5zZm9ybVswXSAhPT0gZ2VvbS50cmFuc2Zvcm1bM10pIHtcbiAgICBjb25zdCBhYnNTY2FsZVggPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVswXSksXG4gICAgICBhYnNTY2FsZVkgPSBNYXRoLmFicyhnZW9tLnRyYW5zZm9ybVszXSk7XG4gICAgaWYgKGFic1NjYWxlWCAhPT0gYWJzU2NhbGVZICYmIE1hdGgubWF4KGFic1NjYWxlWCwgYWJzU2NhbGVZKSAvIE1hdGgubWluKGFic1NjYWxlWCwgYWJzU2NhbGVZKSA+IDEuNSkge1xuICAgICAgc2hvdWxkU2NhbGVUZXh0ID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgaWYgKHNob3VsZFNjYWxlVGV4dCkge1xuICAgIHRleHREaXZQcm9wZXJ0aWVzLmNhbnZhc1dpZHRoID0gc3R5bGUudmVydGljYWwgPyBnZW9tLmhlaWdodCA6IGdlb20ud2lkdGg7XG4gIH1cbiAgdGFzay5fdGV4dERpdlByb3BlcnRpZXMuc2V0KHRleHREaXYsIHRleHREaXZQcm9wZXJ0aWVzKTtcbiAgaWYgKHRhc2suX2lzUmVhZGFibGVTdHJlYW0pIHtcbiAgICB0YXNrLl9sYXlvdXRUZXh0KHRleHREaXYpO1xuICB9XG59XG5mdW5jdGlvbiBsYXlvdXQocGFyYW1zKSB7XG4gIGNvbnN0IHtcbiAgICBkaXYsXG4gICAgc2NhbGUsXG4gICAgcHJvcGVydGllcyxcbiAgICBjdHgsXG4gICAgcHJldkZvbnRTaXplLFxuICAgIHByZXZGb250RmFtaWx5XG4gIH0gPSBwYXJhbXM7XG4gIGNvbnN0IHtcbiAgICBzdHlsZVxuICB9ID0gZGl2O1xuICBsZXQgdHJhbnNmb3JtID0gXCJcIjtcbiAgaWYgKHByb3BlcnRpZXMuY2FudmFzV2lkdGggIT09IDAgJiYgcHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgY29uc3Qge1xuICAgICAgZm9udEZhbWlseVxuICAgIH0gPSBzdHlsZTtcbiAgICBjb25zdCB7XG4gICAgICBjYW52YXNXaWR0aCxcbiAgICAgIGZvbnRTaXplXG4gICAgfSA9IHByb3BlcnRpZXM7XG4gICAgaWYgKHByZXZGb250U2l6ZSAhPT0gZm9udFNpemUgfHwgcHJldkZvbnRGYW1pbHkgIT09IGZvbnRGYW1pbHkpIHtcbiAgICAgIGN0eC5mb250ID0gYCR7Zm9udFNpemUgKiBzY2FsZX1weCAke2ZvbnRGYW1pbHl9YDtcbiAgICAgIHBhcmFtcy5wcmV2Rm9udFNpemUgPSBmb250U2l6ZTtcbiAgICAgIHBhcmFtcy5wcmV2Rm9udEZhbWlseSA9IGZvbnRGYW1pbHk7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoXG4gICAgfSA9IGN0eC5tZWFzdXJlVGV4dChkaXYudGV4dENvbnRlbnQpO1xuICAgIGlmICh3aWR0aCA+IDApIHtcbiAgICAgIHRyYW5zZm9ybSA9IGBzY2FsZVgoJHtjYW52YXNXaWR0aCAqIHNjYWxlIC8gd2lkdGh9KWA7XG4gICAgfVxuICB9XG4gIGlmIChwcm9wZXJ0aWVzLmFuZ2xlICE9PSAwKSB7XG4gICAgdHJhbnNmb3JtID0gYHJvdGF0ZSgke3Byb3BlcnRpZXMuYW5nbGV9ZGVnKSAke3RyYW5zZm9ybX1gO1xuICB9XG4gIGlmICh0cmFuc2Zvcm0ubGVuZ3RoID4gMCkge1xuICAgIHN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgfVxufVxuZnVuY3Rpb24gcmVuZGVyKHRhc2spIHtcbiAgaWYgKHRhc2suX2NhbmNlbGVkKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIGNvbnN0IHRleHREaXZzID0gdGFzay5fdGV4dERpdnM7XG4gIGNvbnN0IGNhcGFiaWxpdHkgPSB0YXNrLl9jYXBhYmlsaXR5O1xuICBjb25zdCB0ZXh0RGl2c0xlbmd0aCA9IHRleHREaXZzLmxlbmd0aDtcbiAgaWYgKHRleHREaXZzTGVuZ3RoID4gTUFYX1RFWFRfRElWU19UT19SRU5ERVIpIHtcbiAgICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbiAgICByZXR1cm47XG4gIH1cbiAgaWYgKCF0YXNrLl9pc1JlYWRhYmxlU3RyZWFtKSB7XG4gICAgZm9yIChjb25zdCB0ZXh0RGl2IG9mIHRleHREaXZzKSB7XG4gICAgICB0YXNrLl9sYXlvdXRUZXh0KHRleHREaXYpO1xuICAgIH1cbiAgfVxuICBjYXBhYmlsaXR5LnJlc29sdmUoKTtcbn1cbmNsYXNzIFRleHRMYXllclJlbmRlclRhc2sge1xuICBjb25zdHJ1Y3RvcihfcmVmKSB7XG4gICAgbGV0IHtcbiAgICAgIHRleHRDb250ZW50U291cmNlLFxuICAgICAgY29udGFpbmVyLFxuICAgICAgdmlld3BvcnQsXG4gICAgICB0ZXh0RGl2cyxcbiAgICAgIHRleHREaXZQcm9wZXJ0aWVzLFxuICAgICAgdGV4dENvbnRlbnRJdGVtc1N0cixcbiAgICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkXG4gICAgfSA9IF9yZWY7XG4gICAgdGhpcy5fdGV4dENvbnRlbnRTb3VyY2UgPSB0ZXh0Q29udGVudFNvdXJjZTtcbiAgICB0aGlzLl9pc1JlYWRhYmxlU3RyZWFtID0gdGV4dENvbnRlbnRTb3VyY2UgaW5zdGFuY2VvZiBSZWFkYWJsZVN0cmVhbTtcbiAgICB0aGlzLl9jb250YWluZXIgPSB0aGlzLl9yb290Q29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuX3RleHREaXZzID0gdGV4dERpdnMgfHwgW107XG4gICAgdGhpcy5fdGV4dENvbnRlbnRJdGVtc1N0ciA9IHRleHRDb250ZW50SXRlbXNTdHIgfHwgW107XG4gICAgdGhpcy5faXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQgPSBpc09mZnNjcmVlbkNhbnZhc1N1cHBvcnRlZDtcbiAgICB0aGlzLl9mb250SW5zcGVjdG9yRW5hYmxlZCA9ICEhZ2xvYmFsVGhpcy5Gb250SW5zcGVjdG9yPy5lbmFibGVkO1xuICAgIHRoaXMuX3JlYWRlciA9IG51bGw7XG4gICAgdGhpcy5fdGV4dERpdlByb3BlcnRpZXMgPSB0ZXh0RGl2UHJvcGVydGllcyB8fCBuZXcgV2Vha01hcCgpO1xuICAgIHRoaXMuX2NhbmNlbGVkID0gZmFsc2U7XG4gICAgdGhpcy5fY2FwYWJpbGl0eSA9IG5ldyBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eSgpO1xuICAgIHRoaXMuX2xheW91dFRleHRQYXJhbXMgPSB7XG4gICAgICBwcmV2Rm9udFNpemU6IG51bGwsXG4gICAgICBwcmV2Rm9udEZhbWlseTogbnVsbCxcbiAgICAgIGRpdjogbnVsbCxcbiAgICAgIHNjYWxlOiB2aWV3cG9ydC5zY2FsZSAqIChnbG9iYWxUaGlzLmRldmljZVBpeGVsUmF0aW8gfHwgMSksXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgY3R4OiBnZXRDdHgoMCwgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpXG4gICAgfTtcbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIHRoaXMuX3RyYW5zZm9ybSA9IFsxLCAwLCAwLCAtMSwgLXBhZ2VYLCBwYWdlWSArIHBhZ2VIZWlnaHRdO1xuICAgIHRoaXMuX3BhZ2VXaWR0aCA9IHBhZ2VXaWR0aDtcbiAgICB0aGlzLl9wYWdlSGVpZ2h0ID0gcGFnZUhlaWdodDtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKShjb250YWluZXIsIHZpZXdwb3J0KTtcbiAgICB0aGlzLl9jYXBhYmlsaXR5LnByb21pc2UuZmluYWxseSgoKSA9PiB7XG4gICAgICB0aGlzLl9sYXlvdXRUZXh0UGFyYW1zID0gbnVsbDtcbiAgICB9KS5jYXRjaCgoKSA9PiB7fSk7XG4gIH1cbiAgZ2V0IHByb21pc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMuX2NhcGFiaWxpdHkucHJvbWlzZTtcbiAgfVxuICBjYW5jZWwoKSB7XG4gICAgdGhpcy5fY2FuY2VsZWQgPSB0cnVlO1xuICAgIGlmICh0aGlzLl9yZWFkZXIpIHtcbiAgICAgIHRoaXMuX3JlYWRlci5jYW5jZWwobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKSkuY2F0Y2goKCkgPT4ge30pO1xuICAgICAgdGhpcy5fcmVhZGVyID0gbnVsbDtcbiAgICB9XG4gICAgdGhpcy5fY2FwYWJpbGl0eS5yZWplY3QobmV3IF91dGlsLkFib3J0RXhjZXB0aW9uKFwiVGV4dExheWVyIHRhc2sgY2FuY2VsbGVkLlwiKSk7XG4gIH1cbiAgX3Byb2Nlc3NJdGVtcyhpdGVtcywgc3R5bGVDYWNoZSkge1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBpdGVtcykge1xuICAgICAgaWYgKGl0ZW0uc3RyID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRQcm9wc1wiIHx8IGl0ZW0udHlwZSA9PT0gXCJiZWdpbk1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIGNvbnN0IHBhcmVudCA9IHRoaXMuX2NvbnRhaW5lcjtcbiAgICAgICAgICB0aGlzLl9jb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgICAgICB0aGlzLl9jb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm1hcmtlZENvbnRlbnRcIik7XG4gICAgICAgICAgaWYgKGl0ZW0uaWQgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRoaXMuX2NvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJpZFwiLCBgJHtpdGVtLmlkfWApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJlbnQuYXBwZW5kKHRoaXMuX2NvbnRhaW5lcik7XG4gICAgICAgIH0gZWxzZSBpZiAoaXRlbS50eXBlID09PSBcImVuZE1hcmtlZENvbnRlbnRcIikge1xuICAgICAgICAgIHRoaXMuX2NvbnRhaW5lciA9IHRoaXMuX2NvbnRhaW5lci5wYXJlbnROb2RlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgdGhpcy5fdGV4dENvbnRlbnRJdGVtc1N0ci5wdXNoKGl0ZW0uc3RyKTtcbiAgICAgIGFwcGVuZFRleHQodGhpcywgaXRlbSwgc3R5bGVDYWNoZSk7XG4gICAgfVxuICB9XG4gIF9sYXlvdXRUZXh0KHRleHREaXYpIHtcbiAgICBjb25zdCB0ZXh0RGl2UHJvcGVydGllcyA9IHRoaXMuX2xheW91dFRleHRQYXJhbXMucHJvcGVydGllcyA9IHRoaXMuX3RleHREaXZQcm9wZXJ0aWVzLmdldCh0ZXh0RGl2KTtcbiAgICB0aGlzLl9sYXlvdXRUZXh0UGFyYW1zLmRpdiA9IHRleHREaXY7XG4gICAgbGF5b3V0KHRoaXMuX2xheW91dFRleHRQYXJhbXMpO1xuICAgIGlmICh0ZXh0RGl2UHJvcGVydGllcy5oYXNUZXh0KSB7XG4gICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kKHRleHREaXYpO1xuICAgIH1cbiAgICBpZiAodGV4dERpdlByb3BlcnRpZXMuaGFzRU9MKSB7XG4gICAgICBjb25zdCBiciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJiclwiKTtcbiAgICAgIGJyLnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJwcmVzZW50YXRpb25cIik7XG4gICAgICB0aGlzLl9jb250YWluZXIuYXBwZW5kKGJyKTtcbiAgICB9XG4gIH1cbiAgX3JlbmRlcigpIHtcbiAgICBjb25zdCBjYXBhYmlsaXR5ID0gbmV3IF91dGlsLlByb21pc2VDYXBhYmlsaXR5KCk7XG4gICAgbGV0IHN0eWxlQ2FjaGUgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIGlmICh0aGlzLl9pc1JlYWRhYmxlU3RyZWFtKSB7XG4gICAgICBjb25zdCBwdW1wID0gKCkgPT4ge1xuICAgICAgICB0aGlzLl9yZWFkZXIucmVhZCgpLnRoZW4oX3JlZjIgPT4ge1xuICAgICAgICAgIGxldCB7XG4gICAgICAgICAgICB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmVcbiAgICAgICAgICB9ID0gX3JlZjI7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBPYmplY3QuYXNzaWduKHN0eWxlQ2FjaGUsIHZhbHVlLnN0eWxlcyk7XG4gICAgICAgICAgdGhpcy5fcHJvY2Vzc0l0ZW1zKHZhbHVlLml0ZW1zLCBzdHlsZUNhY2hlKTtcbiAgICAgICAgICBwdW1wKCk7XG4gICAgICAgIH0sIGNhcGFiaWxpdHkucmVqZWN0KTtcbiAgICAgIH07XG4gICAgICB0aGlzLl9yZWFkZXIgPSB0aGlzLl90ZXh0Q29udGVudFNvdXJjZS5nZXRSZWFkZXIoKTtcbiAgICAgIHB1bXAoKTtcbiAgICB9IGVsc2UgaWYgKHRoaXMuX3RleHRDb250ZW50U291cmNlKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGl0ZW1zLFxuICAgICAgICBzdHlsZXNcbiAgICAgIH0gPSB0aGlzLl90ZXh0Q29udGVudFNvdXJjZTtcbiAgICAgIHRoaXMuX3Byb2Nlc3NJdGVtcyhpdGVtcywgc3R5bGVzKTtcbiAgICAgIGNhcGFiaWxpdHkucmVzb2x2ZSgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ05vIFwidGV4dENvbnRlbnRTb3VyY2VcIiBwYXJhbWV0ZXIgc3BlY2lmaWVkLicpO1xuICAgIH1cbiAgICBjYXBhYmlsaXR5LnByb21pc2UudGhlbigoKSA9PiB7XG4gICAgICBzdHlsZUNhY2hlID0gbnVsbDtcbiAgICAgIHJlbmRlcih0aGlzKTtcbiAgICB9LCB0aGlzLl9jYXBhYmlsaXR5LnJlamVjdCk7XG4gIH1cbn1cbmV4cG9ydHMuVGV4dExheWVyUmVuZGVyVGFzayA9IFRleHRMYXllclJlbmRlclRhc2s7XG5mdW5jdGlvbiByZW5kZXJUZXh0TGF5ZXIocGFyYW1zKSB7XG4gIGlmICghcGFyYW1zLnRleHRDb250ZW50U291cmNlICYmIChwYXJhbXMudGV4dENvbnRlbnQgfHwgcGFyYW1zLnRleHRDb250ZW50U3RyZWFtKSkge1xuICAgICgwLCBfZGlzcGxheV91dGlscy5kZXByZWNhdGVkKShcIlRoZSBUZXh0TGF5ZXJSZW5kZXIgYHRleHRDb250ZW50YC9gdGV4dENvbnRlbnRTdHJlYW1gIHBhcmFtZXRlcnMgXCIgKyBcIndpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgZnV0dXJlLCBwbGVhc2UgdXNlIGB0ZXh0Q29udGVudFNvdXJjZWAgaW5zdGVhZC5cIik7XG4gICAgcGFyYW1zLnRleHRDb250ZW50U291cmNlID0gcGFyYW1zLnRleHRDb250ZW50IHx8IHBhcmFtcy50ZXh0Q29udGVudFN0cmVhbTtcbiAgfVxuICBjb25zdCB7XG4gICAgY29udGFpbmVyLFxuICAgIHZpZXdwb3J0XG4gIH0gPSBwYXJhbXM7XG4gIGNvbnN0IHN0eWxlID0gZ2V0Q29tcHV0ZWRTdHlsZShjb250YWluZXIpO1xuICBjb25zdCB2aXNpYmlsaXR5ID0gc3R5bGUuZ2V0UHJvcGVydHlWYWx1ZShcInZpc2liaWxpdHlcIik7XG4gIGNvbnN0IHNjYWxlRmFjdG9yID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1zY2FsZS1mYWN0b3JcIikpO1xuICBpZiAodmlzaWJpbGl0eSA9PT0gXCJ2aXNpYmxlXCIgJiYgKCFzY2FsZUZhY3RvciB8fCBNYXRoLmFicyhzY2FsZUZhY3RvciAtIHZpZXdwb3J0LnNjYWxlKSA+IDFlLTUpKSB7XG4gICAgY29uc29sZS5lcnJvcihcIlRoZSBgLS1zY2FsZS1mYWN0b3JgIENTUy12YXJpYWJsZSBtdXN0IGJlIHNldCwgXCIgKyBcInRvIHRoZSBzYW1lIHZhbHVlIGFzIGB2aWV3cG9ydC5zY2FsZWAsIFwiICsgXCJlaXRoZXIgb24gdGhlIGBjb250YWluZXJgLWVsZW1lbnQgaXRzZWxmIG9yIGhpZ2hlciB1cCBpbiB0aGUgRE9NLlwiKTtcbiAgfVxuICBjb25zdCB0YXNrID0gbmV3IFRleHRMYXllclJlbmRlclRhc2socGFyYW1zKTtcbiAgdGFzay5fcmVuZGVyKCk7XG4gIHJldHVybiB0YXNrO1xufVxuZnVuY3Rpb24gdXBkYXRlVGV4dExheWVyKF9yZWYzKSB7XG4gIGxldCB7XG4gICAgY29udGFpbmVyLFxuICAgIHZpZXdwb3J0LFxuICAgIHRleHREaXZzLFxuICAgIHRleHREaXZQcm9wZXJ0aWVzLFxuICAgIGlzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydGVkLFxuICAgIG11c3RSb3RhdGUgPSB0cnVlLFxuICAgIG11c3RSZXNjYWxlID0gdHJ1ZVxuICB9ID0gX3JlZjM7XG4gIGlmIChtdXN0Um90YXRlKSB7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucykoY29udGFpbmVyLCB7XG4gICAgICByb3RhdGlvbjogdmlld3BvcnQucm90YXRpb25cbiAgICB9KTtcbiAgfVxuICBpZiAobXVzdFJlc2NhbGUpIHtcbiAgICBjb25zdCBjdHggPSBnZXRDdHgoMCwgaXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ZWQpO1xuICAgIGNvbnN0IHNjYWxlID0gdmlld3BvcnQuc2NhbGUgKiAoZ2xvYmFsVGhpcy5kZXZpY2VQaXhlbFJhdGlvIHx8IDEpO1xuICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgIHByZXZGb250U2l6ZTogbnVsbCxcbiAgICAgIHByZXZGb250RmFtaWx5OiBudWxsLFxuICAgICAgZGl2OiBudWxsLFxuICAgICAgc2NhbGUsXG4gICAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgICAgY3R4XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGRpdiBvZiB0ZXh0RGl2cykge1xuICAgICAgcGFyYW1zLnByb3BlcnRpZXMgPSB0ZXh0RGl2UHJvcGVydGllcy5nZXQoZGl2KTtcbiAgICAgIHBhcmFtcy5kaXYgPSBkaXY7XG4gICAgICBsYXlvdXQocGFyYW1zKTtcbiAgICB9XG4gIH1cbn1cblxuLyoqKi8gfSksXG4vKiAxOTYgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMsIF9fd19wZGZqc19yZXF1aXJlX18pID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQW5ub3RhdGlvbkVkaXRvckxheWVyID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMjUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMzYpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxMzgpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDEpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDMpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDUpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDcpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZWRpdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjQpO1xudmFyIF9mcmVldGV4dCA9IF9fd19wZGZqc19yZXF1aXJlX18oMTk3KTtcbnZhciBfaW5rID0gX193X3BkZmpzX3JlcXVpcmVfXygyMDIpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjgpO1xudmFyIF9zdGFtcCA9IF9fd19wZGZqc19yZXF1aXJlX18oMjAzKTtcbmNsYXNzIEFubm90YXRpb25FZGl0b3JMYXllciB7XG4gICNhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgI2FsbG93Q2xpY2sgPSBmYWxzZTtcbiAgI2Fubm90YXRpb25MYXllciA9IG51bGw7XG4gICNib3VuZFBvaW50ZXJ1cCA9IHRoaXMucG9pbnRlcnVwLmJpbmQodGhpcyk7XG4gICNib3VuZFBvaW50ZXJkb3duID0gdGhpcy5wb2ludGVyZG93bi5iaW5kKHRoaXMpO1xuICAjZWRpdG9ycyA9IG5ldyBNYXAoKTtcbiAgI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICNpc0NsZWFuaW5nVXAgPSBmYWxzZTtcbiAgI2lzRGlzYWJsaW5nID0gZmFsc2U7XG4gICN1aU1hbmFnZXI7XG4gIHN0YXRpYyBfaW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IoX3JlZikge1xuICAgIGxldCB7XG4gICAgICB1aU1hbmFnZXIsXG4gICAgICBwYWdlSW5kZXgsXG4gICAgICBkaXYsXG4gICAgICBhY2Nlc3NpYmlsaXR5TWFuYWdlcixcbiAgICAgIGFubm90YXRpb25MYXllcixcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgbDEwblxuICAgIH0gPSBfcmVmO1xuICAgIGNvbnN0IGVkaXRvclR5cGVzID0gW19mcmVldGV4dC5GcmVlVGV4dEVkaXRvciwgX2luay5JbmtFZGl0b3IsIF9zdGFtcC5TdGFtcEVkaXRvcl07XG4gICAgaWYgKCFBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkKSB7XG4gICAgICBBbm5vdGF0aW9uRWRpdG9yTGF5ZXIuX2luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIGZvciAoY29uc3QgZWRpdG9yVHlwZSBvZiBlZGl0b3JUeXBlcykge1xuICAgICAgICBlZGl0b3JUeXBlLmluaXRpYWxpemUobDEwbik7XG4gICAgICB9XG4gICAgfVxuICAgIHVpTWFuYWdlci5yZWdpc3RlckVkaXRvclR5cGVzKGVkaXRvclR5cGVzKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIgPSB1aU1hbmFnZXI7XG4gICAgdGhpcy5wYWdlSW5kZXggPSBwYWdlSW5kZXg7XG4gICAgdGhpcy5kaXYgPSBkaXY7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXIgPSBhY2Nlc3NpYmlsaXR5TWFuYWdlcjtcbiAgICB0aGlzLiNhbm5vdGF0aW9uTGF5ZXIgPSBhbm5vdGF0aW9uTGF5ZXI7XG4gICAgdGhpcy52aWV3cG9ydCA9IHZpZXdwb3J0O1xuICAgIHRoaXMuI3VpTWFuYWdlci5hZGRMYXllcih0aGlzKTtcbiAgfVxuICBnZXQgaXNFbXB0eSgpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdG9ycy5zaXplID09PSAwO1xuICB9XG4gIHVwZGF0ZVRvb2xiYXIobW9kZSkge1xuICAgIHRoaXMuI3VpTWFuYWdlci51cGRhdGVUb29sYmFyKG1vZGUpO1xuICB9XG4gIHVwZGF0ZU1vZGUoKSB7XG4gICAgbGV0IG1vZGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCk7XG4gICAgdGhpcy4jY2xlYW51cCgpO1xuICAgIGlmIChtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkspIHtcbiAgICAgIHRoaXMuYWRkSW5rRWRpdG9ySWZOZWVkZWQoZmFsc2UpO1xuICAgICAgdGhpcy5kaXNhYmxlQ2xpY2soKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5lbmFibGVDbGljaygpO1xuICAgIH1cbiAgICBpZiAobW9kZSAhPT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuTk9ORSkge1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcImZyZWVUZXh0RWRpdGluZ1wiLCBtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCk7XG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiaW5rRWRpdGluZ1wiLCBtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5JTkspO1xuICAgICAgdGhpcy5kaXYuY2xhc3NMaXN0LnRvZ2dsZShcInN0YW1wRWRpdGluZ1wiLCBtb2RlID09PSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCk7XG4gICAgICB0aGlzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgYWRkSW5rRWRpdG9ySWZOZWVkZWQoaXNDb21taXR0aW5nKSB7XG4gICAgaWYgKCFpc0NvbW1pdHRpbmcgJiYgdGhpcy4jdWlNYW5hZ2VyLmdldE1vZGUoKSAhPT0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghaXNDb21taXR0aW5nKSB7XG4gICAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgICAgZWRpdG9yLnNldEluQmFja2dyb3VuZCgpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVBbmRBZGROZXdFZGl0b3Ioe1xuICAgICAgb2Zmc2V0WDogMCxcbiAgICAgIG9mZnNldFk6IDBcbiAgICB9LCBmYWxzZSk7XG4gICAgZWRpdG9yLnNldEluQmFja2dyb3VuZCgpO1xuICB9XG4gIHNldEVkaXRpbmdTdGF0ZShpc0VkaXRpbmcpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0RWRpdGluZ1N0YXRlKGlzRWRpdGluZyk7XG4gIH1cbiAgYWRkQ29tbWFuZHMocGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZENvbW1hbmRzKHBhcmFtcyk7XG4gIH1cbiAgZW5hYmxlKCkge1xuICAgIHRoaXMuZGl2LnN0eWxlLnBvaW50ZXJFdmVudHMgPSBcImF1dG9cIjtcbiAgICBjb25zdCBhbm5vdGF0aW9uRWxlbWVudElkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICAgIGFubm90YXRpb25FbGVtZW50SWRzLmFkZChlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvbkxheWVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGVkaXRhYmxlcyA9IHRoaXMuI2Fubm90YXRpb25MYXllci5nZXRFZGl0YWJsZUFubm90YXRpb25zKCk7XG4gICAgZm9yIChjb25zdCBlZGl0YWJsZSBvZiBlZGl0YWJsZXMpIHtcbiAgICAgIGVkaXRhYmxlLmhpZGUoKTtcbiAgICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdGFibGUuZGF0YS5pZCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZHMuaGFzKGVkaXRhYmxlLmRhdGEuaWQpKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5kZXNlcmlhbGl6ZShlZGl0YWJsZSk7XG4gICAgICBpZiAoIWVkaXRvcikge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuYWRkT3JSZWJ1aWxkKGVkaXRvcik7XG4gICAgICBlZGl0b3IuZW5hYmxlRWRpdGluZygpO1xuICAgIH1cbiAgfVxuICBkaXNhYmxlKCkge1xuICAgIHRoaXMuI2lzRGlzYWJsaW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5zdHlsZS5wb2ludGVyRXZlbnRzID0gXCJub25lXCI7XG4gICAgY29uc3QgaGlkZGVuQW5ub3RhdGlvbklkcyA9IG5ldyBTZXQoKTtcbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICBlZGl0b3IuZGlzYWJsZUVkaXRpbmcoKTtcbiAgICAgIGlmICghZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgfHwgZWRpdG9yLnNlcmlhbGl6ZSgpICE9PSBudWxsKSB7XG4gICAgICAgIGhpZGRlbkFubm90YXRpb25JZHMuYWRkKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICB0aGlzLmdldEVkaXRhYmxlQW5ub3RhdGlvbihlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCk/LnNob3coKTtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2Fubm90YXRpb25MYXllcikge1xuICAgICAgY29uc3QgZWRpdGFibGVzID0gdGhpcy4jYW5ub3RhdGlvbkxheWVyLmdldEVkaXRhYmxlQW5ub3RhdGlvbnMoKTtcbiAgICAgIGZvciAoY29uc3QgZWRpdGFibGUgb2YgZWRpdGFibGVzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZWRpdGFibGUuZGF0YTtcbiAgICAgICAgaWYgKGhpZGRlbkFubm90YXRpb25JZHMuaGFzKGlkKSB8fCB0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoaWQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWRpdGFibGUuc2hvdygpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNjbGVhbnVwKCk7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSkge1xuICAgICAgdGhpcy5kaXYuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy4jaXNEaXNhYmxpbmcgPSBmYWxzZTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jYW5ub3RhdGlvbkxheWVyPy5nZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHx8IG51bGw7XG4gIH1cbiAgc2V0QWN0aXZlRWRpdG9yKGVkaXRvcikge1xuICAgIGNvbnN0IGN1cnJlbnRBY3RpdmUgPSB0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk7XG4gICAgaWYgKGN1cnJlbnRBY3RpdmUgPT09IGVkaXRvcikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKGVkaXRvcik7XG4gIH1cbiAgZW5hYmxlQ2xpY2soKSB7XG4gICAgdGhpcy5kaXYuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJkb3duXCIsIHRoaXMuI2JvdW5kUG9pbnRlcmRvd24pO1xuICAgIHRoaXMuZGl2LmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy4jYm91bmRQb2ludGVydXApO1xuICB9XG4gIGRpc2FibGVDbGljaygpIHtcbiAgICB0aGlzLmRpdi5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRQb2ludGVyZG93bik7XG4gICAgdGhpcy5kaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJ1cFwiLCB0aGlzLiNib3VuZFBvaW50ZXJ1cCk7XG4gIH1cbiAgYXR0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuc2V0KGVkaXRvci5pZCwgZWRpdG9yKTtcbiAgICBjb25zdCB7XG4gICAgICBhbm5vdGF0aW9uRWxlbWVudElkXG4gICAgfSA9IGVkaXRvcjtcbiAgICBpZiAoYW5ub3RhdGlvbkVsZW1lbnRJZCAmJiB0aGlzLiN1aU1hbmFnZXIuaXNEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoYW5ub3RhdGlvbkVsZW1lbnRJZCkpIHtcbiAgICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVEZWxldGVkQW5ub3RhdGlvbkVsZW1lbnQoZWRpdG9yKTtcbiAgICB9XG4gIH1cbiAgZGV0YWNoKGVkaXRvcikge1xuICAgIHRoaXMuI2VkaXRvcnMuZGVsZXRlKGVkaXRvci5pZCk7XG4gICAgdGhpcy4jYWNjZXNzaWJpbGl0eU1hbmFnZXI/LnJlbW92ZVBvaW50ZXJJblRleHRMYXllcihlZGl0b3IuY29udGVudERpdik7XG4gICAgaWYgKCF0aGlzLiNpc0Rpc2FibGluZyAmJiBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCkge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmFkZERlbGV0ZWRBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICByZW1vdmUoZWRpdG9yKSB7XG4gICAgdGhpcy5kZXRhY2goZWRpdG9yKTtcbiAgICB0aGlzLiN1aU1hbmFnZXIucmVtb3ZlRWRpdG9yKGVkaXRvcik7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICB0aGlzLiN1aU1hbmFnZXIuZm9jdXNNYWluQ29udGFpbmVyKCk7XG4gICAgICB9LCAwKTtcbiAgICB9XG4gICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLiNpc0NsZWFuaW5nVXApIHtcbiAgICAgIHRoaXMuYWRkSW5rRWRpdG9ySWZOZWVkZWQoZmFsc2UpO1xuICAgIH1cbiAgfVxuICBjaGFuZ2VQYXJlbnQoZWRpdG9yKSB7XG4gICAgaWYgKGVkaXRvci5wYXJlbnQgPT09IHRoaXMpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuYWRkRGVsZXRlZEFubm90YXRpb25FbGVtZW50KGVkaXRvci5hbm5vdGF0aW9uRWxlbWVudElkKTtcbiAgICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5kZWxldGVBbm5vdGF0aW9uRWxlbWVudChlZGl0b3IpO1xuICAgICAgZWRpdG9yLmFubm90YXRpb25FbGVtZW50SWQgPSBudWxsO1xuICAgIH1cbiAgICB0aGlzLmF0dGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5wYXJlbnQ/LmRldGFjaChlZGl0b3IpO1xuICAgIGVkaXRvci5zZXRQYXJlbnQodGhpcyk7XG4gICAgaWYgKGVkaXRvci5kaXYgJiYgZWRpdG9yLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgZWRpdG9yLmRpdi5yZW1vdmUoKTtcbiAgICAgIHRoaXMuZGl2LmFwcGVuZChlZGl0b3IuZGl2KTtcbiAgICB9XG4gIH1cbiAgYWRkKGVkaXRvcikge1xuICAgIHRoaXMuY2hhbmdlUGFyZW50KGVkaXRvcik7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZEVkaXRvcihlZGl0b3IpO1xuICAgIHRoaXMuYXR0YWNoKGVkaXRvcik7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICBjb25zdCBkaXYgPSBlZGl0b3IucmVuZGVyKCk7XG4gICAgICB0aGlzLmRpdi5hcHBlbmQoZGl2KTtcbiAgICAgIGVkaXRvci5pc0F0dGFjaGVkVG9ET00gPSB0cnVlO1xuICAgIH1cbiAgICBlZGl0b3IuZml4QW5kU2V0UG9zaXRpb24oKTtcbiAgICBlZGl0b3Iub25jZUFkZGVkKCk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLmFkZFRvQW5ub3RhdGlvblN0b3JhZ2UoZWRpdG9yKTtcbiAgfVxuICBtb3ZlRWRpdG9ySW5ET00oZWRpdG9yKSB7XG4gICAgaWYgKCFlZGl0b3IuaXNBdHRhY2hlZFRvRE9NKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGFjdGl2ZUVsZW1lbnRcbiAgICB9ID0gZG9jdW1lbnQ7XG4gICAgaWYgKGVkaXRvci5kaXYuY29udGFpbnMoYWN0aXZlRWxlbWVudCkpIHtcbiAgICAgIGVkaXRvci5fZm9jdXNFdmVudHNBbGxvd2VkID0gZmFsc2U7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgaWYgKCFlZGl0b3IuZGl2LmNvbnRhaW5zKGRvY3VtZW50LmFjdGl2ZUVsZW1lbnQpKSB7XG4gICAgICAgICAgZWRpdG9yLmRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNpblwiLCAoKSA9PiB7XG4gICAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgICAgfSwge1xuICAgICAgICAgICAgb25jZTogdHJ1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGFjdGl2ZUVsZW1lbnQuZm9jdXMoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBlZGl0b3IuX2ZvY3VzRXZlbnRzQWxsb3dlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH0sIDApO1xuICAgIH1cbiAgICBlZGl0b3IuX3N0cnVjdFRyZWVQYXJlbnRJZCA9IHRoaXMuI2FjY2Vzc2liaWxpdHlNYW5hZ2VyPy5tb3ZlRWxlbWVudEluRE9NKHRoaXMuZGl2LCBlZGl0b3IuZGl2LCBlZGl0b3IuY29udGVudERpdiwgdHJ1ZSk7XG4gIH1cbiAgYWRkT3JSZWJ1aWxkKGVkaXRvcikge1xuICAgIGlmIChlZGl0b3IubmVlZHNUb0JlUmVidWlsdCgpKSB7XG4gICAgICBlZGl0b3IucmVidWlsZCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBhZGRVbmRvYWJsZUVkaXRvcihlZGl0b3IpIHtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiBlZGl0b3IuX3VpTWFuYWdlci5yZWJ1aWxkKGVkaXRvcik7XG4gICAgY29uc3QgdW5kbyA9ICgpID0+IHtcbiAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiBmYWxzZVxuICAgIH0pO1xuICB9XG4gIGdldE5leHRJZCgpIHtcbiAgICByZXR1cm4gdGhpcy4jdWlNYW5hZ2VyLmdldElkKCk7XG4gIH1cbiAgI2NyZWF0ZU5ld0VkaXRvcihwYXJhbXMpIHtcbiAgICBzd2l0Y2ggKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgX2ZyZWV0ZXh0LkZyZWVUZXh0RWRpdG9yKHBhcmFtcyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLklOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBfaW5rLklua0VkaXRvcihwYXJhbXMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUDpcbiAgICAgICAgcmV0dXJuIG5ldyBfc3RhbXAuU3RhbXBFZGl0b3IocGFyYW1zKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgcGFzdGVFZGl0b3IobW9kZSwgcGFyYW1zKSB7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZVRvb2xiYXIobW9kZSk7XG4gICAgdGhpcy4jdWlNYW5hZ2VyLnVwZGF0ZU1vZGUobW9kZSk7XG4gICAgY29uc3Qge1xuICAgICAgb2Zmc2V0WCxcbiAgICAgIG9mZnNldFlcbiAgICB9ID0gdGhpcy4jZ2V0Q2VudGVyUG9pbnQoKTtcbiAgICBjb25zdCBpZCA9IHRoaXMuZ2V0TmV4dElkKCk7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jY3JlYXRlTmV3RWRpdG9yKHtcbiAgICAgIHBhcmVudDogdGhpcyxcbiAgICAgIGlkLFxuICAgICAgeDogb2Zmc2V0WCxcbiAgICAgIHk6IG9mZnNldFksXG4gICAgICB1aU1hbmFnZXI6IHRoaXMuI3VpTWFuYWdlcixcbiAgICAgIGlzQ2VudGVyZWQ6IHRydWUsXG4gICAgICAuLi5wYXJhbXNcbiAgICB9KTtcbiAgICBpZiAoZWRpdG9yKSB7XG4gICAgICB0aGlzLmFkZChlZGl0b3IpO1xuICAgIH1cbiAgfVxuICBkZXNlcmlhbGl6ZShkYXRhKSB7XG4gICAgc3dpdGNoIChkYXRhLmFubm90YXRpb25UeXBlID8/IGRhdGEuYW5ub3RhdGlvbkVkaXRvclR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQ6XG4gICAgICAgIHJldHVybiBfZnJlZXRleHQuRnJlZVRleHRFZGl0b3IuZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gX2luay5JbmtFZGl0b3IuZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuU1RBTVA6XG4gICAgICAgIHJldHVybiBfc3RhbXAuU3RhbXBFZGl0b3IuZGVzZXJpYWxpemUoZGF0YSwgdGhpcywgdGhpcy4jdWlNYW5hZ2VyKTtcbiAgICB9XG4gICAgcmV0dXJuIG51bGw7XG4gIH1cbiAgI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcihldmVudCwgaXNDZW50ZXJlZCkge1xuICAgIGNvbnN0IGlkID0gdGhpcy5nZXROZXh0SWQoKTtcbiAgICBjb25zdCBlZGl0b3IgPSB0aGlzLiNjcmVhdGVOZXdFZGl0b3Ioe1xuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgaWQsXG4gICAgICB4OiBldmVudC5vZmZzZXRYLFxuICAgICAgeTogZXZlbnQub2Zmc2V0WSxcbiAgICAgIHVpTWFuYWdlcjogdGhpcy4jdWlNYW5hZ2VyLFxuICAgICAgaXNDZW50ZXJlZFxuICAgIH0pO1xuICAgIGlmIChlZGl0b3IpIHtcbiAgICAgIHRoaXMuYWRkKGVkaXRvcik7XG4gICAgfVxuICAgIHJldHVybiBlZGl0b3I7XG4gIH1cbiAgI2dldENlbnRlclBvaW50KCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHgsXG4gICAgICB5LFxuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gdGhpcy5kaXYuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgY29uc3QgdGxYID0gTWF0aC5tYXgoMCwgeCk7XG4gICAgY29uc3QgdGxZID0gTWF0aC5tYXgoMCwgeSk7XG4gICAgY29uc3QgYnJYID0gTWF0aC5taW4od2luZG93LmlubmVyV2lkdGgsIHggKyB3aWR0aCk7XG4gICAgY29uc3QgYnJZID0gTWF0aC5taW4od2luZG93LmlubmVySGVpZ2h0LCB5ICsgaGVpZ2h0KTtcbiAgICBjb25zdCBjZW50ZXJYID0gKHRsWCArIGJyWCkgLyAyIC0geDtcbiAgICBjb25zdCBjZW50ZXJZID0gKHRsWSArIGJyWSkgLyAyIC0geTtcbiAgICBjb25zdCBbb2Zmc2V0WCwgb2Zmc2V0WV0gPSB0aGlzLnZpZXdwb3J0LnJvdGF0aW9uICUgMTgwID09PSAwID8gW2NlbnRlclgsIGNlbnRlclldIDogW2NlbnRlclksIGNlbnRlclhdO1xuICAgIHJldHVybiB7XG4gICAgICBvZmZzZXRYLFxuICAgICAgb2Zmc2V0WVxuICAgIH07XG4gIH1cbiAgYWRkTmV3RWRpdG9yKCkge1xuICAgIHRoaXMuI2NyZWF0ZUFuZEFkZE5ld0VkaXRvcih0aGlzLiNnZXRDZW50ZXJQb2ludCgpLCB0cnVlKTtcbiAgfVxuICBzZXRTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIuc2V0U2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICB0b2dnbGVTZWxlY3RlZChlZGl0b3IpIHtcbiAgICB0aGlzLiN1aU1hbmFnZXIudG9nZ2xlU2VsZWN0ZWQoZWRpdG9yKTtcbiAgfVxuICBpc1NlbGVjdGVkKGVkaXRvcikge1xuICAgIHJldHVybiB0aGlzLiN1aU1hbmFnZXIuaXNTZWxlY3RlZChlZGl0b3IpO1xuICB9XG4gIHVuc2VsZWN0KGVkaXRvcikge1xuICAgIHRoaXMuI3VpTWFuYWdlci51bnNlbGVjdChlZGl0b3IpO1xuICB9XG4gIHBvaW50ZXJ1cChldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuI2hhZFBvaW50ZXJEb3duKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgaWYgKCF0aGlzLiNhbGxvd0NsaWNrKSB7XG4gICAgICB0aGlzLiNhbGxvd0NsaWNrID0gdHJ1ZTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI3VpTWFuYWdlci5nZXRNb2RlKCkgPT09IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QKSB7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIudW5zZWxlY3RBbGwoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY3JlYXRlQW5kQWRkTmV3RWRpdG9yKGV2ZW50LCBmYWxzZSk7XG4gIH1cbiAgcG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBpZiAodGhpcy4jaGFkUG9pbnRlckRvd24pIHtcbiAgICAgIHRoaXMuI2hhZFBvaW50ZXJEb3duID0gZmFsc2U7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGlmIChldmVudC5idXR0b24gIT09IDAgfHwgZXZlbnQuY3RybEtleSAmJiBpc01hYykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmRpdikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiNoYWRQb2ludGVyRG93biA9IHRydWU7XG4gICAgY29uc3QgZWRpdG9yID0gdGhpcy4jdWlNYW5hZ2VyLmdldEFjdGl2ZSgpO1xuICAgIHRoaXMuI2FsbG93Q2xpY2sgPSAhZWRpdG9yIHx8IGVkaXRvci5pc0VtcHR5KCk7XG4gIH1cbiAgZmluZE5ld1BhcmVudChlZGl0b3IsIHgsIHkpIHtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuI3VpTWFuYWdlci5maW5kUGFyZW50KHgsIHkpO1xuICAgIGlmIChsYXllciA9PT0gbnVsbCB8fCBsYXllciA9PT0gdGhpcykge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBsYXllci5jaGFuZ2VQYXJlbnQoZWRpdG9yKTtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBkZXN0cm95KCkge1xuICAgIGlmICh0aGlzLiN1aU1hbmFnZXIuZ2V0QWN0aXZlKCk/LnBhcmVudCA9PT0gdGhpcykge1xuICAgICAgdGhpcy4jdWlNYW5hZ2VyLmNvbW1pdE9yUmVtb3ZlKCk7XG4gICAgICB0aGlzLiN1aU1hbmFnZXIuc2V0QWN0aXZlRWRpdG9yKG51bGwpO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGVkaXRvciBvZiB0aGlzLiNlZGl0b3JzLnZhbHVlcygpKSB7XG4gICAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ucmVtb3ZlUG9pbnRlckluVGV4dExheWVyKGVkaXRvci5jb250ZW50RGl2KTtcbiAgICAgIGVkaXRvci5zZXRQYXJlbnQobnVsbCk7XG4gICAgICBlZGl0b3IuaXNBdHRhY2hlZFRvRE9NID0gZmFsc2U7XG4gICAgICBlZGl0b3IuZGl2LnJlbW92ZSgpO1xuICAgIH1cbiAgICB0aGlzLmRpdiA9IG51bGw7XG4gICAgdGhpcy4jZWRpdG9ycy5jbGVhcigpO1xuICAgIHRoaXMuI3VpTWFuYWdlci5yZW1vdmVMYXllcih0aGlzKTtcbiAgfVxuICAjY2xlYW51cCgpIHtcbiAgICB0aGlzLiNpc0NsZWFuaW5nVXAgPSB0cnVlO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI2VkaXRvcnMudmFsdWVzKCkpIHtcbiAgICAgIGlmIChlZGl0b3IuaXNFbXB0eSgpKSB7XG4gICAgICAgIGVkaXRvci5yZW1vdmUoKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy4jaXNDbGVhbmluZ1VwID0gZmFsc2U7XG4gIH1cbiAgcmVuZGVyKF9yZWYyKSB7XG4gICAgbGV0IHtcbiAgICAgIHZpZXdwb3J0XG4gICAgfSA9IF9yZWYyO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKSh0aGlzLmRpdiwgdmlld3BvcnQpO1xuICAgIGZvciAoY29uc3QgZWRpdG9yIG9mIHRoaXMuI3VpTWFuYWdlci5nZXRFZGl0b3JzKHRoaXMucGFnZUluZGV4KSkge1xuICAgICAgdGhpcy5hZGQoZWRpdG9yKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVNb2RlKCk7XG4gIH1cbiAgdXBkYXRlKF9yZWYzKSB7XG4gICAgbGV0IHtcbiAgICAgIHZpZXdwb3J0XG4gICAgfSA9IF9yZWYzO1xuICAgIHRoaXMuI3VpTWFuYWdlci5jb21taXRPclJlbW92ZSgpO1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKSh0aGlzLmRpdiwge1xuICAgICAgcm90YXRpb246IHZpZXdwb3J0LnJvdGF0aW9uXG4gICAgfSk7XG4gICAgdGhpcy51cGRhdGVNb2RlKCk7XG4gIH1cbiAgZ2V0IHBhZ2VEaW1lbnNpb25zKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2VXaWR0aCxcbiAgICAgIHBhZ2VIZWlnaHRcbiAgICB9ID0gdGhpcy52aWV3cG9ydC5yYXdEaW1zO1xuICAgIHJldHVybiBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XTtcbiAgfVxufVxuZXhwb3J0cy5Bbm5vdGF0aW9uRWRpdG9yTGF5ZXIgPSBBbm5vdGF0aW9uRWRpdG9yTGF5ZXI7XG5cbi8qKiovIH0pLFxuLyogMTk3ICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLkZyZWVUZXh0RWRpdG9yID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF90b29scyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTY1KTtcbnZhciBfZWRpdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjQpO1xudmFyIF9hbm5vdGF0aW9uX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxOTgpO1xuY2xhc3MgRnJlZVRleHRFZGl0b3IgZXh0ZW5kcyBfZWRpdG9yLkFubm90YXRpb25FZGl0b3Ige1xuICAjYm91bmRFZGl0b3JEaXZCbHVyID0gdGhpcy5lZGl0b3JEaXZCbHVyLmJpbmQodGhpcyk7XG4gICNib3VuZEVkaXRvckRpdkZvY3VzID0gdGhpcy5lZGl0b3JEaXZGb2N1cy5iaW5kKHRoaXMpO1xuICAjYm91bmRFZGl0b3JEaXZJbnB1dCA9IHRoaXMuZWRpdG9yRGl2SW5wdXQuYmluZCh0aGlzKTtcbiAgI2JvdW5kRWRpdG9yRGl2S2V5ZG93biA9IHRoaXMuZWRpdG9yRGl2S2V5ZG93bi5iaW5kKHRoaXMpO1xuICAjY29sb3I7XG4gICNjb250ZW50ID0gXCJcIjtcbiAgI2VkaXRvckRpdklkID0gYCR7dGhpcy5pZH0tZWRpdG9yYDtcbiAgI2ZvbnRTaXplO1xuICAjaW5pdGlhbERhdGEgPSBudWxsO1xuICBzdGF0aWMgX2ZyZWVUZXh0RGVmYXVsdENvbnRlbnQgPSBcIlwiO1xuICBzdGF0aWMgX2ludGVybmFsUGFkZGluZyA9IDA7XG4gIHN0YXRpYyBfZGVmYXVsdENvbG9yID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0Rm9udFNpemUgPSAxMDtcbiAgc3RhdGljIGdldCBfa2V5Ym9hcmRNYW5hZ2VyKCkge1xuICAgIGNvbnN0IHByb3RvID0gRnJlZVRleHRFZGl0b3IucHJvdG90eXBlO1xuICAgIGNvbnN0IGFycm93Q2hlY2tlciA9IHNlbGYgPT4gc2VsZi5pc0VtcHR5KCk7XG4gICAgY29uc3Qgc21hbGwgPSBfdG9vbHMuQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlci5UUkFOU0xBVEVfU01BTEw7XG4gICAgY29uc3QgYmlnID0gX3Rvb2xzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXIuVFJBTlNMQVRFX0JJRztcbiAgICByZXR1cm4gKDAsIF91dGlsLnNoYWRvdykodGhpcywgXCJfa2V5Ym9hcmRNYW5hZ2VyXCIsIG5ldyBfdG9vbHMuS2V5Ym9hcmRNYW5hZ2VyKFtbW1wiY3RybCtzXCIsIFwibWFjK21ldGErc1wiLCBcImN0cmwrcFwiLCBcIm1hYyttZXRhK3BcIl0sIHByb3RvLmNvbW1pdE9yUmVtb3ZlLCB7XG4gICAgICBidWJibGVzOiB0cnVlXG4gICAgfV0sIFtbXCJjdHJsK0VudGVyXCIsIFwibWFjK21ldGErRW50ZXJcIiwgXCJFc2NhcGVcIiwgXCJtYWMrRXNjYXBlXCJdLCBwcm90by5jb21taXRPclJlbW92ZV0sIFtbXCJBcnJvd0xlZnRcIiwgXCJtYWMrQXJyb3dMZWZ0XCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFstc21hbGwsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJjdHJsK0Fycm93TGVmdFwiLCBcIm1hYytzaGlmdCtBcnJvd0xlZnRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWy1iaWcsIDBdLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd1JpZ2h0XCIsIFwibWFjK0Fycm93UmlnaHRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogW3NtYWxsLCAwXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1JpZ2h0XCIsIFwibWFjK3NoaWZ0K0Fycm93UmlnaHRcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogW2JpZywgMF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcIkFycm93VXBcIiwgXCJtYWMrQXJyb3dVcFwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgLXNtYWxsXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dLCBbW1wiY3RybCtBcnJvd1VwXCIsIFwibWFjK3NoaWZ0K0Fycm93VXBcIl0sIHByb3RvLl90cmFuc2xhdGVFbXB0eSwge1xuICAgICAgYXJnczogWzAsIC1iaWddLFxuICAgICAgY2hlY2tlcjogYXJyb3dDaGVja2VyXG4gICAgfV0sIFtbXCJBcnJvd0Rvd25cIiwgXCJtYWMrQXJyb3dEb3duXCJdLCBwcm90by5fdHJhbnNsYXRlRW1wdHksIHtcbiAgICAgIGFyZ3M6IFswLCBzbWFsbF0sXG4gICAgICBjaGVja2VyOiBhcnJvd0NoZWNrZXJcbiAgICB9XSwgW1tcImN0cmwrQXJyb3dEb3duXCIsIFwibWFjK3NoaWZ0K0Fycm93RG93blwiXSwgcHJvdG8uX3RyYW5zbGF0ZUVtcHR5LCB7XG4gICAgICBhcmdzOiBbMCwgYmlnXSxcbiAgICAgIGNoZWNrZXI6IGFycm93Q2hlY2tlclxuICAgIH1dXSkpO1xuICB9XG4gIHN0YXRpYyBfdHlwZSA9IFwiZnJlZXRleHRcIjtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJmcmVlVGV4dEVkaXRvclwiXG4gICAgfSk7XG4gICAgdGhpcy4jY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3I7XG4gICAgdGhpcy4jZm9udFNpemUgPSBwYXJhbXMuZm9udFNpemUgfHwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbiwge1xuICAgICAgc3RyaW5nczogW1wiZnJlZV90ZXh0Ml9kZWZhdWx0X2NvbnRlbnRcIiwgXCJlZGl0b3JfZnJlZV90ZXh0Ml9hcmlhX2xhYmVsXCJdXG4gICAgfSk7XG4gICAgY29uc3Qgc3R5bGUgPSBnZXRDb21wdXRlZFN0eWxlKGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCk7XG4gICAgdGhpcy5faW50ZXJuYWxQYWRkaW5nID0gcGFyc2VGbG9hdChzdHlsZS5nZXRQcm9wZXJ0eVZhbHVlKFwiLS1mcmVldGV4dC1wYWRkaW5nXCIpKTtcbiAgfVxuICBzdGF0aWMgdXBkYXRlRGVmYXVsdFBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9TSVpFOlxuICAgICAgICBGcmVlVGV4dEVkaXRvci5fZGVmYXVsdEZvbnRTaXplID0gdmFsdWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUjpcbiAgICAgICAgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICB9XG4gIH1cbiAgdXBkYXRlUGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkU6XG4gICAgICAgIHRoaXMuI3VwZGF0ZUZvbnRTaXplKHZhbHVlKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRGb250U2l6ZV0sIFtfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5GUkVFVEVYVF9DT0xPUiwgRnJlZVRleHRFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3JdXTtcbiAgfVxuICBnZXQgcHJvcGVydGllc1RvVXBkYXRlKCkge1xuICAgIHJldHVybiBbW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX1NJWkUsIHRoaXMuI2ZvbnRTaXplXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLCB0aGlzLiNjb2xvcl1dO1xuICB9XG4gICN1cGRhdGVGb250U2l6ZShmb250U2l6ZSkge1xuICAgIGNvbnN0IHNldEZvbnRzaXplID0gc2l6ZSA9PiB7XG4gICAgICB0aGlzLmVkaXRvckRpdi5zdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7c2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICAgIHRoaXMudHJhbnNsYXRlKDAsIC0oc2l6ZSAtIHRoaXMuI2ZvbnRTaXplKSAqIHRoaXMucGFyZW50U2NhbGUpO1xuICAgICAgdGhpcy4jZm9udFNpemUgPSBzaXplO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG4gICAgY29uc3Qgc2F2ZWRGb250c2l6ZSA9IHRoaXMuI2ZvbnRTaXplO1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kOiAoKSA9PiB7XG4gICAgICAgIHNldEZvbnRzaXplKGZvbnRTaXplKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHNldEZvbnRzaXplKHNhdmVkRm9udHNpemUpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuRlJFRVRFWFRfU0laRSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gICN1cGRhdGVDb2xvcihjb2xvcikge1xuICAgIGNvbnN0IHNhdmVkQ29sb3IgPSB0aGlzLiNjb2xvcjtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLiNjb2xvciA9IHRoaXMuZWRpdG9yRGl2LnN0eWxlLmNvbG9yID0gY29sb3I7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLiNjb2xvciA9IHRoaXMuZWRpdG9yRGl2LnN0eWxlLmNvbG9yID0gc2F2ZWRDb2xvcjtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLkZSRUVURVhUX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgX3RyYW5zbGF0ZUVtcHR5KHgsIHkpIHtcbiAgICB0aGlzLl91aU1hbmFnZXIudHJhbnNsYXRlU2VsZWN0ZWRFZGl0b3JzKHgsIHksIHRydWUpO1xuICB9XG4gIGdldEluaXRpYWxUcmFuc2xhdGlvbigpIHtcbiAgICBjb25zdCBzY2FsZSA9IHRoaXMucGFyZW50U2NhbGU7XG4gICAgcmV0dXJuIFstRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHNjYWxlLCAtKEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKyB0aGlzLiNmb250U2l6ZSkgKiBzY2FsZV07XG4gIH1cbiAgcmVidWlsZCgpIHtcbiAgICBpZiAoIXRoaXMucGFyZW50KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLnJlYnVpbGQoKTtcbiAgICBpZiAodGhpcy5kaXYgPT09IG51bGwpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgIH1cbiAgfVxuICBlbmFibGVFZGl0TW9kZSgpIHtcbiAgICBpZiAodGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUoZmFsc2UpO1xuICAgIHRoaXMucGFyZW50LnVwZGF0ZVRvb2xiYXIoX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuRlJFRVRFWFQpO1xuICAgIHN1cGVyLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5yZW1vdmUoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IHRydWU7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLWFjdGl2ZWRlc2NlbmRhbnRcIik7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZLZXlkb3duKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiZm9jdXNcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZGb2N1cyk7XG4gICAgdGhpcy5lZGl0b3JEaXYuYWRkRXZlbnRMaXN0ZW5lcihcImJsdXJcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZCbHVyKTtcbiAgICB0aGlzLmVkaXRvckRpdi5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgdGhpcy4jYm91bmRFZGl0b3JEaXZJbnB1dCk7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLnBhcmVudC5zZXRFZGl0aW5nU3RhdGUodHJ1ZSk7XG4gICAgc3VwZXIuZGlzYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5vdmVybGF5RGl2LmNsYXNzTGlzdC5hZGQoXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIHRoaXMuZGl2LnNldEF0dHJpYnV0ZShcImFyaWEtYWN0aXZlZGVzY2VuZGFudFwiLCB0aGlzLiNlZGl0b3JEaXZJZCk7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSB0cnVlO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2S2V5ZG93bik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImZvY3VzXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2Rm9jdXMpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2Qmx1cik7XG4gICAgdGhpcy5lZGl0b3JEaXYucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHRoaXMuI2JvdW5kRWRpdG9yRGl2SW5wdXQpO1xuICAgIHRoaXMuZGl2LmZvY3VzKHtcbiAgICAgIHByZXZlbnRTY3JvbGw6IHRydWVcbiAgICB9KTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QuYWRkKFwiZnJlZVRleHRFZGl0aW5nXCIpO1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5mb2N1c2luKGV2ZW50KTtcbiAgICBpZiAoZXZlbnQudGFyZ2V0ICE9PSB0aGlzLmVkaXRvckRpdikge1xuICAgICAgdGhpcy5lZGl0b3JEaXYuZm9jdXMoKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIGlmICh0aGlzLndpZHRoKSB7XG4gICAgICB0aGlzLiNjaGVhdEluaXRpYWxSZWN0KCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9XG4gICAgdGhpcy5faW5pdGlhbE9wdGlvbnMgPSBudWxsO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICF0aGlzLmVkaXRvckRpdiB8fCB0aGlzLmVkaXRvckRpdi5pbm5lclRleHQudHJpbSgpID09PSBcIlwiO1xuICB9XG4gIHJlbW92ZSgpIHtcbiAgICB0aGlzLmlzRWRpdGluZyA9IGZhbHNlO1xuICAgIGlmICh0aGlzLnBhcmVudCkge1xuICAgICAgdGhpcy5wYXJlbnQuc2V0RWRpdGluZ1N0YXRlKHRydWUpO1xuICAgICAgdGhpcy5wYXJlbnQuZGl2LmNsYXNzTGlzdC5hZGQoXCJmcmVlVGV4dEVkaXRpbmdcIik7XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gICNleHRyYWN0VGV4dCgpIHtcbiAgICBjb25zdCBkaXZzID0gdGhpcy5lZGl0b3JEaXYuZ2V0RWxlbWVudHNCeVRhZ05hbWUoXCJkaXZcIik7XG4gICAgaWYgKGRpdnMubGVuZ3RoID09PSAwKSB7XG4gICAgICByZXR1cm4gdGhpcy5lZGl0b3JEaXYuaW5uZXJUZXh0O1xuICAgIH1cbiAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGRpdiBvZiBkaXZzKSB7XG4gICAgICBidWZmZXIucHVzaChkaXYuaW5uZXJUZXh0LnJlcGxhY2UoL1xcclxcbj98XFxuLywgXCJcIikpO1xuICAgIH1cbiAgICByZXR1cm4gYnVmZmVyLmpvaW4oXCJcXG5cIik7XG4gIH1cbiAgI3NldEVkaXRvckRpbWVuc2lvbnMoKSB7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIGxldCByZWN0O1xuICAgIGlmICh0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgcmVjdCA9IHRoaXMuZGl2LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGN1cnJlbnRMYXllcixcbiAgICAgICAgZGl2XG4gICAgICB9ID0gdGhpcztcbiAgICAgIGNvbnN0IHNhdmVkRGlzcGxheSA9IGRpdi5zdHlsZS5kaXNwbGF5O1xuICAgICAgZGl2LnN0eWxlLmRpc3BsYXkgPSBcImhpZGRlblwiO1xuICAgICAgY3VycmVudExheWVyLmRpdi5hcHBlbmQodGhpcy5kaXYpO1xuICAgICAgcmVjdCA9IGRpdi5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcbiAgICAgIGRpdi5yZW1vdmUoKTtcbiAgICAgIGRpdi5zdHlsZS5kaXNwbGF5ID0gc2F2ZWREaXNwbGF5O1xuICAgIH1cbiAgICBpZiAodGhpcy5yb3RhdGlvbiAlIDE4MCA9PT0gdGhpcy5wYXJlbnRSb3RhdGlvbiAlIDE4MCkge1xuICAgICAgdGhpcy53aWR0aCA9IHJlY3Qud2lkdGggLyBwYXJlbnRXaWR0aDtcbiAgICAgIHRoaXMuaGVpZ2h0ID0gcmVjdC5oZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMud2lkdGggPSByZWN0LmhlaWdodCAvIHBhcmVudFdpZHRoO1xuICAgICAgdGhpcy5oZWlnaHQgPSByZWN0LndpZHRoIC8gcGFyZW50SGVpZ2h0O1xuICAgIH1cbiAgICB0aGlzLmZpeEFuZFNldFBvc2l0aW9uKCk7XG4gIH1cbiAgY29tbWl0KCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5jb21taXQoKTtcbiAgICB0aGlzLmRpc2FibGVFZGl0TW9kZSgpO1xuICAgIGNvbnN0IHNhdmVkVGV4dCA9IHRoaXMuI2NvbnRlbnQ7XG4gICAgY29uc3QgbmV3VGV4dCA9IHRoaXMuI2NvbnRlbnQgPSB0aGlzLiNleHRyYWN0VGV4dCgpLnRyaW1FbmQoKTtcbiAgICBpZiAoc2F2ZWRUZXh0ID09PSBuZXdUZXh0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHNldFRleHQgPSB0ZXh0ID0+IHtcbiAgICAgIHRoaXMuI2NvbnRlbnQgPSB0ZXh0O1xuICAgICAgaWYgKCF0ZXh0KSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NldENvbnRlbnQoKTtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZWJ1aWxkKHRoaXMpO1xuICAgICAgdGhpcy4jc2V0RWRpdG9yRGltZW5zaW9ucygpO1xuICAgIH07XG4gICAgdGhpcy5hZGRDb21tYW5kcyh7XG4gICAgICBjbWQ6ICgpID0+IHtcbiAgICAgICAgc2V0VGV4dChuZXdUZXh0KTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHNldFRleHQoc2F2ZWRUZXh0KTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogZmFsc2VcbiAgICB9KTtcbiAgICB0aGlzLiNzZXRFZGl0b3JEaW1lbnNpb25zKCk7XG4gIH1cbiAgc2hvdWxkR2V0S2V5Ym9hcmRFdmVudHMoKSB7XG4gICAgcmV0dXJuIHRoaXMuaXNJbkVkaXRNb2RlKCk7XG4gIH1cbiAgZW50ZXJJbkVkaXRNb2RlKCkge1xuICAgIHRoaXMuZW5hYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLmVkaXRvckRpdi5mb2N1cygpO1xuICB9XG4gIGRibGNsaWNrKGV2ZW50KSB7XG4gICAgdGhpcy5lbnRlckluRWRpdE1vZGUoKTtcbiAgfVxuICBrZXlkb3duKGV2ZW50KSB7XG4gICAgaWYgKGV2ZW50LnRhcmdldCA9PT0gdGhpcy5kaXYgJiYgZXZlbnQua2V5ID09PSBcIkVudGVyXCIpIHtcbiAgICAgIHRoaXMuZW50ZXJJbkVkaXRNb2RlKCk7XG4gICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIH1cbiAgfVxuICBlZGl0b3JEaXZLZXlkb3duKGV2ZW50KSB7XG4gICAgRnJlZVRleHRFZGl0b3IuX2tleWJvYXJkTWFuYWdlci5leGVjKHRoaXMsIGV2ZW50KTtcbiAgfVxuICBlZGl0b3JEaXZGb2N1cyhldmVudCkge1xuICAgIHRoaXMuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgfVxuICBlZGl0b3JEaXZCbHVyKGV2ZW50KSB7XG4gICAgdGhpcy5pc0VkaXRpbmcgPSBmYWxzZTtcbiAgfVxuICBlZGl0b3JEaXZJbnB1dChldmVudCkge1xuICAgIHRoaXMucGFyZW50LmRpdi5jbGFzc0xpc3QudG9nZ2xlKFwiZnJlZVRleHRFZGl0aW5nXCIsIHRoaXMuaXNFbXB0eSgpKTtcbiAgfVxuICBkaXNhYmxlRWRpdGluZygpIHtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJyb2xlXCIsIFwiY29tbWVudFwiKTtcbiAgICB0aGlzLmVkaXRvckRpdi5yZW1vdmVBdHRyaWJ1dGUoXCJhcmlhLW11bHRpbGluZVwiKTtcbiAgfVxuICBlbmFibGVFZGl0aW5nKCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcInJvbGVcIiwgXCJ0ZXh0Ym94XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LnNldEF0dHJpYnV0ZShcImFyaWEtbXVsdGlsaW5lXCIsIHRydWUpO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgdGhpcy5lZGl0b3JEaXYgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiZGl2XCIpO1xuICAgIHRoaXMuZWRpdG9yRGl2LmNsYXNzTmFtZSA9IFwiaW50ZXJuYWxcIjtcbiAgICB0aGlzLmVkaXRvckRpdi5zZXRBdHRyaWJ1dGUoXCJpZFwiLCB0aGlzLiNlZGl0b3JEaXZJZCk7XG4gICAgdGhpcy5lbmFibGVFZGl0aW5nKCk7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfZnJlZV90ZXh0Ml9hcmlhX2xhYmVsXCIpLnRoZW4obXNnID0+IHRoaXMuZWRpdG9yRGl2Py5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG1zZykpO1xuICAgIF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fbDEwblByb21pc2UuZ2V0KFwiZnJlZV90ZXh0Ml9kZWZhdWx0X2NvbnRlbnRcIikudGhlbihtc2cgPT4gdGhpcy5lZGl0b3JEaXY/LnNldEF0dHJpYnV0ZShcImRlZmF1bHQtY29udGVudFwiLCBtc2cpKTtcbiAgICB0aGlzLmVkaXRvckRpdi5jb250ZW50RWRpdGFibGUgPSB0cnVlO1xuICAgIGNvbnN0IHtcbiAgICAgIHN0eWxlXG4gICAgfSA9IHRoaXMuZWRpdG9yRGl2O1xuICAgIHN0eWxlLmZvbnRTaXplID0gYGNhbGMoJHt0aGlzLiNmb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IHRoaXMuI2NvbG9yO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmVkaXRvckRpdik7XG4gICAgdGhpcy5vdmVybGF5RGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB0aGlzLm92ZXJsYXlEaXYuY2xhc3NMaXN0LmFkZChcIm92ZXJsYXlcIiwgXCJlbmFibGVkXCIpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLm92ZXJsYXlEaXYpO1xuICAgICgwLCBfdG9vbHMuYmluZEV2ZW50cykodGhpcywgdGhpcy5kaXYsIFtcImRibGNsaWNrXCIsIFwia2V5ZG93blwiXSk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIGlmICh0aGlzLmFubm90YXRpb25FbGVtZW50SWQpIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHBvc2l0aW9uXG4gICAgICAgIH0gPSB0aGlzLiNpbml0aWFsRGF0YTtcbiAgICAgICAgbGV0IFt0eCwgdHldID0gdGhpcy5nZXRJbml0aWFsVHJhbnNsYXRpb24oKTtcbiAgICAgICAgW3R4LCB0eV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvblRvU2NyZWVuKHR4LCB0eSk7XG4gICAgICAgIGNvbnN0IFtwYWdlV2lkdGgsIHBhZ2VIZWlnaHRdID0gdGhpcy5wYWdlRGltZW5zaW9ucztcbiAgICAgICAgY29uc3QgW3BhZ2VYLCBwYWdlWV0gPSB0aGlzLnBhZ2VUcmFuc2xhdGlvbjtcbiAgICAgICAgbGV0IHBvc1gsIHBvc1k7XG4gICAgICAgIHN3aXRjaCAodGhpcy5yb3RhdGlvbikge1xuICAgICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCArIChwb3NpdGlvblswXSAtIHBhZ2VYKSAvIHBhZ2VXaWR0aDtcbiAgICAgICAgICAgIHBvc1kgPSBiYXNlWSArIHRoaXMuaGVpZ2h0IC0gKHBvc2l0aW9uWzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgOTA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbdHksIC10eF07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIDE4MDpcbiAgICAgICAgICAgIHBvc1ggPSBiYXNlWCAtIHRoaXMud2lkdGggKyAocG9zaXRpb25bMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgLSAocG9zaXRpb25bMV0gLSBwYWdlWSkgLyBwYWdlSGVpZ2h0O1xuICAgICAgICAgICAgW3R4LCB0eV0gPSBbLXR4LCAtdHldO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSAyNzA6XG4gICAgICAgICAgICBwb3NYID0gYmFzZVggKyAocG9zaXRpb25bMF0gLSBwYWdlWCAtIHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCkgLyBwYWdlV2lkdGg7XG4gICAgICAgICAgICBwb3NZID0gYmFzZVkgKyAocG9zaXRpb25bMV0gLSBwYWdlWSAtIHRoaXMud2lkdGggKiBwYWdlV2lkdGgpIC8gcGFnZUhlaWdodDtcbiAgICAgICAgICAgIFt0eCwgdHldID0gWy10eSwgdHhdO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5zZXRBdChwb3NYICogcGFyZW50V2lkdGgsIHBvc1kgKiBwYXJlbnRIZWlnaHQsIHR4LCB0eSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIH1cbiAgICAgIHRoaXMuI3NldENvbnRlbnQoKTtcbiAgICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmNvbnRlbnRFZGl0YWJsZSA9IGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aGlzLl9pc0RyYWdnYWJsZSA9IGZhbHNlO1xuICAgICAgdGhpcy5lZGl0b3JEaXYuY29udGVudEVkaXRhYmxlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuZGl2O1xuICB9XG4gICNzZXRDb250ZW50KCkge1xuICAgIHRoaXMuZWRpdG9yRGl2LnJlcGxhY2VDaGlsZHJlbigpO1xuICAgIGlmICghdGhpcy4jY29udGVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy4jY29udGVudC5zcGxpdChcIlxcblwiKSkge1xuICAgICAgY29uc3QgZGl2ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGRpdi5hcHBlbmQobGluZSA/IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGxpbmUpIDogZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImJyXCIpKTtcbiAgICAgIHRoaXMuZWRpdG9yRGl2LmFwcGVuZChkaXYpO1xuICAgIH1cbiAgfVxuICBnZXQgY29udGVudERpdigpIHtcbiAgICByZXR1cm4gdGhpcy5lZGl0b3JEaXY7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgbGV0IGluaXRpYWxEYXRhID0gbnVsbDtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIF9hbm5vdGF0aW9uX2xheWVyLkZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZGF0YToge1xuICAgICAgICAgIGRlZmF1bHRBcHBlYXJhbmNlRGF0YToge1xuICAgICAgICAgICAgZm9udFNpemUsXG4gICAgICAgICAgICBmb250Q29sb3JcbiAgICAgICAgICB9LFxuICAgICAgICAgIHJlY3QsXG4gICAgICAgICAgcm90YXRpb24sXG4gICAgICAgICAgaWRcbiAgICAgICAgfSxcbiAgICAgICAgdGV4dENvbnRlbnQsXG4gICAgICAgIHRleHRQb3NpdGlvbixcbiAgICAgICAgcGFyZW50OiB7XG4gICAgICAgICAgcGFnZToge1xuICAgICAgICAgICAgcGFnZU51bWJlclxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSA9IGRhdGE7XG4gICAgICBpZiAoIXRleHRDb250ZW50IHx8IHRleHRDb250ZW50Lmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICAgIGluaXRpYWxEYXRhID0gZGF0YSA9IHtcbiAgICAgICAgYW5ub3RhdGlvblR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhULFxuICAgICAgICBjb2xvcjogQXJyYXkuZnJvbShmb250Q29sb3IpLFxuICAgICAgICBmb250U2l6ZSxcbiAgICAgICAgdmFsdWU6IHRleHRDb250ZW50LmpvaW4oXCJcXG5cIiksXG4gICAgICAgIHBvc2l0aW9uOiB0ZXh0UG9zaXRpb24sXG4gICAgICAgIHBhZ2VJbmRleDogcGFnZU51bWJlciAtIDEsXG4gICAgICAgIHJlY3QsXG4gICAgICAgIHJvdGF0aW9uLFxuICAgICAgICBpZCxcbiAgICAgICAgZGVsZXRlZDogZmFsc2VcbiAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IuI2ZvbnRTaXplID0gZGF0YS5mb250U2l6ZTtcbiAgICBlZGl0b3IuI2NvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4uZGF0YS5jb2xvcik7XG4gICAgZWRpdG9yLiNjb250ZW50ID0gZGF0YS52YWx1ZTtcbiAgICBlZGl0b3IuYW5ub3RhdGlvbkVsZW1lbnRJZCA9IGRhdGEuaWQgfHwgbnVsbDtcbiAgICBlZGl0b3IuI2luaXRpYWxEYXRhID0gaW5pdGlhbERhdGE7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgbGV0IGlzRm9yQ29weWluZyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKHRoaXMuZGVsZXRlZCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgICAgaWQ6IHRoaXMuYW5ub3RhdGlvbkVsZW1lbnRJZCxcbiAgICAgICAgZGVsZXRlZDogdHJ1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgY29uc3QgcGFkZGluZyA9IEZyZWVUZXh0RWRpdG9yLl9pbnRlcm5hbFBhZGRpbmcgKiB0aGlzLnBhcmVudFNjYWxlO1xuICAgIGNvbnN0IHJlY3QgPSB0aGlzLmdldFJlY3QocGFkZGluZywgcGFkZGluZyk7XG4gICAgY29uc3QgY29sb3IgPSBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2NvbG9yTWFuYWdlci5jb252ZXJ0KHRoaXMuaXNBdHRhY2hlZFRvRE9NID8gZ2V0Q29tcHV0ZWRTdHlsZSh0aGlzLmVkaXRvckRpdikuY29sb3IgOiB0aGlzLiNjb2xvcik7XG4gICAgY29uc3Qgc2VyaWFsaXplZCA9IHtcbiAgICAgIGFubm90YXRpb25UeXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5GUkVFVEVYVCxcbiAgICAgIGNvbG9yLFxuICAgICAgZm9udFNpemU6IHRoaXMuI2ZvbnRTaXplLFxuICAgICAgdmFsdWU6IHRoaXMuI2NvbnRlbnQsXG4gICAgICBwYWdlSW5kZXg6IHRoaXMucGFnZUluZGV4LFxuICAgICAgcmVjdCxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHJldHVybiBzZXJpYWxpemVkO1xuICAgIH1cbiAgICBpZiAodGhpcy5hbm5vdGF0aW9uRWxlbWVudElkICYmICF0aGlzLiNoYXNFbGVtZW50Q2hhbmdlZChzZXJpYWxpemVkKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIHNlcmlhbGl6ZWQuaWQgPSB0aGlzLmFubm90YXRpb25FbGVtZW50SWQ7XG4gICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gIH1cbiAgI2hhc0VsZW1lbnRDaGFuZ2VkKHNlcmlhbGl6ZWQpIHtcbiAgICBjb25zdCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIGZvbnRTaXplLFxuICAgICAgY29sb3IsXG4gICAgICByZWN0LFxuICAgICAgcGFnZUluZGV4XG4gICAgfSA9IHRoaXMuI2luaXRpYWxEYXRhO1xuICAgIHJldHVybiBzZXJpYWxpemVkLnZhbHVlICE9PSB2YWx1ZSB8fCBzZXJpYWxpemVkLmZvbnRTaXplICE9PSBmb250U2l6ZSB8fCBzZXJpYWxpemVkLnJlY3Quc29tZSgoeCwgaSkgPT4gTWF0aC5hYnMoeCAtIHJlY3RbaV0pID49IDEpIHx8IHNlcmlhbGl6ZWQuY29sb3Iuc29tZSgoYywgaSkgPT4gYyAhPT0gY29sb3JbaV0pIHx8IHNlcmlhbGl6ZWQucGFnZUluZGV4ICE9PSBwYWdlSW5kZXg7XG4gIH1cbiAgI2NoZWF0SW5pdGlhbFJlY3QoKSB7XG4gICAgbGV0IGRlbGF5ZWQgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IGZhbHNlO1xuICAgIGlmICghdGhpcy5hbm5vdGF0aW9uRWxlbWVudElkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3NldEVkaXRvckRpbWVuc2lvbnMoKTtcbiAgICBpZiAoIWRlbGF5ZWQgJiYgKHRoaXMud2lkdGggPT09IDAgfHwgdGhpcy5oZWlnaHQgPT09IDApKSB7XG4gICAgICBzZXRUaW1lb3V0KCgpID0+IHRoaXMuI2NoZWF0SW5pdGlhbFJlY3QodHJ1ZSksIDApO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBwYWRkaW5nID0gRnJlZVRleHRFZGl0b3IuX2ludGVybmFsUGFkZGluZyAqIHRoaXMucGFyZW50U2NhbGU7XG4gICAgdGhpcy4jaW5pdGlhbERhdGEucmVjdCA9IHRoaXMuZ2V0UmVjdChwYWRkaW5nLCBwYWRkaW5nKTtcbiAgfVxufVxuZXhwb3J0cy5GcmVlVGV4dEVkaXRvciA9IEZyZWVUZXh0RWRpdG9yO1xuXG4vKioqLyB9KSxcbi8qIDE5OCAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5TdGFtcEFubm90YXRpb25FbGVtZW50ID0gZXhwb3J0cy5JbmtBbm5vdGF0aW9uRWxlbWVudCA9IGV4cG9ydHMuRnJlZVRleHRBbm5vdGF0aW9uRWxlbWVudCA9IGV4cG9ydHMuQW5ub3RhdGlvbkxheWVyID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEyNSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEzNik7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDEzOCk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDE0MSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDE0Myk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDE0NSk7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDE0Nyk7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjgpO1xudmFyIF9hbm5vdGF0aW9uX3N0b3JhZ2UgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2Myk7XG52YXIgX3NjcmlwdGluZ191dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTk5KTtcbnZhciBfZGlzcGxheUwxMG5fdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDIwMCk7XG52YXIgX3hmYV9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMjAxKTtcbmNvbnN0IERFRkFVTFRfVEFCX0lOREVYID0gMTAwMDtcbmNvbnN0IERFRkFVTFRfRk9OVF9TSVpFID0gOTtcbmNvbnN0IEdldEVsZW1lbnRzQnlOYW1lU2V0ID0gbmV3IFdlYWtTZXQoKTtcbmZ1bmN0aW9uIGdldFJlY3REaW1zKHJlY3QpIHtcbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogcmVjdFsyXSAtIHJlY3RbMF0sXG4gICAgaGVpZ2h0OiByZWN0WzNdIC0gcmVjdFsxXVxuICB9O1xufVxuY2xhc3MgQW5ub3RhdGlvbkVsZW1lbnRGYWN0b3J5IHtcbiAgc3RhdGljIGNyZWF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc3VidHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5hbm5vdGF0aW9uVHlwZTtcbiAgICBzd2l0Y2ggKHN1YnR5cGUpIHtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuTElOSzpcbiAgICAgICAgcmV0dXJuIG5ldyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlRFWFQ6XG4gICAgICAgIHJldHVybiBuZXcgVGV4dEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5XSURHRVQ6XG4gICAgICAgIGNvbnN0IGZpZWxkVHlwZSA9IHBhcmFtZXRlcnMuZGF0YS5maWVsZFR5cGU7XG4gICAgICAgIHN3aXRjaCAoZmllbGRUeXBlKSB7XG4gICAgICAgICAgY2FzZSBcIlR4XCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiQnRuXCI6XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVycy5kYXRhLnJhZGlvQnV0dG9uKSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgUmFkaW9CdXR0b25XaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocGFyYW1ldGVycy5kYXRhLmNoZWNrQm94KSB7XG4gICAgICAgICAgICAgIHJldHVybiBuZXcgQ2hlY2tib3hXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHVzaEJ1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICAgIGNhc2UgXCJDaFwiOlxuICAgICAgICAgICAgcmV0dXJuIG5ldyBDaG9pY2VXaWRnZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgICAgICBjYXNlIFwiU2lnXCI6XG4gICAgICAgICAgICByZXR1cm4gbmV3IFNpZ25hdHVyZVdpZGdldEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBuZXcgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlBPUFVQOlxuICAgICAgICByZXR1cm4gbmV3IFBvcHVwQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkZSRUVURVhUOlxuICAgICAgICByZXR1cm4gbmV3IEZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgTGluZUFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5TUVVBUkU6XG4gICAgICAgIHJldHVybiBuZXcgU3F1YXJlQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLkNJUkNMRTpcbiAgICAgICAgcmV0dXJuIG5ldyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuUE9MWUxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuQ0FSRVQ6XG4gICAgICAgIHJldHVybiBuZXcgQ2FyZXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuSU5LOlxuICAgICAgICByZXR1cm4gbmV3IElua0Fubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT0xZR09OOlxuICAgICAgICByZXR1cm4gbmV3IFBvbHlnb25Bbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuSElHSExJR0hUOlxuICAgICAgICByZXR1cm4gbmV3IEhpZ2hsaWdodEFubm90YXRpb25FbGVtZW50KHBhcmFtZXRlcnMpO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5VTkRFUkxJTkU6XG4gICAgICAgIHJldHVybiBuZXcgVW5kZXJsaW5lQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNRVUlHR0xZOlxuICAgICAgICByZXR1cm4gbmV3IFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25UeXBlLlNUUklLRU9VVDpcbiAgICAgICAgcmV0dXJuIG5ldyBTdHJpa2VPdXRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuU1RBTVA6XG4gICAgICAgIHJldHVybiBuZXcgU3RhbXBBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvblR5cGUuRklMRUFUVEFDSE1FTlQ6XG4gICAgICAgIHJldHVybiBuZXcgRmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uRWxlbWVudChwYXJhbWV0ZXJzKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHJldHVybiBuZXcgQW5ub3RhdGlvbkVsZW1lbnQocGFyYW1ldGVycyk7XG4gICAgfVxuICB9XG59XG5jbGFzcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gICNoYXNCb3JkZXIgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGxldCB7XG4gICAgICBpc1JlbmRlcmFibGUgPSBmYWxzZSxcbiAgICAgIGlnbm9yZUJvcmRlciA9IGZhbHNlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHMgPSBmYWxzZVxuICAgIH0gPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHt9O1xuICAgIHRoaXMuaXNSZW5kZXJhYmxlID0gaXNSZW5kZXJhYmxlO1xuICAgIHRoaXMuZGF0YSA9IHBhcmFtZXRlcnMuZGF0YTtcbiAgICB0aGlzLmxheWVyID0gcGFyYW1ldGVycy5sYXllcjtcbiAgICB0aGlzLmxpbmtTZXJ2aWNlID0gcGFyYW1ldGVycy5saW5rU2VydmljZTtcbiAgICB0aGlzLmRvd25sb2FkTWFuYWdlciA9IHBhcmFtZXRlcnMuZG93bmxvYWRNYW5hZ2VyO1xuICAgIHRoaXMuaW1hZ2VSZXNvdXJjZXNQYXRoID0gcGFyYW1ldGVycy5pbWFnZVJlc291cmNlc1BhdGg7XG4gICAgdGhpcy5yZW5kZXJGb3JtcyA9IHBhcmFtZXRlcnMucmVuZGVyRm9ybXM7XG4gICAgdGhpcy5zdmdGYWN0b3J5ID0gcGFyYW1ldGVycy5zdmdGYWN0b3J5O1xuICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2UgPSBwYXJhbWV0ZXJzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIHRoaXMuZW5hYmxlU2NyaXB0aW5nID0gcGFyYW1ldGVycy5lbmFibGVTY3JpcHRpbmc7XG4gICAgdGhpcy5oYXNKU0FjdGlvbnMgPSBwYXJhbWV0ZXJzLmhhc0pTQWN0aW9ucztcbiAgICB0aGlzLl9maWVsZE9iamVjdHMgPSBwYXJhbWV0ZXJzLmZpZWxkT2JqZWN0cztcbiAgICB0aGlzLnBhcmVudCA9IHBhcmFtZXRlcnMucGFyZW50O1xuICAgIGlmIChpc1JlbmRlcmFibGUpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyID0gdGhpcy5fY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcik7XG4gICAgfVxuICAgIGlmIChjcmVhdGVRdWFkcmlsYXRlcmFscykge1xuICAgICAgdGhpcy5fY3JlYXRlUXVhZHJpbGF0ZXJhbHMoKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIF9oYXNQb3B1cERhdGEoX3JlZikge1xuICAgIGxldCB7XG4gICAgICB0aXRsZU9iaixcbiAgICAgIGNvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHRcbiAgICB9ID0gX3JlZjtcbiAgICByZXR1cm4gISEodGl0bGVPYmo/LnN0ciB8fCBjb250ZW50c09iaj8uc3RyIHx8IHJpY2hUZXh0Py5zdHIpO1xuICB9XG4gIGdldCBoYXNQb3B1cERhdGEoKSB7XG4gICAgcmV0dXJuIEFubm90YXRpb25FbGVtZW50Ll9oYXNQb3B1cERhdGEodGhpcy5kYXRhKTtcbiAgfVxuICBfY3JlYXRlQ29udGFpbmVyKGlnbm9yZUJvcmRlcikge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBwYXJlbnQ6IHtcbiAgICAgICAgcGFnZSxcbiAgICAgICAgdmlld3BvcnRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICBjb25zdCBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VjdGlvblwiKTtcbiAgICBjb250YWluZXIuc2V0QXR0cmlidXRlKFwiZGF0YS1hbm5vdGF0aW9uLWlkXCIsIGRhdGEuaWQpO1xuICAgIGlmICghKHRoaXMgaW5zdGFuY2VvZiBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCkpIHtcbiAgICAgIGNvbnRhaW5lci50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIH1cbiAgICBjb250YWluZXIuc3R5bGUuekluZGV4ID0gdGhpcy5wYXJlbnQuekluZGV4Kys7XG4gICAgaWYgKHRoaXMuZGF0YS5wb3B1cFJlZikge1xuICAgICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgXCJkaWFsb2dcIik7XG4gICAgfVxuICAgIGlmIChkYXRhLm5vUm90YXRlKSB7XG4gICAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcIm5vcm90YXRlXCIpO1xuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBwYWdlV2lkdGgsXG4gICAgICBwYWdlSGVpZ2h0LFxuICAgICAgcGFnZVgsXG4gICAgICBwYWdlWVxuICAgIH0gPSB2aWV3cG9ydC5yYXdEaW1zO1xuICAgIGlmICghZGF0YS5yZWN0IHx8IHRoaXMgaW5zdGFuY2VvZiBQb3B1cEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJvdGF0aW9uXG4gICAgICB9ID0gZGF0YTtcbiAgICAgIGlmICghZGF0YS5oYXNPd25DYW52YXMgJiYgcm90YXRpb24gIT09IDApIHtcbiAgICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBjb250YWluZXI7XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3QgcmVjdCA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbZGF0YS5yZWN0WzBdLCBwYWdlLnZpZXdbM10gLSBkYXRhLnJlY3RbMV0gKyBwYWdlLnZpZXdbMV0sIGRhdGEucmVjdFsyXSwgcGFnZS52aWV3WzNdIC0gZGF0YS5yZWN0WzNdICsgcGFnZS52aWV3WzFdXSk7XG4gICAgaWYgKCFpZ25vcmVCb3JkZXIgJiYgZGF0YS5ib3JkZXJTdHlsZS53aWR0aCA+IDApIHtcbiAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJXaWR0aCA9IGAke2RhdGEuYm9yZGVyU3R5bGUud2lkdGh9cHhgO1xuICAgICAgY29uc3QgaG9yaXpvbnRhbFJhZGl1cyA9IGRhdGEuYm9yZGVyU3R5bGUuaG9yaXpvbnRhbENvcm5lclJhZGl1cztcbiAgICAgIGNvbnN0IHZlcnRpY2FsUmFkaXVzID0gZGF0YS5ib3JkZXJTdHlsZS52ZXJ0aWNhbENvcm5lclJhZGl1cztcbiAgICAgIGlmIChob3Jpem9udGFsUmFkaXVzID4gMCB8fCB2ZXJ0aWNhbFJhZGl1cyA+IDApIHtcbiAgICAgICAgY29uc3QgcmFkaXVzID0gYGNhbGMoJHtob3Jpem9udGFsUmFkaXVzfXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSkgLyBjYWxjKCR7dmVydGljYWxSYWRpdXN9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9IGVsc2UgaWYgKHRoaXMgaW5zdGFuY2VvZiBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICAgIGNvbnN0IHJhZGl1cyA9IGBjYWxjKCR7d2lkdGh9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKSAvIGNhbGMoJHtoZWlnaHR9cHggKiB2YXIoLS1zY2FsZS1mYWN0b3IpKWA7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJSYWRpdXMgPSByYWRpdXM7XG4gICAgICB9XG4gICAgICBzd2l0Y2ggKGRhdGEuYm9yZGVyU3R5bGUuc3R5bGUpIHtcbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlNPTElEOlxuICAgICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJTdHlsZSA9IFwic29saWRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLkRBU0hFRDpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyU3R5bGUgPSBcImRhc2hlZFwiO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIF91dGlsLkFubm90YXRpb25Cb3JkZXJTdHlsZVR5cGUuQkVWRUxFRDpcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoXCJVbmltcGxlbWVudGVkIGJvcmRlciBzdHlsZTogYmV2ZWxlZFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLklOU0VUOlxuICAgICAgICAgICgwLCBfdXRpbC53YXJuKShcIlVuaW1wbGVtZW50ZWQgYm9yZGVyIHN0eWxlOiBpbnNldFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uQm9yZGVyU3R5bGVUeXBlLlVOREVSTElORTpcbiAgICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyQm90dG9tU3R5bGUgPSBcInNvbGlkXCI7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjb25zdCBib3JkZXJDb2xvciA9IGRhdGEuYm9yZGVyQ29sb3IgfHwgbnVsbDtcbiAgICAgIGlmIChib3JkZXJDb2xvcikge1xuICAgICAgICB0aGlzLiNoYXNCb3JkZXIgPSB0cnVlO1xuICAgICAgICBjb250YWluZXIuc3R5bGUuYm9yZGVyQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvcihib3JkZXJDb2xvclswXSB8IDAsIGJvcmRlckNvbG9yWzFdIHwgMCwgYm9yZGVyQ29sb3JbMl0gfCAwKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnRhaW5lci5zdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnRhaW5lci5zdHlsZS5sZWZ0ID0gYCR7MTAwICogKHJlY3RbMF0gLSBwYWdlWCkgLyBwYWdlV2lkdGh9JWA7XG4gICAgY29udGFpbmVyLnN0eWxlLnRvcCA9IGAkezEwMCAqIChyZWN0WzFdIC0gcGFnZVkpIC8gcGFnZUhlaWdodH0lYDtcbiAgICBjb25zdCB7XG4gICAgICByb3RhdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGlmIChkYXRhLmhhc093bkNhbnZhcyB8fCByb3RhdGlvbiA9PT0gMCkge1xuICAgICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7MTAwICogd2lkdGggLyBwYWdlV2lkdGh9JWA7XG4gICAgICBjb250YWluZXIuc3R5bGUuaGVpZ2h0ID0gYCR7MTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodH0lYDtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5zZXRSb3RhdGlvbihyb3RhdGlvbiwgY29udGFpbmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxuICBzZXRSb3RhdGlvbihhbmdsZSkge1xuICAgIGxldCBjb250YWluZXIgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IHRoaXMuY29udGFpbmVyO1xuICAgIGlmICghdGhpcy5kYXRhLnJlY3QpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgcGFnZVdpZHRoLFxuICAgICAgcGFnZUhlaWdodFxuICAgIH0gPSB0aGlzLnBhcmVudC52aWV3cG9ydC5yYXdEaW1zO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKHRoaXMuZGF0YS5yZWN0KTtcbiAgICBsZXQgZWxlbWVudFdpZHRoLCBlbGVtZW50SGVpZ2h0O1xuICAgIGlmIChhbmdsZSAlIDE4MCA9PT0gMCkge1xuICAgICAgZWxlbWVudFdpZHRoID0gMTAwICogd2lkdGggLyBwYWdlV2lkdGg7XG4gICAgICBlbGVtZW50SGVpZ2h0ID0gMTAwICogaGVpZ2h0IC8gcGFnZUhlaWdodDtcbiAgICB9IGVsc2Uge1xuICAgICAgZWxlbWVudFdpZHRoID0gMTAwICogaGVpZ2h0IC8gcGFnZVdpZHRoO1xuICAgICAgZWxlbWVudEhlaWdodCA9IDEwMCAqIHdpZHRoIC8gcGFnZUhlaWdodDtcbiAgICB9XG4gICAgY29udGFpbmVyLnN0eWxlLndpZHRoID0gYCR7ZWxlbWVudFdpZHRofSVgO1xuICAgIGNvbnRhaW5lci5zdHlsZS5oZWlnaHQgPSBgJHtlbGVtZW50SGVpZ2h0fSVgO1xuICAgIGNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJkYXRhLW1haW4tcm90YXRpb25cIiwgKDM2MCAtIGFuZ2xlKSAlIDM2MCk7XG4gIH1cbiAgZ2V0IF9jb21tb25BY3Rpb25zKCkge1xuICAgIGNvbnN0IHNldENvbG9yID0gKGpzTmFtZSwgc3R5bGVOYW1lLCBldmVudCkgPT4ge1xuICAgICAgY29uc3QgY29sb3IgPSBldmVudC5kZXRhaWxbanNOYW1lXTtcbiAgICAgIGNvbnN0IGNvbG9yVHlwZSA9IGNvbG9yWzBdO1xuICAgICAgY29uc3QgY29sb3JBcnJheSA9IGNvbG9yLnNsaWNlKDEpO1xuICAgICAgZXZlbnQudGFyZ2V0LnN0eWxlW3N0eWxlTmFtZV0gPSBfc2NyaXB0aW5nX3V0aWxzLkNvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X0hUTUxgXShjb2xvckFycmF5KTtcbiAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgIFtzdHlsZU5hbWVdOiBfc2NyaXB0aW5nX3V0aWxzLkNvbG9yQ29udmVydGVyc1tgJHtjb2xvclR5cGV9X3JnYmBdKGNvbG9yQXJyYXkpXG4gICAgICB9KTtcbiAgICB9O1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcIl9jb21tb25BY3Rpb25zXCIsIHtcbiAgICAgIGRpc3BsYXk6IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGRpc3BsYXlcbiAgICAgICAgfSA9IGV2ZW50LmRldGFpbDtcbiAgICAgICAgY29uc3QgaGlkZGVuID0gZGlzcGxheSAlIDIgPT09IDE7XG4gICAgICAgIHRoaXMuY29udGFpbmVyLnN0eWxlLnZpc2liaWxpdHkgPSBoaWRkZW4gPyBcImhpZGRlblwiIDogXCJ2aXNpYmxlXCI7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9WaWV3OiBoaWRkZW4sXG4gICAgICAgICAgbm9QcmludDogZGlzcGxheSA9PT0gMSB8fCBkaXNwbGF5ID09PSAyXG4gICAgICAgIH0pO1xuICAgICAgfSxcbiAgICAgIHByaW50OiBldmVudCA9PiB7XG4gICAgICAgIHRoaXMuYW5ub3RhdGlvblN0b3JhZ2Uuc2V0VmFsdWUodGhpcy5kYXRhLmlkLCB7XG4gICAgICAgICAgbm9QcmludDogIWV2ZW50LmRldGFpbC5wcmludFxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBoaWRkZW46IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIGhpZGRlblxuICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICB0aGlzLmNvbnRhaW5lci5zdHlsZS52aXNpYmlsaXR5ID0gaGlkZGVuID8gXCJoaWRkZW5cIiA6IFwidmlzaWJsZVwiO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIG5vUHJpbnQ6IGhpZGRlbixcbiAgICAgICAgICBub1ZpZXc6IGhpZGRlblxuICAgICAgICB9KTtcbiAgICAgIH0sXG4gICAgICBmb2N1czogZXZlbnQgPT4ge1xuICAgICAgICBzZXRUaW1lb3V0KCgpID0+IGV2ZW50LnRhcmdldC5mb2N1cyh7XG4gICAgICAgICAgcHJldmVudFNjcm9sbDogZmFsc2VcbiAgICAgICAgfSksIDApO1xuICAgICAgfSxcbiAgICAgIHVzZXJOYW1lOiBldmVudCA9PiB7XG4gICAgICAgIGV2ZW50LnRhcmdldC50aXRsZSA9IGV2ZW50LmRldGFpbC51c2VyTmFtZTtcbiAgICAgIH0sXG4gICAgICByZWFkb25seTogZXZlbnQgPT4ge1xuICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSBldmVudC5kZXRhaWwucmVhZG9ubHk7XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5fc2V0UmVxdWlyZWQoZXZlbnQudGFyZ2V0LCBldmVudC5kZXRhaWwucmVxdWlyZWQpO1xuICAgICAgfSxcbiAgICAgIGJnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJiZ0NvbG9yXCIsIFwiYmFja2dyb3VuZENvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBmaWxsQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmaWxsQ29sb3JcIiwgXCJiYWNrZ3JvdW5kQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIGZnQ29sb3I6IGV2ZW50ID0+IHtcbiAgICAgICAgc2V0Q29sb3IoXCJmZ0NvbG9yXCIsIFwiY29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHRleHRDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcInRleHRDb2xvclwiLCBcImNvbG9yXCIsIGV2ZW50KTtcbiAgICAgIH0sXG4gICAgICBib3JkZXJDb2xvcjogZXZlbnQgPT4ge1xuICAgICAgICBzZXRDb2xvcihcImJvcmRlckNvbG9yXCIsIFwiYm9yZGVyQ29sb3JcIiwgZXZlbnQpO1xuICAgICAgfSxcbiAgICAgIHN0cm9rZUNvbG9yOiBldmVudCA9PiB7XG4gICAgICAgIHNldENvbG9yKFwic3Ryb2tlQ29sb3JcIiwgXCJib3JkZXJDb2xvclwiLCBldmVudCk7XG4gICAgICB9LFxuICAgICAgcm90YXRpb246IGV2ZW50ID0+IHtcbiAgICAgICAgY29uc3QgYW5nbGUgPSBldmVudC5kZXRhaWwucm90YXRpb247XG4gICAgICAgIHRoaXMuc2V0Um90YXRpb24oYW5nbGUpO1xuICAgICAgICB0aGlzLmFubm90YXRpb25TdG9yYWdlLnNldFZhbHVlKHRoaXMuZGF0YS5pZCwge1xuICAgICAgICAgIHJvdGF0aW9uOiBhbmdsZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBfZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpIHtcbiAgICBjb25zdCBjb21tb25BY3Rpb25zID0gdGhpcy5fY29tbW9uQWN0aW9ucztcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoanNFdmVudC5kZXRhaWwpKSB7XG4gICAgICBjb25zdCBhY3Rpb24gPSBhY3Rpb25zW25hbWVdIHx8IGNvbW1vbkFjdGlvbnNbbmFtZV07XG4gICAgICBhY3Rpb24/Lihqc0V2ZW50KTtcbiAgICB9XG4gIH1cbiAgX3NldERlZmF1bHRQcm9wZXJ0aWVzRnJvbUpTKGVsZW1lbnQpIHtcbiAgICBpZiAoIXRoaXMuZW5hYmxlU2NyaXB0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHN0b3JlZERhdGEgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlLmdldFJhd1ZhbHVlKHRoaXMuZGF0YS5pZCk7XG4gICAgaWYgKCFzdG9yZWREYXRhKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IGNvbW1vbkFjdGlvbnMgPSB0aGlzLl9jb21tb25BY3Rpb25zO1xuICAgIGZvciAoY29uc3QgW2FjdGlvbk5hbWUsIGRldGFpbF0gb2YgT2JqZWN0LmVudHJpZXMoc3RvcmVkRGF0YSkpIHtcbiAgICAgIGNvbnN0IGFjdGlvbiA9IGNvbW1vbkFjdGlvbnNbYWN0aW9uTmFtZV07XG4gICAgICBpZiAoYWN0aW9uKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50UHJveHkgPSB7XG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBbYWN0aW9uTmFtZV06IGRldGFpbFxuICAgICAgICAgIH0sXG4gICAgICAgICAgdGFyZ2V0OiBlbGVtZW50XG4gICAgICAgIH07XG4gICAgICAgIGFjdGlvbihldmVudFByb3h5KTtcbiAgICAgICAgZGVsZXRlIHN0b3JlZERhdGFbYWN0aW9uTmFtZV07XG4gICAgICB9XG4gICAgfVxuICB9XG4gIF9jcmVhdGVRdWFkcmlsYXRlcmFscygpIHtcbiAgICBpZiAoIXRoaXMuY29udGFpbmVyKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHF1YWRQb2ludHNcbiAgICB9ID0gdGhpcy5kYXRhO1xuICAgIGlmICghcXVhZFBvaW50cykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBbcmVjdEJsWCwgcmVjdEJsWSwgcmVjdFRyWCwgcmVjdFRyWV0gPSB0aGlzLmRhdGEucmVjdDtcbiAgICBpZiAocXVhZFBvaW50cy5sZW5ndGggPT09IDEpIHtcbiAgICAgIGNvbnN0IFssIHtcbiAgICAgICAgeDogdHJYLFxuICAgICAgICB5OiB0cllcbiAgICAgIH0sIHtcbiAgICAgICAgeDogYmxYLFxuICAgICAgICB5OiBibFlcbiAgICAgIH1dID0gcXVhZFBvaW50c1swXTtcbiAgICAgIGlmIChyZWN0VHJYID09PSB0clggJiYgcmVjdFRyWSA9PT0gdHJZICYmIHJlY3RCbFggPT09IGJsWCAmJiByZWN0QmxZID09PSBibFkpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCB7XG4gICAgICBzdHlsZVxuICAgIH0gPSB0aGlzLmNvbnRhaW5lcjtcbiAgICBsZXQgc3ZnQnVmZmVyO1xuICAgIGlmICh0aGlzLiNoYXNCb3JkZXIpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgYm9yZGVyQ29sb3IsXG4gICAgICAgIGJvcmRlcldpZHRoXG4gICAgICB9ID0gc3R5bGU7XG4gICAgICBzdHlsZS5ib3JkZXJXaWR0aCA9IDA7XG4gICAgICBzdmdCdWZmZXIgPSBbXCJ1cmwoJ2RhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LFwiLCBgPHN2ZyB4bWxucz1cImh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnXCJgLCBgIHByZXNlcnZlQXNwZWN0UmF0aW89XCJub25lXCIgdmlld0JveD1cIjAgMCAxIDFcIj5gLCBgPGcgZmlsbD1cInRyYW5zcGFyZW50XCIgc3Ryb2tlPVwiJHtib3JkZXJDb2xvcn1cIiBzdHJva2Utd2lkdGg9XCIke2JvcmRlcldpZHRofVwiPmBdO1xuICAgICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhhc0JvcmRlclwiKTtcbiAgICB9XG4gICAgY29uc3Qgd2lkdGggPSByZWN0VHJYIC0gcmVjdEJsWDtcbiAgICBjb25zdCBoZWlnaHQgPSByZWN0VHJZIC0gcmVjdEJsWTtcbiAgICBjb25zdCB7XG4gICAgICBzdmdGYWN0b3J5XG4gICAgfSA9IHRoaXM7XG4gICAgY29uc3Qgc3ZnID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnXCIpO1xuICAgIHN2Zy5jbGFzc0xpc3QuYWRkKFwicXVhZHJpbGF0ZXJhbHNDb250YWluZXJcIik7XG4gICAgc3ZnLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIDApO1xuICAgIHN2Zy5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgMCk7XG4gICAgY29uc3QgZGVmcyA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImRlZnNcIik7XG4gICAgc3ZnLmFwcGVuZChkZWZzKTtcbiAgICBjb25zdCBjbGlwUGF0aCA9IHN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudChcImNsaXBQYXRoXCIpO1xuICAgIGNvbnN0IGlkID0gYGNsaXBwYXRoXyR7dGhpcy5kYXRhLmlkfWA7XG4gICAgY2xpcFBhdGguc2V0QXR0cmlidXRlKFwiaWRcIiwgaWQpO1xuICAgIGNsaXBQYXRoLnNldEF0dHJpYnV0ZShcImNsaXBQYXRoVW5pdHNcIiwgXCJvYmplY3RCb3VuZGluZ0JveFwiKTtcbiAgICBkZWZzLmFwcGVuZChjbGlwUGF0aCk7XG4gICAgZm9yIChjb25zdCBbLCB7XG4gICAgICB4OiB0clgsXG4gICAgICB5OiB0cllcbiAgICB9LCB7XG4gICAgICB4OiBibFgsXG4gICAgICB5OiBibFlcbiAgICB9XSBvZiBxdWFkUG9pbnRzKSB7XG4gICAgICBjb25zdCByZWN0ID0gc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwicmVjdFwiKTtcbiAgICAgIGNvbnN0IHggPSAoYmxYIC0gcmVjdEJsWCkgLyB3aWR0aDtcbiAgICAgIGNvbnN0IHkgPSAocmVjdFRyWSAtIHRyWSkgLyBoZWlnaHQ7XG4gICAgICBjb25zdCByZWN0V2lkdGggPSAodHJYIC0gYmxYKSAvIHdpZHRoO1xuICAgICAgY29uc3QgcmVjdEhlaWdodCA9ICh0clkgLSBibFkpIC8gaGVpZ2h0O1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ4XCIsIHgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ5XCIsIHkpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJ3aWR0aFwiLCByZWN0V2lkdGgpO1xuICAgICAgcmVjdC5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgcmVjdEhlaWdodCk7XG4gICAgICBjbGlwUGF0aC5hcHBlbmQocmVjdCk7XG4gICAgICBzdmdCdWZmZXI/LnB1c2goYDxyZWN0IHZlY3Rvci1lZmZlY3Q9XCJub24tc2NhbGluZy1zdHJva2VcIiB4PVwiJHt4fVwiIHk9XCIke3l9XCIgd2lkdGg9XCIke3JlY3RXaWR0aH1cIiBoZWlnaHQ9XCIke3JlY3RIZWlnaHR9XCIvPmApO1xuICAgIH1cbiAgICBpZiAodGhpcy4jaGFzQm9yZGVyKSB7XG4gICAgICBzdmdCdWZmZXIucHVzaChgPC9nPjwvc3ZnPicpYCk7XG4gICAgICBzdHlsZS5iYWNrZ3JvdW5kSW1hZ2UgPSBzdmdCdWZmZXIuam9pbihcIlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHN2Zyk7XG4gICAgdGhpcy5jb250YWluZXIuc3R5bGUuY2xpcFBhdGggPSBgdXJsKCMke2lkfSlgO1xuICB9XG4gIF9jcmVhdGVQb3B1cCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjb250YWluZXIsXG4gICAgICBkYXRhXG4gICAgfSA9IHRoaXM7XG4gICAgY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImFyaWEtaGFzcG9wdXBcIiwgXCJkaWFsb2dcIik7XG4gICAgY29uc3QgcG9wdXAgPSBuZXcgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCh7XG4gICAgICBkYXRhOiB7XG4gICAgICAgIGNvbG9yOiBkYXRhLmNvbG9yLFxuICAgICAgICB0aXRsZU9iajogZGF0YS50aXRsZU9iaixcbiAgICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogZGF0YS5tb2RpZmljYXRpb25EYXRlLFxuICAgICAgICBjb250ZW50c09iajogZGF0YS5jb250ZW50c09iaixcbiAgICAgICAgcmljaFRleHQ6IGRhdGEucmljaFRleHQsXG4gICAgICAgIHBhcmVudFJlY3Q6IGRhdGEucmVjdCxcbiAgICAgICAgYm9yZGVyU3R5bGU6IDAsXG4gICAgICAgIGlkOiBgcG9wdXBfJHtkYXRhLmlkfWAsXG4gICAgICAgIHJvdGF0aW9uOiBkYXRhLnJvdGF0aW9uXG4gICAgICB9LFxuICAgICAgcGFyZW50OiB0aGlzLnBhcmVudCxcbiAgICAgIGVsZW1lbnRzOiBbdGhpc11cbiAgICB9KTtcbiAgICB0aGlzLnBhcmVudC5kaXYuYXBwZW5kKHBvcHVwLnJlbmRlcigpKTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgKDAsIF91dGlsLnVucmVhY2hhYmxlKShcIkFic3RyYWN0IG1ldGhvZCBgQW5ub3RhdGlvbkVsZW1lbnQucmVuZGVyYCBjYWxsZWRcIik7XG4gIH1cbiAgX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUpIHtcbiAgICBsZXQgc2tpcElkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBudWxsO1xuICAgIGNvbnN0IGZpZWxkcyA9IFtdO1xuICAgIGlmICh0aGlzLl9maWVsZE9iamVjdHMpIHtcbiAgICAgIGNvbnN0IGZpZWxkT2JqID0gdGhpcy5fZmllbGRPYmplY3RzW25hbWVdO1xuICAgICAgaWYgKGZpZWxkT2JqKSB7XG4gICAgICAgIGZvciAoY29uc3Qge1xuICAgICAgICAgIHBhZ2UsXG4gICAgICAgICAgaWQsXG4gICAgICAgICAgZXhwb3J0VmFsdWVzXG4gICAgICAgIH0gb2YgZmllbGRPYmopIHtcbiAgICAgICAgICBpZiAocGFnZSA9PT0gLTEpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaWQgPT09IHNraXBJZCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gdHlwZW9mIGV4cG9ydFZhbHVlcyA9PT0gXCJzdHJpbmdcIiA/IGV4cG9ydFZhbHVlcyA6IG51bGw7XG4gICAgICAgICAgY29uc3QgZG9tRWxlbWVudCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoYFtkYXRhLWVsZW1lbnQtaWQ9XCIke2lkfVwiXWApO1xuICAgICAgICAgIGlmIChkb21FbGVtZW50ICYmICFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAgICgwLCBfdXRpbC53YXJuKShgX2dldEVsZW1lbnRzQnlOYW1lIC0gZWxlbWVudCBub3QgYWxsb3dlZDogJHtpZH1gKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgICAgICBpZCxcbiAgICAgICAgICAgIGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgZG9tRWxlbWVudFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gZmllbGRzO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGRvbUVsZW1lbnQgb2YgZG9jdW1lbnQuZ2V0RWxlbWVudHNCeU5hbWUobmFtZSkpIHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgIH0gPSBkb21FbGVtZW50O1xuICAgICAgY29uc3QgaWQgPSBkb21FbGVtZW50LmdldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiKTtcbiAgICAgIGlmIChpZCA9PT0gc2tpcElkKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBmaWVsZHMucHVzaCh7XG4gICAgICAgIGlkLFxuICAgICAgICBleHBvcnRWYWx1ZSxcbiAgICAgICAgZG9tRWxlbWVudFxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBmaWVsZHM7XG4gIH1cbiAgc2hvdygpIHtcbiAgICBpZiAodGhpcy5jb250YWluZXIpIHtcbiAgICAgIHRoaXMuY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICAgIH1cbiAgICB0aGlzLnBvcHVwPy5tYXliZVNob3coKTtcbiAgfVxuICBoaWRlKCkge1xuICAgIGlmICh0aGlzLmNvbnRhaW5lcikge1xuICAgICAgdGhpcy5jb250YWluZXIuaGlkZGVuID0gdHJ1ZTtcbiAgICB9XG4gICAgdGhpcy5wb3B1cD8uZm9yY2VIaWRlKCk7XG4gIH1cbiAgZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpIHtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICBjb25zdCB0cmlnZ2VycyA9IHRoaXMuZ2V0RWxlbWVudHNUb1RyaWdnZXJQb3B1cCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHRyaWdnZXJzKSkge1xuICAgICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRyaWdnZXJzKSB7XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRyaWdnZXJzLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICAgIH1cbiAgfVxuICBfZWRpdE9uRG91YmxlQ2xpY2soKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbkVkaXRvclR5cGU6IG1vZGUsXG4gICAgICBkYXRhOiB7XG4gICAgICAgIGlkOiBlZGl0SWRcbiAgICAgIH1cbiAgICB9ID0gdGhpcztcbiAgICB0aGlzLmNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiZGJsY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJzd2l0Y2hhbm5vdGF0aW9uZWRpdG9ybW9kZVwiLCB7XG4gICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgbW9kZSxcbiAgICAgICAgZWRpdElkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxufVxuY2xhc3MgTGlua0Fubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgbGV0IG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6IG51bGw7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiAhIW9wdGlvbnM/Lmlnbm9yZUJvcmRlcixcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5pc1Rvb2x0aXBPbmx5ID0gcGFyYW1ldGVycy5kYXRhLmlzVG9vbHRpcE9ubHk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBsaW5rU2VydmljZVxuICAgIH0gPSB0aGlzO1xuICAgIGNvbnN0IGxpbmsgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYVwiKTtcbiAgICBsaW5rLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBkYXRhLmlkKTtcbiAgICBsZXQgaXNCb3VuZCA9IGZhbHNlO1xuICAgIGlmIChkYXRhLnVybCkge1xuICAgICAgbGlua1NlcnZpY2UuYWRkTGlua0F0dHJpYnV0ZXMobGluaywgZGF0YS51cmwsIGRhdGEubmV3V2luZG93KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5hY3Rpb24pIHtcbiAgICAgIHRoaXMuX2JpbmROYW1lZEFjdGlvbihsaW5rLCBkYXRhLmFjdGlvbik7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2UgaWYgKGRhdGEuYXR0YWNobWVudCkge1xuICAgICAgdGhpcy5fYmluZEF0dGFjaG1lbnQobGluaywgZGF0YS5hdHRhY2htZW50KTtcbiAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgIH0gZWxzZSBpZiAoZGF0YS5zZXRPQ0dTdGF0ZSkge1xuICAgICAgdGhpcy4jYmluZFNldE9DR1N0YXRlKGxpbmssIGRhdGEuc2V0T0NHU3RhdGUpO1xuICAgICAgaXNCb3VuZCA9IHRydWU7XG4gICAgfSBlbHNlIGlmIChkYXRhLmRlc3QpIHtcbiAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIGRhdGEuZGVzdCk7XG4gICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGRhdGEuYWN0aW9ucyAmJiAoZGF0YS5hY3Rpb25zLkFjdGlvbiB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBVcFwiXSB8fCBkYXRhLmFjdGlvbnNbXCJNb3VzZSBEb3duXCJdKSAmJiB0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICB0aGlzLl9iaW5kSlNBY3Rpb24obGluaywgZGF0YSk7XG4gICAgICAgIGlzQm91bmQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGRhdGEucmVzZXRGb3JtKSB7XG4gICAgICAgIHRoaXMuX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgZGF0YS5yZXNldEZvcm0pO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAodGhpcy5pc1Rvb2x0aXBPbmx5ICYmICFpc0JvdW5kKSB7XG4gICAgICAgIHRoaXMuX2JpbmRMaW5rKGxpbmssIFwiXCIpO1xuICAgICAgICBpc0JvdW5kID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmtBbm5vdGF0aW9uXCIpO1xuICAgIGlmIChpc0JvdW5kKSB7XG4gICAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQobGluayk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICAjc2V0SW50ZXJuYWxMaW5rKCkge1xuICAgIHRoaXMuY29udGFpbmVyLnNldEF0dHJpYnV0ZShcImRhdGEtaW50ZXJuYWwtbGlua1wiLCBcIlwiKTtcbiAgfVxuICBfYmluZExpbmsobGluaywgZGVzdGluYXRpb24pIHtcbiAgICBsaW5rLmhyZWYgPSB0aGlzLmxpbmtTZXJ2aWNlLmdldERlc3RpbmF0aW9uSGFzaChkZXN0aW5hdGlvbik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgaWYgKGRlc3RpbmF0aW9uKSB7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZ29Ub0Rlc3RpbmF0aW9uKGRlc3RpbmF0aW9uKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIGlmIChkZXN0aW5hdGlvbiB8fCBkZXN0aW5hdGlvbiA9PT0gXCJcIikge1xuICAgICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gICAgfVxuICB9XG4gIF9iaW5kTmFtZWRBY3Rpb24obGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlTmFtZWRBY3Rpb24oYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kQXR0YWNobWVudChsaW5rLCBhdHRhY2htZW50KSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YSh0aGlzLmNvbnRhaW5lciwgYXR0YWNobWVudC5jb250ZW50LCBhdHRhY2htZW50LmZpbGVuYW1lKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gICNiaW5kU2V0T0NHU3RhdGUobGluaywgYWN0aW9uKSB7XG4gICAgbGluay5ocmVmID0gdGhpcy5saW5rU2VydmljZS5nZXRBbmNob3JVcmwoXCJcIik7XG4gICAgbGluay5vbmNsaWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy5saW5rU2VydmljZS5leGVjdXRlU2V0T0NHU3RhdGUoYWN0aW9uKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIHRoaXMuI3NldEludGVybmFsTGluaygpO1xuICB9XG4gIF9iaW5kSlNBY3Rpb24obGluaywgZGF0YSkge1xuICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIGNvbnN0IG1hcCA9IG5ldyBNYXAoW1tcIkFjdGlvblwiLCBcIm9uY2xpY2tcIl0sIFtcIk1vdXNlIFVwXCIsIFwib25tb3VzZXVwXCJdLCBbXCJNb3VzZSBEb3duXCIsIFwib25tb3VzZWRvd25cIl1dKTtcbiAgICBmb3IgKGNvbnN0IG5hbWUgb2YgT2JqZWN0LmtleXMoZGF0YS5hY3Rpb25zKSkge1xuICAgICAgY29uc3QganNOYW1lID0gbWFwLmdldChuYW1lKTtcbiAgICAgIGlmICghanNOYW1lKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgbGlua1tqc05hbWVdID0gKCkgPT4ge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBkYXRhLmlkLFxuICAgICAgICAgICAgbmFtZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH07XG4gICAgfVxuICAgIGlmICghbGluay5vbmNsaWNrKSB7XG4gICAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiBmYWxzZTtcbiAgICB9XG4gICAgdGhpcy4jc2V0SW50ZXJuYWxMaW5rKCk7XG4gIH1cbiAgX2JpbmRSZXNldEZvcm1BY3Rpb24obGluaywgcmVzZXRGb3JtKSB7XG4gICAgY29uc3Qgb3RoZXJDbGlja0FjdGlvbiA9IGxpbmsub25jbGljaztcbiAgICBpZiAoIW90aGVyQ2xpY2tBY3Rpb24pIHtcbiAgICAgIGxpbmsuaHJlZiA9IHRoaXMubGlua1NlcnZpY2UuZ2V0QW5jaG9yVXJsKFwiXCIpO1xuICAgIH1cbiAgICB0aGlzLiNzZXRJbnRlcm5hbExpbmsoKTtcbiAgICBpZiAoIXRoaXMuX2ZpZWxkT2JqZWN0cykge1xuICAgICAgKDAsIF91dGlsLndhcm4pKGBfYmluZFJlc2V0Rm9ybUFjdGlvbiAtIFwicmVzZXRGb3JtXCIgYWN0aW9uIG5vdCBzdXBwb3J0ZWQsIGAgKyBcImVuc3VyZSB0aGF0IHRoZSBgZmllbGRPYmplY3RzYCBwYXJhbWV0ZXIgaXMgcHJvdmlkZWQuXCIpO1xuICAgICAgaWYgKCFvdGhlckNsaWNrQWN0aW9uKSB7XG4gICAgICAgIGxpbmsub25jbGljayA9ICgpID0+IGZhbHNlO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBsaW5rLm9uY2xpY2sgPSAoKSA9PiB7XG4gICAgICBvdGhlckNsaWNrQWN0aW9uPy4oKTtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmllbGRzOiByZXNldEZvcm1GaWVsZHMsXG4gICAgICAgIHJlZnM6IHJlc2V0Rm9ybVJlZnMsXG4gICAgICAgIGluY2x1ZGVcbiAgICAgIH0gPSByZXNldEZvcm07XG4gICAgICBjb25zdCBhbGxGaWVsZHMgPSBbXTtcbiAgICAgIGlmIChyZXNldEZvcm1GaWVsZHMubGVuZ3RoICE9PSAwIHx8IHJlc2V0Rm9ybVJlZnMubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgIGNvbnN0IGZpZWxkSWRzID0gbmV3IFNldChyZXNldEZvcm1SZWZzKTtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZE5hbWUgb2YgcmVzZXRGb3JtRmllbGRzKSB7XG4gICAgICAgICAgY29uc3QgZmllbGRzID0gdGhpcy5fZmllbGRPYmplY3RzW2ZpZWxkTmFtZV0gfHwgW107XG4gICAgICAgICAgZm9yIChjb25zdCB7XG4gICAgICAgICAgICBpZFxuICAgICAgICAgIH0gb2YgZmllbGRzKSB7XG4gICAgICAgICAgICBmaWVsZElkcy5hZGQoaWQpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkcyBvZiBPYmplY3QudmFsdWVzKHRoaXMuX2ZpZWxkT2JqZWN0cykpIHtcbiAgICAgICAgICBmb3IgKGNvbnN0IGZpZWxkIG9mIGZpZWxkcykge1xuICAgICAgICAgICAgaWYgKGZpZWxkSWRzLmhhcyhmaWVsZC5pZCkgPT09IGluY2x1ZGUpIHtcbiAgICAgICAgICAgICAgYWxsRmllbGRzLnB1c2goZmllbGQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBmaWVsZHMgb2YgT2JqZWN0LnZhbHVlcyh0aGlzLl9maWVsZE9iamVjdHMpKSB7XG4gICAgICAgICAgYWxsRmllbGRzLnB1c2goLi4uZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgICBjb25zdCBhbGxJZHMgPSBbXTtcbiAgICAgIGZvciAoY29uc3QgZmllbGQgb2YgYWxsRmllbGRzKSB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBpZFxuICAgICAgICB9ID0gZmllbGQ7XG4gICAgICAgIGFsbElkcy5wdXNoKGlkKTtcbiAgICAgICAgc3dpdGNoIChmaWVsZC50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgfHwgXCJcIjtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY2hlY2tib3hcIjpcbiAgICAgICAgICBjYXNlIFwicmFkaW9idXR0b25cIjpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsdWUgPSBmaWVsZC5kZWZhdWx0VmFsdWUgPT09IGZpZWxkLmV4cG9ydFZhbHVlcztcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiY29tYm9ib3hcIjpcbiAgICAgICAgICBjYXNlIFwibGlzdGJveFwiOlxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICBjb25zdCB2YWx1ZSA9IGZpZWxkLmRlZmF1bHRWYWx1ZSB8fCBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBkb21FbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3RvcihgW2RhdGEtZWxlbWVudC1pZD1cIiR7aWR9XCJdYCk7XG4gICAgICAgIGlmICghZG9tRWxlbWVudCkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9IGVsc2UgaWYgKCFHZXRFbGVtZW50c0J5TmFtZVNldC5oYXMoZG9tRWxlbWVudCkpIHtcbiAgICAgICAgICAoMCwgX3V0aWwud2FybikoYF9iaW5kUmVzZXRGb3JtQWN0aW9uIC0gZWxlbWVudCBub3QgYWxsb3dlZDogJHtpZH1gKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBkb21FbGVtZW50LmRpc3BhdGNoRXZlbnQobmV3IEV2ZW50KFwicmVzZXRmb3JtXCIpKTtcbiAgICAgIH1cbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZykge1xuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiBcImFwcFwiLFxuICAgICAgICAgICAgaWRzOiBhbGxJZHMsXG4gICAgICAgICAgICBuYW1lOiBcIlJlc2V0Rm9ybVwiXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICB9XG59XG5jbGFzcyBUZXh0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInRleHRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGltYWdlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImltZ1wiKTtcbiAgICBpbWFnZS5zcmMgPSB0aGlzLmltYWdlUmVzb3VyY2VzUGF0aCArIFwiYW5ub3RhdGlvbi1cIiArIHRoaXMuZGF0YS5uYW1lLnRvTG93ZXJDYXNlKCkgKyBcIi5zdmdcIjtcbiAgICBpbWFnZS5hbHQgPSBcIlt7e3R5cGV9fSBBbm5vdGF0aW9uXVwiO1xuICAgIGltYWdlLmRhdGFzZXQubDEwbklkID0gXCJ0ZXh0X2Fubm90YXRpb25fdHlwZVwiO1xuICAgIGltYWdlLmRhdGFzZXQubDEwbkFyZ3MgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICB0eXBlOiB0aGlzLmRhdGEubmFtZVxuICAgIH0pO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoaW1hZ2UpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kYXRhLmFsdGVybmF0aXZlVGV4dCkge1xuICAgICAgdGhpcy5jb250YWluZXIudGl0bGUgPSB0aGlzLmRhdGEuYWx0ZXJuYXRpdmVUZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbiAgc2hvd0VsZW1lbnRBbmRIaWRlQ2FudmFzKGVsZW1lbnQpIHtcbiAgICBpZiAodGhpcy5kYXRhLmhhc093bkNhbnZhcykge1xuICAgICAgaWYgKGVsZW1lbnQucHJldmlvdXNTaWJsaW5nPy5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBlbGVtZW50LnByZXZpb3VzU2libGluZy5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgZWxlbWVudC5oaWRkZW4gPSBmYWxzZTtcbiAgICB9XG4gIH1cbiAgX2dldEtleU1vZGlmaWVyKGV2ZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgaXNXaW4sXG4gICAgICBpc01hY1xuICAgIH0gPSBfdXRpbC5GZWF0dXJlVGVzdC5wbGF0Zm9ybTtcbiAgICByZXR1cm4gaXNXaW4gJiYgZXZlbnQuY3RybEtleSB8fCBpc01hYyAmJiBldmVudC5tZXRhS2V5O1xuICB9XG4gIF9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBiYXNlTmFtZSwgZXZlbnROYW1lLCB2YWx1ZUdldHRlcikge1xuICAgIGlmIChiYXNlTmFtZS5pbmNsdWRlcyhcIm1vdXNlXCIpKSB7XG4gICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoYmFzZU5hbWUsIGV2ZW50ID0+IHtcbiAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICBzb3VyY2U6IHRoaXMsXG4gICAgICAgICAgZGV0YWlsOiB7XG4gICAgICAgICAgICBpZDogdGhpcy5kYXRhLmlkLFxuICAgICAgICAgICAgbmFtZTogZXZlbnROYW1lLFxuICAgICAgICAgICAgdmFsdWU6IHZhbHVlR2V0dGVyKGV2ZW50KSxcbiAgICAgICAgICAgIHNoaWZ0OiBldmVudC5zaGlmdEtleSxcbiAgICAgICAgICAgIG1vZGlmaWVyOiB0aGlzLl9nZXRLZXlNb2RpZmllcihldmVudClcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihiYXNlTmFtZSwgZXZlbnQgPT4ge1xuICAgICAgICBpZiAoYmFzZU5hbWUgPT09IFwiYmx1clwiKSB7XG4gICAgICAgICAgaWYgKCFlbGVtZW50RGF0YS5mb2N1c2VkIHx8ICFldmVudC5yZWxhdGVkVGFyZ2V0KSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgfVxuICAgICAgICAgIGVsZW1lbnREYXRhLmZvY3VzZWQgPSBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChiYXNlTmFtZSA9PT0gXCJmb2N1c1wiKSB7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCF2YWx1ZUdldHRlcikge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgIGlkOiB0aGlzLmRhdGEuaWQsXG4gICAgICAgICAgICBuYW1lOiBldmVudE5hbWUsXG4gICAgICAgICAgICB2YWx1ZTogdmFsdWVHZXR0ZXIoZXZlbnQpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBfc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgZWxlbWVudERhdGEsIG5hbWVzLCBnZXR0ZXIpIHtcbiAgICBmb3IgKGNvbnN0IFtiYXNlTmFtZSwgZXZlbnROYW1lXSBvZiBuYW1lcykge1xuICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJBY3Rpb25cIiB8fCB0aGlzLmRhdGEuYWN0aW9ucz8uW2V2ZW50TmFtZV0pIHtcbiAgICAgICAgaWYgKGV2ZW50TmFtZSA9PT0gXCJGb2N1c1wiIHx8IGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIpIHtcbiAgICAgICAgICBlbGVtZW50RGF0YSB8fD0ge1xuICAgICAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIGJhc2VOYW1lLCBldmVudE5hbWUsIGdldHRlcik7XG4gICAgICAgIGlmIChldmVudE5hbWUgPT09IFwiRm9jdXNcIiAmJiAhdGhpcy5kYXRhLmFjdGlvbnM/LkJsdXIpIHtcbiAgICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVyKGVsZW1lbnQsIGVsZW1lbnREYXRhLCBcImJsdXJcIiwgXCJCbHVyXCIsIG51bGwpO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50TmFtZSA9PT0gXCJCbHVyXCIgJiYgIXRoaXMuZGF0YS5hY3Rpb25zPy5Gb2N1cykge1xuICAgICAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXIoZWxlbWVudCwgZWxlbWVudERhdGEsIFwiZm9jdXNcIiwgXCJGb2N1c1wiLCBudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBfc2V0QmFja2dyb3VuZENvbG9yKGVsZW1lbnQpIHtcbiAgICBjb25zdCBjb2xvciA9IHRoaXMuZGF0YS5iYWNrZ3JvdW5kQ29sb3IgfHwgbnVsbDtcbiAgICBlbGVtZW50LnN0eWxlLmJhY2tncm91bmRDb2xvciA9IGNvbG9yID09PSBudWxsID8gXCJ0cmFuc3BhcmVudFwiIDogX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoY29sb3JbMF0sIGNvbG9yWzFdLCBjb2xvclsyXSk7XG4gIH1cbiAgX3NldFRleHRTdHlsZShlbGVtZW50KSB7XG4gICAgY29uc3QgVEVYVF9BTElHTk1FTlQgPSBbXCJsZWZ0XCIsIFwiY2VudGVyXCIsIFwicmlnaHRcIl07XG4gICAgY29uc3Qge1xuICAgICAgZm9udENvbG9yXG4gICAgfSA9IHRoaXMuZGF0YS5kZWZhdWx0QXBwZWFyYW5jZURhdGE7XG4gICAgY29uc3QgZm9udFNpemUgPSB0aGlzLmRhdGEuZGVmYXVsdEFwcGVhcmFuY2VEYXRhLmZvbnRTaXplIHx8IERFRkFVTFRfRk9OVF9TSVpFO1xuICAgIGNvbnN0IHN0eWxlID0gZWxlbWVudC5zdHlsZTtcbiAgICBsZXQgY29tcHV0ZWRGb250U2l6ZTtcbiAgICBjb25zdCBCT1JERVJfU0laRSA9IDI7XG4gICAgY29uc3Qgcm91bmRUb09uZURlY2ltYWwgPSB4ID0+IE1hdGgucm91bmQoMTAgKiB4KSAvIDEwO1xuICAgIGlmICh0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29uc3QgbnVtYmVyT2ZMaW5lcyA9IE1hdGgucm91bmQoaGVpZ2h0IC8gKF91dGlsLkxJTkVfRkFDVE9SICogZm9udFNpemUpKSB8fCAxO1xuICAgICAgY29uc3QgbGluZUhlaWdodCA9IGhlaWdodCAvIG51bWJlck9mTGluZXM7XG4gICAgICBjb21wdXRlZEZvbnRTaXplID0gTWF0aC5taW4oZm9udFNpemUsIHJvdW5kVG9PbmVEZWNpbWFsKGxpbmVIZWlnaHQgLyBfdXRpbC5MSU5FX0ZBQ1RPUikpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmFicyh0aGlzLmRhdGEucmVjdFszXSAtIHRoaXMuZGF0YS5yZWN0WzFdIC0gQk9SREVSX1NJWkUpO1xuICAgICAgY29tcHV0ZWRGb250U2l6ZSA9IE1hdGgubWluKGZvbnRTaXplLCByb3VuZFRvT25lRGVjaW1hbChoZWlnaHQgLyBfdXRpbC5MSU5FX0ZBQ1RPUikpO1xuICAgIH1cbiAgICBzdHlsZS5mb250U2l6ZSA9IGBjYWxjKCR7Y29tcHV0ZWRGb250U2l6ZX1weCAqIHZhcigtLXNjYWxlLWZhY3RvcikpYDtcbiAgICBzdHlsZS5jb2xvciA9IF91dGlsLlV0aWwubWFrZUhleENvbG9yKGZvbnRDb2xvclswXSwgZm9udENvbG9yWzFdLCBmb250Q29sb3JbMl0pO1xuICAgIGlmICh0aGlzLmRhdGEudGV4dEFsaWdubWVudCAhPT0gbnVsbCkge1xuICAgICAgc3R5bGUudGV4dEFsaWduID0gVEVYVF9BTElHTk1FTlRbdGhpcy5kYXRhLnRleHRBbGlnbm1lbnRdO1xuICAgIH1cbiAgfVxuICBfc2V0UmVxdWlyZWQoZWxlbWVudCwgaXNSZXF1aXJlZCkge1xuICAgIGlmIChpc1JlcXVpcmVkKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInJlcXVpcmVkXCIsIHRydWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShcInJlcXVpcmVkXCIpO1xuICAgIH1cbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImFyaWEtcmVxdWlyZWRcIiwgaXNSZXF1aXJlZCk7XG4gIH1cbn1cbmNsYXNzIFRleHRXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IGlzUmVuZGVyYWJsZSA9IHBhcmFtZXRlcnMucmVuZGVyRm9ybXMgfHwgIXBhcmFtZXRlcnMuZGF0YS5oYXNBcHBlYXJhbmNlICYmICEhcGFyYW1ldGVycy5kYXRhLmZpZWxkVmFsdWU7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlXG4gICAgfSk7XG4gIH1cbiAgc2V0UHJvcGVydHlPblNpYmxpbmdzKGJhc2UsIGtleSwgdmFsdWUsIGtleUluU3RvcmFnZSkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLl9nZXRFbGVtZW50c0J5TmFtZShiYXNlLm5hbWUsIGJhc2UuaWQpKSB7XG4gICAgICBpZiAoZWxlbWVudC5kb21FbGVtZW50KSB7XG4gICAgICAgIGVsZW1lbnQuZG9tRWxlbWVudFtrZXldID0gdmFsdWU7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGVsZW1lbnQuaWQsIHtcbiAgICAgICAgW2tleUluU3RvcmFnZV06IHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGNvbnN0IHN0b3JhZ2UgPSB0aGlzLmFubm90YXRpb25TdG9yYWdlO1xuICAgIGNvbnN0IGlkID0gdGhpcy5kYXRhLmlkO1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJ0ZXh0V2lkZ2V0QW5ub3RhdGlvblwiKTtcbiAgICBsZXQgZWxlbWVudCA9IG51bGw7XG4gICAgaWYgKHRoaXMucmVuZGVyRm9ybXMpIHtcbiAgICAgIGNvbnN0IHN0b3JlZERhdGEgPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgICAgfSk7XG4gICAgICBsZXQgdGV4dENvbnRlbnQgPSBzdG9yZWREYXRhLnZhbHVlIHx8IFwiXCI7XG4gICAgICBjb25zdCBtYXhMZW4gPSBzdG9yYWdlLmdldFZhbHVlKGlkLCB7XG4gICAgICAgIGNoYXJMaW1pdDogdGhpcy5kYXRhLm1heExlblxuICAgICAgfSkuY2hhckxpbWl0O1xuICAgICAgaWYgKG1heExlbiAmJiB0ZXh0Q29udGVudC5sZW5ndGggPiBtYXhMZW4pIHtcbiAgICAgICAgdGV4dENvbnRlbnQgPSB0ZXh0Q29udGVudC5zbGljZSgwLCBtYXhMZW4pO1xuICAgICAgfVxuICAgICAgbGV0IGZpZWxkRm9ybWF0dGVkVmFsdWVzID0gc3RvcmVkRGF0YS5mb3JtYXR0ZWRWYWx1ZSB8fCB0aGlzLmRhdGEudGV4dENvbnRlbnQ/LmpvaW4oXCJcXG5cIikgfHwgbnVsbDtcbiAgICAgIGlmIChmaWVsZEZvcm1hdHRlZFZhbHVlcyAmJiB0aGlzLmRhdGEuY29tYikge1xuICAgICAgICBmaWVsZEZvcm1hdHRlZFZhbHVlcyA9IGZpZWxkRm9ybWF0dGVkVmFsdWVzLnJlcGxhY2VBbGwoL1xccysvZywgXCJcIik7XG4gICAgICB9XG4gICAgICBjb25zdCBlbGVtZW50RGF0YSA9IHtcbiAgICAgICAgdXNlclZhbHVlOiB0ZXh0Q29udGVudCxcbiAgICAgICAgZm9ybWF0dGVkVmFsdWU6IGZpZWxkRm9ybWF0dGVkVmFsdWVzLFxuICAgICAgICBsYXN0Q29tbWl0dGVkVmFsdWU6IG51bGwsXG4gICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgZm9jdXNlZDogZmFsc2VcbiAgICAgIH07XG4gICAgICBpZiAodGhpcy5kYXRhLm11bHRpTGluZSkge1xuICAgICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInRleHRhcmVhXCIpO1xuICAgICAgICBlbGVtZW50LnRleHRDb250ZW50ID0gZmllbGRGb3JtYXR0ZWRWYWx1ZXMgPz8gdGV4dENvbnRlbnQ7XG4gICAgICAgIGlmICh0aGlzLmRhdGEuZG9Ob3RTY3JvbGwpIHtcbiAgICAgICAgICBlbGVtZW50LnN0eWxlLm92ZXJmbG93WSA9IFwiaGlkZGVuXCI7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiaW5wdXRcIik7XG4gICAgICAgIGVsZW1lbnQudHlwZSA9IFwidGV4dFwiO1xuICAgICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIGZpZWxkRm9ybWF0dGVkVmFsdWVzID8/IHRleHRDb250ZW50KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5kb05vdFNjcm9sbCkge1xuICAgICAgICAgIGVsZW1lbnQuc3R5bGUub3ZlcmZsb3dYID0gXCJoaWRkZW5cIjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKHRoaXMuZGF0YS5oYXNPd25DYW52YXMpIHtcbiAgICAgICAgZWxlbWVudC5oaWRkZW4gPSB0cnVlO1xuICAgICAgfVxuICAgICAgR2V0RWxlbWVudHNCeU5hbWVTZXQuYWRkKGVsZW1lbnQpO1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgICAgZWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICAgIGVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgICBlbGVtZW50LnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgICB0aGlzLl9zZXRSZXF1aXJlZChlbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgICAgaWYgKG1heExlbikge1xuICAgICAgICBlbGVtZW50Lm1heExlbmd0aCA9IG1heExlbjtcbiAgICAgIH1cbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2V0UHJvcGVydHlPblNpYmxpbmdzKGVsZW1lbnQsIFwidmFsdWVcIiwgZXZlbnQudGFyZ2V0LnZhbHVlLCBcInZhbHVlXCIpO1xuICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZSA/PyBcIlwiO1xuICAgICAgICBlbGVtZW50LnZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlID0gZGVmYXVsdFZhbHVlO1xuICAgICAgICBlbGVtZW50RGF0YS5mb3JtYXR0ZWRWYWx1ZSA9IG51bGw7XG4gICAgICB9KTtcbiAgICAgIGxldCBibHVyTGlzdGVuZXIgPSBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICB9ID0gZWxlbWVudERhdGE7XG4gICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgZXZlbnQudGFyZ2V0LnNjcm9sbExlZnQgPSAwO1xuICAgICAgfTtcbiAgICAgIGlmICh0aGlzLmVuYWJsZVNjcmlwdGluZyAmJiB0aGlzLmhhc0pTQWN0aW9ucykge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJmb2N1c1wiLCBldmVudCA9PiB7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmZvY3VzZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgfSA9IGV2ZW50O1xuICAgICAgICAgIGlmIChlbGVtZW50RGF0YS51c2VyVmFsdWUpIHtcbiAgICAgICAgICAgIHRhcmdldC52YWx1ZSA9IGVsZW1lbnREYXRhLnVzZXJWYWx1ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdGFyZ2V0LnZhbHVlO1xuICAgICAgICAgIGVsZW1lbnREYXRhLmNvbW1pdEtleSA9IDE7XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IHRydWU7XG4gICAgICAgIH0pO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJ1cGRhdGVmcm9tc2FuZGJveFwiLCBqc0V2ZW50ID0+IHtcbiAgICAgICAgICB0aGlzLnNob3dFbGVtZW50QW5kSGlkZUNhbnZhcyhqc0V2ZW50LnRhcmdldCk7XG4gICAgICAgICAgY29uc3QgYWN0aW9ucyA9IHtcbiAgICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLnVzZXJWYWx1ZSA9IGV2ZW50LmRldGFpbC52YWx1ZSA/PyBcIlwiO1xuICAgICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgICAgdmFsdWU6IGVsZW1lbnREYXRhLnVzZXJWYWx1ZS50b1N0cmluZygpXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9ybWF0dGVkVmFsdWUoZXZlbnQpIHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGZvcm1hdHRlZFZhbHVlXG4gICAgICAgICAgICAgIH0gPSBldmVudC5kZXRhaWw7XG4gICAgICAgICAgICAgIGVsZW1lbnREYXRhLmZvcm1hdHRlZFZhbHVlID0gZm9ybWF0dGVkVmFsdWU7XG4gICAgICAgICAgICAgIGlmIChmb3JtYXR0ZWRWYWx1ZSAhPT0gbnVsbCAmJiBmb3JtYXR0ZWRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGV2ZW50LnRhcmdldCAhPT0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCkge1xuICAgICAgICAgICAgICAgIGV2ZW50LnRhcmdldC52YWx1ZSA9IGZvcm1hdHRlZFZhbHVlO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgICBmb3JtYXR0ZWRWYWx1ZVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZWxSYW5nZShldmVudCkge1xuICAgICAgICAgICAgICBldmVudC50YXJnZXQuc2V0U2VsZWN0aW9uUmFuZ2UoLi4uZXZlbnQuZGV0YWlsLnNlbFJhbmdlKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjaGFyTGltaXQ6IGV2ZW50ID0+IHtcbiAgICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICAgIGNoYXJMaW1pdFxuICAgICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0XG4gICAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgICAgaWYgKGNoYXJMaW1pdCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIHRhcmdldC5yZW1vdmVBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRhcmdldC5zZXRBdHRyaWJ1dGUoXCJtYXhMZW5ndGhcIiwgY2hhckxpbWl0KTtcbiAgICAgICAgICAgICAgbGV0IHZhbHVlID0gZWxlbWVudERhdGEudXNlclZhbHVlO1xuICAgICAgICAgICAgICBpZiAoIXZhbHVlIHx8IHZhbHVlLmxlbmd0aCA8PSBjaGFyTGltaXQpIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgdmFsdWUgPSB2YWx1ZS5zbGljZSgwLCBjaGFyTGltaXQpO1xuICAgICAgICAgICAgICB0YXJnZXQudmFsdWUgPSBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICB0aGlzLmxpbmtTZXJ2aWNlLmV2ZW50QnVzPy5kaXNwYXRjaChcImRpc3BhdGNoZXZlbnRpbnNhbmRib3hcIiwge1xuICAgICAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgICAgd2lsbENvbW1pdDogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgIGNvbW1pdEtleTogMSxcbiAgICAgICAgICAgICAgICAgIHNlbFN0YXJ0OiB0YXJnZXQuc2VsZWN0aW9uU3RhcnQsXG4gICAgICAgICAgICAgICAgICBzZWxFbmQ6IHRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH07XG4gICAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldmVudCA9PiB7XG4gICAgICAgICAgZWxlbWVudERhdGEuY29tbWl0S2V5ID0gMTtcbiAgICAgICAgICBsZXQgY29tbWl0S2V5ID0gLTE7XG4gICAgICAgICAgaWYgKGV2ZW50LmtleSA9PT0gXCJFc2NhcGVcIikge1xuICAgICAgICAgICAgY29tbWl0S2V5ID0gMDtcbiAgICAgICAgICB9IGVsc2UgaWYgKGV2ZW50LmtleSA9PT0gXCJFbnRlclwiICYmICF0aGlzLmRhdGEubXVsdGlMaW5lKSB7XG4gICAgICAgICAgICBjb21taXRLZXkgPSAyO1xuICAgICAgICAgIH0gZWxzZSBpZiAoZXZlbnQua2V5ID09PSBcIlRhYlwiKSB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5jb21taXRLZXkgPSAzO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY29tbWl0S2V5ID09PSAtMSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICAgICAgaWYgKGVsZW1lbnREYXRhLmxhc3RDb21taXR0ZWRWYWx1ZSA9PT0gdmFsdWUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgZWxlbWVudERhdGEudXNlclZhbHVlID0gdmFsdWU7XG4gICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgbmFtZTogXCJLZXlzdHJva2VcIixcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgIGNvbW1pdEtleSxcbiAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kOiBldmVudC50YXJnZXQuc2VsZWN0aW9uRW5kXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBfYmx1ckxpc3RlbmVyID0gYmx1ckxpc3RlbmVyO1xuICAgICAgICBibHVyTGlzdGVuZXIgPSBudWxsO1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBpZiAoIWVsZW1lbnREYXRhLmZvY3VzZWQgfHwgIWV2ZW50LnJlbGF0ZWRUYXJnZXQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgZWxlbWVudERhdGEuZm9jdXNlZCA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIHZhbHVlXG4gICAgICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgICAgICBlbGVtZW50RGF0YS51c2VyVmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgICBpZiAoZWxlbWVudERhdGEubGFzdENvbW1pdHRlZFZhbHVlICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IHRydWUsXG4gICAgICAgICAgICAgICAgY29tbWl0S2V5OiBlbGVtZW50RGF0YS5jb21taXRLZXksXG4gICAgICAgICAgICAgICAgc2VsU3RhcnQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgICBzZWxFbmQ6IGV2ZW50LnRhcmdldC5zZWxlY3Rpb25FbmRcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIF9ibHVyTGlzdGVuZXIoZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YS5hY3Rpb25zPy5LZXlzdHJva2UpIHtcbiAgICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJiZWZvcmVpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBlbGVtZW50RGF0YS5sYXN0Q29tbWl0dGVkVmFsdWUgPSBudWxsO1xuICAgICAgICAgICAgY29uc3Qge1xuICAgICAgICAgICAgICBkYXRhLFxuICAgICAgICAgICAgICB0YXJnZXRcbiAgICAgICAgICAgIH0gPSBldmVudDtcbiAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICAgIHNlbGVjdGlvblN0YXJ0LFxuICAgICAgICAgICAgICBzZWxlY3Rpb25FbmRcbiAgICAgICAgICAgIH0gPSB0YXJnZXQ7XG4gICAgICAgICAgICBsZXQgc2VsU3RhcnQgPSBzZWxlY3Rpb25TdGFydCxcbiAgICAgICAgICAgICAgc2VsRW5kID0gc2VsZWN0aW9uRW5kO1xuICAgICAgICAgICAgc3dpdGNoIChldmVudC5pbnB1dFR5cGUpIHtcbiAgICAgICAgICAgICAgY2FzZSBcImRlbGV0ZVdvcmRCYWNrd2FyZFwiOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNlbGVjdGlvblN0YXJ0KS5tYXRjaCgvXFx3KlteXFx3XSokLyk7XG4gICAgICAgICAgICAgICAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgICAgICAgICAgICAgc2VsU3RhcnQgLT0gbWF0Y2hbMF0ubGVuZ3RoO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBjYXNlIFwiZGVsZXRlV29yZEZvcndhcmRcIjpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBjb25zdCBtYXRjaCA9IHZhbHVlLnN1YnN0cmluZyhzZWxlY3Rpb25TdGFydCkubWF0Y2goL15bXlxcd10qXFx3Ki8pO1xuICAgICAgICAgICAgICAgICAgaWYgKG1hdGNoKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbEVuZCArPSBtYXRjaFswXS5sZW5ndGg7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50QmFja3dhcmRcIjpcbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0aW9uU3RhcnQgPT09IHNlbGVjdGlvbkVuZCkge1xuICAgICAgICAgICAgICAgICAgc2VsU3RhcnQgLT0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIGNhc2UgXCJkZWxldGVDb250ZW50Rm9yd2FyZFwiOlxuICAgICAgICAgICAgICAgIGlmIChzZWxlY3Rpb25TdGFydCA9PT0gc2VsZWN0aW9uRW5kKSB7XG4gICAgICAgICAgICAgICAgICBzZWxFbmQgKz0gMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgICAgICAgICAgdGhpcy5saW5rU2VydmljZS5ldmVudEJ1cz8uZGlzcGF0Y2goXCJkaXNwYXRjaGV2ZW50aW5zYW5kYm94XCIsIHtcbiAgICAgICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgICAgICBkZXRhaWw6IHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgICAgIGNoYW5nZTogZGF0YSB8fCBcIlwiLFxuICAgICAgICAgICAgICAgIHdpbGxDb21taXQ6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlbFN0YXJ0LFxuICAgICAgICAgICAgICAgIHNlbEVuZFxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZXRFdmVudExpc3RlbmVycyhlbGVtZW50LCBlbGVtZW50RGF0YSwgW1tcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQudmFsdWUpO1xuICAgICAgfVxuICAgICAgaWYgKGJsdXJMaXN0ZW5lcikge1xuICAgICAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJibHVyXCIsIGJsdXJMaXN0ZW5lcik7XG4gICAgICB9XG4gICAgICBpZiAodGhpcy5kYXRhLmNvbWIpIHtcbiAgICAgICAgY29uc3QgZmllbGRXaWR0aCA9IHRoaXMuZGF0YS5yZWN0WzJdIC0gdGhpcy5kYXRhLnJlY3RbMF07XG4gICAgICAgIGNvbnN0IGNvbWJXaWR0aCA9IGZpZWxkV2lkdGggLyBtYXhMZW47XG4gICAgICAgIGVsZW1lbnQuY2xhc3NMaXN0LmFkZChcImNvbWJcIik7XG4gICAgICAgIGVsZW1lbnQuc3R5bGUubGV0dGVyU3BhY2luZyA9IGBjYWxjKCR7Y29tYldpZHRofXB4ICogdmFyKC0tc2NhbGUtZmFjdG9yKSAtIDFjaClgO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGVsZW1lbnQudGV4dENvbnRlbnQgPSB0aGlzLmRhdGEuZmllbGRWYWx1ZTtcbiAgICAgIGVsZW1lbnQuc3R5bGUudmVydGljYWxBbGlnbiA9IFwibWlkZGxlXCI7XG4gICAgICBlbGVtZW50LnN0eWxlLmRpc3BsYXkgPSBcInRhYmxlLWNlbGxcIjtcbiAgICB9XG4gICAgdGhpcy5fc2V0VGV4dFN0eWxlKGVsZW1lbnQpO1xuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBTaWduYXR1cmVXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIFdpZGdldEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogISFwYXJhbWV0ZXJzLmRhdGEuaGFzT3duQ2FudmFzXG4gICAgfSk7XG4gIH1cbn1cbmNsYXNzIENoZWNrYm94V2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBpZCA9IGRhdGEuaWQ7XG4gICAgbGV0IHZhbHVlID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IGRhdGEuZXhwb3J0VmFsdWUgPT09IGRhdGEuZmllbGRWYWx1ZVxuICAgIH0pLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09IFwiT2ZmXCI7XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJjaGVja0JveFwiKTtcbiAgICBjb25zdCBlbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImlucHV0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChlbGVtZW50KTtcbiAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgZWxlbWVudC5kaXNhYmxlZCA9IGRhdGEucmVhZE9ubHk7XG4gICAgdGhpcy5fc2V0UmVxdWlyZWQoZWxlbWVudCwgdGhpcy5kYXRhLnJlcXVpcmVkKTtcbiAgICBlbGVtZW50LnR5cGUgPSBcImNoZWNrYm94XCI7XG4gICAgZWxlbWVudC5uYW1lID0gZGF0YS5maWVsZE5hbWU7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBlbGVtZW50LnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKFwiZXhwb3J0VmFsdWVcIiwgZGF0YS5leHBvcnRWYWx1ZSk7XG4gICAgZWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGNoZWNrZWRcbiAgICAgIH0gPSBldmVudC50YXJnZXQ7XG4gICAgICBmb3IgKGNvbnN0IGNoZWNrYm94IG9mIHRoaXMuX2dldEVsZW1lbnRzQnlOYW1lKG5hbWUsIGlkKSkge1xuICAgICAgICBjb25zdCBjdXJDaGVja2VkID0gY2hlY2tlZCAmJiBjaGVja2JveC5leHBvcnRWYWx1ZSA9PT0gZGF0YS5leHBvcnRWYWx1ZTtcbiAgICAgICAgaWYgKGNoZWNrYm94LmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICBjaGVja2JveC5kb21FbGVtZW50LmNoZWNrZWQgPSBjdXJDaGVja2VkO1xuICAgICAgICB9XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoY2hlY2tib3guaWQsIHtcbiAgICAgICAgICB2YWx1ZTogY3VyQ2hlY2tlZFxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgdmFsdWU6IGNoZWNrZWRcbiAgICAgIH0pO1xuICAgIH0pO1xuICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInJlc2V0Zm9ybVwiLCBldmVudCA9PiB7XG4gICAgICBjb25zdCBkZWZhdWx0VmFsdWUgPSBkYXRhLmRlZmF1bHRGaWVsZFZhbHVlIHx8IFwiT2ZmXCI7XG4gICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGRlZmF1bHRWYWx1ZSA9PT0gZGF0YS5leHBvcnRWYWx1ZTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuY2hlY2tlZCA9IGV2ZW50LmRldGFpbC52YWx1ZSAhPT0gXCJPZmZcIjtcbiAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgICAgdmFsdWU6IGV2ZW50LnRhcmdldC5jaGVja2VkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgbnVsbCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfVxuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBSYWRpb0J1dHRvbldpZGdldEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiBwYXJhbWV0ZXJzLnJlbmRlckZvcm1zXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJidXR0b25XaWRnZXRBbm5vdGF0aW9uXCIsIFwicmFkaW9CdXR0b25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCBpZCA9IGRhdGEuaWQ7XG4gICAgbGV0IHZhbHVlID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IGRhdGEuZmllbGRWYWx1ZSA9PT0gZGF0YS5idXR0b25WYWx1ZVxuICAgIH0pLnZhbHVlO1xuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHZhbHVlID0gdmFsdWUgIT09IGRhdGEuYnV0dG9uVmFsdWU7XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlXG4gICAgICB9KTtcbiAgICB9XG4gICAgY29uc3QgZWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBHZXRFbGVtZW50c0J5TmFtZVNldC5hZGQoZWxlbWVudCk7XG4gICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJkYXRhLWVsZW1lbnQtaWRcIiwgaWQpO1xuICAgIGVsZW1lbnQuZGlzYWJsZWQgPSBkYXRhLnJlYWRPbmx5O1xuICAgIHRoaXMuX3NldFJlcXVpcmVkKGVsZW1lbnQsIHRoaXMuZGF0YS5yZXF1aXJlZCk7XG4gICAgZWxlbWVudC50eXBlID0gXCJyYWRpb1wiO1xuICAgIGVsZW1lbnQubmFtZSA9IGRhdGEuZmllbGROYW1lO1xuICAgIGlmICh2YWx1ZSkge1xuICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoXCJjaGVja2VkXCIsIHRydWUpO1xuICAgIH1cbiAgICBlbGVtZW50LnRhYkluZGV4ID0gREVGQVVMVF9UQUJfSU5ERVg7XG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2hhbmdlXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgY2hlY2tlZFxuICAgICAgfSA9IGV2ZW50LnRhcmdldDtcbiAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUobmFtZSwgaWQpKSB7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZmFsc2VcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgIHZhbHVlOiBjaGVja2VkXG4gICAgICB9KTtcbiAgICB9KTtcbiAgICBlbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNldGZvcm1cIiwgZXZlbnQgPT4ge1xuICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGV2ZW50LnRhcmdldC5jaGVja2VkID0gZGVmYXVsdFZhbHVlICE9PSBudWxsICYmIGRlZmF1bHRWYWx1ZSAhPT0gdW5kZWZpbmVkICYmIGRlZmF1bHRWYWx1ZSA9PT0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICB9KTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIGNvbnN0IHBkZkJ1dHRvblZhbHVlID0gZGF0YS5idXR0b25WYWx1ZTtcbiAgICAgIGVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlOiBldmVudCA9PiB7XG4gICAgICAgICAgICBjb25zdCBjaGVja2VkID0gcGRmQnV0dG9uVmFsdWUgPT09IGV2ZW50LmRldGFpbC52YWx1ZTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgcmFkaW8gb2YgdGhpcy5fZ2V0RWxlbWVudHNCeU5hbWUoZXZlbnQudGFyZ2V0Lm5hbWUpKSB7XG4gICAgICAgICAgICAgIGNvbnN0IGN1ckNoZWNrZWQgPSBjaGVja2VkICYmIHJhZGlvLmlkID09PSBpZDtcbiAgICAgICAgICAgICAgaWYgKHJhZGlvLmRvbUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICByYWRpby5kb21FbGVtZW50LmNoZWNrZWQgPSBjdXJDaGVja2VkO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUocmFkaW8uaWQsIHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogY3VyQ2hlY2tlZFxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveChhY3Rpb25zLCBqc0V2ZW50KTtcbiAgICAgIH0pO1xuICAgICAgdGhpcy5fc2V0RXZlbnRMaXN0ZW5lcnMoZWxlbWVudCwgbnVsbCwgW1tcImNoYW5nZVwiLCBcIlZhbGlkYXRlXCJdLCBbXCJjaGFuZ2VcIiwgXCJBY3Rpb25cIl0sIFtcImZvY3VzXCIsIFwiRm9jdXNcIl0sIFtcImJsdXJcIiwgXCJCbHVyXCJdLCBbXCJtb3VzZWRvd25cIiwgXCJNb3VzZSBEb3duXCJdLCBbXCJtb3VzZWVudGVyXCIsIFwiTW91c2UgRW50ZXJcIl0sIFtcIm1vdXNlbGVhdmVcIiwgXCJNb3VzZSBFeGl0XCJdLCBbXCJtb3VzZXVwXCIsIFwiTW91c2UgVXBcIl1dLCBldmVudCA9PiBldmVudC50YXJnZXQuY2hlY2tlZCk7XG4gICAgfVxuICAgIHRoaXMuX3NldEJhY2tncm91bmRDb2xvcihlbGVtZW50KTtcbiAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhlbGVtZW50KTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoZWxlbWVudCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQdXNoQnV0dG9uV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBMaW5rQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaWdub3JlQm9yZGVyOiBwYXJhbWV0ZXJzLmRhdGEuaGFzQXBwZWFyYW5jZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBjb25zdCBjb250YWluZXIgPSBzdXBlci5yZW5kZXIoKTtcbiAgICBjb250YWluZXIuY2xhc3NMaXN0LmFkZChcImJ1dHRvbldpZGdldEFubm90YXRpb25cIiwgXCJwdXNoQnV0dG9uXCIpO1xuICAgIGlmICh0aGlzLmRhdGEuYWx0ZXJuYXRpdmVUZXh0KSB7XG4gICAgICBjb250YWluZXIudGl0bGUgPSB0aGlzLmRhdGEuYWx0ZXJuYXRpdmVUZXh0O1xuICAgIH1cbiAgICBjb25zdCBsaW5rRWxlbWVudCA9IGNvbnRhaW5lci5sYXN0Q2hpbGQ7XG4gICAgaWYgKHRoaXMuZW5hYmxlU2NyaXB0aW5nICYmIHRoaXMuaGFzSlNBY3Rpb25zICYmIGxpbmtFbGVtZW50KSB7XG4gICAgICB0aGlzLl9zZXREZWZhdWx0UHJvcGVydGllc0Zyb21KUyhsaW5rRWxlbWVudCk7XG4gICAgICBsaW5rRWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwidXBkYXRlZnJvbXNhbmRib3hcIiwganNFdmVudCA9PiB7XG4gICAgICAgIHRoaXMuX2Rpc3BhdGNoRXZlbnRGcm9tU2FuZGJveCh7fSwganNFdmVudCk7XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgQ2hvaWNlV2lkZ2V0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBXaWRnZXRBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHBhcmFtZXRlcnMucmVuZGVyRm9ybXNcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNob2ljZVdpZGdldEFubm90YXRpb25cIik7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHRoaXMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgaWQgPSB0aGlzLmRhdGEuaWQ7XG4gICAgY29uc3Qgc3RvcmVkRGF0YSA9IHN0b3JhZ2UuZ2V0VmFsdWUoaWQsIHtcbiAgICAgIHZhbHVlOiB0aGlzLmRhdGEuZmllbGRWYWx1ZVxuICAgIH0pO1xuICAgIGNvbnN0IHNlbGVjdEVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic2VsZWN0XCIpO1xuICAgIEdldEVsZW1lbnRzQnlOYW1lU2V0LmFkZChzZWxlY3RFbGVtZW50KTtcbiAgICBzZWxlY3RFbGVtZW50LnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCBpZCk7XG4gICAgc2VsZWN0RWxlbWVudC5kaXNhYmxlZCA9IHRoaXMuZGF0YS5yZWFkT25seTtcbiAgICB0aGlzLl9zZXRSZXF1aXJlZChzZWxlY3RFbGVtZW50LCB0aGlzLmRhdGEucmVxdWlyZWQpO1xuICAgIHNlbGVjdEVsZW1lbnQubmFtZSA9IHRoaXMuZGF0YS5maWVsZE5hbWU7XG4gICAgc2VsZWN0RWxlbWVudC50YWJJbmRleCA9IERFRkFVTFRfVEFCX0lOREVYO1xuICAgIGxldCBhZGRBbkVtcHR5RW50cnkgPSB0aGlzLmRhdGEuY29tYm8gJiYgdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoID4gMDtcbiAgICBpZiAoIXRoaXMuZGF0YS5jb21ibykge1xuICAgICAgc2VsZWN0RWxlbWVudC5zaXplID0gdGhpcy5kYXRhLm9wdGlvbnMubGVuZ3RoO1xuICAgICAgaWYgKHRoaXMuZGF0YS5tdWx0aVNlbGVjdCkge1xuICAgICAgICBzZWxlY3RFbGVtZW50Lm11bHRpcGxlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZWN0RWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwicmVzZXRmb3JtXCIsIGV2ZW50ID0+IHtcbiAgICAgIGNvbnN0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuZGF0YS5kZWZhdWx0RmllbGRWYWx1ZTtcbiAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIHNlbGVjdEVsZW1lbnQub3B0aW9ucykge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBvcHRpb24udmFsdWUgPT09IGRlZmF1bHRWYWx1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiB0aGlzLmRhdGEub3B0aW9ucykge1xuICAgICAgY29uc3Qgb3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gb3B0aW9uLmRpc3BsYXlWYWx1ZTtcbiAgICAgIG9wdGlvbkVsZW1lbnQudmFsdWUgPSBvcHRpb24uZXhwb3J0VmFsdWU7XG4gICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZS5pbmNsdWRlcyhvcHRpb24uZXhwb3J0VmFsdWUpKSB7XG4gICAgICAgIG9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICAgIGFkZEFuRW1wdHlFbnRyeSA9IGZhbHNlO1xuICAgICAgfVxuICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgfVxuICAgIGxldCByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICBpZiAoYWRkQW5FbXB0eUVudHJ5KSB7XG4gICAgICBjb25zdCBub25lT3B0aW9uRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJvcHRpb25cIik7XG4gICAgICBub25lT3B0aW9uRWxlbWVudC52YWx1ZSA9IFwiIFwiO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwiaGlkZGVuXCIsIHRydWUpO1xuICAgICAgbm9uZU9wdGlvbkVsZW1lbnQuc2V0QXR0cmlidXRlKFwic2VsZWN0ZWRcIiwgdHJ1ZSk7XG4gICAgICBzZWxlY3RFbGVtZW50LnByZXBlbmQobm9uZU9wdGlvbkVsZW1lbnQpO1xuICAgICAgcmVtb3ZlRW1wdHlFbnRyeSA9ICgpID0+IHtcbiAgICAgICAgbm9uZU9wdGlvbkVsZW1lbnQucmVtb3ZlKCk7XG4gICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIHJlbW92ZUVtcHR5RW50cnkpO1xuICAgICAgICByZW1vdmVFbXB0eUVudHJ5ID0gbnVsbDtcbiAgICAgIH07XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCByZW1vdmVFbXB0eUVudHJ5KTtcbiAgICB9XG4gICAgY29uc3QgZ2V0VmFsdWUgPSBpc0V4cG9ydCA9PiB7XG4gICAgICBjb25zdCBuYW1lID0gaXNFeHBvcnQgPyBcInZhbHVlXCIgOiBcInRleHRDb250ZW50XCI7XG4gICAgICBjb25zdCB7XG4gICAgICAgIG9wdGlvbnMsXG4gICAgICAgIG11bHRpcGxlXG4gICAgICB9ID0gc2VsZWN0RWxlbWVudDtcbiAgICAgIGlmICghbXVsdGlwbGUpIHtcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMuc2VsZWN0ZWRJbmRleCA9PT0gLTEgPyBudWxsIDogb3B0aW9uc1tvcHRpb25zLnNlbGVjdGVkSW5kZXhdW25hbWVdO1xuICAgICAgfVxuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5maWx0ZXIuY2FsbChvcHRpb25zLCBvcHRpb24gPT4gb3B0aW9uLnNlbGVjdGVkKS5tYXAob3B0aW9uID0+IG9wdGlvbltuYW1lXSk7XG4gICAgfTtcbiAgICBsZXQgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgY29uc3QgZ2V0SXRlbXMgPSBldmVudCA9PiB7XG4gICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICByZXR1cm4gQXJyYXkucHJvdG90eXBlLm1hcC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgZGlzcGxheVZhbHVlOiBvcHRpb24udGV4dENvbnRlbnQsXG4gICAgICAgICAgZXhwb3J0VmFsdWU6IG9wdGlvbi52YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSk7XG4gICAgfTtcbiAgICBpZiAodGhpcy5lbmFibGVTY3JpcHRpbmcgJiYgdGhpcy5oYXNKU0FjdGlvbnMpIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInVwZGF0ZWZyb21zYW5kYm94XCIsIGpzRXZlbnQgPT4ge1xuICAgICAgICBjb25zdCBhY3Rpb25zID0ge1xuICAgICAgICAgIHZhbHVlKGV2ZW50KSB7XG4gICAgICAgICAgICByZW1vdmVFbXB0eUVudHJ5Py4oKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gZXZlbnQuZGV0YWlsLnZhbHVlO1xuICAgICAgICAgICAgY29uc3QgdmFsdWVzID0gbmV3IFNldChBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlIDogW3ZhbHVlXSk7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IG9wdGlvbiBvZiBzZWxlY3RFbGVtZW50Lm9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgb3B0aW9uLnNlbGVjdGVkID0gdmFsdWVzLmhhcyhvcHRpb24udmFsdWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSlcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBtdWx0aXBsZVNlbGVjdGlvbihldmVudCkge1xuICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5tdWx0aXBsZSA9IHRydWU7XG4gICAgICAgICAgfSxcbiAgICAgICAgICByZW1vdmUoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSBzZWxlY3RFbGVtZW50Lm9wdGlvbnM7XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGV2ZW50LmRldGFpbC5yZW1vdmU7XG4gICAgICAgICAgICBvcHRpb25zW2luZGV4XS5zZWxlY3RlZCA9IGZhbHNlO1xuICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5yZW1vdmUoaW5kZXgpO1xuICAgICAgICAgICAgaWYgKG9wdGlvbnMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICBjb25zdCBpID0gQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleC5jYWxsKG9wdGlvbnMsIG9wdGlvbiA9PiBvcHRpb24uc2VsZWN0ZWQpO1xuICAgICAgICAgICAgICBpZiAoaSA9PT0gLTEpIHtcbiAgICAgICAgICAgICAgICBvcHRpb25zWzBdLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogZ2V0VmFsdWUodHJ1ZSksXG4gICAgICAgICAgICAgIGl0ZW1zOiBnZXRJdGVtcyhldmVudClcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgc2VsZWN0ZWRWYWx1ZXMgPSBnZXRWYWx1ZShmYWxzZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBjbGVhcihldmVudCkge1xuICAgICAgICAgICAgd2hpbGUgKHNlbGVjdEVsZW1lbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3RvcmFnZS5zZXRWYWx1ZShpZCwge1xuICAgICAgICAgICAgICB2YWx1ZTogbnVsbCxcbiAgICAgICAgICAgICAgaXRlbXM6IFtdXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHNlbGVjdGVkVmFsdWVzID0gZ2V0VmFsdWUoZmFsc2UpO1xuICAgICAgICAgIH0sXG4gICAgICAgICAgaW5zZXJ0KGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICBkaXNwbGF5VmFsdWUsXG4gICAgICAgICAgICAgIGV4cG9ydFZhbHVlXG4gICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsLmluc2VydDtcbiAgICAgICAgICAgIGNvbnN0IHNlbGVjdENoaWxkID0gc2VsZWN0RWxlbWVudC5jaGlsZHJlbltpbmRleF07XG4gICAgICAgICAgICBjb25zdCBvcHRpb25FbGVtZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcIm9wdGlvblwiKTtcbiAgICAgICAgICAgIG9wdGlvbkVsZW1lbnQudGV4dENvbnRlbnQgPSBkaXNwbGF5VmFsdWU7XG4gICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gZXhwb3J0VmFsdWU7XG4gICAgICAgICAgICBpZiAoc2VsZWN0Q2hpbGQpIHtcbiAgICAgICAgICAgICAgc2VsZWN0Q2hpbGQuYmVmb3JlKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgc2VsZWN0RWxlbWVudC5hcHBlbmQob3B0aW9uRWxlbWVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGl0ZW1zKGV2ZW50KSB7XG4gICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgIGl0ZW1zXG4gICAgICAgICAgICB9ID0gZXZlbnQuZGV0YWlsO1xuICAgICAgICAgICAgd2hpbGUgKHNlbGVjdEVsZW1lbnQubGVuZ3RoICE9PSAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQucmVtb3ZlKDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZm9yIChjb25zdCBpdGVtIG9mIGl0ZW1zKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgICAgICBkaXNwbGF5VmFsdWUsXG4gICAgICAgICAgICAgICAgZXhwb3J0VmFsdWVcbiAgICAgICAgICAgICAgfSA9IGl0ZW07XG4gICAgICAgICAgICAgIGNvbnN0IG9wdGlvbkVsZW1lbnQgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwib3B0aW9uXCIpO1xuICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnRleHRDb250ZW50ID0gZGlzcGxheVZhbHVlO1xuICAgICAgICAgICAgICBvcHRpb25FbGVtZW50LnZhbHVlID0gZXhwb3J0VmFsdWU7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQuYXBwZW5kKG9wdGlvbkVsZW1lbnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNlbGVjdEVsZW1lbnQub3B0aW9ucy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgIHNlbGVjdEVsZW1lbnQub3B0aW9uc1swXS5zZWxlY3RlZCA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKSxcbiAgICAgICAgICAgICAgaXRlbXM6IGdldEl0ZW1zKGV2ZW50KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGluZGljZXMoZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGluZGljZXMgPSBuZXcgU2V0KGV2ZW50LmRldGFpbC5pbmRpY2VzKTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qgb3B0aW9uIG9mIGV2ZW50LnRhcmdldC5vcHRpb25zKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5zZWxlY3RlZCA9IGluZGljZXMuaGFzKG9wdGlvbi5pbmRleCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBnZXRWYWx1ZSh0cnVlKVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzZWxlY3RlZFZhbHVlcyA9IGdldFZhbHVlKGZhbHNlKTtcbiAgICAgICAgICB9LFxuICAgICAgICAgIGVkaXRhYmxlKGV2ZW50KSB7XG4gICAgICAgICAgICBldmVudC50YXJnZXQuZGlzYWJsZWQgPSAhZXZlbnQuZGV0YWlsLmVkaXRhYmxlO1xuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fZGlzcGF0Y2hFdmVudEZyb21TYW5kYm94KGFjdGlvbnMsIGpzRXZlbnQpO1xuICAgICAgfSk7XG4gICAgICBzZWxlY3RFbGVtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgIGNvbnN0IGV4cG9ydFZhbHVlID0gZ2V0VmFsdWUodHJ1ZSk7XG4gICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICB2YWx1ZTogZXhwb3J0VmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGV2ZW50LnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZGlzcGF0Y2hldmVudGluc2FuZGJveFwiLCB7XG4gICAgICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgICAgIGRldGFpbDoge1xuICAgICAgICAgICAgaWQsXG4gICAgICAgICAgICBuYW1lOiBcIktleXN0cm9rZVwiLFxuICAgICAgICAgICAgdmFsdWU6IHNlbGVjdGVkVmFsdWVzLFxuICAgICAgICAgICAgY2hhbmdlRXg6IGV4cG9ydFZhbHVlLFxuICAgICAgICAgICAgd2lsbENvbW1pdDogZmFsc2UsXG4gICAgICAgICAgICBjb21taXRLZXk6IDEsXG4gICAgICAgICAgICBrZXlEb3duOiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICAgIHRoaXMuX3NldEV2ZW50TGlzdGVuZXJzKHNlbGVjdEVsZW1lbnQsIG51bGwsIFtbXCJmb2N1c1wiLCBcIkZvY3VzXCJdLCBbXCJibHVyXCIsIFwiQmx1clwiXSwgW1wibW91c2Vkb3duXCIsIFwiTW91c2UgRG93blwiXSwgW1wibW91c2VlbnRlclwiLCBcIk1vdXNlIEVudGVyXCJdLCBbXCJtb3VzZWxlYXZlXCIsIFwiTW91c2UgRXhpdFwiXSwgW1wibW91c2V1cFwiLCBcIk1vdXNlIFVwXCJdLCBbXCJpbnB1dFwiLCBcIkFjdGlvblwiXSwgW1wiaW5wdXRcIiwgXCJWYWxpZGF0ZVwiXV0sIGV2ZW50ID0+IGV2ZW50LnRhcmdldC52YWx1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNlbGVjdEVsZW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGZ1bmN0aW9uIChldmVudCkge1xuICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgdmFsdWU6IGdldFZhbHVlKHRydWUpXG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuICAgIGlmICh0aGlzLmRhdGEuY29tYm8pIHtcbiAgICAgIHRoaXMuX3NldFRleHRTdHlsZShzZWxlY3RFbGVtZW50KTtcbiAgICB9IGVsc2Uge31cbiAgICB0aGlzLl9zZXRCYWNrZ3JvdW5kQ29sb3Ioc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5fc2V0RGVmYXVsdFByb3BlcnRpZXNGcm9tSlMoc2VsZWN0RWxlbWVudCk7XG4gICAgdGhpcy5jb250YWluZXIuYXBwZW5kKHNlbGVjdEVsZW1lbnQpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgUG9wdXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIGNvbnN0IHtcbiAgICAgIGRhdGEsXG4gICAgICBlbGVtZW50c1xuICAgIH0gPSBwYXJhbWV0ZXJzO1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogQW5ub3RhdGlvbkVsZW1lbnQuX2hhc1BvcHVwRGF0YShkYXRhKVxuICAgIH0pO1xuICAgIHRoaXMuZWxlbWVudHMgPSBlbGVtZW50cztcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInBvcHVwQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBwb3B1cCA9IG5ldyBQb3B1cEVsZW1lbnQoe1xuICAgICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgIGNvbG9yOiB0aGlzLmRhdGEuY29sb3IsXG4gICAgICB0aXRsZU9iajogdGhpcy5kYXRhLnRpdGxlT2JqLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZTogdGhpcy5kYXRhLm1vZGlmaWNhdGlvbkRhdGUsXG4gICAgICBjb250ZW50c09iajogdGhpcy5kYXRhLmNvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQ6IHRoaXMuZGF0YS5yaWNoVGV4dCxcbiAgICAgIHJlY3Q6IHRoaXMuZGF0YS5yZWN0LFxuICAgICAgcGFyZW50UmVjdDogdGhpcy5kYXRhLnBhcmVudFJlY3QgfHwgbnVsbCxcbiAgICAgIHBhcmVudDogdGhpcy5wYXJlbnQsXG4gICAgICBlbGVtZW50czogdGhpcy5lbGVtZW50cyxcbiAgICAgIG9wZW46IHRoaXMuZGF0YS5vcGVuXG4gICAgfSk7XG4gICAgY29uc3QgZWxlbWVudElkcyA9IFtdO1xuICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiB0aGlzLmVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LnBvcHVwID0gcG9wdXA7XG4gICAgICBlbGVtZW50SWRzLnB1c2goZWxlbWVudC5kYXRhLmlkKTtcbiAgICAgIGVsZW1lbnQuYWRkSGlnaGxpZ2h0QXJlYSgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5zZXRBdHRyaWJ1dGUoXCJhcmlhLWNvbnRyb2xzXCIsIGVsZW1lbnRJZHMubWFwKGlkID0+IGAke191dGlsLkFubm90YXRpb25QcmVmaXh9JHtpZH1gKS5qb2luKFwiLFwiKSk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBQb3B1cEVsZW1lbnQge1xuICAjZGF0ZVRpbWVQcm9taXNlID0gbnVsbDtcbiAgI2JvdW5kS2V5RG93biA9IHRoaXMuI2tleURvd24uYmluZCh0aGlzKTtcbiAgI2JvdW5kSGlkZSA9IHRoaXMuI2hpZGUuYmluZCh0aGlzKTtcbiAgI2JvdW5kU2hvdyA9IHRoaXMuI3Nob3cuYmluZCh0aGlzKTtcbiAgI2JvdW5kVG9nZ2xlID0gdGhpcy4jdG9nZ2xlLmJpbmQodGhpcyk7XG4gICNjb2xvciA9IG51bGw7XG4gICNjb250YWluZXIgPSBudWxsO1xuICAjY29udGVudHNPYmogPSBudWxsO1xuICAjZWxlbWVudHMgPSBudWxsO1xuICAjcGFyZW50ID0gbnVsbDtcbiAgI3BhcmVudFJlY3QgPSBudWxsO1xuICAjcGlubmVkID0gZmFsc2U7XG4gICNwb3B1cCA9IG51bGw7XG4gICNyZWN0ID0gbnVsbDtcbiAgI3JpY2hUZXh0ID0gbnVsbDtcbiAgI3RpdGxlT2JqID0gbnVsbDtcbiAgI3dhc1Zpc2libGUgPSBmYWxzZTtcbiAgY29uc3RydWN0b3IoX3JlZjIpIHtcbiAgICBsZXQge1xuICAgICAgY29udGFpbmVyLFxuICAgICAgY29sb3IsXG4gICAgICBlbGVtZW50cyxcbiAgICAgIHRpdGxlT2JqLFxuICAgICAgbW9kaWZpY2F0aW9uRGF0ZSxcbiAgICAgIGNvbnRlbnRzT2JqLFxuICAgICAgcmljaFRleHQsXG4gICAgICBwYXJlbnQsXG4gICAgICByZWN0LFxuICAgICAgcGFyZW50UmVjdCxcbiAgICAgIG9wZW5cbiAgICB9ID0gX3JlZjI7XG4gICAgdGhpcy4jY29udGFpbmVyID0gY29udGFpbmVyO1xuICAgIHRoaXMuI3RpdGxlT2JqID0gdGl0bGVPYmo7XG4gICAgdGhpcy4jY29udGVudHNPYmogPSBjb250ZW50c09iajtcbiAgICB0aGlzLiNyaWNoVGV4dCA9IHJpY2hUZXh0O1xuICAgIHRoaXMuI3BhcmVudCA9IHBhcmVudDtcbiAgICB0aGlzLiNjb2xvciA9IGNvbG9yO1xuICAgIHRoaXMuI3JlY3QgPSByZWN0O1xuICAgIHRoaXMuI3BhcmVudFJlY3QgPSBwYXJlbnRSZWN0O1xuICAgIHRoaXMuI2VsZW1lbnRzID0gZWxlbWVudHM7XG4gICAgY29uc3QgZGF0ZU9iamVjdCA9IF9kaXNwbGF5X3V0aWxzLlBERkRhdGVTdHJpbmcudG9EYXRlT2JqZWN0KG1vZGlmaWNhdGlvbkRhdGUpO1xuICAgIGlmIChkYXRlT2JqZWN0KSB7XG4gICAgICB0aGlzLiNkYXRlVGltZVByb21pc2UgPSBwYXJlbnQubDEwbi5nZXQoXCJhbm5vdGF0aW9uX2RhdGVfc3RyaW5nXCIsIHtcbiAgICAgICAgZGF0ZTogZGF0ZU9iamVjdC50b0xvY2FsZURhdGVTdHJpbmcoKSxcbiAgICAgICAgdGltZTogZGF0ZU9iamVjdC50b0xvY2FsZVRpbWVTdHJpbmcoKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHRoaXMudHJpZ2dlciA9IGVsZW1lbnRzLmZsYXRNYXAoZSA9PiBlLmdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSk7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMudHJpZ2dlcikge1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VlbnRlclwiLCB0aGlzLiNib3VuZFNob3cpO1xuICAgICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKFwibW91c2VsZWF2ZVwiLCB0aGlzLiNib3VuZEhpZGUpO1xuICAgICAgZWxlbWVudC5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIGVsZW1lbnRzKSB7XG4gICAgICBlbGVtZW50LmNvbnRhaW5lcj8uYWRkRXZlbnRMaXN0ZW5lcihcImtleWRvd25cIiwgdGhpcy4jYm91bmRLZXlEb3duKTtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gICAgaWYgKG9wZW4pIHtcbiAgICAgIHRoaXMuI3RvZ2dsZSgpO1xuICAgIH1cbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuI3BvcHVwKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHBhZ2U6IHtcbiAgICAgICAgdmlld1xuICAgICAgfSxcbiAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgIHJhd0RpbXM6IHtcbiAgICAgICAgICBwYWdlV2lkdGgsXG4gICAgICAgICAgcGFnZUhlaWdodCxcbiAgICAgICAgICBwYWdlWCxcbiAgICAgICAgICBwYWdlWVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSA9IHRoaXMuI3BhcmVudDtcbiAgICBjb25zdCBwb3B1cCA9IHRoaXMuI3BvcHVwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICBwb3B1cC5jbGFzc05hbWUgPSBcInBvcHVwXCI7XG4gICAgaWYgKHRoaXMuI2NvbG9yKSB7XG4gICAgICBjb25zdCBiYXNlQ29sb3IgPSBwb3B1cC5zdHlsZS5vdXRsaW5lQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi50aGlzLiNjb2xvcik7XG4gICAgICBpZiAoQ1NTLnN1cHBvcnRzKFwiYmFja2dyb3VuZC1jb2xvclwiLCBcImNvbG9yLW1peChpbiBzcmdiLCByZWQgMzAlLCB3aGl0ZSlcIikpIHtcbiAgICAgICAgcG9wdXAuc3R5bGUuYmFja2dyb3VuZENvbG9yID0gYGNvbG9yLW1peChpbiBzcmdiLCAke2Jhc2VDb2xvcn0gMzAlLCB3aGl0ZSlgO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgQkFDS0dST1VORF9FTkxJR0hUID0gMC43O1xuICAgICAgICBwb3B1cC5zdHlsZS5iYWNrZ3JvdW5kQ29sb3IgPSBfdXRpbC5VdGlsLm1ha2VIZXhDb2xvciguLi50aGlzLiNjb2xvci5tYXAoYyA9PiBNYXRoLmZsb29yKEJBQ0tHUk9VTkRfRU5MSUdIVCAqICgyNTUgLSBjKSArIGMpKSk7XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IGhlYWRlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgIGhlYWRlci5jbGFzc05hbWUgPSBcImhlYWRlclwiO1xuICAgIGNvbnN0IHRpdGxlID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImgxXCIpO1xuICAgIGhlYWRlci5hcHBlbmQodGl0bGUpO1xuICAgICh7XG4gICAgICBkaXI6IHRpdGxlLmRpcixcbiAgICAgIHN0cjogdGl0bGUudGV4dENvbnRlbnRcbiAgICB9ID0gdGhpcy4jdGl0bGVPYmopO1xuICAgIHBvcHVwLmFwcGVuZChoZWFkZXIpO1xuICAgIGlmICh0aGlzLiNkYXRlVGltZVByb21pc2UpIHtcbiAgICAgIGNvbnN0IG1vZGlmaWNhdGlvbkRhdGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3BhblwiKTtcbiAgICAgIG1vZGlmaWNhdGlvbkRhdGUuY2xhc3NMaXN0LmFkZChcInBvcHVwRGF0ZVwiKTtcbiAgICAgIHRoaXMuI2RhdGVUaW1lUHJvbWlzZS50aGVuKGxvY2FsaXplZCA9PiB7XG4gICAgICAgIG1vZGlmaWNhdGlvbkRhdGUudGV4dENvbnRlbnQgPSBsb2NhbGl6ZWQ7XG4gICAgICB9KTtcbiAgICAgIGhlYWRlci5hcHBlbmQobW9kaWZpY2F0aW9uRGF0ZSk7XG4gICAgfVxuICAgIGNvbnN0IGNvbnRlbnRzT2JqID0gdGhpcy4jY29udGVudHNPYmo7XG4gICAgY29uc3QgcmljaFRleHQgPSB0aGlzLiNyaWNoVGV4dDtcbiAgICBpZiAocmljaFRleHQ/LnN0ciAmJiAoIWNvbnRlbnRzT2JqPy5zdHIgfHwgY29udGVudHNPYmouc3RyID09PSByaWNoVGV4dC5zdHIpKSB7XG4gICAgICBfeGZhX2xheWVyLlhmYUxheWVyLnJlbmRlcih7XG4gICAgICAgIHhmYUh0bWw6IHJpY2hUZXh0Lmh0bWwsXG4gICAgICAgIGludGVudDogXCJyaWNoVGV4dFwiLFxuICAgICAgICBkaXY6IHBvcHVwXG4gICAgICB9KTtcbiAgICAgIHBvcHVwLmxhc3RDaGlsZC5jbGFzc0xpc3QuYWRkKFwicmljaFRleHRcIiwgXCJwb3B1cENvbnRlbnRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNvbnN0IGNvbnRlbnRzID0gdGhpcy5fZm9ybWF0Q29udGVudHMoY29udGVudHNPYmopO1xuICAgICAgcG9wdXAuYXBwZW5kKGNvbnRlbnRzKTtcbiAgICB9XG4gICAgbGV0IHVzZVBhcmVudFJlY3QgPSAhIXRoaXMuI3BhcmVudFJlY3Q7XG4gICAgbGV0IHJlY3QgPSB1c2VQYXJlbnRSZWN0ID8gdGhpcy4jcGFyZW50UmVjdCA6IHRoaXMuI3JlY3Q7XG4gICAgZm9yIChjb25zdCBlbGVtZW50IG9mIHRoaXMuI2VsZW1lbnRzKSB7XG4gICAgICBpZiAoIXJlY3QgfHwgX3V0aWwuVXRpbC5pbnRlcnNlY3QoZWxlbWVudC5kYXRhLnJlY3QsIHJlY3QpICE9PSBudWxsKSB7XG4gICAgICAgIHJlY3QgPSBlbGVtZW50LmRhdGEucmVjdDtcbiAgICAgICAgdXNlUGFyZW50UmVjdCA9IHRydWU7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBub3JtYWxpemVkUmVjdCA9IF91dGlsLlV0aWwubm9ybWFsaXplUmVjdChbcmVjdFswXSwgdmlld1szXSAtIHJlY3RbMV0gKyB2aWV3WzFdLCByZWN0WzJdLCB2aWV3WzNdIC0gcmVjdFszXSArIHZpZXdbMV1dKTtcbiAgICBjb25zdCBIT1JJWk9OVEFMX1NQQUNFX0FGVEVSX0FOTk9UQVRJT04gPSA1O1xuICAgIGNvbnN0IHBhcmVudFdpZHRoID0gdXNlUGFyZW50UmVjdCA/IHJlY3RbMl0gLSByZWN0WzBdICsgSE9SSVpPTlRBTF9TUEFDRV9BRlRFUl9BTk5PVEFUSU9OIDogMDtcbiAgICBjb25zdCBwb3B1cExlZnQgPSBub3JtYWxpemVkUmVjdFswXSArIHBhcmVudFdpZHRoO1xuICAgIGNvbnN0IHBvcHVwVG9wID0gbm9ybWFsaXplZFJlY3RbMV07XG4gICAgY29uc3Qge1xuICAgICAgc3R5bGVcbiAgICB9ID0gdGhpcy4jY29udGFpbmVyO1xuICAgIHN0eWxlLmxlZnQgPSBgJHsxMDAgKiAocG9wdXBMZWZ0IC0gcGFnZVgpIC8gcGFnZVdpZHRofSVgO1xuICAgIHN0eWxlLnRvcCA9IGAkezEwMCAqIChwb3B1cFRvcCAtIHBhZ2VZKSAvIHBhZ2VIZWlnaHR9JWA7XG4gICAgdGhpcy4jY29udGFpbmVyLmFwcGVuZChwb3B1cCk7XG4gIH1cbiAgX2Zvcm1hdENvbnRlbnRzKF9yZWYzKSB7XG4gICAgbGV0IHtcbiAgICAgIHN0cixcbiAgICAgIGRpclxuICAgIH0gPSBfcmVmMztcbiAgICBjb25zdCBwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcInBcIik7XG4gICAgcC5jbGFzc0xpc3QuYWRkKFwicG9wdXBDb250ZW50XCIpO1xuICAgIHAuZGlyID0gZGlyO1xuICAgIGNvbnN0IGxpbmVzID0gc3RyLnNwbGl0KC8oPzpcXHJcXG4/fFxcbikvKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBsaW5lcy5sZW5ndGg7IGkgPCBpaTsgKytpKSB7XG4gICAgICBjb25zdCBsaW5lID0gbGluZXNbaV07XG4gICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShsaW5lKSk7XG4gICAgICBpZiAoaSA8IGlpIC0gMSkge1xuICAgICAgICBwLmFwcGVuZChkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiYnJcIikpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcDtcbiAgfVxuICAja2V5RG93bihldmVudCkge1xuICAgIGlmIChldmVudC5hbHRLZXkgfHwgZXZlbnQuc2hpZnRLZXkgfHwgZXZlbnQuY3RybEtleSB8fCBldmVudC5tZXRhS2V5KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChldmVudC5rZXkgPT09IFwiRW50ZXJcIiB8fCBldmVudC5rZXkgPT09IFwiRXNjYXBlXCIgJiYgdGhpcy4jcGlubmVkKSB7XG4gICAgICB0aGlzLiN0b2dnbGUoKTtcbiAgICB9XG4gIH1cbiAgI3RvZ2dsZSgpIHtcbiAgICB0aGlzLiNwaW5uZWQgPSAhdGhpcy4jcGlubmVkO1xuICAgIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI3Nob3coKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2hpZGUoKTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5yZW1vdmVFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgdGhpcy4jYm91bmRUb2dnbGUpO1xuICAgICAgdGhpcy4jY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJrZXlkb3duXCIsIHRoaXMuI2JvdW5kS2V5RG93bik7XG4gICAgfVxuICB9XG4gICNzaG93KCkge1xuICAgIGlmICghdGhpcy4jcG9wdXApIHtcbiAgICAgIHRoaXMucmVuZGVyKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc1Zpc2libGUpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSBmYWxzZTtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSArIDEwMDA7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNwaW5uZWQpIHtcbiAgICAgIHRoaXMuI2NvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZm9jdXNlZFwiKTtcbiAgICB9XG4gIH1cbiAgI2hpZGUoKSB7XG4gICAgdGhpcy4jY29udGFpbmVyLmNsYXNzTGlzdC5yZW1vdmUoXCJmb2N1c2VkXCIpO1xuICAgIGlmICh0aGlzLiNwaW5uZWQgfHwgIXRoaXMuaXNWaXNpYmxlKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPSB0cnVlO1xuICAgIHRoaXMuI2NvbnRhaW5lci5zdHlsZS56SW5kZXggPSBwYXJzZUludCh0aGlzLiNjb250YWluZXIuc3R5bGUuekluZGV4KSAtIDEwMDA7XG4gIH1cbiAgZm9yY2VIaWRlKCkge1xuICAgIHRoaXMuI3dhc1Zpc2libGUgPSB0aGlzLmlzVmlzaWJsZTtcbiAgICBpZiAoIXRoaXMuI3dhc1Zpc2libGUpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IHRydWU7XG4gIH1cbiAgbWF5YmVTaG93KCkge1xuICAgIGlmICghdGhpcy4jd2FzVmlzaWJsZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICB0aGlzLiN3YXNWaXNpYmxlID0gZmFsc2U7XG4gICAgdGhpcy4jY29udGFpbmVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gIGdldCBpc1Zpc2libGUoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2NvbnRhaW5lci5oaWRkZW4gPT09IGZhbHNlO1xuICB9XG59XG5jbGFzcyBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy50ZXh0Q29udGVudCA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0Q29udGVudDtcbiAgICB0aGlzLnRleHRQb3NpdGlvbiA9IHBhcmFtZXRlcnMuZGF0YS50ZXh0UG9zaXRpb247XG4gICAgdGhpcy5hbm5vdGF0aW9uRWRpdG9yVHlwZSA9IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLkZSRUVURVhUO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZnJlZVRleHRBbm5vdGF0aW9uXCIpO1xuICAgIGlmICh0aGlzLnRleHRDb250ZW50KSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICAgIGNvbnRlbnQuY2xhc3NMaXN0LmFkZChcImFubm90YXRpb25UZXh0Q29udGVudFwiKTtcbiAgICAgIGNvbnRlbnQuc2V0QXR0cmlidXRlKFwicm9sZVwiLCBcImNvbW1lbnRcIik7XG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgdGhpcy50ZXh0Q29udGVudCkge1xuICAgICAgICBjb25zdCBsaW5lU3BhbiA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzcGFuXCIpO1xuICAgICAgICBsaW5lU3Bhbi50ZXh0Q29udGVudCA9IGxpbmU7XG4gICAgICAgIGNvbnRlbnQuYXBwZW5kKGxpbmVTcGFuKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChjb250ZW50KTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuX2VkaXRPbkRvdWJsZUNsaWNrKCk7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5leHBvcnRzLkZyZWVUZXh0QW5ub3RhdGlvbkVsZW1lbnQgPSBGcmVlVGV4dEFubm90YXRpb25FbGVtZW50O1xuY2xhc3MgTGluZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjbGluZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImxpbmVBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHRcbiAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICBjb25zdCBzdmcgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlKHdpZHRoLCBoZWlnaHQsIHRydWUpO1xuICAgIGNvbnN0IGxpbmUgPSB0aGlzLiNsaW5lID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6bGluZVwiKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngxXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzBdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkxXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzFdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcIngyXCIsIGRhdGEucmVjdFsyXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzJdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInkyXCIsIGRhdGEucmVjdFszXSAtIGRhdGEubGluZUNvb3JkaW5hdGVzWzNdKTtcbiAgICBsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIGxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgbGluZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNsaW5lO1xuICB9XG4gIGFkZEhpZ2hsaWdodEFyZWEoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFyZWFcIik7XG4gIH1cbn1cbmNsYXNzIFNxdWFyZUFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjc3F1YXJlID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3F1YXJlQW5ub3RhdGlvblwiKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBjb25zdCBib3JkZXJXaWR0aCA9IGRhdGEuYm9yZGVyU3R5bGUud2lkdGg7XG4gICAgY29uc3Qgc3F1YXJlID0gdGhpcy4jc3F1YXJlID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZUVsZW1lbnQoXCJzdmc6cmVjdFwiKTtcbiAgICBzcXVhcmUuc2V0QXR0cmlidXRlKFwieFwiLCBib3JkZXJXaWR0aCAvIDIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJ5XCIsIGJvcmRlcldpZHRoIC8gMik7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcIndpZHRoXCIsIHdpZHRoIC0gYm9yZGVyV2lkdGgpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJoZWlnaHRcIiwgaGVpZ2h0IC0gYm9yZGVyV2lkdGgpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2Utd2lkdGhcIiwgYm9yZGVyV2lkdGggfHwgMSk7XG4gICAgc3F1YXJlLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHNxdWFyZS5zZXRBdHRyaWJ1dGUoXCJmaWxsXCIsIFwidHJhbnNwYXJlbnRcIik7XG4gICAgc3ZnLmFwcGVuZChzcXVhcmUpO1xuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3NxdWFyZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBDaXJjbGVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI2NpcmNsZSA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNpcmNsZUFubm90YXRpb25cIik7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgY29uc3QgYm9yZGVyV2lkdGggPSBkYXRhLmJvcmRlclN0eWxlLndpZHRoO1xuICAgIGNvbnN0IGNpcmNsZSA9IHRoaXMuI2NpcmNsZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KFwic3ZnOmVsbGlwc2VcIik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN4XCIsIHdpZHRoIC8gMik7XG4gICAgY2lyY2xlLnNldEF0dHJpYnV0ZShcImN5XCIsIGhlaWdodCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeFwiLCB3aWR0aCAvIDIgLSBib3JkZXJXaWR0aCAvIDIpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJyeVwiLCBoZWlnaHQgLyAyIC0gYm9yZGVyV2lkdGggLyAyKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGJvcmRlcldpZHRoIHx8IDEpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKFwiZmlsbFwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHN2Zy5hcHBlbmQoY2lyY2xlKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNjaXJjbGU7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuY2xhc3MgUG9seWxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lID0gbnVsbDtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5bGluZUFubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZCh0aGlzLmNvbnRhaW5lckNsYXNzTmFtZSk7XG4gICAgY29uc3QgZGF0YSA9IHRoaXMuZGF0YTtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSBnZXRSZWN0RGltcyhkYXRhLnJlY3QpO1xuICAgIGNvbnN0IHN2ZyA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGUod2lkdGgsIGhlaWdodCwgdHJ1ZSk7XG4gICAgbGV0IHBvaW50cyA9IFtdO1xuICAgIGZvciAoY29uc3QgY29vcmRpbmF0ZSBvZiBkYXRhLnZlcnRpY2VzKSB7XG4gICAgICBjb25zdCB4ID0gY29vcmRpbmF0ZS54IC0gZGF0YS5yZWN0WzBdO1xuICAgICAgY29uc3QgeSA9IGRhdGEucmVjdFszXSAtIGNvb3JkaW5hdGUueTtcbiAgICAgIHBvaW50cy5wdXNoKHggKyBcIixcIiArIHkpO1xuICAgIH1cbiAgICBwb2ludHMgPSBwb2ludHMuam9pbihcIiBcIik7XG4gICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLiNwb2x5bGluZSA9IHRoaXMuc3ZnRmFjdG9yeS5jcmVhdGVFbGVtZW50KHRoaXMuc3ZnRWxlbWVudE5hbWUpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZS13aWR0aFwiLCBkYXRhLmJvcmRlclN0eWxlLndpZHRoIHx8IDEpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInN0cm9rZVwiLCBcInRyYW5zcGFyZW50XCIpO1xuICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICBzdmcuYXBwZW5kKHBvbHlsaW5lKTtcbiAgICB0aGlzLmNvbnRhaW5lci5hcHBlbmQoc3ZnKTtcbiAgICBpZiAoIWRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZTtcbiAgfVxuICBhZGRIaWdobGlnaHRBcmVhKCkge1xuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJoaWdobGlnaHRBcmVhXCIpO1xuICB9XG59XG5jbGFzcyBQb2x5Z29uQW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBQb2x5bGluZUFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMpO1xuICAgIHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lID0gXCJwb2x5Z29uQW5ub3RhdGlvblwiO1xuICAgIHRoaXMuc3ZnRWxlbWVudE5hbWUgPSBcInN2Zzpwb2x5Z29uXCI7XG4gIH1cbn1cbmNsYXNzIENhcmV0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImNhcmV0QW5ub3RhdGlvblwiKTtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBJbmtBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgI3BvbHlsaW5lcyA9IFtdO1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlXG4gICAgfSk7XG4gICAgdGhpcy5jb250YWluZXJDbGFzc05hbWUgPSBcImlua0Fubm90YXRpb25cIjtcbiAgICB0aGlzLnN2Z0VsZW1lbnROYW1lID0gXCJzdmc6cG9seWxpbmVcIjtcbiAgICB0aGlzLmFubm90YXRpb25FZGl0b3JUeXBlID0gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKHRoaXMuY29udGFpbmVyQ2xhc3NOYW1lKTtcbiAgICBjb25zdCBkYXRhID0gdGhpcy5kYXRhO1xuICAgIGNvbnN0IHtcbiAgICAgIHdpZHRoLFxuICAgICAgaGVpZ2h0XG4gICAgfSA9IGdldFJlY3REaW1zKGRhdGEucmVjdCk7XG4gICAgY29uc3Qgc3ZnID0gdGhpcy5zdmdGYWN0b3J5LmNyZWF0ZSh3aWR0aCwgaGVpZ2h0LCB0cnVlKTtcbiAgICBmb3IgKGNvbnN0IGlua0xpc3Qgb2YgZGF0YS5pbmtMaXN0cykge1xuICAgICAgbGV0IHBvaW50cyA9IFtdO1xuICAgICAgZm9yIChjb25zdCBjb29yZGluYXRlIG9mIGlua0xpc3QpIHtcbiAgICAgICAgY29uc3QgeCA9IGNvb3JkaW5hdGUueCAtIGRhdGEucmVjdFswXTtcbiAgICAgICAgY29uc3QgeSA9IGRhdGEucmVjdFszXSAtIGNvb3JkaW5hdGUueTtcbiAgICAgICAgcG9pbnRzLnB1c2goYCR7eH0sJHt5fWApO1xuICAgICAgfVxuICAgICAgcG9pbnRzID0gcG9pbnRzLmpvaW4oXCIgXCIpO1xuICAgICAgY29uc3QgcG9seWxpbmUgPSB0aGlzLnN2Z0ZhY3RvcnkuY3JlYXRlRWxlbWVudCh0aGlzLnN2Z0VsZW1lbnROYW1lKTtcbiAgICAgIHRoaXMuI3BvbHlsaW5lcy5wdXNoKHBvbHlsaW5lKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcInBvaW50c1wiLCBwb2ludHMpO1xuICAgICAgcG9seWxpbmUuc2V0QXR0cmlidXRlKFwic3Ryb2tlLXdpZHRoXCIsIGRhdGEuYm9yZGVyU3R5bGUud2lkdGggfHwgMSk7XG4gICAgICBwb2x5bGluZS5zZXRBdHRyaWJ1dGUoXCJzdHJva2VcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIHBvbHlsaW5lLnNldEF0dHJpYnV0ZShcImZpbGxcIiwgXCJ0cmFuc3BhcmVudFwiKTtcbiAgICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgICAgfVxuICAgICAgc3ZnLmFwcGVuZChwb2x5bGluZSk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZChzdmcpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxuICBnZXRFbGVtZW50c1RvVHJpZ2dlclBvcHVwKCkge1xuICAgIHJldHVybiB0aGlzLiNwb2x5bGluZXM7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxufVxuZXhwb3J0cy5JbmtBbm5vdGF0aW9uRWxlbWVudCA9IElua0Fubm90YXRpb25FbGVtZW50O1xuY2xhc3MgSGlnaGxpZ2h0QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcImhpZ2hsaWdodEFubm90YXRpb25cIik7XG4gICAgcmV0dXJuIHRoaXMuY29udGFpbmVyO1xuICB9XG59XG5jbGFzcyBVbmRlcmxpbmVBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZSxcbiAgICAgIGNyZWF0ZVF1YWRyaWxhdGVyYWxzOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwidW5kZXJsaW5lQW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFNxdWlnZ2x5QW5ub3RhdGlvbkVsZW1lbnQgZXh0ZW5kcyBBbm5vdGF0aW9uRWxlbWVudCB7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWUsXG4gICAgICBpZ25vcmVCb3JkZXI6IHRydWUsXG4gICAgICBjcmVhdGVRdWFkcmlsYXRlcmFsczogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAoIXRoaXMuZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9XG4gICAgdGhpcy5jb250YWluZXIuY2xhc3NMaXN0LmFkZChcInNxdWlnZ2x5QW5ub3RhdGlvblwiKTtcbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmNsYXNzIFN0cmlrZU91dEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzKSB7XG4gICAgc3VwZXIocGFyYW1ldGVycywge1xuICAgICAgaXNSZW5kZXJhYmxlOiB0cnVlLFxuICAgICAgaWdub3JlQm9yZGVyOiB0cnVlLFxuICAgICAgY3JlYXRlUXVhZHJpbGF0ZXJhbHM6IHRydWVcbiAgICB9KTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKCF0aGlzLmRhdGEucG9wdXBSZWYgJiYgdGhpcy5oYXNQb3B1cERhdGEpIHtcbiAgICAgIHRoaXMuX2NyZWF0ZVBvcHVwKCk7XG4gICAgfVxuICAgIHRoaXMuY29udGFpbmVyLmNsYXNzTGlzdC5hZGQoXCJzdHJpa2VvdXRBbm5vdGF0aW9uXCIpO1xuICAgIHJldHVybiB0aGlzLmNvbnRhaW5lcjtcbiAgfVxufVxuY2xhc3MgU3RhbXBBbm5vdGF0aW9uRWxlbWVudCBleHRlbmRzIEFubm90YXRpb25FbGVtZW50IHtcbiAgY29uc3RydWN0b3IocGFyYW1ldGVycykge1xuICAgIHN1cGVyKHBhcmFtZXRlcnMsIHtcbiAgICAgIGlzUmVuZGVyYWJsZTogdHJ1ZSxcbiAgICAgIGlnbm9yZUJvcmRlcjogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwic3RhbXBBbm5vdGF0aW9uXCIpO1xuICAgIGlmICghdGhpcy5kYXRhLnBvcHVwUmVmICYmIHRoaXMuaGFzUG9wdXBEYXRhKSB7XG4gICAgICB0aGlzLl9jcmVhdGVQb3B1cCgpO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb250YWluZXI7XG4gIH1cbn1cbmV4cG9ydHMuU3RhbXBBbm5vdGF0aW9uRWxlbWVudCA9IFN0YW1wQW5ub3RhdGlvbkVsZW1lbnQ7XG5jbGFzcyBGaWxlQXR0YWNobWVudEFubm90YXRpb25FbGVtZW50IGV4dGVuZHMgQW5ub3RhdGlvbkVsZW1lbnQge1xuICAjdHJpZ2dlciA9IG51bGw7XG4gIGNvbnN0cnVjdG9yKHBhcmFtZXRlcnMpIHtcbiAgICBzdXBlcihwYXJhbWV0ZXJzLCB7XG4gICAgICBpc1JlbmRlcmFibGU6IHRydWVcbiAgICB9KTtcbiAgICBjb25zdCB7XG4gICAgICBmaWxlbmFtZSxcbiAgICAgIGNvbnRlbnRcbiAgICB9ID0gdGhpcy5kYXRhLmZpbGU7XG4gICAgdGhpcy5maWxlbmFtZSA9ICgwLCBfZGlzcGxheV91dGlscy5nZXRGaWxlbmFtZUZyb21VcmwpKGZpbGVuYW1lLCB0cnVlKTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICAgIHRoaXMubGlua1NlcnZpY2UuZXZlbnRCdXM/LmRpc3BhdGNoKFwiZmlsZWF0dGFjaG1lbnRhbm5vdGF0aW9uXCIsIHtcbiAgICAgIHNvdXJjZTogdGhpcyxcbiAgICAgIGZpbGVuYW1lLFxuICAgICAgY29udGVudFxuICAgIH0pO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiZmlsZUF0dGFjaG1lbnRBbm5vdGF0aW9uXCIpO1xuICAgIGNvbnN0IHtcbiAgICAgIGNvbnRhaW5lcixcbiAgICAgIGRhdGFcbiAgICB9ID0gdGhpcztcbiAgICBsZXQgdHJpZ2dlcjtcbiAgICBpZiAoZGF0YS5oYXNBcHBlYXJhbmNlIHx8IGRhdGEuZmlsbEFscGhhID09PSAwKSB7XG4gICAgICB0cmlnZ2VyID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImRpdlwiKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbWdcIik7XG4gICAgICB0cmlnZ2VyLnNyYyA9IGAke3RoaXMuaW1hZ2VSZXNvdXJjZXNQYXRofWFubm90YXRpb24tJHsvcGFwZXJjbGlwL2kudGVzdChkYXRhLm5hbWUpID8gXCJwYXBlcmNsaXBcIiA6IFwicHVzaHBpblwifS5zdmdgO1xuICAgICAgaWYgKGRhdGEuZmlsbEFscGhhICYmIGRhdGEuZmlsbEFscGhhIDwgMSkge1xuICAgICAgICB0cmlnZ2VyLnN0eWxlID0gYGZpbHRlcjogb3BhY2l0eSgke01hdGgucm91bmQoZGF0YS5maWxsQWxwaGEgKiAxMDApfSUpO2A7XG4gICAgICB9XG4gICAgfVxuICAgIHRyaWdnZXIuYWRkRXZlbnRMaXN0ZW5lcihcImRibGNsaWNrXCIsIHRoaXMuI2Rvd25sb2FkLmJpbmQodGhpcykpO1xuICAgIHRoaXMuI3RyaWdnZXIgPSB0cmlnZ2VyO1xuICAgIGNvbnN0IHtcbiAgICAgIGlzTWFjXG4gICAgfSA9IF91dGlsLkZlYXR1cmVUZXN0LnBsYXRmb3JtO1xuICAgIGNvbnRhaW5lci5hZGRFdmVudExpc3RlbmVyKFwia2V5ZG93blwiLCBldnQgPT4ge1xuICAgICAgaWYgKGV2dC5rZXkgPT09IFwiRW50ZXJcIiAmJiAoaXNNYWMgPyBldnQubWV0YUtleSA6IGV2dC5jdHJsS2V5KSkge1xuICAgICAgICB0aGlzLiNkb3dubG9hZCgpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIGlmICghZGF0YS5wb3B1cFJlZiAmJiB0aGlzLmhhc1BvcHVwRGF0YSkge1xuICAgICAgdGhpcy5fY3JlYXRlUG9wdXAoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdHJpZ2dlci5jbGFzc0xpc3QuYWRkKFwicG9wdXBUcmlnZ2VyQXJlYVwiKTtcbiAgICB9XG4gICAgY29udGFpbmVyLmFwcGVuZCh0cmlnZ2VyKTtcbiAgICByZXR1cm4gY29udGFpbmVyO1xuICB9XG4gIGdldEVsZW1lbnRzVG9UcmlnZ2VyUG9wdXAoKSB7XG4gICAgcmV0dXJuIHRoaXMuI3RyaWdnZXI7XG4gIH1cbiAgYWRkSGlnaGxpZ2h0QXJlYSgpIHtcbiAgICB0aGlzLmNvbnRhaW5lci5jbGFzc0xpc3QuYWRkKFwiaGlnaGxpZ2h0QXJlYVwiKTtcbiAgfVxuICAjZG93bmxvYWQoKSB7XG4gICAgdGhpcy5kb3dubG9hZE1hbmFnZXI/Lm9wZW5PckRvd25sb2FkRGF0YSh0aGlzLmNvbnRhaW5lciwgdGhpcy5jb250ZW50LCB0aGlzLmZpbGVuYW1lKTtcbiAgfVxufVxuY2xhc3MgQW5ub3RhdGlvbkxheWVyIHtcbiAgI2FjY2Vzc2liaWxpdHlNYW5hZ2VyID0gbnVsbDtcbiAgI2Fubm90YXRpb25DYW52YXNNYXAgPSBudWxsO1xuICAjZWRpdGFibGVBbm5vdGF0aW9ucyA9IG5ldyBNYXAoKTtcbiAgY29uc3RydWN0b3IoX3JlZjQpIHtcbiAgICBsZXQge1xuICAgICAgZGl2LFxuICAgICAgYWNjZXNzaWJpbGl0eU1hbmFnZXIsXG4gICAgICBhbm5vdGF0aW9uQ2FudmFzTWFwLFxuICAgICAgbDEwbixcbiAgICAgIHBhZ2UsXG4gICAgICB2aWV3cG9ydFxuICAgIH0gPSBfcmVmNDtcbiAgICB0aGlzLmRpdiA9IGRpdjtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlciA9IGFjY2Vzc2liaWxpdHlNYW5hZ2VyO1xuICAgIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXAgPSBhbm5vdGF0aW9uQ2FudmFzTWFwO1xuICAgIHRoaXMubDEwbiA9IGwxMG47XG4gICAgdGhpcy5wYWdlID0gcGFnZTtcbiAgICB0aGlzLnZpZXdwb3J0ID0gdmlld3BvcnQ7XG4gICAgdGhpcy56SW5kZXggPSAwO1xuICAgIHRoaXMubDEwbiB8fD0gX2Rpc3BsYXlMMTBuX3V0aWxzLk51bGxMMTBuO1xuICB9XG4gICNhcHBlbmRFbGVtZW50KGVsZW1lbnQsIGlkKSB7XG4gICAgY29uc3QgY29udGVudEVsZW1lbnQgPSBlbGVtZW50LmZpcnN0Q2hpbGQgfHwgZWxlbWVudDtcbiAgICBjb250ZW50RWxlbWVudC5pZCA9IGAke191dGlsLkFubm90YXRpb25QcmVmaXh9JHtpZH1gO1xuICAgIHRoaXMuZGl2LmFwcGVuZChlbGVtZW50KTtcbiAgICB0aGlzLiNhY2Nlc3NpYmlsaXR5TWFuYWdlcj8ubW92ZUVsZW1lbnRJbkRPTSh0aGlzLmRpdiwgZWxlbWVudCwgY29udGVudEVsZW1lbnQsIGZhbHNlKTtcbiAgfVxuICBhc3luYyByZW5kZXIocGFyYW1zKSB7XG4gICAgY29uc3Qge1xuICAgICAgYW5ub3RhdGlvbnNcbiAgICB9ID0gcGFyYW1zO1xuICAgIGNvbnN0IGxheWVyID0gdGhpcy5kaXY7XG4gICAgKDAsIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucykobGF5ZXIsIHRoaXMudmlld3BvcnQpO1xuICAgIGNvbnN0IHBvcHVwVG9FbGVtZW50cyA9IG5ldyBNYXAoKTtcbiAgICBjb25zdCBlbGVtZW50UGFyYW1zID0ge1xuICAgICAgZGF0YTogbnVsbCxcbiAgICAgIGxheWVyLFxuICAgICAgbGlua1NlcnZpY2U6IHBhcmFtcy5saW5rU2VydmljZSxcbiAgICAgIGRvd25sb2FkTWFuYWdlcjogcGFyYW1zLmRvd25sb2FkTWFuYWdlcixcbiAgICAgIGltYWdlUmVzb3VyY2VzUGF0aDogcGFyYW1zLmltYWdlUmVzb3VyY2VzUGF0aCB8fCBcIlwiLFxuICAgICAgcmVuZGVyRm9ybXM6IHBhcmFtcy5yZW5kZXJGb3JtcyAhPT0gZmFsc2UsXG4gICAgICBzdmdGYWN0b3J5OiBuZXcgX2Rpc3BsYXlfdXRpbHMuRE9NU1ZHRmFjdG9yeSgpLFxuICAgICAgYW5ub3RhdGlvblN0b3JhZ2U6IHBhcmFtcy5hbm5vdGF0aW9uU3RvcmFnZSB8fCBuZXcgX2Fubm90YXRpb25fc3RvcmFnZS5Bbm5vdGF0aW9uU3RvcmFnZSgpLFxuICAgICAgZW5hYmxlU2NyaXB0aW5nOiBwYXJhbXMuZW5hYmxlU2NyaXB0aW5nID09PSB0cnVlLFxuICAgICAgaGFzSlNBY3Rpb25zOiBwYXJhbXMuaGFzSlNBY3Rpb25zLFxuICAgICAgZmllbGRPYmplY3RzOiBwYXJhbXMuZmllbGRPYmplY3RzLFxuICAgICAgcGFyZW50OiB0aGlzLFxuICAgICAgZWxlbWVudHM6IG51bGxcbiAgICB9O1xuICAgIGZvciAoY29uc3QgZGF0YSBvZiBhbm5vdGF0aW9ucykge1xuICAgICAgaWYgKGRhdGEubm9IVE1MKSB7XG4gICAgICAgIGNvbnRpbnVlO1xuICAgICAgfVxuICAgICAgY29uc3QgaXNQb3B1cEFubm90YXRpb24gPSBkYXRhLmFubm90YXRpb25UeXBlID09PSBfdXRpbC5Bbm5vdGF0aW9uVHlwZS5QT1BVUDtcbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24pIHtcbiAgICAgICAgY29uc3Qge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodFxuICAgICAgICB9ID0gZ2V0UmVjdERpbXMoZGF0YS5yZWN0KTtcbiAgICAgICAgaWYgKHdpZHRoIDw9IDAgfHwgaGVpZ2h0IDw9IDApIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgZWxlbWVudHMgPSBwb3B1cFRvRWxlbWVudHMuZ2V0KGRhdGEuaWQpO1xuICAgICAgICBpZiAoIWVsZW1lbnRzKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxlbWVudFBhcmFtcy5lbGVtZW50cyA9IGVsZW1lbnRzO1xuICAgICAgfVxuICAgICAgZWxlbWVudFBhcmFtcy5kYXRhID0gZGF0YTtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBBbm5vdGF0aW9uRWxlbWVudEZhY3RvcnkuY3JlYXRlKGVsZW1lbnRQYXJhbXMpO1xuICAgICAgaWYgKCFlbGVtZW50LmlzUmVuZGVyYWJsZSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGlmICghaXNQb3B1cEFubm90YXRpb24gJiYgZGF0YS5wb3B1cFJlZikge1xuICAgICAgICBjb25zdCBlbGVtZW50cyA9IHBvcHVwVG9FbGVtZW50cy5nZXQoZGF0YS5wb3B1cFJlZik7XG4gICAgICAgIGlmICghZWxlbWVudHMpIHtcbiAgICAgICAgICBwb3B1cFRvRWxlbWVudHMuc2V0KGRhdGEucG9wdXBSZWYsIFtlbGVtZW50XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWxlbWVudHMucHVzaChlbGVtZW50KTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKGVsZW1lbnQuYW5ub3RhdGlvbkVkaXRvclR5cGUgPiAwKSB7XG4gICAgICAgIHRoaXMuI2VkaXRhYmxlQW5ub3RhdGlvbnMuc2V0KGVsZW1lbnQuZGF0YS5pZCwgZWxlbWVudCk7XG4gICAgICB9XG4gICAgICBjb25zdCByZW5kZXJlZCA9IGVsZW1lbnQucmVuZGVyKCk7XG4gICAgICBpZiAoZGF0YS5oaWRkZW4pIHtcbiAgICAgICAgcmVuZGVyZWQuc3R5bGUudmlzaWJpbGl0eSA9IFwiaGlkZGVuXCI7XG4gICAgICB9XG4gICAgICB0aGlzLiNhcHBlbmRFbGVtZW50KHJlbmRlcmVkLCBkYXRhLmlkKTtcbiAgICB9XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICAgIGF3YWl0IHRoaXMubDEwbi50cmFuc2xhdGUobGF5ZXIpO1xuICB9XG4gIHVwZGF0ZShfcmVmNSkge1xuICAgIGxldCB7XG4gICAgICB2aWV3cG9ydFxuICAgIH0gPSBfcmVmNTtcbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIHRoaXMudmlld3BvcnQgPSB2aWV3cG9ydDtcbiAgICAoMCwgX2Rpc3BsYXlfdXRpbHMuc2V0TGF5ZXJEaW1lbnNpb25zKShsYXllciwge1xuICAgICAgcm90YXRpb246IHZpZXdwb3J0LnJvdGF0aW9uXG4gICAgfSk7XG4gICAgdGhpcy4jc2V0QW5ub3RhdGlvbkNhbnZhc01hcCgpO1xuICAgIGxheWVyLmhpZGRlbiA9IGZhbHNlO1xuICB9XG4gICNzZXRBbm5vdGF0aW9uQ2FudmFzTWFwKCkge1xuICAgIGlmICghdGhpcy4jYW5ub3RhdGlvbkNhbnZhc01hcCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXllciA9IHRoaXMuZGl2O1xuICAgIGZvciAoY29uc3QgW2lkLCBjYW52YXNdIG9mIHRoaXMuI2Fubm90YXRpb25DYW52YXNNYXApIHtcbiAgICAgIGNvbnN0IGVsZW1lbnQgPSBsYXllci5xdWVyeVNlbGVjdG9yKGBbZGF0YS1hbm5vdGF0aW9uLWlkPVwiJHtpZH1cIl1gKTtcbiAgICAgIGlmICghZWxlbWVudCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgZmlyc3RDaGlsZFxuICAgICAgfSA9IGVsZW1lbnQ7XG4gICAgICBpZiAoIWZpcnN0Q2hpbGQpIHtcbiAgICAgICAgZWxlbWVudC5hcHBlbmQoY2FudmFzKTtcbiAgICAgIH0gZWxzZSBpZiAoZmlyc3RDaGlsZC5ub2RlTmFtZSA9PT0gXCJDQU5WQVNcIikge1xuICAgICAgICBmaXJzdENoaWxkLnJlcGxhY2VXaXRoKGNhbnZhcyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBmaXJzdENoaWxkLmJlZm9yZShjYW52YXMpO1xuICAgICAgfVxuICAgIH1cbiAgICB0aGlzLiNhbm5vdGF0aW9uQ2FudmFzTWFwLmNsZWFyKCk7XG4gIH1cbiAgZ2V0RWRpdGFibGVBbm5vdGF0aW9ucygpIHtcbiAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLiNlZGl0YWJsZUFubm90YXRpb25zLnZhbHVlcygpKTtcbiAgfVxuICBnZXRFZGl0YWJsZUFubm90YXRpb24oaWQpIHtcbiAgICByZXR1cm4gdGhpcy4jZWRpdGFibGVBbm5vdGF0aW9ucy5nZXQoaWQpO1xuICB9XG59XG5leHBvcnRzLkFubm90YXRpb25MYXllciA9IEFubm90YXRpb25MYXllcjtcblxuLyoqKi8gfSksXG4vKiAxOTkgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuQ29sb3JDb252ZXJ0ZXJzID0gdm9pZCAwO1xuZnVuY3Rpb24gbWFrZUNvbG9yQ29tcChuKSB7XG4gIHJldHVybiBNYXRoLmZsb29yKE1hdGgubWF4KDAsIE1hdGgubWluKDEsIG4pKSAqIDI1NSkudG9TdHJpbmcoMTYpLnBhZFN0YXJ0KDIsIFwiMFwiKTtcbn1cbmZ1bmN0aW9uIHNjYWxlQW5kQ2xhbXAoeCkge1xuICByZXR1cm4gTWF0aC5tYXgoMCwgTWF0aC5taW4oMjU1LCAyNTUgKiB4KSk7XG59XG5jbGFzcyBDb2xvckNvbnZlcnRlcnMge1xuICBzdGF0aWMgQ01ZS19HKF9yZWYpIHtcbiAgICBsZXQgW2MsIHksIG0sIGtdID0gX3JlZjtcbiAgICByZXR1cm4gW1wiR1wiLCAxIC0gTWF0aC5taW4oMSwgMC4zICogYyArIDAuNTkgKiBtICsgMC4xMSAqIHkgKyBrKV07XG4gIH1cbiAgc3RhdGljIEdfQ01ZSyhfcmVmMikge1xuICAgIGxldCBbZ10gPSBfcmVmMjtcbiAgICByZXR1cm4gW1wiQ01ZS1wiLCAwLCAwLCAwLCAxIC0gZ107XG4gIH1cbiAgc3RhdGljIEdfUkdCKF9yZWYzKSB7XG4gICAgbGV0IFtnXSA9IF9yZWYzO1xuICAgIHJldHVybiBbXCJSR0JcIiwgZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfcmdiKF9yZWY0KSB7XG4gICAgbGV0IFtnXSA9IF9yZWY0O1xuICAgIGcgPSBzY2FsZUFuZENsYW1wKGcpO1xuICAgIHJldHVybiBbZywgZywgZ107XG4gIH1cbiAgc3RhdGljIEdfSFRNTChfcmVmNSkge1xuICAgIGxldCBbZ10gPSBfcmVmNTtcbiAgICBjb25zdCBHID0gbWFrZUNvbG9yQ29tcChnKTtcbiAgICByZXR1cm4gYCMke0d9JHtHfSR7R31gO1xuICB9XG4gIHN0YXRpYyBSR0JfRyhfcmVmNikge1xuICAgIGxldCBbciwgZywgYl0gPSBfcmVmNjtcbiAgICByZXR1cm4gW1wiR1wiLCAwLjMgKiByICsgMC41OSAqIGcgKyAwLjExICogYl07XG4gIH1cbiAgc3RhdGljIFJHQl9yZ2IoY29sb3IpIHtcbiAgICByZXR1cm4gY29sb3IubWFwKHNjYWxlQW5kQ2xhbXApO1xuICB9XG4gIHN0YXRpYyBSR0JfSFRNTChjb2xvcikge1xuICAgIHJldHVybiBgIyR7Y29sb3IubWFwKG1ha2VDb2xvckNvbXApLmpvaW4oXCJcIil9YDtcbiAgfVxuICBzdGF0aWMgVF9IVE1MKCkge1xuICAgIHJldHVybiBcIiMwMDAwMDAwMFwiO1xuICB9XG4gIHN0YXRpYyBUX3JnYigpIHtcbiAgICByZXR1cm4gW251bGxdO1xuICB9XG4gIHN0YXRpYyBDTVlLX1JHQihfcmVmNykge1xuICAgIGxldCBbYywgeSwgbSwga10gPSBfcmVmNztcbiAgICByZXR1cm4gW1wiUkdCXCIsIDEgLSBNYXRoLm1pbigxLCBjICsgayksIDEgLSBNYXRoLm1pbigxLCBtICsgayksIDEgLSBNYXRoLm1pbigxLCB5ICsgayldO1xuICB9XG4gIHN0YXRpYyBDTVlLX3JnYihfcmVmOCkge1xuICAgIGxldCBbYywgeSwgbSwga10gPSBfcmVmODtcbiAgICByZXR1cm4gW3NjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIGMgKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIG0gKyBrKSksIHNjYWxlQW5kQ2xhbXAoMSAtIE1hdGgubWluKDEsIHkgKyBrKSldO1xuICB9XG4gIHN0YXRpYyBDTVlLX0hUTUwoY29tcG9uZW50cykge1xuICAgIGNvbnN0IHJnYiA9IHRoaXMuQ01ZS19SR0IoY29tcG9uZW50cykuc2xpY2UoMSk7XG4gICAgcmV0dXJuIHRoaXMuUkdCX0hUTUwocmdiKTtcbiAgfVxuICBzdGF0aWMgUkdCX0NNWUsoX3JlZjkpIHtcbiAgICBsZXQgW3IsIGcsIGJdID0gX3JlZjk7XG4gICAgY29uc3QgYyA9IDEgLSByO1xuICAgIGNvbnN0IG0gPSAxIC0gZztcbiAgICBjb25zdCB5ID0gMSAtIGI7XG4gICAgY29uc3QgayA9IE1hdGgubWluKGMsIG0sIHkpO1xuICAgIHJldHVybiBbXCJDTVlLXCIsIGMsIG0sIHksIGtdO1xuICB9XG59XG5leHBvcnRzLkNvbG9yQ29udmVydGVycyA9IENvbG9yQ29udmVydGVycztcblxuLyoqKi8gfSksXG4vKiAyMDAgKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIGV4cG9ydHMpID0+IHtcblxuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbmV4cG9ydHMuTnVsbEwxMG4gPSB2b2lkIDA7XG5leHBvcnRzLmdldEwxMG5GYWxsYmFjayA9IGdldEwxMG5GYWxsYmFjaztcbmNvbnN0IERFRkFVTFRfTDEwTl9TVFJJTkdTID0ge1xuICBvZl9wYWdlczogXCJvZiB7e3BhZ2VzQ291bnR9fVwiLFxuICBwYWdlX29mX3BhZ2VzOiBcIih7e3BhZ2VOdW1iZXJ9fSBvZiB7e3BhZ2VzQ291bnR9fSlcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19rYjogXCJ7e3NpemVfa2J9fSBLQiAoe3tzaXplX2J9fSBieXRlcylcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19tYjogXCJ7e3NpemVfbWJ9fSBNQiAoe3tzaXplX2J9fSBieXRlcylcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19kYXRlX3N0cmluZzogXCJ7e2RhdGV9fSwge3t0aW1lfX1cIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfdW5pdF9pbmNoZXM6IFwiaW5cIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfdW5pdF9taWxsaW1ldGVyczogXCJtbVwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9vcmllbnRhdGlvbl9wb3J0cmFpdDogXCJwb3J0cmFpdFwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9vcmllbnRhdGlvbl9sYW5kc2NhcGU6IFwibGFuZHNjYXBlXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX25hbWVfYTM6IFwiQTNcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfbmFtZV9hNDogXCJBNFwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9uYW1lX2xldHRlcjogXCJMZXR0ZXJcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19wYWdlX3NpemVfbmFtZV9sZWdhbDogXCJMZWdhbFwiLFxuICBkb2N1bWVudF9wcm9wZXJ0aWVzX3BhZ2Vfc2l6ZV9kaW1lbnNpb25fc3RyaW5nOiBcInt7d2lkdGh9fSDDlyB7e2hlaWdodH19IHt7dW5pdH19ICh7e29yaWVudGF0aW9ufX0pXCIsXG4gIGRvY3VtZW50X3Byb3BlcnRpZXNfcGFnZV9zaXplX2RpbWVuc2lvbl9uYW1lX3N0cmluZzogXCJ7e3dpZHRofX0gw5cge3toZWlnaHR9fSB7e3VuaXR9fSAoe3tuYW1lfX0sIHt7b3JpZW50YXRpb259fSlcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19saW5lYXJpemVkX3llczogXCJZZXNcIixcbiAgZG9jdW1lbnRfcHJvcGVydGllc19saW5lYXJpemVkX25vOiBcIk5vXCIsXG4gIGFkZGl0aW9uYWxfbGF5ZXJzOiBcIkFkZGl0aW9uYWwgTGF5ZXJzXCIsXG4gIHBhZ2VfbGFuZG1hcms6IFwiUGFnZSB7e3BhZ2V9fVwiLFxuICB0aHVtYl9wYWdlX3RpdGxlOiBcIlBhZ2Uge3twYWdlfX1cIixcbiAgdGh1bWJfcGFnZV9jYW52YXM6IFwiVGh1bWJuYWlsIG9mIFBhZ2Uge3twYWdlfX1cIixcbiAgZmluZF9yZWFjaGVkX3RvcDogXCJSZWFjaGVkIHRvcCBvZiBkb2N1bWVudCwgY29udGludWVkIGZyb20gYm90dG9tXCIsXG4gIGZpbmRfcmVhY2hlZF9ib3R0b206IFwiUmVhY2hlZCBlbmQgb2YgZG9jdW1lbnQsIGNvbnRpbnVlZCBmcm9tIHRvcFwiLFxuICBcImZpbmRfbWF0Y2hfY291bnRbb25lXVwiOiBcInt7Y3VycmVudH19IG9mIHt7dG90YWx9fSBtYXRjaFwiLFxuICBcImZpbmRfbWF0Y2hfY291bnRbb3RoZXJdXCI6IFwie3tjdXJyZW50fX0gb2Yge3t0b3RhbH19IG1hdGNoZXNcIixcbiAgXCJmaW5kX21hdGNoX2NvdW50X2xpbWl0W29uZV1cIjogXCJNb3JlIHRoYW4ge3tsaW1pdH19IG1hdGNoXCIsXG4gIFwiZmluZF9tYXRjaF9jb3VudF9saW1pdFtvdGhlcl1cIjogXCJNb3JlIHRoYW4ge3tsaW1pdH19IG1hdGNoZXNcIixcbiAgZmluZF9ub3RfZm91bmQ6IFwiUGhyYXNlIG5vdCBmb3VuZFwiLFxuICBwYWdlX3NjYWxlX3dpZHRoOiBcIlBhZ2UgV2lkdGhcIixcbiAgcGFnZV9zY2FsZV9maXQ6IFwiUGFnZSBGaXRcIixcbiAgcGFnZV9zY2FsZV9hdXRvOiBcIkF1dG9tYXRpYyBab29tXCIsXG4gIHBhZ2Vfc2NhbGVfYWN0dWFsOiBcIkFjdHVhbCBTaXplXCIsXG4gIHBhZ2Vfc2NhbGVfcGVyY2VudDogXCJ7e3NjYWxlfX0lXCIsXG4gIGxvYWRpbmdfZXJyb3I6IFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgbG9hZGluZyB0aGUgUERGLlwiLFxuICBpbnZhbGlkX2ZpbGVfZXJyb3I6IFwiSW52YWxpZCBvciBjb3JydXB0ZWQgUERGIGZpbGUuXCIsXG4gIG1pc3NpbmdfZmlsZV9lcnJvcjogXCJNaXNzaW5nIFBERiBmaWxlLlwiLFxuICB1bmV4cGVjdGVkX3Jlc3BvbnNlX2Vycm9yOiBcIlVuZXhwZWN0ZWQgc2VydmVyIHJlc3BvbnNlLlwiLFxuICByZW5kZXJpbmdfZXJyb3I6IFwiQW4gZXJyb3Igb2NjdXJyZWQgd2hpbGUgcmVuZGVyaW5nIHRoZSBwYWdlLlwiLFxuICBhbm5vdGF0aW9uX2RhdGVfc3RyaW5nOiBcInt7ZGF0ZX19LCB7e3RpbWV9fVwiLFxuICBwcmludGluZ19ub3Rfc3VwcG9ydGVkOiBcIldhcm5pbmc6IFByaW50aW5nIGlzIG5vdCBmdWxseSBzdXBwb3J0ZWQgYnkgdGhpcyBicm93c2VyLlwiLFxuICBwcmludGluZ19ub3RfcmVhZHk6IFwiV2FybmluZzogVGhlIFBERiBpcyBub3QgZnVsbHkgbG9hZGVkIGZvciBwcmludGluZy5cIixcbiAgd2ViX2ZvbnRzX2Rpc2FibGVkOiBcIldlYiBmb250cyBhcmUgZGlzYWJsZWQ6IHVuYWJsZSB0byB1c2UgZW1iZWRkZWQgUERGIGZvbnRzLlwiLFxuICBmcmVlX3RleHQyX2RlZmF1bHRfY29udGVudDogXCJTdGFydCB0eXBpbmfigKZcIixcbiAgZWRpdG9yX2ZyZWVfdGV4dDJfYXJpYV9sYWJlbDogXCJUZXh0IEVkaXRvclwiLFxuICBlZGl0b3JfaW5rMl9hcmlhX2xhYmVsOiBcIkRyYXcgRWRpdG9yXCIsXG4gIGVkaXRvcl9pbmtfY2FudmFzX2FyaWFfbGFiZWw6IFwiVXNlci1jcmVhdGVkIGltYWdlXCIsXG4gIGVkaXRvcl9hbHRfdGV4dF9idXR0b25fbGFiZWw6IFwiQWx0IHRleHRcIixcbiAgZWRpdG9yX2FsdF90ZXh0X2VkaXRfYnV0dG9uX2xhYmVsOiBcIkVkaXQgYWx0IHRleHRcIixcbiAgZWRpdG9yX2FsdF90ZXh0X2RlY29yYXRpdmVfdG9vbHRpcDogXCJNYXJrZWQgYXMgZGVjb3JhdGl2ZVwiXG59O1xue1xuICBERUZBVUxUX0wxME5fU1RSSU5HUy5wcmludF9wcm9ncmVzc19wZXJjZW50ID0gXCJ7e3Byb2dyZXNzfX0lXCI7XG59XG5mdW5jdGlvbiBnZXRMMTBuRmFsbGJhY2soa2V5LCBhcmdzKSB7XG4gIHN3aXRjaCAoa2V5KSB7XG4gICAgY2FzZSBcImZpbmRfbWF0Y2hfY291bnRcIjpcbiAgICAgIGtleSA9IGBmaW5kX21hdGNoX2NvdW50WyR7YXJncy50b3RhbCA9PT0gMSA/IFwib25lXCIgOiBcIm90aGVyXCJ9XWA7XG4gICAgICBicmVhaztcbiAgICBjYXNlIFwiZmluZF9tYXRjaF9jb3VudF9saW1pdFwiOlxuICAgICAga2V5ID0gYGZpbmRfbWF0Y2hfY291bnRfbGltaXRbJHthcmdzLmxpbWl0ID09PSAxID8gXCJvbmVcIiA6IFwib3RoZXJcIn1dYDtcbiAgICAgIGJyZWFrO1xuICB9XG4gIHJldHVybiBERUZBVUxUX0wxME5fU1RSSU5HU1trZXldIHx8IFwiXCI7XG59XG5mdW5jdGlvbiBmb3JtYXRMMTBuVmFsdWUodGV4dCwgYXJncykge1xuICBpZiAoIWFyZ3MpIHtcbiAgICByZXR1cm4gdGV4dDtcbiAgfVxuICByZXR1cm4gdGV4dC5yZXBsYWNlQWxsKC9cXHtcXHtcXHMqKFxcdyspXFxzKlxcfVxcfS9nLCAoYWxsLCBuYW1lKSA9PiB7XG4gICAgcmV0dXJuIG5hbWUgaW4gYXJncyA/IGFyZ3NbbmFtZV0gOiBcInt7XCIgKyBuYW1lICsgXCJ9fVwiO1xuICB9KTtcbn1cbmNvbnN0IE51bGxMMTBuID0ge1xuICBhc3luYyBnZXRMYW5ndWFnZSgpIHtcbiAgICByZXR1cm4gXCJlbi11c1wiO1xuICB9LFxuICBhc3luYyBnZXREaXJlY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwibHRyXCI7XG4gIH0sXG4gIGFzeW5jIGdldChrZXkpIHtcbiAgICBsZXQgYXJncyA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICBsZXQgZmFsbGJhY2sgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGdldEwxMG5GYWxsYmFjayhrZXksIGFyZ3MpO1xuICAgIHJldHVybiBmb3JtYXRMMTBuVmFsdWUoZmFsbGJhY2ssIGFyZ3MpO1xuICB9LFxuICBhc3luYyB0cmFuc2xhdGUoZWxlbWVudCkge31cbn07XG5leHBvcnRzLk51bGxMMTBuID0gTnVsbEwxMG47XG5cbi8qKiovIH0pLFxuLyogMjAxICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlhmYUxheWVyID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXyg4OSk7XG52YXIgX3hmYV90ZXh0ID0gX193X3BkZmpzX3JlcXVpcmVfXygxOTQpO1xuY2xhc3MgWGZhTGF5ZXIge1xuICBzdGF0aWMgc2V0dXBTdG9yYWdlKGh0bWwsIGlkLCBlbGVtZW50LCBzdG9yYWdlLCBpbnRlbnQpIHtcbiAgICBjb25zdCBzdG9yZWREYXRhID0gc3RvcmFnZS5nZXRWYWx1ZShpZCwge1xuICAgICAgdmFsdWU6IG51bGxcbiAgICB9KTtcbiAgICBzd2l0Y2ggKGVsZW1lbnQubmFtZSkge1xuICAgICAgY2FzZSBcInRleHRhcmVhXCI6XG4gICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgaHRtbC50ZXh0Q29udGVudCA9IHN0b3JlZERhdGEudmFsdWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGludGVudCA9PT0gXCJwcmludFwiKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaHRtbC5hZGRFdmVudExpc3RlbmVyKFwiaW5wdXRcIiwgZXZlbnQgPT4ge1xuICAgICAgICAgIHN0b3JhZ2Uuc2V0VmFsdWUoaWQsIHtcbiAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcImlucHV0XCI6XG4gICAgICAgIGlmIChlbGVtZW50LmF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiIHx8IGVsZW1lbnQuYXR0cmlidXRlcy50eXBlID09PSBcImNoZWNrYm94XCIpIHtcbiAgICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSA9PT0gZWxlbWVudC5hdHRyaWJ1dGVzLnhmYU9uKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImNoZWNrZWRcIiwgdHJ1ZSk7XG4gICAgICAgICAgfSBlbHNlIGlmIChzdG9yZWREYXRhLnZhbHVlID09PSBlbGVtZW50LmF0dHJpYnV0ZXMueGZhT2ZmKSB7XG4gICAgICAgICAgICBodG1sLnJlbW92ZUF0dHJpYnV0ZShcImNoZWNrZWRcIik7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChpbnRlbnQgPT09IFwicHJpbnRcIikge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQuY2hlY2tlZCA/IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPblwiKSA6IGV2ZW50LnRhcmdldC5nZXRBdHRyaWJ1dGUoXCJ4ZmFPZmZcIilcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGlmIChzdG9yZWREYXRhLnZhbHVlICE9PSBudWxsKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcInZhbHVlXCIsIHN0b3JlZERhdGEudmFsdWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaW50ZW50ID09PSBcInByaW50XCIpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBodG1sLmFkZEV2ZW50TGlzdGVuZXIoXCJpbnB1dFwiLCBldmVudCA9PiB7XG4gICAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICAgIHZhbHVlOiBldmVudC50YXJnZXQudmFsdWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcInNlbGVjdFwiOlxuICAgICAgICBpZiAoc3RvcmVkRGF0YS52YWx1ZSAhPT0gbnVsbCkge1xuICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKFwidmFsdWVcIiwgc3RvcmVkRGF0YS52YWx1ZSk7XG4gICAgICAgICAgZm9yIChjb25zdCBvcHRpb24gb2YgZWxlbWVudC5jaGlsZHJlbikge1xuICAgICAgICAgICAgaWYgKG9wdGlvbi5hdHRyaWJ1dGVzLnZhbHVlID09PSBzdG9yZWREYXRhLnZhbHVlKSB7XG4gICAgICAgICAgICAgIG9wdGlvbi5hdHRyaWJ1dGVzLnNlbGVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIH0gZWxzZSBpZiAob3B0aW9uLmF0dHJpYnV0ZXMuaGFzT3duUHJvcGVydHkoXCJzZWxlY3RlZFwiKSkge1xuICAgICAgICAgICAgICBkZWxldGUgb3B0aW9uLmF0dHJpYnV0ZXMuc2VsZWN0ZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGh0bWwuYWRkRXZlbnRMaXN0ZW5lcihcImlucHV0XCIsIGV2ZW50ID0+IHtcbiAgICAgICAgICBjb25zdCBvcHRpb25zID0gZXZlbnQudGFyZ2V0Lm9wdGlvbnM7XG4gICAgICAgICAgY29uc3QgdmFsdWUgPSBvcHRpb25zLnNlbGVjdGVkSW5kZXggPT09IC0xID8gXCJcIiA6IG9wdGlvbnNbb3B0aW9ucy5zZWxlY3RlZEluZGV4XS52YWx1ZTtcbiAgICAgICAgICBzdG9yYWdlLnNldFZhbHVlKGlkLCB7XG4gICAgICAgICAgICB2YWx1ZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHN0YXRpYyBzZXRBdHRyaWJ1dGVzKF9yZWYpIHtcbiAgICBsZXQge1xuICAgICAgaHRtbCxcbiAgICAgIGVsZW1lbnQsXG4gICAgICBzdG9yYWdlID0gbnVsbCxcbiAgICAgIGludGVudCxcbiAgICAgIGxpbmtTZXJ2aWNlXG4gICAgfSA9IF9yZWY7XG4gICAgY29uc3Qge1xuICAgICAgYXR0cmlidXRlc1xuICAgIH0gPSBlbGVtZW50O1xuICAgIGNvbnN0IGlzSFRNTEFuY2hvckVsZW1lbnQgPSBodG1sIGluc3RhbmNlb2YgSFRNTEFuY2hvckVsZW1lbnQ7XG4gICAgaWYgKGF0dHJpYnV0ZXMudHlwZSA9PT0gXCJyYWRpb1wiKSB7XG4gICAgICBhdHRyaWJ1dGVzLm5hbWUgPSBgJHthdHRyaWJ1dGVzLm5hbWV9LSR7aW50ZW50fWA7XG4gICAgfVxuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGF0dHJpYnV0ZXMpKSB7XG4gICAgICBpZiAodmFsdWUgPT09IG51bGwgfHwgdmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIHN3aXRjaCAoa2V5KSB7XG4gICAgICAgIGNhc2UgXCJjbGFzc1wiOlxuICAgICAgICAgIGlmICh2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgICAgIGh0bWwuc2V0QXR0cmlidXRlKGtleSwgdmFsdWUuam9pbihcIiBcIikpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBcImRhdGFJZFwiOlxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwiaWRcIjpcbiAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShcImRhdGEtZWxlbWVudC1pZFwiLCB2YWx1ZSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgXCJzdHlsZVwiOlxuICAgICAgICAgIE9iamVjdC5hc3NpZ24oaHRtbC5zdHlsZSwgdmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlIFwidGV4dENvbnRlbnRcIjpcbiAgICAgICAgICBodG1sLnRleHRDb250ZW50ID0gdmFsdWU7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgaWYgKCFpc0hUTUxBbmNob3JFbGVtZW50IHx8IGtleSAhPT0gXCJocmVmXCIgJiYga2V5ICE9PSBcIm5ld1dpbmRvd1wiKSB7XG4gICAgICAgICAgICBodG1sLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0hUTUxBbmNob3JFbGVtZW50KSB7XG4gICAgICBsaW5rU2VydmljZS5hZGRMaW5rQXR0cmlidXRlcyhodG1sLCBhdHRyaWJ1dGVzLmhyZWYsIGF0dHJpYnV0ZXMubmV3V2luZG93KTtcbiAgICB9XG4gICAgaWYgKHN0b3JhZ2UgJiYgYXR0cmlidXRlcy5kYXRhSWQpIHtcbiAgICAgIHRoaXMuc2V0dXBTdG9yYWdlKGh0bWwsIGF0dHJpYnV0ZXMuZGF0YUlkLCBlbGVtZW50LCBzdG9yYWdlKTtcbiAgICB9XG4gIH1cbiAgc3RhdGljIHJlbmRlcihwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3Qgc3RvcmFnZSA9IHBhcmFtZXRlcnMuYW5ub3RhdGlvblN0b3JhZ2U7XG4gICAgY29uc3QgbGlua1NlcnZpY2UgPSBwYXJhbWV0ZXJzLmxpbmtTZXJ2aWNlO1xuICAgIGNvbnN0IHJvb3QgPSBwYXJhbWV0ZXJzLnhmYUh0bWw7XG4gICAgY29uc3QgaW50ZW50ID0gcGFyYW1ldGVycy5pbnRlbnQgfHwgXCJkaXNwbGF5XCI7XG4gICAgY29uc3Qgcm9vdEh0bWwgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KHJvb3QubmFtZSk7XG4gICAgaWYgKHJvb3QuYXR0cmlidXRlcykge1xuICAgICAgdGhpcy5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgaHRtbDogcm9vdEh0bWwsXG4gICAgICAgIGVsZW1lbnQ6IHJvb3QsXG4gICAgICAgIGludGVudCxcbiAgICAgICAgbGlua1NlcnZpY2VcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBzdGFjayA9IFtbcm9vdCwgLTEsIHJvb3RIdG1sXV07XG4gICAgY29uc3Qgcm9vdERpdiA9IHBhcmFtZXRlcnMuZGl2O1xuICAgIHJvb3REaXYuYXBwZW5kKHJvb3RIdG1sKTtcbiAgICBpZiAocGFyYW1ldGVycy52aWV3cG9ydCkge1xuICAgICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgICAgcm9vdERpdi5zdHlsZS50cmFuc2Zvcm0gPSB0cmFuc2Zvcm07XG4gICAgfVxuICAgIGlmIChpbnRlbnQgIT09IFwicmljaFRleHRcIikge1xuICAgICAgcm9vdERpdi5zZXRBdHRyaWJ1dGUoXCJjbGFzc1wiLCBcInhmYUxheWVyIHhmYUZvbnRcIik7XG4gICAgfVxuICAgIGNvbnN0IHRleHREaXZzID0gW107XG4gICAgd2hpbGUgKHN0YWNrLmxlbmd0aCA+IDApIHtcbiAgICAgIGNvbnN0IFtwYXJlbnQsIGksIGh0bWxdID0gc3RhY2suYXQoLTEpO1xuICAgICAgaWYgKGkgKyAxID09PSBwYXJlbnQuY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoaWxkID0gcGFyZW50LmNoaWxkcmVuWysrc3RhY2suYXQoLTEpWzFdXTtcbiAgICAgIGlmIChjaGlsZCA9PT0gbnVsbCkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgbmFtZVxuICAgICAgfSA9IGNoaWxkO1xuICAgICAgaWYgKG5hbWUgPT09IFwiI3RleHRcIikge1xuICAgICAgICBjb25zdCBub2RlID0gZG9jdW1lbnQuY3JlYXRlVGV4dE5vZGUoY2hpbGQudmFsdWUpO1xuICAgICAgICB0ZXh0RGl2cy5wdXNoKG5vZGUpO1xuICAgICAgICBodG1sLmFwcGVuZChub2RlKTtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgICBjb25zdCBjaGlsZEh0bWwgPSBjaGlsZD8uYXR0cmlidXRlcz8ueG1sbnMgPyBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMoY2hpbGQuYXR0cmlidXRlcy54bWxucywgbmFtZSkgOiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KG5hbWUpO1xuICAgICAgaHRtbC5hcHBlbmQoY2hpbGRIdG1sKTtcbiAgICAgIGlmIChjaGlsZC5hdHRyaWJ1dGVzKSB7XG4gICAgICAgIHRoaXMuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgaHRtbDogY2hpbGRIdG1sLFxuICAgICAgICAgIGVsZW1lbnQ6IGNoaWxkLFxuICAgICAgICAgIHN0b3JhZ2UsXG4gICAgICAgICAgaW50ZW50LFxuICAgICAgICAgIGxpbmtTZXJ2aWNlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgaWYgKGNoaWxkLmNoaWxkcmVuICYmIGNoaWxkLmNoaWxkcmVuLmxlbmd0aCA+IDApIHtcbiAgICAgICAgc3RhY2sucHVzaChbY2hpbGQsIC0xLCBjaGlsZEh0bWxdKTtcbiAgICAgIH0gZWxzZSBpZiAoY2hpbGQudmFsdWUpIHtcbiAgICAgICAgY29uc3Qgbm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNoaWxkLnZhbHVlKTtcbiAgICAgICAgaWYgKF94ZmFfdGV4dC5YZmFUZXh0LnNob3VsZEJ1aWxkVGV4dChuYW1lKSkge1xuICAgICAgICAgIHRleHREaXZzLnB1c2gobm9kZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2hpbGRIdG1sLmFwcGVuZChub2RlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBlbCBvZiByb290RGl2LnF1ZXJ5U2VsZWN0b3JBbGwoXCIueGZhTm9uSW50ZXJhY3RpdmUgaW5wdXQsIC54ZmFOb25JbnRlcmFjdGl2ZSB0ZXh0YXJlYVwiKSkge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKFwicmVhZE9ubHlcIiwgdHJ1ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0ZXh0RGl2c1xuICAgIH07XG4gIH1cbiAgc3RhdGljIHVwZGF0ZShwYXJhbWV0ZXJzKSB7XG4gICAgY29uc3QgdHJhbnNmb3JtID0gYG1hdHJpeCgke3BhcmFtZXRlcnMudmlld3BvcnQudHJhbnNmb3JtLmpvaW4oXCIsXCIpfSlgO1xuICAgIHBhcmFtZXRlcnMuZGl2LnN0eWxlLnRyYW5zZm9ybSA9IHRyYW5zZm9ybTtcbiAgICBwYXJhbWV0ZXJzLmRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgfVxufVxuZXhwb3J0cy5YZmFMYXllciA9IFhmYUxheWVyO1xuXG4vKioqLyB9KSxcbi8qIDIwMiAqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgZXhwb3J0cywgX193X3BkZmpzX3JlcXVpcmVfXykgPT4ge1xuXG5cblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCAoe1xuICB2YWx1ZTogdHJ1ZVxufSkpO1xuZXhwb3J0cy5JbmtFZGl0b3IgPSB2b2lkIDA7XG5fX3dfcGRmanNfcmVxdWlyZV9fKDg5KTtcbl9fd19wZGZqc19yZXF1aXJlX18oMik7XG52YXIgX3V0aWwgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDEpO1xudmFyIF9lZGl0b3IgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2NCk7XG52YXIgX2Fubm90YXRpb25fbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5OCk7XG52YXIgX2Rpc3BsYXlfdXRpbHMgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE2OCk7XG52YXIgX3Rvb2xzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjUpO1xuY2xhc3MgSW5rRWRpdG9yIGV4dGVuZHMgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yIHtcbiAgI2Jhc2VIZWlnaHQgPSAwO1xuICAjYmFzZVdpZHRoID0gMDtcbiAgI2JvdW5kQ2FudmFzUG9pbnRlcm1vdmUgPSB0aGlzLmNhbnZhc1BvaW50ZXJtb3ZlLmJpbmQodGhpcyk7XG4gICNib3VuZENhbnZhc1BvaW50ZXJsZWF2ZSA9IHRoaXMuY2FudmFzUG9pbnRlcmxlYXZlLmJpbmQodGhpcyk7XG4gICNib3VuZENhbnZhc1BvaW50ZXJ1cCA9IHRoaXMuY2FudmFzUG9pbnRlcnVwLmJpbmQodGhpcyk7XG4gICNib3VuZENhbnZhc1BvaW50ZXJkb3duID0gdGhpcy5jYW52YXNQb2ludGVyZG93bi5iaW5kKHRoaXMpO1xuICAjY3VycmVudFBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgI2Rpc2FibGVFZGl0aW5nID0gZmFsc2U7XG4gICNoYXNTb21ldGhpbmdUb0RyYXcgPSBmYWxzZTtcbiAgI2lzQ2FudmFzSW5pdGlhbGl6ZWQgPSBmYWxzZTtcbiAgI29ic2VydmVyID0gbnVsbDtcbiAgI3JlYWxXaWR0aCA9IDA7XG4gICNyZWFsSGVpZ2h0ID0gMDtcbiAgI3JlcXVlc3RGcmFtZUNhbGxiYWNrID0gbnVsbDtcbiAgc3RhdGljIF9kZWZhdWx0Q29sb3IgPSBudWxsO1xuICBzdGF0aWMgX2RlZmF1bHRPcGFjaXR5ID0gMTtcbiAgc3RhdGljIF9kZWZhdWx0VGhpY2tuZXNzID0gMTtcbiAgc3RhdGljIF90eXBlID0gXCJpbmtcIjtcbiAgY29uc3RydWN0b3IocGFyYW1zKSB7XG4gICAgc3VwZXIoe1xuICAgICAgLi4ucGFyYW1zLFxuICAgICAgbmFtZTogXCJpbmtFZGl0b3JcIlxuICAgIH0pO1xuICAgIHRoaXMuY29sb3IgPSBwYXJhbXMuY29sb3IgfHwgbnVsbDtcbiAgICB0aGlzLnRoaWNrbmVzcyA9IHBhcmFtcy50aGlja25lc3MgfHwgbnVsbDtcbiAgICB0aGlzLm9wYWNpdHkgPSBwYXJhbXMub3BhY2l0eSB8fCBudWxsO1xuICAgIHRoaXMucGF0aHMgPSBbXTtcbiAgICB0aGlzLmJlemllclBhdGgyRCA9IFtdO1xuICAgIHRoaXMuYWxsUmF3UGF0aHMgPSBbXTtcbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gW107XG4gICAgdGhpcy5zY2FsZUZhY3RvciA9IDE7XG4gICAgdGhpcy50cmFuc2xhdGlvblggPSB0aGlzLnRyYW5zbGF0aW9uWSA9IDA7XG4gICAgdGhpcy54ID0gMDtcbiAgICB0aGlzLnkgPSAwO1xuICAgIHRoaXMuX3dpbGxLZWVwQXNwZWN0UmF0aW8gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpbml0aWFsaXplKGwxMG4pIHtcbiAgICBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuaW5pdGlhbGl6ZShsMTBuLCB7XG4gICAgICBzdHJpbmdzOiBbXCJlZGl0b3JfaW5rX2NhbnZhc19hcmlhX2xhYmVsXCIsIFwiZWRpdG9yX2luazJfYXJpYV9sYWJlbFwiXVxuICAgIH0pO1xuICB9XG4gIHN0YXRpYyB1cGRhdGVEZWZhdWx0UGFyYW1zKHR5cGUsIHZhbHVlKSB7XG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICBjYXNlIF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1M6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdFRoaWNrbmVzcyA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SOlxuICAgICAgICBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciA9IHZhbHVlO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX09QQUNJVFk6XG4gICAgICAgIElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkgPSB2YWx1ZSAvIDEwMDtcbiAgICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHVwZGF0ZVBhcmFtcyh0eXBlLCB2YWx1ZSkge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTOlxuICAgICAgICB0aGlzLiN1cGRhdGVUaGlja25lc3ModmFsdWUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SOlxuICAgICAgICB0aGlzLiN1cGRhdGVDb2xvcih2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWTpcbiAgICAgICAgdGhpcy4jdXBkYXRlT3BhY2l0eSh2YWx1ZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgZ2V0IGRlZmF1bHRQcm9wZXJ0aWVzVG9VcGRhdGUoKSB7XG4gICAgcmV0dXJuIFtbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX1RISUNLTkVTUywgSW5rRWRpdG9yLl9kZWZhdWx0VGhpY2tuZXNzXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19DT0xPUiwgSW5rRWRpdG9yLl9kZWZhdWx0Q29sb3IgfHwgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9kZWZhdWx0TGluZUNvbG9yXSwgW191dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19PUEFDSVRZLCBNYXRoLnJvdW5kKElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkgKiAxMDApXV07XG4gIH1cbiAgZ2V0IHByb3BlcnRpZXNUb1VwZGF0ZSgpIHtcbiAgICByZXR1cm4gW1tfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfVEhJQ0tORVNTLCB0aGlzLnRoaWNrbmVzcyB8fCBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3NdLCBbX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLCB0aGlzLmNvbG9yIHx8IElua0VkaXRvci5fZGVmYXVsdENvbG9yIHx8IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fZGVmYXVsdExpbmVDb2xvcl0sIFtfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWSwgTWF0aC5yb3VuZCgxMDAgKiAodGhpcy5vcGFjaXR5ID8/IElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHkpKV1dO1xuICB9XG4gICN1cGRhdGVUaGlja25lc3ModGhpY2tuZXNzKSB7XG4gICAgY29uc3Qgc2F2ZWRUaGlja25lc3MgPSB0aGlzLnRoaWNrbmVzcztcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IHRoaWNrbmVzcztcbiAgICAgICAgdGhpcy4jZml0VG9Db250ZW50KCk7XG4gICAgICB9LFxuICAgICAgdW5kbzogKCkgPT4ge1xuICAgICAgICB0aGlzLnRoaWNrbmVzcyA9IHNhdmVkVGhpY2tuZXNzO1xuICAgICAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgICAgIH0sXG4gICAgICBtdXN0RXhlYzogdHJ1ZSxcbiAgICAgIHR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JQYXJhbXNUeXBlLklOS19USElDS05FU1MsXG4gICAgICBvdmVyd3JpdGVJZlNhbWVUeXBlOiB0cnVlLFxuICAgICAga2VlcFVuZG86IHRydWVcbiAgICB9KTtcbiAgfVxuICAjdXBkYXRlQ29sb3IoY29sb3IpIHtcbiAgICBjb25zdCBzYXZlZENvbG9yID0gdGhpcy5jb2xvcjtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLmNvbG9yID0gY29sb3I7XG4gICAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIHVuZG86ICgpID0+IHtcbiAgICAgICAgdGhpcy5jb2xvciA9IHNhdmVkQ29sb3I7XG4gICAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgfSxcbiAgICAgIG11c3RFeGVjOiB0cnVlLFxuICAgICAgdHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGUuSU5LX0NPTE9SLFxuICAgICAgb3ZlcndyaXRlSWZTYW1lVHlwZTogdHJ1ZSxcbiAgICAgIGtlZXBVbmRvOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI3VwZGF0ZU9wYWNpdHkob3BhY2l0eSkge1xuICAgIG9wYWNpdHkgLz0gMTAwO1xuICAgIGNvbnN0IHNhdmVkT3BhY2l0eSA9IHRoaXMub3BhY2l0eTtcbiAgICB0aGlzLmFkZENvbW1hbmRzKHtcbiAgICAgIGNtZDogKCkgPT4ge1xuICAgICAgICB0aGlzLm9wYWNpdHkgPSBvcGFjaXR5O1xuICAgICAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICAgIH0sXG4gICAgICB1bmRvOiAoKSA9PiB7XG4gICAgICAgIHRoaXMub3BhY2l0eSA9IHNhdmVkT3BhY2l0eTtcbiAgICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB9LFxuICAgICAgbXVzdEV4ZWM6IHRydWUsXG4gICAgICB0eXBlOiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZS5JTktfT1BBQ0lUWSxcbiAgICAgIG92ZXJ3cml0ZUlmU2FtZVR5cGU6IHRydWUsXG4gICAgICBrZWVwVW5kbzogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5jYW52YXMpIHtcbiAgICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICAgICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmlzQXR0YWNoZWRUb0RPTSkge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkKHRoaXMpO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgIH1cbiAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHRoaXMuY29tbWl0KCk7XG4gICAgfVxuICAgIHRoaXMuY2FudmFzLndpZHRoID0gdGhpcy5jYW52YXMuaGVpZ2h0ID0gMDtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmUoKTtcbiAgICB0aGlzLmNhbnZhcyA9IG51bGw7XG4gICAgdGhpcy4jb2JzZXJ2ZXIuZGlzY29ubmVjdCgpO1xuICAgIHRoaXMuI29ic2VydmVyID0gbnVsbDtcbiAgICBzdXBlci5yZW1vdmUoKTtcbiAgfVxuICBzZXRQYXJlbnQocGFyZW50KSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCAmJiBwYXJlbnQpIHtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5yZW1vdmVTaG91bGRSZXNjYWxlKHRoaXMpO1xuICAgIH0gZWxzZSBpZiAodGhpcy5wYXJlbnQgJiYgcGFyZW50ID09PSBudWxsKSB7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuYWRkU2hvdWxkUmVzY2FsZSh0aGlzKTtcbiAgICB9XG4gICAgc3VwZXIuc2V0UGFyZW50KHBhcmVudCk7XG4gIH1cbiAgb25TY2FsZUNoYW5naW5nKCkge1xuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICBjb25zdCB3aWR0aCA9IHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aDtcbiAgICBjb25zdCBoZWlnaHQgPSB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodDtcbiAgICB0aGlzLnNldERpbWVuc2lvbnMod2lkdGgsIGhlaWdodCk7XG4gIH1cbiAgZW5hYmxlRWRpdE1vZGUoKSB7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nIHx8IHRoaXMuY2FudmFzID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmVuYWJsZUVkaXRNb2RlKCk7XG4gICAgdGhpcy5faXNEcmFnZ2FibGUgPSBmYWxzZTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVyZG93bik7XG4gIH1cbiAgZGlzYWJsZUVkaXRNb2RlKCkge1xuICAgIGlmICghdGhpcy5pc0luRWRpdE1vZGUoKSB8fCB0aGlzLmNhbnZhcyA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLl9pc0RyYWdnYWJsZSA9ICF0aGlzLmlzRW1wdHkoKTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QucmVtb3ZlKFwiZWRpdGluZ1wiKTtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVyZG93bik7XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gIXRoaXMuaXNFbXB0eSgpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuIHRoaXMucGF0aHMubGVuZ3RoID09PSAwIHx8IHRoaXMucGF0aHMubGVuZ3RoID09PSAxICYmIHRoaXMucGF0aHNbMF0ubGVuZ3RoID09PSAwO1xuICB9XG4gICNnZXRJbml0aWFsQkJveCgpIHtcbiAgICBjb25zdCB7XG4gICAgICBwYXJlbnRSb3RhdGlvbixcbiAgICAgIHBhcmVudERpbWVuc2lvbnM6IFt3aWR0aCwgaGVpZ2h0XVxuICAgIH0gPSB0aGlzO1xuICAgIHN3aXRjaCAocGFyZW50Um90YXRpb24pIHtcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIHJldHVybiBbMCwgaGVpZ2h0LCBoZWlnaHQsIHdpZHRoXTtcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICByZXR1cm4gW3dpZHRoLCBoZWlnaHQsIHdpZHRoLCBoZWlnaHRdO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIHJldHVybiBbd2lkdGgsIDAsIGhlaWdodCwgd2lkdGhdO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgcmV0dXJuIFswLCAwLCB3aWR0aCwgaGVpZ2h0XTtcbiAgICB9XG4gIH1cbiAgI3NldFN0cm9rZSgpIHtcbiAgICBjb25zdCB7XG4gICAgICBjdHgsXG4gICAgICBjb2xvcixcbiAgICAgIG9wYWNpdHksXG4gICAgICB0aGlja25lc3MsXG4gICAgICBwYXJlbnRTY2FsZSxcbiAgICAgIHNjYWxlRmFjdG9yXG4gICAgfSA9IHRoaXM7XG4gICAgY3R4LmxpbmVXaWR0aCA9IHRoaWNrbmVzcyAqIHBhcmVudFNjYWxlIC8gc2NhbGVGYWN0b3I7XG4gICAgY3R4LmxpbmVDYXAgPSBcInJvdW5kXCI7XG4gICAgY3R4LmxpbmVKb2luID0gXCJyb3VuZFwiO1xuICAgIGN0eC5taXRlckxpbWl0ID0gMTA7XG4gICAgY3R4LnN0cm9rZVN0eWxlID0gYCR7Y29sb3J9JHsoMCwgX3Rvb2xzLm9wYWNpdHlUb0hleCkob3BhY2l0eSl9YDtcbiAgfVxuICAjc3RhcnREcmF3aW5nKHgsIHkpIHtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJsZWF2ZVwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJsZWF2ZSk7XG4gICAgdGhpcy5jYW52YXMuYWRkRXZlbnRMaXN0ZW5lcihcInBvaW50ZXJtb3ZlXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcm1vdmUpO1xuICAgIHRoaXMuY2FudmFzLmFkZEV2ZW50TGlzdGVuZXIoXCJwb2ludGVydXBcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVydXApO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVyZG93blwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJkb3duKTtcbiAgICB0aGlzLmlzRWRpdGluZyA9IHRydWU7XG4gICAgaWYgKCF0aGlzLiNpc0NhbnZhc0luaXRpYWxpemVkKSB7XG4gICAgICB0aGlzLiNpc0NhbnZhc0luaXRpYWxpemVkID0gdHJ1ZTtcbiAgICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICAgIHRoaXMudGhpY2tuZXNzIHx8PSBJbmtFZGl0b3IuX2RlZmF1bHRUaGlja25lc3M7XG4gICAgICB0aGlzLmNvbG9yIHx8PSBJbmtFZGl0b3IuX2RlZmF1bHRDb2xvciB8fCBfZWRpdG9yLkFubm90YXRpb25FZGl0b3IuX2RlZmF1bHRMaW5lQ29sb3I7XG4gICAgICB0aGlzLm9wYWNpdHkgPz89IElua0VkaXRvci5fZGVmYXVsdE9wYWNpdHk7XG4gICAgfVxuICAgIHRoaXMuY3VycmVudFBhdGgucHVzaChbeCwgeV0pO1xuICAgIHRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdyA9IGZhbHNlO1xuICAgIHRoaXMuI3NldFN0cm9rZSgpO1xuICAgIHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrID0gKCkgPT4ge1xuICAgICAgdGhpcy4jZHJhd1BvaW50cygpO1xuICAgICAgaWYgKHRoaXMuI3JlcXVlc3RGcmFtZUNhbGxiYWNrKSB7XG4gICAgICAgIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2spO1xuICAgICAgfVxuICAgIH07XG4gICAgd2luZG93LnJlcXVlc3RBbmltYXRpb25GcmFtZSh0aGlzLiNyZXF1ZXN0RnJhbWVDYWxsYmFjayk7XG4gIH1cbiAgI2RyYXcoeCwgeSkge1xuICAgIGNvbnN0IFtsYXN0WCwgbGFzdFldID0gdGhpcy5jdXJyZW50UGF0aC5hdCgtMSk7XG4gICAgaWYgKHRoaXMuY3VycmVudFBhdGgubGVuZ3RoID4gMSAmJiB4ID09PSBsYXN0WCAmJiB5ID09PSBsYXN0WSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBjdXJyZW50UGF0aCA9IHRoaXMuY3VycmVudFBhdGg7XG4gICAgbGV0IHBhdGgyRCA9IHRoaXMuI2N1cnJlbnRQYXRoMkQ7XG4gICAgY3VycmVudFBhdGgucHVzaChbeCwgeV0pO1xuICAgIHRoaXMuI2hhc1NvbWV0aGluZ1RvRHJhdyA9IHRydWU7XG4gICAgaWYgKGN1cnJlbnRQYXRoLmxlbmd0aCA8PSAyKSB7XG4gICAgICBwYXRoMkQubW92ZVRvKC4uLmN1cnJlbnRQYXRoWzBdKTtcbiAgICAgIHBhdGgyRC5saW5lVG8oeCwgeSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmIChjdXJyZW50UGF0aC5sZW5ndGggPT09IDMpIHtcbiAgICAgIHRoaXMuI2N1cnJlbnRQYXRoMkQgPSBwYXRoMkQgPSBuZXcgUGF0aDJEKCk7XG4gICAgICBwYXRoMkQubW92ZVRvKC4uLmN1cnJlbnRQYXRoWzBdKTtcbiAgICB9XG4gICAgdGhpcy4jbWFrZUJlemllckN1cnZlKHBhdGgyRCwgLi4uY3VycmVudFBhdGguYXQoLTMpLCAuLi5jdXJyZW50UGF0aC5hdCgtMiksIHgsIHkpO1xuICB9XG4gICNlbmRQYXRoKCkge1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLmxlbmd0aCA9PT0gMCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBsYXN0UG9pbnQgPSB0aGlzLmN1cnJlbnRQYXRoLmF0KC0xKTtcbiAgICB0aGlzLiNjdXJyZW50UGF0aDJELmxpbmVUbyguLi5sYXN0UG9pbnQpO1xuICB9XG4gICNzdG9wRHJhd2luZyh4LCB5KSB7XG4gICAgdGhpcy4jcmVxdWVzdEZyYW1lQ2FsbGJhY2sgPSBudWxsO1xuICAgIHggPSBNYXRoLm1pbihNYXRoLm1heCh4LCAwKSwgdGhpcy5jYW52YXMud2lkdGgpO1xuICAgIHkgPSBNYXRoLm1pbihNYXRoLm1heCh5LCAwKSwgdGhpcy5jYW52YXMuaGVpZ2h0KTtcbiAgICB0aGlzLiNkcmF3KHgsIHkpO1xuICAgIHRoaXMuI2VuZFBhdGgoKTtcbiAgICBsZXQgYmV6aWVyO1xuICAgIGlmICh0aGlzLmN1cnJlbnRQYXRoLmxlbmd0aCAhPT0gMSkge1xuICAgICAgYmV6aWVyID0gdGhpcy4jZ2VuZXJhdGVCZXppZXJQb2ludHMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgeHkgPSBbeCwgeV07XG4gICAgICBiZXppZXIgPSBbW3h5LCB4eS5zbGljZSgpLCB4eS5zbGljZSgpLCB4eV1dO1xuICAgIH1cbiAgICBjb25zdCBwYXRoMkQgPSB0aGlzLiNjdXJyZW50UGF0aDJEO1xuICAgIGNvbnN0IGN1cnJlbnRQYXRoID0gdGhpcy5jdXJyZW50UGF0aDtcbiAgICB0aGlzLmN1cnJlbnRQYXRoID0gW107XG4gICAgdGhpcy4jY3VycmVudFBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgICBjb25zdCBjbWQgPSAoKSA9PiB7XG4gICAgICB0aGlzLmFsbFJhd1BhdGhzLnB1c2goY3VycmVudFBhdGgpO1xuICAgICAgdGhpcy5wYXRocy5wdXNoKGJlemllcik7XG4gICAgICB0aGlzLmJlemllclBhdGgyRC5wdXNoKHBhdGgyRCk7XG4gICAgICB0aGlzLnJlYnVpbGQoKTtcbiAgICB9O1xuICAgIGNvbnN0IHVuZG8gPSAoKSA9PiB7XG4gICAgICB0aGlzLmFsbFJhd1BhdGhzLnBvcCgpO1xuICAgICAgdGhpcy5wYXRocy5wb3AoKTtcbiAgICAgIHRoaXMuYmV6aWVyUGF0aDJELnBvcCgpO1xuICAgICAgaWYgKHRoaXMucGF0aHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAoIXRoaXMuY2FudmFzKSB7XG4gICAgICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgICAgICAgdGhpcy4jY3JlYXRlT2JzZXJ2ZXIoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLiNmaXRUb0NvbnRlbnQoKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIHRoaXMuYWRkQ29tbWFuZHMoe1xuICAgICAgY21kLFxuICAgICAgdW5kbyxcbiAgICAgIG11c3RFeGVjOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgI2RyYXdQb2ludHMoKSB7XG4gICAgaWYgKCF0aGlzLiNoYXNTb21ldGhpbmdUb0RyYXcpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jaGFzU29tZXRoaW5nVG9EcmF3ID0gZmFsc2U7XG4gICAgY29uc3QgdGhpY2tuZXNzID0gTWF0aC5jZWlsKHRoaXMudGhpY2tuZXNzICogdGhpcy5wYXJlbnRTY2FsZSk7XG4gICAgY29uc3QgbGFzdFBvaW50cyA9IHRoaXMuY3VycmVudFBhdGguc2xpY2UoLTMpO1xuICAgIGNvbnN0IHggPSBsYXN0UG9pbnRzLm1hcCh4eSA9PiB4eVswXSk7XG4gICAgY29uc3QgeSA9IGxhc3RQb2ludHMubWFwKHh5ID0+IHh5WzFdKTtcbiAgICBjb25zdCB4TWluID0gTWF0aC5taW4oLi4ueCkgLSB0aGlja25lc3M7XG4gICAgY29uc3QgeE1heCA9IE1hdGgubWF4KC4uLngpICsgdGhpY2tuZXNzO1xuICAgIGNvbnN0IHlNaW4gPSBNYXRoLm1pbiguLi55KSAtIHRoaWNrbmVzcztcbiAgICBjb25zdCB5TWF4ID0gTWF0aC5tYXgoLi4ueSkgKyB0aGlja25lc3M7XG4gICAgY29uc3Qge1xuICAgICAgY3R4XG4gICAgfSA9IHRoaXM7XG4gICAgY3R4LnNhdmUoKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIHRoaXMuY2FudmFzLndpZHRoLCB0aGlzLmNhbnZhcy5oZWlnaHQpO1xuICAgIGZvciAoY29uc3QgcGF0aCBvZiB0aGlzLmJlemllclBhdGgyRCkge1xuICAgICAgY3R4LnN0cm9rZShwYXRoKTtcbiAgICB9XG4gICAgY3R4LnN0cm9rZSh0aGlzLiNjdXJyZW50UGF0aDJEKTtcbiAgICBjdHgucmVzdG9yZSgpO1xuICB9XG4gICNtYWtlQmV6aWVyQ3VydmUocGF0aDJELCB4MCwgeTAsIHgxLCB5MSwgeDIsIHkyKSB7XG4gICAgY29uc3QgcHJldlggPSAoeDAgKyB4MSkgLyAyO1xuICAgIGNvbnN0IHByZXZZID0gKHkwICsgeTEpIC8gMjtcbiAgICBjb25zdCB4MyA9ICh4MSArIHgyKSAvIDI7XG4gICAgY29uc3QgeTMgPSAoeTEgKyB5MikgLyAyO1xuICAgIHBhdGgyRC5iZXppZXJDdXJ2ZVRvKHByZXZYICsgMiAqICh4MSAtIHByZXZYKSAvIDMsIHByZXZZICsgMiAqICh5MSAtIHByZXZZKSAvIDMsIHgzICsgMiAqICh4MSAtIHgzKSAvIDMsIHkzICsgMiAqICh5MSAtIHkzKSAvIDMsIHgzLCB5Myk7XG4gIH1cbiAgI2dlbmVyYXRlQmV6aWVyUG9pbnRzKCkge1xuICAgIGNvbnN0IHBhdGggPSB0aGlzLmN1cnJlbnRQYXRoO1xuICAgIGlmIChwYXRoLmxlbmd0aCA8PSAyKSB7XG4gICAgICByZXR1cm4gW1twYXRoWzBdLCBwYXRoWzBdLCBwYXRoLmF0KC0xKSwgcGF0aC5hdCgtMSldXTtcbiAgICB9XG4gICAgY29uc3QgYmV6aWVyUG9pbnRzID0gW107XG4gICAgbGV0IGk7XG4gICAgbGV0IFt4MCwgeTBdID0gcGF0aFswXTtcbiAgICBmb3IgKGkgPSAxOyBpIDwgcGF0aC5sZW5ndGggLSAyOyBpKyspIHtcbiAgICAgIGNvbnN0IFt4MSwgeTFdID0gcGF0aFtpXTtcbiAgICAgIGNvbnN0IFt4MiwgeTJdID0gcGF0aFtpICsgMV07XG4gICAgICBjb25zdCB4MyA9ICh4MSArIHgyKSAvIDI7XG4gICAgICBjb25zdCB5MyA9ICh5MSArIHkyKSAvIDI7XG4gICAgICBjb25zdCBjb250cm9sMSA9IFt4MCArIDIgKiAoeDEgLSB4MCkgLyAzLCB5MCArIDIgKiAoeTEgLSB5MCkgLyAzXTtcbiAgICAgIGNvbnN0IGNvbnRyb2wyID0gW3gzICsgMiAqICh4MSAtIHgzKSAvIDMsIHkzICsgMiAqICh5MSAtIHkzKSAvIDNdO1xuICAgICAgYmV6aWVyUG9pbnRzLnB1c2goW1t4MCwgeTBdLCBjb250cm9sMSwgY29udHJvbDIsIFt4MywgeTNdXSk7XG4gICAgICBbeDAsIHkwXSA9IFt4MywgeTNdO1xuICAgIH1cbiAgICBjb25zdCBbeDEsIHkxXSA9IHBhdGhbaV07XG4gICAgY29uc3QgW3gyLCB5Ml0gPSBwYXRoW2kgKyAxXTtcbiAgICBjb25zdCBjb250cm9sMSA9IFt4MCArIDIgKiAoeDEgLSB4MCkgLyAzLCB5MCArIDIgKiAoeTEgLSB5MCkgLyAzXTtcbiAgICBjb25zdCBjb250cm9sMiA9IFt4MiArIDIgKiAoeDEgLSB4MikgLyAzLCB5MiArIDIgKiAoeTEgLSB5MikgLyAzXTtcbiAgICBiZXppZXJQb2ludHMucHVzaChbW3gwLCB5MF0sIGNvbnRyb2wxLCBjb250cm9sMiwgW3gyLCB5Ml1dKTtcbiAgICByZXR1cm4gYmV6aWVyUG9pbnRzO1xuICB9XG4gICNyZWRyYXcoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdGhpcy4jc2V0U3Ryb2tlKCk7XG4gICAgY29uc3Qge1xuICAgICAgY2FudmFzLFxuICAgICAgY3R4XG4gICAgfSA9IHRoaXM7XG4gICAgY3R4LnNldFRyYW5zZm9ybSgxLCAwLCAwLCAxLCAwLCAwKTtcbiAgICBjdHguY2xlYXJSZWN0KDAsIDAsIGNhbnZhcy53aWR0aCwgY2FudmFzLmhlaWdodCk7XG4gICAgdGhpcy4jdXBkYXRlVHJhbnNmb3JtKCk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMuYmV6aWVyUGF0aDJEKSB7XG4gICAgICBjdHguc3Ryb2tlKHBhdGgpO1xuICAgIH1cbiAgfVxuICBjb21taXQoKSB7XG4gICAgaWYgKHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHN1cGVyLmNvbW1pdCgpO1xuICAgIHRoaXMuaXNFZGl0aW5nID0gZmFsc2U7XG4gICAgdGhpcy5kaXNhYmxlRWRpdE1vZGUoKTtcbiAgICB0aGlzLnNldEluRm9yZWdyb3VuZCgpO1xuICAgIHRoaXMuI2Rpc2FibGVFZGl0aW5nID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5jbGFzc0xpc3QuYWRkKFwiZGlzYWJsZWRcIik7XG4gICAgdGhpcy4jZml0VG9Db250ZW50KHRydWUpO1xuICAgIHRoaXMubWFrZVJlc2l6YWJsZSgpO1xuICAgIHRoaXMucGFyZW50LmFkZElua0VkaXRvcklmTmVlZGVkKHRydWUpO1xuICAgIHRoaXMubW92ZUluRE9NKCk7XG4gICAgdGhpcy5kaXYuZm9jdXMoe1xuICAgICAgcHJldmVudFNjcm9sbDogdHJ1ZVxuICAgIH0pO1xuICB9XG4gIGZvY3VzaW4oZXZlbnQpIHtcbiAgICBpZiAoIXRoaXMuX2ZvY3VzRXZlbnRzQWxsb3dlZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5mb2N1c2luKGV2ZW50KTtcbiAgICB0aGlzLmVuYWJsZUVkaXRNb2RlKCk7XG4gIH1cbiAgY2FudmFzUG9pbnRlcmRvd24oZXZlbnQpIHtcbiAgICBpZiAoZXZlbnQuYnV0dG9uICE9PSAwIHx8ICF0aGlzLmlzSW5FZGl0TW9kZSgpIHx8IHRoaXMuI2Rpc2FibGVFZGl0aW5nKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuc2V0SW5Gb3JlZ3JvdW5kKCk7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICBpZiAoZXZlbnQudHlwZSAhPT0gXCJtb3VzZVwiKSB7XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgICB0aGlzLiNzdGFydERyYXdpbmcoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gIH1cbiAgY2FudmFzUG9pbnRlcm1vdmUoZXZlbnQpIHtcbiAgICBldmVudC5wcmV2ZW50RGVmYXVsdCgpO1xuICAgIHRoaXMuI2RyYXcoZXZlbnQub2Zmc2V0WCwgZXZlbnQub2Zmc2V0WSk7XG4gIH1cbiAgY2FudmFzUG9pbnRlcnVwKGV2ZW50KSB7XG4gICAgZXZlbnQucHJldmVudERlZmF1bHQoKTtcbiAgICB0aGlzLiNlbmREcmF3aW5nKGV2ZW50KTtcbiAgfVxuICBjYW52YXNQb2ludGVybGVhdmUoZXZlbnQpIHtcbiAgICB0aGlzLiNlbmREcmF3aW5nKGV2ZW50KTtcbiAgfVxuICAjZW5kRHJhd2luZyhldmVudCkge1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybGVhdmVcIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVybGVhdmUpO1xuICAgIHRoaXMuY2FudmFzLnJlbW92ZUV2ZW50TGlzdGVuZXIoXCJwb2ludGVybW92ZVwiLCB0aGlzLiNib3VuZENhbnZhc1BvaW50ZXJtb3ZlKTtcbiAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwicG9pbnRlcnVwXCIsIHRoaXMuI2JvdW5kQ2FudmFzUG9pbnRlcnVwKTtcbiAgICB0aGlzLmNhbnZhcy5hZGRFdmVudExpc3RlbmVyKFwicG9pbnRlcmRvd25cIiwgdGhpcy4jYm91bmRDYW52YXNQb2ludGVyZG93bik7XG4gICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICB0aGlzLmNhbnZhcy5yZW1vdmVFdmVudExpc3RlbmVyKFwiY29udGV4dG1lbnVcIiwgX2Rpc3BsYXlfdXRpbHMubm9Db250ZXh0TWVudSk7XG4gICAgfSwgMTApO1xuICAgIHRoaXMuI3N0b3BEcmF3aW5nKGV2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFkpO1xuICAgIHRoaXMuYWRkVG9Bbm5vdGF0aW9uU3RvcmFnZSgpO1xuICAgIHRoaXMuc2V0SW5CYWNrZ3JvdW5kKCk7XG4gIH1cbiAgI2NyZWF0ZUNhbnZhcygpIHtcbiAgICB0aGlzLmNhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgdGhpcy5jYW52YXMud2lkdGggPSB0aGlzLmNhbnZhcy5oZWlnaHQgPSAwO1xuICAgIHRoaXMuY2FudmFzLmNsYXNzTmFtZSA9IFwiaW5rRWRpdG9yQ2FudmFzXCI7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfaW5rX2NhbnZhc19hcmlhX2xhYmVsXCIpLnRoZW4obXNnID0+IHRoaXMuY2FudmFzPy5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG1zZykpO1xuICAgIHRoaXMuZGl2LmFwcGVuZCh0aGlzLmNhbnZhcyk7XG4gICAgdGhpcy5jdHggPSB0aGlzLmNhbnZhcy5nZXRDb250ZXh0KFwiMmRcIik7XG4gIH1cbiAgI2NyZWF0ZU9ic2VydmVyKCkge1xuICAgIHRoaXMuI29ic2VydmVyID0gbmV3IFJlc2l6ZU9ic2VydmVyKGVudHJpZXMgPT4ge1xuICAgICAgY29uc3QgcmVjdCA9IGVudHJpZXNbMF0uY29udGVudFJlY3Q7XG4gICAgICBpZiAocmVjdC53aWR0aCAmJiByZWN0LmhlaWdodCkge1xuICAgICAgICB0aGlzLnNldERpbWVuc2lvbnMocmVjdC53aWR0aCwgcmVjdC5oZWlnaHQpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuI29ic2VydmVyLm9ic2VydmUodGhpcy5kaXYpO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gIXRoaXMuaXNFbXB0eSgpICYmIHRoaXMuI2Rpc2FibGVFZGl0aW5nO1xuICB9XG4gIHJlbmRlcigpIHtcbiAgICBpZiAodGhpcy5kaXYpIHtcbiAgICAgIHJldHVybiB0aGlzLmRpdjtcbiAgICB9XG4gICAgbGV0IGJhc2VYLCBiYXNlWTtcbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgYmFzZVggPSB0aGlzLng7XG4gICAgICBiYXNlWSA9IHRoaXMueTtcbiAgICB9XG4gICAgc3VwZXIucmVuZGVyKCk7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLl9sMTBuUHJvbWlzZS5nZXQoXCJlZGl0b3JfaW5rMl9hcmlhX2xhYmVsXCIpLnRoZW4obXNnID0+IHRoaXMuZGl2Py5zZXRBdHRyaWJ1dGUoXCJhcmlhLWxhYmVsXCIsIG1zZykpO1xuICAgIGNvbnN0IFt4LCB5LCB3LCBoXSA9IHRoaXMuI2dldEluaXRpYWxCQm94KCk7XG4gICAgdGhpcy5zZXRBdCh4LCB5LCAwLCAwKTtcbiAgICB0aGlzLnNldERpbXModywgaCk7XG4gICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICAgIHRoaXMuc2V0QXNwZWN0UmF0aW8odGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgICB0aGlzLnNldEF0KGJhc2VYICogcGFyZW50V2lkdGgsIGJhc2VZICogcGFyZW50SGVpZ2h0LCB0aGlzLndpZHRoICogcGFyZW50V2lkdGgsIHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICAgIHRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQgPSB0cnVlO1xuICAgICAgdGhpcy4jc2V0Q2FudmFzRGltcygpO1xuICAgICAgdGhpcy5zZXREaW1zKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCwgdGhpcy5oZWlnaHQgKiBwYXJlbnRIZWlnaHQpO1xuICAgICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgICB0aGlzLmRpdi5jbGFzc0xpc3QuYWRkKFwiZGlzYWJsZWRcIik7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuZGl2LmNsYXNzTGlzdC5hZGQoXCJlZGl0aW5nXCIpO1xuICAgICAgdGhpcy5lbmFibGVFZGl0TW9kZSgpO1xuICAgIH1cbiAgICB0aGlzLiNjcmVhdGVPYnNlcnZlcigpO1xuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICAjc2V0Q2FudmFzRGltcygpIHtcbiAgICBpZiAoIXRoaXMuI2lzQ2FudmFzSW5pdGlhbGl6ZWQpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgIHRoaXMuY2FudmFzLndpZHRoID0gTWF0aC5jZWlsKHRoaXMud2lkdGggKiBwYXJlbnRXaWR0aCk7XG4gICAgdGhpcy5jYW52YXMuaGVpZ2h0ID0gTWF0aC5jZWlsKHRoaXMuaGVpZ2h0ICogcGFyZW50SGVpZ2h0KTtcbiAgICB0aGlzLiN1cGRhdGVUcmFuc2Zvcm0oKTtcbiAgfVxuICBzZXREaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCByb3VuZGVkV2lkdGggPSBNYXRoLnJvdW5kKHdpZHRoKTtcbiAgICBjb25zdCByb3VuZGVkSGVpZ2h0ID0gTWF0aC5yb3VuZChoZWlnaHQpO1xuICAgIGlmICh0aGlzLiNyZWFsV2lkdGggPT09IHJvdW5kZWRXaWR0aCAmJiB0aGlzLiNyZWFsSGVpZ2h0ID09PSByb3VuZGVkSGVpZ2h0KSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI3JlYWxXaWR0aCA9IHJvdW5kZWRXaWR0aDtcbiAgICB0aGlzLiNyZWFsSGVpZ2h0ID0gcm91bmRlZEhlaWdodDtcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gXCJoaWRkZW5cIjtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIGlmICh0aGlzLiNkaXNhYmxlRWRpdGluZykge1xuICAgICAgdGhpcy4jc2V0U2NhbGVGYWN0b3Iod2lkdGgsIGhlaWdodCk7XG4gICAgfVxuICAgIHRoaXMuI3NldENhbnZhc0RpbXMoKTtcbiAgICB0aGlzLiNyZWRyYXcoKTtcbiAgICB0aGlzLmNhbnZhcy5zdHlsZS52aXNpYmlsaXR5ID0gXCJ2aXNpYmxlXCI7XG4gICAgdGhpcy5maXhEaW1zKCk7XG4gIH1cbiAgI3NldFNjYWxlRmFjdG9yKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy4jZ2V0UGFkZGluZygpO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9yVyA9ICh3aWR0aCAtIHBhZGRpbmcpIC8gdGhpcy4jYmFzZVdpZHRoO1xuICAgIGNvbnN0IHNjYWxlRmFjdG9ySCA9IChoZWlnaHQgLSBwYWRkaW5nKSAvIHRoaXMuI2Jhc2VIZWlnaHQ7XG4gICAgdGhpcy5zY2FsZUZhY3RvciA9IE1hdGgubWluKHNjYWxlRmFjdG9yVywgc2NhbGVGYWN0b3JIKTtcbiAgfVxuICAjdXBkYXRlVHJhbnNmb3JtKCkge1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCkgLyAyO1xuICAgIHRoaXMuY3R4LnNldFRyYW5zZm9ybSh0aGlzLnNjYWxlRmFjdG9yLCAwLCAwLCB0aGlzLnNjYWxlRmFjdG9yLCB0aGlzLnRyYW5zbGF0aW9uWCAqIHRoaXMuc2NhbGVGYWN0b3IgKyBwYWRkaW5nLCB0aGlzLnRyYW5zbGF0aW9uWSAqIHRoaXMuc2NhbGVGYWN0b3IgKyBwYWRkaW5nKTtcbiAgfVxuICBzdGF0aWMgI2J1aWxkUGF0aDJEKGJlemllcikge1xuICAgIGNvbnN0IHBhdGgyRCA9IG5ldyBQYXRoMkQoKTtcbiAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBiZXppZXIubGVuZ3RoOyBpIDwgaWk7IGkrKykge1xuICAgICAgY29uc3QgW2ZpcnN0LCBjb250cm9sMSwgY29udHJvbDIsIHNlY29uZF0gPSBiZXppZXJbaV07XG4gICAgICBpZiAoaSA9PT0gMCkge1xuICAgICAgICBwYXRoMkQubW92ZVRvKC4uLmZpcnN0KTtcbiAgICAgIH1cbiAgICAgIHBhdGgyRC5iZXppZXJDdXJ2ZVRvKGNvbnRyb2wxWzBdLCBjb250cm9sMVsxXSwgY29udHJvbDJbMF0sIGNvbnRyb2wyWzFdLCBzZWNvbmRbMF0sIHNlY29uZFsxXSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRoMkQ7XG4gIH1cbiAgc3RhdGljICN0b1BERkNvb3JkaW5hdGVzKHBvaW50cywgcmVjdCwgcm90YXRpb24pIHtcbiAgICBjb25zdCBbYmxYLCBibFksIHRyWCwgdHJZXSA9IHJlY3Q7XG4gICAgc3dpdGNoIChyb3RhdGlvbikge1xuICAgICAgY2FzZSAwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIHBvaW50c1tpXSArPSBibFg7XG4gICAgICAgICAgcG9pbnRzW2kgKyAxXSA9IHRyWSAtIHBvaW50c1tpICsgMV07XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlIDkwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2ldID0gcG9pbnRzW2kgKyAxXSArIGJsWDtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0geCArIGJsWTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMTgwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIHBvaW50c1tpXSA9IHRyWCAtIHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaSArIDFdICs9IGJsWTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgMjcwOlxuICAgICAgICBmb3IgKGxldCBpID0gMCwgaWkgPSBwb2ludHMubGVuZ3RoOyBpIDwgaWk7IGkgKz0gMikge1xuICAgICAgICAgIGNvbnN0IHggPSBwb2ludHNbaV07XG4gICAgICAgICAgcG9pbnRzW2ldID0gdHJYIC0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0gdHJZIC0geDtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcm90YXRpb25cIik7XG4gICAgfVxuICAgIHJldHVybiBwb2ludHM7XG4gIH1cbiAgc3RhdGljICNmcm9tUERGQ29vcmRpbmF0ZXMocG9pbnRzLCByZWN0LCByb3RhdGlvbikge1xuICAgIGNvbnN0IFtibFgsIGJsWSwgdHJYLCB0clldID0gcmVjdDtcbiAgICBzd2l0Y2ggKHJvdGF0aW9uKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldIC09IGJsWDtcbiAgICAgICAgICBwb2ludHNbaSArIDFdID0gdHJZIC0gcG9pbnRzW2kgKyAxXTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgOTA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSBwb2ludHNbaSArIDFdIC0gYmxZO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB4IC0gYmxYO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAxODA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgcG9pbnRzW2ldID0gdHJYIC0gcG9pbnRzW2ldO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gLT0gYmxZO1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSAyNzA6XG4gICAgICAgIGZvciAobGV0IGkgPSAwLCBpaSA9IHBvaW50cy5sZW5ndGg7IGkgPCBpaTsgaSArPSAyKSB7XG4gICAgICAgICAgY29uc3QgeCA9IHBvaW50c1tpXTtcbiAgICAgICAgICBwb2ludHNbaV0gPSB0clkgLSBwb2ludHNbaSArIDFdO1xuICAgICAgICAgIHBvaW50c1tpICsgMV0gPSB0clggLSB4O1xuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgZGVmYXVsdDpcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCByb3RhdGlvblwiKTtcbiAgICB9XG4gICAgcmV0dXJuIHBvaW50cztcbiAgfVxuICAjc2VyaWFsaXplUGF0aHMocywgdHgsIHR5LCByZWN0KSB7XG4gICAgY29uc3QgcGF0aHMgPSBbXTtcbiAgICBjb25zdCBwYWRkaW5nID0gdGhpcy50aGlja25lc3MgLyAyO1xuICAgIGNvbnN0IHNoaWZ0WCA9IHMgKiB0eCArIHBhZGRpbmc7XG4gICAgY29uc3Qgc2hpZnRZID0gcyAqIHR5ICsgcGFkZGluZztcbiAgICBmb3IgKGNvbnN0IGJlemllciBvZiB0aGlzLnBhdGhzKSB7XG4gICAgICBjb25zdCBidWZmZXIgPSBbXTtcbiAgICAgIGNvbnN0IHBvaW50cyA9IFtdO1xuICAgICAgZm9yIChsZXQgaiA9IDAsIGpqID0gYmV6aWVyLmxlbmd0aDsgaiA8IGpqOyBqKyspIHtcbiAgICAgICAgY29uc3QgW2ZpcnN0LCBjb250cm9sMSwgY29udHJvbDIsIHNlY29uZF0gPSBiZXppZXJbal07XG4gICAgICAgIGNvbnN0IHAxMCA9IHMgKiBmaXJzdFswXSArIHNoaWZ0WDtcbiAgICAgICAgY29uc3QgcDExID0gcyAqIGZpcnN0WzFdICsgc2hpZnRZO1xuICAgICAgICBjb25zdCBwMjAgPSBzICogY29udHJvbDFbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHAyMSA9IHMgKiBjb250cm9sMVsxXSArIHNoaWZ0WTtcbiAgICAgICAgY29uc3QgcDMwID0gcyAqIGNvbnRyb2wyWzBdICsgc2hpZnRYO1xuICAgICAgICBjb25zdCBwMzEgPSBzICogY29udHJvbDJbMV0gKyBzaGlmdFk7XG4gICAgICAgIGNvbnN0IHA0MCA9IHMgKiBzZWNvbmRbMF0gKyBzaGlmdFg7XG4gICAgICAgIGNvbnN0IHA0MSA9IHMgKiBzZWNvbmRbMV0gKyBzaGlmdFk7XG4gICAgICAgIGlmIChqID09PSAwKSB7XG4gICAgICAgICAgYnVmZmVyLnB1c2gocDEwLCBwMTEpO1xuICAgICAgICAgIHBvaW50cy5wdXNoKHAxMCwgcDExKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIucHVzaChwMjAsIHAyMSwgcDMwLCBwMzEsIHA0MCwgcDQxKTtcbiAgICAgICAgcG9pbnRzLnB1c2gocDIwLCBwMjEpO1xuICAgICAgICBpZiAoaiA9PT0gamogLSAxKSB7XG4gICAgICAgICAgcG9pbnRzLnB1c2gocDQwLCBwNDEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBwYXRocy5wdXNoKHtcbiAgICAgICAgYmV6aWVyOiBJbmtFZGl0b3IuI3RvUERGQ29vcmRpbmF0ZXMoYnVmZmVyLCByZWN0LCB0aGlzLnJvdGF0aW9uKSxcbiAgICAgICAgcG9pbnRzOiBJbmtFZGl0b3IuI3RvUERGQ29vcmRpbmF0ZXMocG9pbnRzLCByZWN0LCB0aGlzLnJvdGF0aW9uKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwYXRocztcbiAgfVxuICAjZ2V0QmJveCgpIHtcbiAgICBsZXQgeE1pbiA9IEluZmluaXR5O1xuICAgIGxldCB4TWF4ID0gLUluZmluaXR5O1xuICAgIGxldCB5TWluID0gSW5maW5pdHk7XG4gICAgbGV0IHlNYXggPSAtSW5maW5pdHk7XG4gICAgZm9yIChjb25zdCBwYXRoIG9mIHRoaXMucGF0aHMpIHtcbiAgICAgIGZvciAoY29uc3QgW2ZpcnN0LCBjb250cm9sMSwgY29udHJvbDIsIHNlY29uZF0gb2YgcGF0aCkge1xuICAgICAgICBjb25zdCBiYm94ID0gX3V0aWwuVXRpbC5iZXppZXJCb3VuZGluZ0JveCguLi5maXJzdCwgLi4uY29udHJvbDEsIC4uLmNvbnRyb2wyLCAuLi5zZWNvbmQpO1xuICAgICAgICB4TWluID0gTWF0aC5taW4oeE1pbiwgYmJveFswXSk7XG4gICAgICAgIHlNaW4gPSBNYXRoLm1pbih5TWluLCBiYm94WzFdKTtcbiAgICAgICAgeE1heCA9IE1hdGgubWF4KHhNYXgsIGJib3hbMl0pO1xuICAgICAgICB5TWF4ID0gTWF0aC5tYXgoeU1heCwgYmJveFszXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBbeE1pbiwgeU1pbiwgeE1heCwgeU1heF07XG4gIH1cbiAgI2dldFBhZGRpbmcoKSB7XG4gICAgcmV0dXJuIHRoaXMuI2Rpc2FibGVFZGl0aW5nID8gTWF0aC5jZWlsKHRoaXMudGhpY2tuZXNzICogdGhpcy5wYXJlbnRTY2FsZSkgOiAwO1xuICB9XG4gICNmaXRUb0NvbnRlbnQoKSB7XG4gICAgbGV0IGZpcnN0VGltZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDogZmFsc2U7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICghdGhpcy4jZGlzYWJsZUVkaXRpbmcpIHtcbiAgICAgIHRoaXMuI3JlZHJhdygpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBiYm94ID0gdGhpcy4jZ2V0QmJveCgpO1xuICAgIGNvbnN0IHBhZGRpbmcgPSB0aGlzLiNnZXRQYWRkaW5nKCk7XG4gICAgdGhpcy4jYmFzZVdpZHRoID0gTWF0aC5tYXgoX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLk1JTl9TSVpFLCBiYm94WzJdIC0gYmJveFswXSk7XG4gICAgdGhpcy4jYmFzZUhlaWdodCA9IE1hdGgubWF4KF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFszXSAtIGJib3hbMV0pO1xuICAgIGNvbnN0IHdpZHRoID0gTWF0aC5jZWlsKHBhZGRpbmcgKyB0aGlzLiNiYXNlV2lkdGggKiB0aGlzLnNjYWxlRmFjdG9yKTtcbiAgICBjb25zdCBoZWlnaHQgPSBNYXRoLmNlaWwocGFkZGluZyArIHRoaXMuI2Jhc2VIZWlnaHQgKiB0aGlzLnNjYWxlRmFjdG9yKTtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy5zZXRBc3BlY3RSYXRpbyh3aWR0aCwgaGVpZ2h0KTtcbiAgICBjb25zdCBwcmV2VHJhbnNsYXRpb25YID0gdGhpcy50cmFuc2xhdGlvblg7XG4gICAgY29uc3QgcHJldlRyYW5zbGF0aW9uWSA9IHRoaXMudHJhbnNsYXRpb25ZO1xuICAgIHRoaXMudHJhbnNsYXRpb25YID0gLWJib3hbMF07XG4gICAgdGhpcy50cmFuc2xhdGlvblkgPSAtYmJveFsxXTtcbiAgICB0aGlzLiNzZXRDYW52YXNEaW1zKCk7XG4gICAgdGhpcy4jcmVkcmF3KCk7XG4gICAgdGhpcy4jcmVhbFdpZHRoID0gd2lkdGg7XG4gICAgdGhpcy4jcmVhbEhlaWdodCA9IGhlaWdodDtcbiAgICB0aGlzLnNldERpbXMod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgdW5zY2FsZWRQYWRkaW5nID0gZmlyc3RUaW1lID8gcGFkZGluZyAvIHRoaXMuc2NhbGVGYWN0b3IgLyAyIDogMDtcbiAgICB0aGlzLnRyYW5zbGF0ZShwcmV2VHJhbnNsYXRpb25YIC0gdGhpcy50cmFuc2xhdGlvblggLSB1bnNjYWxlZFBhZGRpbmcsIHByZXZUcmFuc2xhdGlvblkgLSB0aGlzLnRyYW5zbGF0aW9uWSAtIHVuc2NhbGVkUGFkZGluZyk7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBfYW5ub3RhdGlvbl9sYXllci5JbmtBbm5vdGF0aW9uRWxlbWVudCkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuICAgIGNvbnN0IGVkaXRvciA9IHN1cGVyLmRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKTtcbiAgICBlZGl0b3IudGhpY2tuZXNzID0gZGF0YS50aGlja25lc3M7XG4gICAgZWRpdG9yLmNvbG9yID0gX3V0aWwuVXRpbC5tYWtlSGV4Q29sb3IoLi4uZGF0YS5jb2xvcik7XG4gICAgZWRpdG9yLm9wYWNpdHkgPSBkYXRhLm9wYWNpdHk7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSBlZGl0b3IucGFnZURpbWVuc2lvbnM7XG4gICAgY29uc3Qgd2lkdGggPSBlZGl0b3Iud2lkdGggKiBwYWdlV2lkdGg7XG4gICAgY29uc3QgaGVpZ2h0ID0gZWRpdG9yLmhlaWdodCAqIHBhZ2VIZWlnaHQ7XG4gICAgY29uc3Qgc2NhbGVGYWN0b3IgPSBlZGl0b3IucGFyZW50U2NhbGU7XG4gICAgY29uc3QgcGFkZGluZyA9IGRhdGEudGhpY2tuZXNzIC8gMjtcbiAgICBlZGl0b3IuI2Rpc2FibGVFZGl0aW5nID0gdHJ1ZTtcbiAgICBlZGl0b3IuI3JlYWxXaWR0aCA9IE1hdGgucm91bmQod2lkdGgpO1xuICAgIGVkaXRvci4jcmVhbEhlaWdodCA9IE1hdGgucm91bmQoaGVpZ2h0KTtcbiAgICBjb25zdCB7XG4gICAgICBwYXRocyxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvblxuICAgIH0gPSBkYXRhO1xuICAgIGZvciAobGV0IHtcbiAgICAgIGJlemllclxuICAgIH0gb2YgcGF0aHMpIHtcbiAgICAgIGJlemllciA9IElua0VkaXRvci4jZnJvbVBERkNvb3JkaW5hdGVzKGJlemllciwgcmVjdCwgcm90YXRpb24pO1xuICAgICAgY29uc3QgcGF0aCA9IFtdO1xuICAgICAgZWRpdG9yLnBhdGhzLnB1c2gocGF0aCk7XG4gICAgICBsZXQgcDAgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbMF0gLSBwYWRkaW5nKTtcbiAgICAgIGxldCBwMSA9IHNjYWxlRmFjdG9yICogKGJlemllclsxXSAtIHBhZGRpbmcpO1xuICAgICAgZm9yIChsZXQgaSA9IDIsIGlpID0gYmV6aWVyLmxlbmd0aDsgaSA8IGlpOyBpICs9IDYpIHtcbiAgICAgICAgY29uc3QgcDEwID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2ldIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAxMSA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgMV0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDIwID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyAyXSAtIHBhZGRpbmcpO1xuICAgICAgICBjb25zdCBwMjEgPSBzY2FsZUZhY3RvciAqIChiZXppZXJbaSArIDNdIC0gcGFkZGluZyk7XG4gICAgICAgIGNvbnN0IHAzMCA9IHNjYWxlRmFjdG9yICogKGJlemllcltpICsgNF0gLSBwYWRkaW5nKTtcbiAgICAgICAgY29uc3QgcDMxID0gc2NhbGVGYWN0b3IgKiAoYmV6aWVyW2kgKyA1XSAtIHBhZGRpbmcpO1xuICAgICAgICBwYXRoLnB1c2goW1twMCwgcDFdLCBbcDEwLCBwMTFdLCBbcDIwLCBwMjFdLCBbcDMwLCBwMzFdXSk7XG4gICAgICAgIHAwID0gcDMwO1xuICAgICAgICBwMSA9IHAzMTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhdGgyRCA9IHRoaXMuI2J1aWxkUGF0aDJEKHBhdGgpO1xuICAgICAgZWRpdG9yLmJlemllclBhdGgyRC5wdXNoKHBhdGgyRCk7XG4gICAgfVxuICAgIGNvbnN0IGJib3ggPSBlZGl0b3IuI2dldEJib3goKTtcbiAgICBlZGl0b3IuI2Jhc2VXaWR0aCA9IE1hdGgubWF4KF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFsyXSAtIGJib3hbMF0pO1xuICAgIGVkaXRvci4jYmFzZUhlaWdodCA9IE1hdGgubWF4KF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5NSU5fU0laRSwgYmJveFszXSAtIGJib3hbMV0pO1xuICAgIGVkaXRvci4jc2V0U2NhbGVGYWN0b3Iod2lkdGgsIGhlaWdodCk7XG4gICAgcmV0dXJuIGVkaXRvcjtcbiAgfVxuICBzZXJpYWxpemUoKSB7XG4gICAgaWYgKHRoaXMuaXNFbXB0eSgpKSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgcmVjdCA9IHRoaXMuZ2V0UmVjdCgwLCAwKTtcbiAgICBjb25zdCBjb2xvciA9IF9lZGl0b3IuQW5ub3RhdGlvbkVkaXRvci5fY29sb3JNYW5hZ2VyLmNvbnZlcnQodGhpcy5jdHguc3Ryb2tlU3R5bGUpO1xuICAgIHJldHVybiB7XG4gICAgICBhbm5vdGF0aW9uVHlwZTogX3V0aWwuQW5ub3RhdGlvbkVkaXRvclR5cGUuSU5LLFxuICAgICAgY29sb3IsXG4gICAgICB0aGlja25lc3M6IHRoaXMudGhpY2tuZXNzLFxuICAgICAgb3BhY2l0eTogdGhpcy5vcGFjaXR5LFxuICAgICAgcGF0aHM6IHRoaXMuI3NlcmlhbGl6ZVBhdGhzKHRoaXMuc2NhbGVGYWN0b3IgLyB0aGlzLnBhcmVudFNjYWxlLCB0aGlzLnRyYW5zbGF0aW9uWCwgdGhpcy50cmFuc2xhdGlvblksIHJlY3QpLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3QsXG4gICAgICByb3RhdGlvbjogdGhpcy5yb3RhdGlvbixcbiAgICAgIHN0cnVjdFRyZWVQYXJlbnRJZDogdGhpcy5fc3RydWN0VHJlZVBhcmVudElkXG4gICAgfTtcbiAgfVxufVxuZXhwb3J0cy5JbmtFZGl0b3IgPSBJbmtFZGl0b3I7XG5cbi8qKiovIH0pLFxuLyogMjAzICovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBleHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKSA9PiB7XG5cblxuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsICh7XG4gIHZhbHVlOiB0cnVlXG59KSk7XG5leHBvcnRzLlN0YW1wRWRpdG9yID0gdm9pZCAwO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNDkpO1xuX193X3BkZmpzX3JlcXVpcmVfXygxNTIpO1xudmFyIF91dGlsID0gX193X3BkZmpzX3JlcXVpcmVfXygxKTtcbnZhciBfZWRpdG9yID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjQpO1xudmFyIF9kaXNwbGF5X3V0aWxzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjgpO1xudmFyIF9hbm5vdGF0aW9uX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxOTgpO1xuY2xhc3MgU3RhbXBFZGl0b3IgZXh0ZW5kcyBfZWRpdG9yLkFubm90YXRpb25FZGl0b3Ige1xuICAjYml0bWFwID0gbnVsbDtcbiAgI2JpdG1hcElkID0gbnVsbDtcbiAgI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAjYml0bWFwVXJsID0gbnVsbDtcbiAgI2JpdG1hcEZpbGUgPSBudWxsO1xuICAjY2FudmFzID0gbnVsbDtcbiAgI29ic2VydmVyID0gbnVsbDtcbiAgI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICNpc1N2ZyA9IGZhbHNlO1xuICAjaGFzQmVlbkFkZGVkSW5VbmRvU3RhY2sgPSBmYWxzZTtcbiAgc3RhdGljIF90eXBlID0gXCJzdGFtcFwiO1xuICBjb25zdHJ1Y3RvcihwYXJhbXMpIHtcbiAgICBzdXBlcih7XG4gICAgICAuLi5wYXJhbXMsXG4gICAgICBuYW1lOiBcInN0YW1wRWRpdG9yXCJcbiAgICB9KTtcbiAgICB0aGlzLiNiaXRtYXBVcmwgPSBwYXJhbXMuYml0bWFwVXJsO1xuICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBwYXJhbXMuYml0bWFwRmlsZTtcbiAgfVxuICBzdGF0aWMgaW5pdGlhbGl6ZShsMTBuKSB7XG4gICAgX2VkaXRvci5Bbm5vdGF0aW9uRWRpdG9yLmluaXRpYWxpemUobDEwbik7XG4gIH1cbiAgc3RhdGljIGdldCBzdXBwb3J0ZWRUeXBlcygpIHtcbiAgICBjb25zdCB0eXBlcyA9IFtcImFwbmdcIiwgXCJhdmlmXCIsIFwiYm1wXCIsIFwiZ2lmXCIsIFwianBlZ1wiLCBcInBuZ1wiLCBcInN2Zyt4bWxcIiwgXCJ3ZWJwXCIsIFwieC1pY29uXCJdO1xuICAgIHJldHVybiAoMCwgX3V0aWwuc2hhZG93KSh0aGlzLCBcInN1cHBvcnRlZFR5cGVzXCIsIHR5cGVzLm1hcCh0eXBlID0+IGBpbWFnZS8ke3R5cGV9YCkpO1xuICB9XG4gIHN0YXRpYyBnZXQgc3VwcG9ydGVkVHlwZXNTdHIoKSB7XG4gICAgcmV0dXJuICgwLCBfdXRpbC5zaGFkb3cpKHRoaXMsIFwic3VwcG9ydGVkVHlwZXNTdHJcIiwgdGhpcy5zdXBwb3J0ZWRUeXBlcy5qb2luKFwiLFwiKSk7XG4gIH1cbiAgc3RhdGljIGlzSGFuZGxpbmdNaW1lRm9yUGFzdGluZyhtaW1lKSB7XG4gICAgcmV0dXJuIHRoaXMuc3VwcG9ydGVkVHlwZXMuaW5jbHVkZXMobWltZSk7XG4gIH1cbiAgc3RhdGljIHBhc3RlKGl0ZW0sIHBhcmVudCkge1xuICAgIHBhcmVudC5wYXN0ZUVkaXRvcihfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZS5TVEFNUCwge1xuICAgICAgYml0bWFwRmlsZTogaXRlbS5nZXRBc0ZpbGUoKVxuICAgIH0pO1xuICB9XG4gICNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpIHtcbiAgICBsZXQgZnJvbUlkID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiBmYWxzZTtcbiAgICBpZiAoIWRhdGEpIHtcbiAgICAgIHRoaXMucmVtb3ZlKCk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIHRoaXMuI2JpdG1hcCA9IGRhdGEuYml0bWFwO1xuICAgIGlmICghZnJvbUlkKSB7XG4gICAgICB0aGlzLiNiaXRtYXBJZCA9IGRhdGEuaWQ7XG4gICAgICB0aGlzLiNpc1N2ZyA9IGRhdGEuaXNTdmc7XG4gICAgfVxuICAgIHRoaXMuI2NyZWF0ZUNhbnZhcygpO1xuICB9XG4gICNnZXRCaXRtYXBEb25lKCkge1xuICAgIHRoaXMuI2JpdG1hcFByb21pc2UgPSBudWxsO1xuICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKGZhbHNlKTtcbiAgICBpZiAodGhpcy4jY2FudmFzKSB7XG4gICAgICB0aGlzLmRpdi5mb2N1cygpO1xuICAgIH1cbiAgfVxuICAjZ2V0Qml0bWFwKCkge1xuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLl91aU1hbmFnZXIuaW1hZ2VNYW5hZ2VyLmdldEZyb21JZCh0aGlzLiNiaXRtYXBJZCkudGhlbihkYXRhID0+IHRoaXMuI2dldEJpdG1hcEZldGNoZWQoZGF0YSwgdHJ1ZSkpLmZpbmFsbHkoKCkgPT4gdGhpcy4jZ2V0Qml0bWFwRG9uZSgpKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2JpdG1hcFVybCkge1xuICAgICAgY29uc3QgdXJsID0gdGhpcy4jYml0bWFwVXJsO1xuICAgICAgdGhpcy4jYml0bWFwVXJsID0gbnVsbDtcbiAgICAgIHRoaXMuX3VpTWFuYWdlci5lbmFibGVXYWl0aW5nKHRydWUpO1xuICAgICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IHRoaXMuX3VpTWFuYWdlci5pbWFnZU1hbmFnZXIuZ2V0RnJvbVVybCh1cmwpLnRoZW4oZGF0YSA9PiB0aGlzLiNnZXRCaXRtYXBGZXRjaGVkKGRhdGEpKS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBGaWxlKSB7XG4gICAgICBjb25zdCBmaWxlID0gdGhpcy4jYml0bWFwRmlsZTtcbiAgICAgIHRoaXMuI2JpdG1hcEZpbGUgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcodHJ1ZSk7XG4gICAgICB0aGlzLiNiaXRtYXBQcm9taXNlID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShmaWxlKS50aGVuKGRhdGEgPT4gdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKSkuZmluYWxseSgoKSA9PiB0aGlzLiNnZXRCaXRtYXBEb25lKCkpO1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjb25zdCBpbnB1dCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJpbnB1dFwiKTtcbiAgICBpbnB1dC50eXBlID0gXCJmaWxlXCI7XG4gICAgaW5wdXQuYWNjZXB0ID0gU3RhbXBFZGl0b3Iuc3VwcG9ydGVkVHlwZXNTdHI7XG4gICAgdGhpcy4jYml0bWFwUHJvbWlzZSA9IG5ldyBQcm9taXNlKHJlc29sdmUgPT4ge1xuICAgICAgaW5wdXQuYWRkRXZlbnRMaXN0ZW5lcihcImNoYW5nZVwiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgIGlmICghaW5wdXQuZmlsZXMgfHwgaW5wdXQuZmlsZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgdGhpcy5yZW1vdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLl91aU1hbmFnZXIuZW5hYmxlV2FpdGluZyh0cnVlKTtcbiAgICAgICAgICBjb25zdCBkYXRhID0gYXdhaXQgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRGcm9tRmlsZShpbnB1dC5maWxlc1swXSk7XG4gICAgICAgICAgdGhpcy4jZ2V0Qml0bWFwRmV0Y2hlZChkYXRhKTtcbiAgICAgICAgfVxuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICAgIGlucHV0LmFkZEV2ZW50TGlzdGVuZXIoXCJjYW5jZWxcIiwgKCkgPT4ge1xuICAgICAgICB0aGlzLnJlbW92ZSgpO1xuICAgICAgICByZXNvbHZlKCk7XG4gICAgICB9KTtcbiAgICB9KS5maW5hbGx5KCgpID0+IHRoaXMuI2dldEJpdG1hcERvbmUoKSk7XG4gICAgaW5wdXQuY2xpY2soKTtcbiAgfVxuICByZW1vdmUoKSB7XG4gICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICB0aGlzLiNiaXRtYXAgPSBudWxsO1xuICAgICAgdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5kZWxldGVJZCh0aGlzLiNiaXRtYXBJZCk7XG4gICAgICB0aGlzLiNjYW52YXM/LnJlbW92ZSgpO1xuICAgICAgdGhpcy4jY2FudmFzID0gbnVsbDtcbiAgICAgIHRoaXMuI29ic2VydmVyPy5kaXNjb25uZWN0KCk7XG4gICAgICB0aGlzLiNvYnNlcnZlciA9IG51bGw7XG4gICAgfVxuICAgIHN1cGVyLnJlbW92ZSgpO1xuICB9XG4gIHJlYnVpbGQoKSB7XG4gICAgaWYgKCF0aGlzLnBhcmVudCkge1xuICAgICAgaWYgKHRoaXMuI2JpdG1hcElkKSB7XG4gICAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBzdXBlci5yZWJ1aWxkKCk7XG4gICAgaWYgKHRoaXMuZGl2ID09PSBudWxsKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGlmICh0aGlzLiNiaXRtYXBJZCkge1xuICAgICAgdGhpcy4jZ2V0Qml0bWFwKCk7XG4gICAgfVxuICAgIGlmICghdGhpcy5pc0F0dGFjaGVkVG9ET00pIHtcbiAgICAgIHRoaXMucGFyZW50LmFkZCh0aGlzKTtcbiAgICB9XG4gIH1cbiAgb25jZUFkZGVkKCkge1xuICAgIHRoaXMuX2lzRHJhZ2dhYmxlID0gdHJ1ZTtcbiAgICB0aGlzLmRpdi5mb2N1cygpO1xuICB9XG4gIGlzRW1wdHkoKSB7XG4gICAgcmV0dXJuICEodGhpcy4jYml0bWFwUHJvbWlzZSB8fCB0aGlzLiNiaXRtYXAgfHwgdGhpcy4jYml0bWFwVXJsIHx8IHRoaXMuI2JpdG1hcEZpbGUpO1xuICB9XG4gIGdldCBpc1Jlc2l6YWJsZSgpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZW5kZXIoKSB7XG4gICAgaWYgKHRoaXMuZGl2KSB7XG4gICAgICByZXR1cm4gdGhpcy5kaXY7XG4gICAgfVxuICAgIGxldCBiYXNlWCwgYmFzZVk7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIGJhc2VYID0gdGhpcy54O1xuICAgICAgYmFzZVkgPSB0aGlzLnk7XG4gICAgfVxuICAgIHN1cGVyLnJlbmRlcigpO1xuICAgIHRoaXMuZGl2LmhpZGRlbiA9IHRydWU7XG4gICAgaWYgKHRoaXMuI2JpdG1hcCkge1xuICAgICAgdGhpcy4jY3JlYXRlQ2FudmFzKCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoaXMuI2dldEJpdG1hcCgpO1xuICAgIH1cbiAgICBpZiAodGhpcy53aWR0aCkge1xuICAgICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gdGhpcy5wYXJlbnREaW1lbnNpb25zO1xuICAgICAgdGhpcy5zZXRBdChiYXNlWCAqIHBhcmVudFdpZHRoLCBiYXNlWSAqIHBhcmVudEhlaWdodCwgdGhpcy53aWR0aCAqIHBhcmVudFdpZHRoLCB0aGlzLmhlaWdodCAqIHBhcmVudEhlaWdodCk7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLmRpdjtcbiAgfVxuICAjY3JlYXRlQ2FudmFzKCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGRpdlxuICAgIH0gPSB0aGlzO1xuICAgIGxldCB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgY29uc3QgW3BhZ2VXaWR0aCwgcGFnZUhlaWdodF0gPSB0aGlzLnBhZ2VEaW1lbnNpb25zO1xuICAgIGNvbnN0IE1BWF9SQVRJTyA9IDAuNzU7XG4gICAgaWYgKHRoaXMud2lkdGgpIHtcbiAgICAgIHdpZHRoID0gdGhpcy53aWR0aCAqIHBhZ2VXaWR0aDtcbiAgICAgIGhlaWdodCA9IHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodDtcbiAgICB9IGVsc2UgaWYgKHdpZHRoID4gTUFYX1JBVElPICogcGFnZVdpZHRoIHx8IGhlaWdodCA+IE1BWF9SQVRJTyAqIHBhZ2VIZWlnaHQpIHtcbiAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGgubWluKE1BWF9SQVRJTyAqIHBhZ2VXaWR0aCAvIHdpZHRoLCBNQVhfUkFUSU8gKiBwYWdlSGVpZ2h0IC8gaGVpZ2h0KTtcbiAgICAgIHdpZHRoICo9IGZhY3RvcjtcbiAgICAgIGhlaWdodCAqPSBmYWN0b3I7XG4gICAgfVxuICAgIGNvbnN0IFtwYXJlbnRXaWR0aCwgcGFyZW50SGVpZ2h0XSA9IHRoaXMucGFyZW50RGltZW5zaW9ucztcbiAgICB0aGlzLnNldERpbXMod2lkdGggKiBwYXJlbnRXaWR0aCAvIHBhZ2VXaWR0aCwgaGVpZ2h0ICogcGFyZW50SGVpZ2h0IC8gcGFnZUhlaWdodCk7XG4gICAgdGhpcy5fdWlNYW5hZ2VyLmVuYWJsZVdhaXRpbmcoZmFsc2UpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuI2NhbnZhcyA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJjYW52YXNcIik7XG4gICAgZGl2LmFwcGVuZChjYW52YXMpO1xuICAgIGRpdi5oaWRkZW4gPSBmYWxzZTtcbiAgICB0aGlzLiNkcmF3Qml0bWFwKHdpZHRoLCBoZWlnaHQpO1xuICAgIHRoaXMuI2NyZWF0ZU9ic2VydmVyKCk7XG4gICAgaWYgKCF0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjaykge1xuICAgICAgdGhpcy5wYXJlbnQuYWRkVW5kb2FibGVFZGl0b3IodGhpcyk7XG4gICAgICB0aGlzLiNoYXNCZWVuQWRkZWRJblVuZG9TdGFjayA9IHRydWU7XG4gICAgfVxuICAgIHRoaXMuX3VpTWFuYWdlci5fZXZlbnRCdXMuZGlzcGF0Y2goXCJyZXBvcnR0ZWxlbWV0cnlcIiwge1xuICAgICAgc291cmNlOiB0aGlzLFxuICAgICAgZGV0YWlsczoge1xuICAgICAgICB0eXBlOiBcImVkaXRpbmdcIixcbiAgICAgICAgc3VidHlwZTogdGhpcy5lZGl0b3JUeXBlLFxuICAgICAgICBkYXRhOiB7XG4gICAgICAgICAgYWN0aW9uOiBcImluc2VydGVkX2ltYWdlXCJcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMuYWRkQWx0VGV4dEJ1dHRvbigpO1xuICB9XG4gICNzZXREaW1lbnNpb25zKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCBbcGFyZW50V2lkdGgsIHBhcmVudEhlaWdodF0gPSB0aGlzLnBhcmVudERpbWVuc2lvbnM7XG4gICAgdGhpcy53aWR0aCA9IHdpZHRoIC8gcGFyZW50V2lkdGg7XG4gICAgdGhpcy5oZWlnaHQgPSBoZWlnaHQgLyBwYXJlbnRIZWlnaHQ7XG4gICAgdGhpcy5zZXREaW1zKHdpZHRoLCBoZWlnaHQpO1xuICAgIGlmICh0aGlzLl9pbml0aWFsT3B0aW9ucz8uaXNDZW50ZXJlZCkge1xuICAgICAgdGhpcy5jZW50ZXIoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdGhpcy5maXhBbmRTZXRQb3NpdGlvbigpO1xuICAgIH1cbiAgICB0aGlzLl9pbml0aWFsT3B0aW9ucyA9IG51bGw7XG4gICAgaWYgKHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCAhPT0gbnVsbCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCk7XG4gICAgfVxuICAgIGNvbnN0IFRJTUVfVE9fV0FJVCA9IDIwMDtcbiAgICB0aGlzLiNyZXNpemVUaW1lb3V0SWQgPSBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgIHRoaXMuI3Jlc2l6ZVRpbWVvdXRJZCA9IG51bGw7XG4gICAgICB0aGlzLiNkcmF3Qml0bWFwKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0sIFRJTUVfVE9fV0FJVCk7XG4gIH1cbiAgI3NjYWxlQml0bWFwKHdpZHRoLCBoZWlnaHQpIHtcbiAgICBjb25zdCB7XG4gICAgICB3aWR0aDogYml0bWFwV2lkdGgsXG4gICAgICBoZWlnaHQ6IGJpdG1hcEhlaWdodFxuICAgIH0gPSB0aGlzLiNiaXRtYXA7XG4gICAgbGV0IG5ld1dpZHRoID0gYml0bWFwV2lkdGg7XG4gICAgbGV0IG5ld0hlaWdodCA9IGJpdG1hcEhlaWdodDtcbiAgICBsZXQgYml0bWFwID0gdGhpcy4jYml0bWFwO1xuICAgIHdoaWxlIChuZXdXaWR0aCA+IDIgKiB3aWR0aCB8fCBuZXdIZWlnaHQgPiAyICogaGVpZ2h0KSB7XG4gICAgICBjb25zdCBwcmV2V2lkdGggPSBuZXdXaWR0aDtcbiAgICAgIGNvbnN0IHByZXZIZWlnaHQgPSBuZXdIZWlnaHQ7XG4gICAgICBpZiAobmV3V2lkdGggPiAyICogd2lkdGgpIHtcbiAgICAgICAgbmV3V2lkdGggPSBuZXdXaWR0aCA+PSAxNjM4NCA/IE1hdGguZmxvb3IobmV3V2lkdGggLyAyKSAtIDEgOiBNYXRoLmNlaWwobmV3V2lkdGggLyAyKTtcbiAgICAgIH1cbiAgICAgIGlmIChuZXdIZWlnaHQgPiAyICogaGVpZ2h0KSB7XG4gICAgICAgIG5ld0hlaWdodCA9IG5ld0hlaWdodCA+PSAxNjM4NCA/IE1hdGguZmxvb3IobmV3SGVpZ2h0IC8gMikgLSAxIDogTWF0aC5jZWlsKG5ld0hlaWdodCAvIDIpO1xuICAgICAgfVxuICAgICAgY29uc3Qgb2Zmc2NyZWVuID0gbmV3IE9mZnNjcmVlbkNhbnZhcyhuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGNvbnN0IGN0eCA9IG9mZnNjcmVlbi5nZXRDb250ZXh0KFwiMmRcIik7XG4gICAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgcHJldldpZHRoLCBwcmV2SGVpZ2h0LCAwLCAwLCBuZXdXaWR0aCwgbmV3SGVpZ2h0KTtcbiAgICAgIGJpdG1hcCA9IG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIGJpdG1hcDtcbiAgfVxuICAjZHJhd0JpdG1hcCh3aWR0aCwgaGVpZ2h0KSB7XG4gICAgd2lkdGggPSBNYXRoLmNlaWwod2lkdGgpO1xuICAgIGhlaWdodCA9IE1hdGguY2VpbChoZWlnaHQpO1xuICAgIGNvbnN0IGNhbnZhcyA9IHRoaXMuI2NhbnZhcztcbiAgICBpZiAoIWNhbnZhcyB8fCBjYW52YXMud2lkdGggPT09IHdpZHRoICYmIGNhbnZhcy5oZWlnaHQgPT09IGhlaWdodCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBjYW52YXMud2lkdGggPSB3aWR0aDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gaGVpZ2h0O1xuICAgIGNvbnN0IGJpdG1hcCA9IHRoaXMuI2lzU3ZnID8gdGhpcy4jYml0bWFwIDogdGhpcy4jc2NhbGVCaXRtYXAod2lkdGgsIGhlaWdodCk7XG4gICAgY29uc3QgY3R4ID0gY2FudmFzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICBjdHguZmlsdGVyID0gdGhpcy5fdWlNYW5hZ2VyLmhjbUZpbHRlcjtcbiAgICBjdHguZHJhd0ltYWdlKGJpdG1hcCwgMCwgMCwgYml0bWFwLndpZHRoLCBiaXRtYXAuaGVpZ2h0LCAwLCAwLCB3aWR0aCwgaGVpZ2h0KTtcbiAgfVxuICAjc2VyaWFsaXplQml0bWFwKHRvVXJsKSB7XG4gICAgaWYgKHRvVXJsKSB7XG4gICAgICBpZiAodGhpcy4jaXNTdmcpIHtcbiAgICAgICAgY29uc3QgdXJsID0gdGhpcy5fdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5nZXRTdmdVcmwodGhpcy4jYml0bWFwSWQpO1xuICAgICAgICBpZiAodXJsKSB7XG4gICAgICAgICAgcmV0dXJuIHVybDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY29uc3QgY2FudmFzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICh7XG4gICAgICAgIHdpZHRoOiBjYW52YXMud2lkdGgsXG4gICAgICAgIGhlaWdodDogY2FudmFzLmhlaWdodFxuICAgICAgfSA9IHRoaXMuI2JpdG1hcCk7XG4gICAgICBjb25zdCBjdHggPSBjYW52YXMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgICAgY3R4LmRyYXdJbWFnZSh0aGlzLiNiaXRtYXAsIDAsIDApO1xuICAgICAgcmV0dXJuIGNhbnZhcy50b0RhdGFVUkwoKTtcbiAgICB9XG4gICAgaWYgKHRoaXMuI2lzU3ZnKSB7XG4gICAgICBjb25zdCBbcGFnZVdpZHRoLCBwYWdlSGVpZ2h0XSA9IHRoaXMucGFnZURpbWVuc2lvbnM7XG4gICAgICBjb25zdCB3aWR0aCA9IE1hdGgucm91bmQodGhpcy53aWR0aCAqIHBhZ2VXaWR0aCAqIF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gICAgICBjb25zdCBoZWlnaHQgPSBNYXRoLnJvdW5kKHRoaXMuaGVpZ2h0ICogcGFnZUhlaWdodCAqIF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2guUERGX1RPX0NTU19VTklUUyk7XG4gICAgICBjb25zdCBvZmZzY3JlZW4gPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgICAgY29uc3QgY3R4ID0gb2Zmc2NyZWVuLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICAgIGN0eC5kcmF3SW1hZ2UodGhpcy4jYml0bWFwLCAwLCAwLCB0aGlzLiNiaXRtYXAud2lkdGgsIHRoaXMuI2JpdG1hcC5oZWlnaHQsIDAsIDAsIHdpZHRoLCBoZWlnaHQpO1xuICAgICAgcmV0dXJuIG9mZnNjcmVlbi50cmFuc2ZlclRvSW1hZ2VCaXRtYXAoKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0cnVjdHVyZWRDbG9uZSh0aGlzLiNiaXRtYXApO1xuICB9XG4gICNjcmVhdGVPYnNlcnZlcigpIHtcbiAgICB0aGlzLiNvYnNlcnZlciA9IG5ldyBSZXNpemVPYnNlcnZlcihlbnRyaWVzID0+IHtcbiAgICAgIGNvbnN0IHJlY3QgPSBlbnRyaWVzWzBdLmNvbnRlbnRSZWN0O1xuICAgICAgaWYgKHJlY3Qud2lkdGggJiYgcmVjdC5oZWlnaHQpIHtcbiAgICAgICAgdGhpcy4jc2V0RGltZW5zaW9ucyhyZWN0LndpZHRoLCByZWN0LmhlaWdodCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy4jb2JzZXJ2ZXIub2JzZXJ2ZSh0aGlzLmRpdik7XG4gIH1cbiAgc3RhdGljIGRlc2VyaWFsaXplKGRhdGEsIHBhcmVudCwgdWlNYW5hZ2VyKSB7XG4gICAgaWYgKGRhdGEgaW5zdGFuY2VvZiBfYW5ub3RhdGlvbl9sYXllci5TdGFtcEFubm90YXRpb25FbGVtZW50KSB7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgY29uc3QgZWRpdG9yID0gc3VwZXIuZGVzZXJpYWxpemUoZGF0YSwgcGFyZW50LCB1aU1hbmFnZXIpO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlY3QsXG4gICAgICBiaXRtYXBVcmwsXG4gICAgICBiaXRtYXBJZCxcbiAgICAgIGlzU3ZnLFxuICAgICAgYWNjZXNzaWJpbGl0eURhdGFcbiAgICB9ID0gZGF0YTtcbiAgICBpZiAoYml0bWFwSWQgJiYgdWlNYW5hZ2VyLmltYWdlTWFuYWdlci5pc1ZhbGlkSWQoYml0bWFwSWQpKSB7XG4gICAgICBlZGl0b3IuI2JpdG1hcElkID0gYml0bWFwSWQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVkaXRvci4jYml0bWFwVXJsID0gYml0bWFwVXJsO1xuICAgIH1cbiAgICBlZGl0b3IuI2lzU3ZnID0gaXNTdmc7XG4gICAgY29uc3QgW3BhcmVudFdpZHRoLCBwYXJlbnRIZWlnaHRdID0gZWRpdG9yLnBhZ2VEaW1lbnNpb25zO1xuICAgIGVkaXRvci53aWR0aCA9IChyZWN0WzJdIC0gcmVjdFswXSkgLyBwYXJlbnRXaWR0aDtcbiAgICBlZGl0b3IuaGVpZ2h0ID0gKHJlY3RbM10gLSByZWN0WzFdKSAvIHBhcmVudEhlaWdodDtcbiAgICBpZiAoYWNjZXNzaWJpbGl0eURhdGEpIHtcbiAgICAgIGVkaXRvci5hbHRUZXh0RGF0YSA9IGFjY2Vzc2liaWxpdHlEYXRhO1xuICAgIH1cbiAgICByZXR1cm4gZWRpdG9yO1xuICB9XG4gIHNlcmlhbGl6ZSgpIHtcbiAgICBsZXQgaXNGb3JDb3B5aW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiBmYWxzZTtcbiAgICBsZXQgY29udGV4dCA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcbiAgICBpZiAodGhpcy5pc0VtcHR5KCkpIHtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBjb25zdCBzZXJpYWxpemVkID0ge1xuICAgICAgYW5ub3RhdGlvblR5cGU6IF91dGlsLkFubm90YXRpb25FZGl0b3JUeXBlLlNUQU1QLFxuICAgICAgYml0bWFwSWQ6IHRoaXMuI2JpdG1hcElkLFxuICAgICAgcGFnZUluZGV4OiB0aGlzLnBhZ2VJbmRleCxcbiAgICAgIHJlY3Q6IHRoaXMuZ2V0UmVjdCgwLCAwKSxcbiAgICAgIHJvdGF0aW9uOiB0aGlzLnJvdGF0aW9uLFxuICAgICAgaXNTdmc6IHRoaXMuI2lzU3ZnLFxuICAgICAgc3RydWN0VHJlZVBhcmVudElkOiB0aGlzLl9zdHJ1Y3RUcmVlUGFyZW50SWRcbiAgICB9O1xuICAgIGlmIChpc0ZvckNvcHlpbmcpIHtcbiAgICAgIHNlcmlhbGl6ZWQuYml0bWFwVXJsID0gdGhpcy4jc2VyaWFsaXplQml0bWFwKHRydWUpO1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHRoaXMuYWx0VGV4dERhdGE7XG4gICAgICByZXR1cm4gc2VyaWFsaXplZDtcbiAgICB9XG4gICAgY29uc3Qge1xuICAgICAgZGVjb3JhdGl2ZSxcbiAgICAgIGFsdFRleHRcbiAgICB9ID0gdGhpcy5hbHRUZXh0RGF0YTtcbiAgICBpZiAoIWRlY29yYXRpdmUgJiYgYWx0VGV4dCkge1xuICAgICAgc2VyaWFsaXplZC5hY2Nlc3NpYmlsaXR5RGF0YSA9IHtcbiAgICAgICAgdHlwZTogXCJGaWd1cmVcIixcbiAgICAgICAgYWx0OiBhbHRUZXh0XG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoY29udGV4dCA9PT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHNlcmlhbGl6ZWQ7XG4gICAgfVxuICAgIGNvbnRleHQuc3RhbXBzIHx8PSBuZXcgTWFwKCk7XG4gICAgY29uc3QgYXJlYSA9IHRoaXMuI2lzU3ZnID8gKHNlcmlhbGl6ZWQucmVjdFsyXSAtIHNlcmlhbGl6ZWQucmVjdFswXSkgKiAoc2VyaWFsaXplZC5yZWN0WzNdIC0gc2VyaWFsaXplZC5yZWN0WzFdKSA6IG51bGw7XG4gICAgaWYgKCFjb250ZXh0LnN0YW1wcy5oYXModGhpcy4jYml0bWFwSWQpKSB7XG4gICAgICBjb250ZXh0LnN0YW1wcy5zZXQodGhpcy4jYml0bWFwSWQsIHtcbiAgICAgICAgYXJlYSxcbiAgICAgICAgc2VyaWFsaXplZFxuICAgICAgfSk7XG4gICAgICBzZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgfSBlbHNlIGlmICh0aGlzLiNpc1N2Zykge1xuICAgICAgY29uc3QgcHJldkRhdGEgPSBjb250ZXh0LnN0YW1wcy5nZXQodGhpcy4jYml0bWFwSWQpO1xuICAgICAgaWYgKGFyZWEgPiBwcmV2RGF0YS5hcmVhKSB7XG4gICAgICAgIHByZXZEYXRhLmFyZWEgPSBhcmVhO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcC5jbG9zZSgpO1xuICAgICAgICBwcmV2RGF0YS5zZXJpYWxpemVkLmJpdG1hcCA9IHRoaXMuI3NlcmlhbGl6ZUJpdG1hcChmYWxzZSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBzZXJpYWxpemVkO1xuICB9XG59XG5leHBvcnRzLlN0YW1wRWRpdG9yID0gU3RhbXBFZGl0b3I7XG5cbi8qKiovIH0pXG4vKioqKioqLyBcdF0pO1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fID0ge307XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dfcGRmanNfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqLyBcdFx0Ly8gQ2hlY2sgaWYgbW9kdWxlIGlzIGluIGNhY2hlXG4vKioqKioqLyBcdFx0dmFyIGNhY2hlZE1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF07XG4vKioqKioqLyBcdFx0aWYgKGNhY2hlZE1vZHVsZSAhPT0gdW5kZWZpbmVkKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gY2FjaGVkTW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdFx0fVxuLyoqKioqKi8gXHRcdC8vIENyZWF0ZSBhIG5ldyBtb2R1bGUgKGFuZCBwdXQgaXQgaW50byB0aGUgY2FjaGUpXG4vKioqKioqLyBcdFx0dmFyIG1vZHVsZSA9IF9fd2VicGFja19tb2R1bGVfY2FjaGVfX1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUuaWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHQvLyBubyBtb2R1bGUubG9hZGVkIG5lZWRlZFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfbW9kdWxlc19fW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dfcGRmanNfcmVxdWlyZV9fKTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovIFx0XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xudmFyIF9fd2VicGFja19leHBvcnRzX18gPSB7fTtcbi8vIFRoaXMgZW50cnkgbmVlZCB0byBiZSB3cmFwcGVkIGluIGFuIElJRkUgYmVjYXVzZSBpdCBuZWVkIHRvIGJlIGlzb2xhdGVkIGFnYWluc3Qgb3RoZXIgbW9kdWxlcyBpbiB0aGUgY2h1bmsuXG4oKCkgPT4ge1xudmFyIGV4cG9ydHMgPSBfX3dlYnBhY2tfZXhwb3J0c19fO1xuXG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgKHtcbiAgdmFsdWU6IHRydWVcbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFib3J0RXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5BYm9ydEV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkVkaXRvckxheWVyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYW5ub3RhdGlvbl9lZGl0b3JfbGF5ZXIuQW5ub3RhdGlvbkVkaXRvckxheWVyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uRWRpdG9yUGFyYW1zVHlwZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuQW5ub3RhdGlvbkVkaXRvclBhcmFtc1R5cGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25FZGl0b3JUeXBlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5Bbm5vdGF0aW9uRWRpdG9yVHlwZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiQW5ub3RhdGlvbkVkaXRvclVJTWFuYWdlclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3Rvb2xzLkFubm90YXRpb25FZGl0b3JVSU1hbmFnZXI7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkFubm90YXRpb25MYXllclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Fubm90YXRpb25fbGF5ZXIuQW5ub3RhdGlvbkxheWVyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJBbm5vdGF0aW9uTW9kZVwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuQW5ub3RhdGlvbk1vZGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkNNYXBDb21wcmVzc2lvblR5cGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLkNNYXBDb21wcmVzc2lvblR5cGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRPTVNWR0ZhY3RvcnlcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLkRPTVNWR0ZhY3Rvcnk7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkZlYXR1cmVUZXN0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5GZWF0dXJlVGVzdDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiR2xvYmFsV29ya2VyT3B0aW9uc1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3dvcmtlcl9vcHRpb25zLkdsb2JhbFdvcmtlck9wdGlvbnM7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkltYWdlS2luZFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuSW1hZ2VLaW5kO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJJbnZhbGlkUERGRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5JbnZhbGlkUERGRXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJNaXNzaW5nUERGRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5NaXNzaW5nUERGRXhjZXB0aW9uO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJPUFNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLk9QUztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGRGF0YVJhbmdlVHJhbnNwb3J0XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLlBERkRhdGFSYW5nZVRyYW5zcG9ydDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGRGF0ZVN0cmluZ1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuUERGRGF0ZVN0cmluZztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUERGV29ya2VyXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLlBERldvcmtlcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUGFzc3dvcmRSZXNwb25zZXNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlBhc3N3b3JkUmVzcG9uc2VzO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJQZXJtaXNzaW9uRmxhZ1wiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuUGVybWlzc2lvbkZsYWc7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlBpeGVsc1BlckluY2hcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLlBpeGVsc1BlckluY2g7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlByb21pc2VDYXBhYmlsaXR5XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5Qcm9taXNlQ2FwYWJpbGl0eTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiUmVuZGVyaW5nQ2FuY2VsbGVkRXhjZXB0aW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5SZW5kZXJpbmdDYW5jZWxsZWRFeGNlcHRpb247XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIlNWR0dyYXBoaWNzXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLlNWR0dyYXBoaWNzO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJVbmV4cGVjdGVkUmVzcG9uc2VFeGNlcHRpb25cIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlVuZXhwZWN0ZWRSZXNwb25zZUV4Y2VwdGlvbjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVXRpbFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3V0aWwuVXRpbDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiVmVyYm9zaXR5TGV2ZWxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLlZlcmJvc2l0eUxldmVsO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJYZmFMYXllclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3hmYV9sYXllci5YZmFMYXllcjtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiYnVpbGRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9hcGkuYnVpbGQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImNyZWF0ZVZhbGlkQWJzb2x1dGVVcmxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLmNyZWF0ZVZhbGlkQWJzb2x1dGVVcmw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldERvY3VtZW50XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLmdldERvY3VtZW50O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJnZXRGaWxlbmFtZUZyb21VcmxcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmdldEZpbGVuYW1lRnJvbVVybDtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZ2V0UGRmRmlsZW5hbWVGcm9tVXJsXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5nZXRQZGZGaWxlbmFtZUZyb21Vcmw7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImdldFhmYVBhZ2VWaWV3cG9ydFwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX2Rpc3BsYXlfdXRpbHMuZ2V0WGZhUGFnZVZpZXdwb3J0O1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJpc0RhdGFTY2hlbWVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmlzRGF0YVNjaGVtZTtcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiaXNQZGZGaWxlXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfZGlzcGxheV91dGlscy5pc1BkZkZpbGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcImxvYWRTY3JpcHRcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLmxvYWRTY3JpcHQ7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vQ29udGV4dE1lbnVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLm5vQ29udGV4dE1lbnU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIm5vcm1hbGl6ZVVuaWNvZGVcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF91dGlsLm5vcm1hbGl6ZVVuaWNvZGU7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInJlbmRlclRleHRMYXllclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RleHRfbGF5ZXIucmVuZGVyVGV4dExheWVyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJzZXRMYXllckRpbWVuc2lvbnNcIiwgKHtcbiAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgZ2V0OiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIF9kaXNwbGF5X3V0aWxzLnNldExheWVyRGltZW5zaW9ucztcbiAgfVxufSkpO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwic2hhZG93XCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfdXRpbC5zaGFkb3c7XG4gIH1cbn0pKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcInVwZGF0ZVRleHRMYXllclwiLCAoe1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBnZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gX3RleHRfbGF5ZXIudXBkYXRlVGV4dExheWVyO1xuICB9XG59KSk7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJ2ZXJzaW9uXCIsICh7XG4gIGVudW1lcmFibGU6IHRydWUsXG4gIGdldDogZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBfYXBpLnZlcnNpb247XG4gIH1cbn0pKTtcbnZhciBfdXRpbCA9IF9fd19wZGZqc19yZXF1aXJlX18oMSk7XG52YXIgX2FwaSA9IF9fd19wZGZqc19yZXF1aXJlX18oMTI0KTtcbnZhciBfZGlzcGxheV91dGlscyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTY4KTtcbnZhciBfdGV4dF9sYXllciA9IF9fd19wZGZqc19yZXF1aXJlX18oMTk1KTtcbnZhciBfYW5ub3RhdGlvbl9lZGl0b3JfbGF5ZXIgPSBfX3dfcGRmanNfcmVxdWlyZV9fKDE5Nik7XG52YXIgX3Rvb2xzID0gX193X3BkZmpzX3JlcXVpcmVfXygxNjUpO1xudmFyIF9hbm5vdGF0aW9uX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygxOTgpO1xudmFyIF93b3JrZXJfb3B0aW9ucyA9IF9fd19wZGZqc19yZXF1aXJlX18oMTc2KTtcbnZhciBfeGZhX2xheWVyID0gX193X3BkZmpzX3JlcXVpcmVfXygyMDEpO1xuY29uc3QgcGRmanNWZXJzaW9uID0gJzMuMTEuMTc0JztcbmNvbnN0IHBkZmpzQnVpbGQgPSAnY2U4NzE2NzQzJztcbn0pKCk7XG5cbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBkZi5qcy5tYXAiXSwibmFtZXMiOltdLCJpZ25vcmVMaXN0IjpbMF0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/.pnpm/pdfjs-dist@3.11.174/node_modules/pdfjs-dist/legacy/build/pdf.js\n");

/***/ })

};
;